
비정형 매개변수
void m2(int...i){//배열처럼
(i.length i[0]..)
for(int j = 0 ; j<i.length ; j++){
	sum = sum+i[j];
}
}

메소드 정의 : 형식매개변수 정의
메소드 호출 실행 : 실매개변수 전달
"call by value"
기본타입 전달:실제값
참조타입 전달:주소값 전달
(형식, 실매개변수 변수가 동일 주소 객체 참조!!! : 객체 내부 변수값 변경)

[modifier] 
		modifier	class	변수		메소드		생성자
접근제한	public		o		o		o		o	
		protected	x		o		o		o
		private		x		o		o		o
		
활용방법	static		x		o		o		x
		final		o		o		o		x
		abstract	o		x		o		x
		
public 다른 패키지의 클래스에서 조회가능 / 수정가능		
final 같은 패키지의 다른 클래스에서 조회가능 / 수정불가능
private 다른 클래스에서 조회불가능 / 수정불가능 (같은 클래스에서 사용)
		
public 메소드(){private 변수}
=> 정보 은닉 / 접근 통로 1개

-객체지향언어 특징
1.캡슐화(데이터+기능=클래스)
	정보은닉 / 공개 (private~public)
2. 상속
3. 다형성(polymorphism)
	overloading
	...

-객체지향언어 목적 : "재사용"
		
		
==========================================================

7장 상속
class 사람{
	//상위, 부모, superclass
이름 나이 밥먹다 잠자다	
}

class 회사원 extends 사람{
	//하위, 자식, subclass
사번 급여
일하다
(extends : 사람 자동 포함)
}

class 학생 extends 사람{
	//하위, 자식, subclass
학번 성적
공부하다
}	
class 유치원생 extends 학생{
}
--------------------------------------
class A{i, ma(){}}
class B extends A{[i,ma(){}],i,mb(){}}
	= class B{j,mb(){},
			A a1=new A();
			a1.i
			a1.ma()}
class C extends A {k,mc(){}}
		
---------------------------------
클래스 재사용
1. is-a 관계 : 상속 
2. has-a 관계 : 객체 변수 포함		
---------------------------------		
		
<기존 클래스 변수 메소드 필요 재사용>
1. 객체생성 변수 포함 사용
	has-a 운전자는 자동차를 가지다
	class 자동차{
		전진하다
		후진하다
		정지하다
	}
	class 운전자{ 운전하다(){
		자동차 car = new 자동차();
		car.전진하다()....
	}}
2. 상속
회사원은 사람이다.
학생은 사람이다.		
		
		
class 학생{ 점심먹다, 공부하다 }
class 교직원{ 점심먹다, 학교업무하다}
class 조교 extends 학생, 교직원{}	 
=>다중 상속 불가!!! (단일 상속만 허용)
  점심먹다 메소드가 겹치기 때문에	
		
-상속 필드변수
1> 상위 변수들은 하위 클래스 자동 포함 사용
2> private 변수,메소드 하위 사용 불가능
3> 상하위 클래스 같은 이름 변수,메소드 존재
	하위클래스에서는 하위 클래스 선언 변수,메소드 우선
	(상위 클래스 변수,메소드 : super키워드)
	
		
-메소드 overloading(중복정의)
1개 클래스에 같은 이름, 매개변수 다르게 여러개 메소드	
리턴타입 상관x
		
-메소드 overriding(우선시하다)
상속 2개 클래스에 같은 이름, 매개변수 같고, 리턴타입 같고
modifier 같거나 더 넓어도 된다.
=>하위클래스에서 상속 메소드 내용 수정 필요
==========================================================

		
this :현재 자신 객체 의미 키워드
1.this.변수명 > 필드변수와 매개변수
	필드변수와 지역변수 이름이 같은 경우 구분
2.this([매개변수]) > 자신의 클래스 다른 생성자 호출
	생성자 overloading (코드 문장 재사용)
super : 상위 객체 의미 키워드
1. super.(상위)변수명
2. super.(상위)메소드()
	>상,하위 클래스 동일 변수나 메소드 존재
	하위클래스 우선
	
		
@ at-sign
@Override : override annotation(컴파일러 주석)		
----------------------------------------------

-상속
		
class A extends java.lang.Object{
	double d1;
	A(){
		//super(); ===========================
		d1 = 10*10;
		//a=1.0;
	}
}		
		
class B extends A{
	double d2;
	B() {
		//super();============================
		d2 = 10*10*10;
		//System.out.println(a);
	}
}		

A a1 = new A();
=>object 생성자 호출 => A생성자 호출
 >Object 객체 생성  >A 객체생성
 
B b1 = new B();
=>object 생성자 호출 => A생성자 호출 => B생성자 호출
 >Object 객체 생성  >A 객체생성  >B 객체생성
 
stack					heap
b1						Object 변수+메소드	<---				
						A:d1 = 100.0	<--|					
	------------------->B:d2 = 1000.0	---|
												
 a1						Object 변수+메소드	<---	
	------------------->A:d1 = 100.0	---|
 
 
-생성자
		
super() : 상위 클래스 기본 생성자 호출
	생성자 첫문장 자동 정의
	상위클래스 생성자 매개변수 없다
	상위객체가 하위객체보다 먼저 생성
	
1. 자바 모든 클래스 Object 상속 관계
2. 최상위 클래스(root)
3. Object non-private 변수나 메소드 자바 다른 클래스 사용가능
4. 메소드 오버라이딩		
		
-super
super.상위필드변수명
super.상위메소드명()

super() : 생성자 첫문장 "자동" 정의!!!
		상위 기본 생성자 호출
super(매개변수전달) : 생성자 첫문장 명시적 정의		
		상위 매개변수 정의 생성자 호출
-------------------------------------SuperTest.java		
		
		
상속 modifier
1. 상위 변수나 메소드 하위 클래스 자동 포함 사용
2. private 상속 사용 불가능		
		
-final : 더이상 수정불가능
	final 변수 = 변수값 수정 불가능 = 상수
	final 메소드 = 메소드 수정 불가능 =>메소드 overriding 불가능
	final 클래스 = 모든 메소드 overriding 불가능 
		=> 상속 불가능 = 객체생성 강제화
	
기존 정의 클래스 : 상속이나 객체생성 	
		
final class 수학공식{----------------------------------
	제곱(){}
	제곱근(){}
	삼각함수(){}
	final void 절대값(){음수*(-1)->양수 리턴}--------------
} => 상속과 오버라이딩 불가능(객체생성해서 호출해야한다)

class Myclass extends 수학공식{-----final class로 상속불가
	print(){}
	절대값(){양수*(-1)-> 음수리턴}---------final 때문에 오버라이딩 금지
		
	수학공식 s = new 수학공식();
	s.절대값(); //호출
}
final class Math{
	random(){0.0<=?<1.0}
	abs(){}
	power(){}
	sqrt(){}
	sin(){}
}
	
---------------------------------------------------------

클래스 묶음 = pakage
같은 패키지 내부 클래스 사용 : no modifier = default
같은 클래스 내부 사용 : private

같은 패키지 내부 상속, 객체생성 클래스들 
	+ 다른 패키지 하위 클래스 국한 : protected		
모든 클래스 사용 : public
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
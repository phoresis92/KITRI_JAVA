


참조타입 : heap 영역 저장하고 stack 영역 저장 한 값은 주소값 저장 타입
(길이 한정 x / 길이 대용량)

stack : 변수 저장 .main 시작-종료 이후 메모리 삭제
heap : stack영역 변수가 더이상 참조하지 않을 경우
(main 종료 이전이라도)필요에 따라 메모리 삭제
-------------------------------------------------------


- String
1. 	String s1 = "java";
	String s2 = new String("java");
	stack			heap
	s2:200			100:java
	s1:100			200:java
s1 == s2 주소값 false
s1.equals(s2) 문자열 내용 true

int i = 10;
int j = 10;
i == j : 값 동등

	String s3 = null;
s3.equals("java") : nullPointerException
-------------------------------------------------------


- Array : 동일 타입 데이터 여러개 모음
데이터타입 배열변수명[];
배열변수명 = new 데이터타입[배열길이];

=> double dar[] = new double[100];
dar[0] ~ dar[99] = dar[dar.length]
0 <= index <= length-1


int twoar[][] = new int[5][3];
[][][]	//이차적 배열길이 3으로 동일
[][][]
[][][]
[][][]
[][][]

int twoar[][] = new int [5][];//이차적 배열길이 동적
twoar[0] = new int[4];
...
twoar[4] = new int[2];
----------------------------------------------------


-command line arguments
1.main 시작 - 종료
2.public static void main(String[] args)
(도스) java 클래스명 입력1 입력2 ...
(이클립스) run configuration - arguments -...
3.(자동) args = new String[입력변수의 갯수];
args[0] = 입력1;
args[1] = 입력2;
...
4. 입력 갯수 확인 문장 : args.length
5. 두번째 입력값 : args[1]
6. String 타입만 받을 수 있다. : 
Integer.ParseInt(args[0])
Double.ParseDouble(args[0])

=========================================================


6장 클래스
-객체지향 프로그래밍
oop(Object Oriented Programming)
절차지향 / 객체지향
1980 C, cobol : 절차지향
1990 C++, java : 객체지향

-------------------------------------------
-교육관리프로그램: 3가지 기능
1.수강하다
2.시험보다
3.평가하다
-------------------
절차지향						객체지향
program 교육관리{				class 학생{
	이름,점수,학번,연락처			학번,이름
	수강하다(){문장}				수강하다(){문장}
	시험보다(){}				시험보다(){}
	평가하다(){}				}
}							class 평가자{
							점수
=>일부 수정시 문제발생 소지많다		평가하다(){}
							}
							class 교육관리{
							main(){
							학생.수강하다();
							학생.시험보다();
							평가자.평가하다();
							}
							}
-------------------------------------------
-취업관리 프로그램 

program 취업관리{				class 회사{	
	설명화개최하다				설명회(){}
	회사정보제공하다				취업정보(){}
	학번, 이름					}
	수강하다(){}
	>다시 생성해야한다!!!			class 취업관리{
}							학생.이름
							학생.수강하다() > 가져다 사용하면 된다.
							}
--------------------------------------------							
1. 프로그래머 경험 :
	유지보수 최소화 : 객체지향
2. 기능 수행 주체별 클래스 단위 분류
3. 새로운 프로그램 기존 정의 클래스내부 내용 필요
	>반복정의하지 말고 "재사용"-"프로그램 코드 간결"!!!!!
============================================

-객체 : 현실세계 명사 표현 모든 것 => 프로그래밍 표현
	벽, 전등, 컴퓨터, 의자, 책상, 칠판, 교육생, 강사

1. 객체 특성 파악!
	1-1. 정적 요소 = 속성, 상태, 정보 표현 데이터 =variable
	1-2. 동적 요소 = 기능, 동작, 행위 =method

김규정 교육생 객체
class 김규정{
	String 이름 = 김규정;
	int 나이 = 27;
	boolean 수료여부 = false
	
	void 교육받다(){}
	void 점심먹다(){}
	void 휴식하다(){}
	void 졸다(){}

김규정 회사원 객체
class 김규정{
	String 이름 = 김규정;
	int 나이 = 27;
	int 본봉
	int 수당
	int 급여
	String 부서
}
	
	void 출근하다(){}
	void 휴가얻다(){}
	void 휴식하다(){}
	void 퇴근하다(){}
	void 졸다(){}
	
2. 동일(정적+동적) 객체 무수히 많이 존재 => class 정의
붕어빵"틀": 1개:  > 붕어빵들: 여러개 같은 모양: 
객체틀				객체들
class			

3. 객체 생성 = 클래스 변수와 메소드 복사 메모리 할당

=============================================


[modifier] clss 클래스이름 [extends][implements]
{
클래스 body = 멤버요소
[modifier] 변수 (field) = 객체정적요소
[modifier] 메소드 = 객체동적요소
[modifier] 생성자
}

[modifier] = 한정자 수정자 제한자
클래스, 변수, 메소드, 생성자 앞 선언 요소
접근제한이나 활용방법 표현 키워드들
		modifier	class	변수		메소드		생성자
접근제한	public		o		o		o		o	
		protected	x		o		o		o
		private		x		o		o		o
		
활용방법	static		x		o		o		x
		final		o		o		o		x
		abstract	o		x		o		x	

기타		synchronized transi
		native volitile
=======================================================

Employee e1 = new Employee();
클래스명 변수명 = new 클래스명();
employee e1; //변수 선언
e1 = new employee(); //객체생성

1. e1 변수 stack 저장
2. new : 객체 생성 연산자
	heap영역 클래스 복사 저장 = 객체생성
3. 2의 결과물(주소)를 1번에 대입

stack				heap
e1:100				100:
					id
					name
					dept
					pay
					title
					e1.id = 100;
e1.name = "김사원";
e1.dept = "인사부";
e1.title = "사원";
e1.pay = 50000;

stack				heap
e1:10				10:객체변수
					id = 100
					name = 김사원
					dept = 인사부
					pay = 50000.0
					title = 사원

e2:20				20:객체변수
					id = 200
					name = 박사장
					dept = 사장실
					pay = 500000.0
					title = 사장

-참조타입 변수 선언문 = 객체생성 선언문					
클래스명 객체참조변수명 = new 클래스명();

객체참조변수.객체내부포함변수

객체변수는 자동 초기화
지역변수는 수동 초기화해야한다!
======================================================

Constructor 
객체변수 = 필드변수 =>정적특성(상태,정보 데이터)
메소드 => 동적특성(기능행위)
생성자 => 클래스 정의 - 객체들 생성 시점에서 수행 문장 정의

class Employee{.....}
Employee e1 =new Employee();
클래스명 객체참조변수명 = new 생성자호출();

클래스정의 > 객체생성 > 객체변수 초기화
자바 클래스 "자동" 생성자 정의 포함
사용자 생성자 정의하면 "자동" 삭제

1. new 객체 생성 뒤에서 자동 호출
2. 객체 생성 시점에서 호출 수행
3. 정의 문장 : 객체생성시점 수행문장 = 객체변수값 초기화
4. 모든 클래스 "자동" 기본 생성자 정의
	default constructor: 클래스명(){}
5. 사용자 생성자 정의 - 기본 생성자 매개변수 수정, 실행 문장 수정
6. 사용자 정의하면 default constructor 삭제
7. 생성자 overloading :
	1개 클래스 내부에 여러개 생성자 정의
	이름은 같고 매개변수 타입, 순서, 갯수중 하나이상 다르게 정의
	:같은 타입 객체 생성 여러개중 선택
	:같은 타입 객체 생성 형태 다르다
8. this : 자신 객체 참조 키워드
	8-1. 매개변수(혹은 지역변수)와 필드변수 이름이 동일한 경우 구분
		:의미 명확 표현
	8-2. 동일 클래스 생성자 내부에서 다른 생성자 호출
		(생성자 overloading시에)
		this(매개변수전달) - 다른 생성자 정의 코드 반복 정의하지 않고 재사용!!!
		

1. public class 이름 = 자바파일명
2. main method 포함 클래스 이름 = 자바파일명














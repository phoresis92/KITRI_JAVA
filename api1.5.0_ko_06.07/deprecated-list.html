<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:29:08 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
비추천 API
 리스트 (Java 2 Platform SE 5.0)</TITLE>


<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="비추천 API
 리스트 (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">패키지</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">사용</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>비추천 API</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp; 전&nbsp;
&nbsp;다음</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="index.html?deprecated-list.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="deprecated-list.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<CENTER>
<H2>
<B>추천되어 있지 않은 API</B></H2>
</CENTER>
<HR SIZE="4" NOSHADE>
<B>컨텐츠</B><UL>
<LI><A HREF="#interface">추천되어 있지 않은 인터페이스</A> 
<LI><A HREF="#class">추천되어 있지 않은 클래스</A> 
<LI><A HREF="#exception">추천되어 있지 않은 예외</A> 
<LI><A HREF="#field">추천되어 있지 않은 필드</A> 
<LI><A HREF="#method">추천되어 있지 않은 메서드</A> 
<LI><A HREF="#constructor">추천되어 있지 않은 constructor</A> 
</UL>

<A NAME="interface"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 인터페이스</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/AttributeList.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.AttributeList</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는
 이름 공간을 지원하는 SAX2 <A HREF="org/xml/sax/Attributes.html" title="org.xml.sax 중의 인터페이스"><CODE>Attributes</CODE></A>  인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Certificate.html" title="java.security 안의 인터페이스">java.security.Certificate</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼에서는
 인증서
를 취급하는 새로운 패키지가 작성되었습니다. 이 Certificate 인터페이스의 사용은 추천 되지 않습니다. 새로운 패키지에의 원활한 이행을 위해서 남아 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/DocumentHandler.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.DocumentHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는
 이름 공간을 지원하는 SAX2 <A HREF="org/xml/sax/ContentHandler.html" title="org.xml.sax 중의 인터페이스"><CODE>ContentHandler</CODE></A>  인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynAny.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynAny</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynAny.html">DynAny</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynArray.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynArray</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynArray.html">DynArray</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynEnum.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynEnum</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynEnum.html">DynEnum</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynFixed.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynFixed</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynFixed.html">DynFixed</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynSequence.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynSequence</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynSequence.html">DynSequence</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynStruct.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynStruct</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynStruct.html">DynStruct</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynUnion.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynUnion</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynUnion.html">DynUnion</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynValue.html" title="org.omg.CORBA 안의 인터페이스">org.omg.CORBA.DynValue</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/&#046;&#046;/DynamicAny/DynValue.html">DynValue</a> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.LoaderHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/Parser.html" title="org.xml.sax 안의 인터페이스">org.xml.sax.Parser</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 인터페이스는
 이름 공간을 지원하는 SAX2 <A HREF="org/xml/sax/XMLReader.html" title="org.xml.sax 중의 인터페이스"><CODE>XMLReader</CODE></A>  인터페이스로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html" title="java.rmi.registry 안의 인터페이스">java.rmi.registry.RegistryHandler</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.RemoteCall</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html" title="java.rmi.server 안의 인터페이스">java.rmi.server.Skeleton</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 리모트 메서드 호출에서는 필요 없습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="class"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 클래스</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/accessibility/AccessibleResourceBundle.html" title="javax.accessibility 안의 클래스">javax.accessibility.AccessibleResourceBundle</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼의 버젼 1.3 에서는
 이 클래스는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/helpers/AttributeListImpl.html" title="org.xml.sax.helpers 안의 클래스">org.xml.sax.helpers.AttributeListImpl</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 비추천의 인터페이스 <A HREF="org/xml/sax/AttributeList.html" title="org.xml.sax 내의 인터페이스"><CODE>AttributeList</CODE></A> 를
 구현합니다. 이 인터페이스는 벌써,<A HREF="org/xml/sax/helpers/AttributesImpl.html" title="org.xml.sax.helpers 안의 클래스"><CODE>AttributesImpl </CODE></A>  헬퍼 클래스에 구현되고 있는 <A HREF="org/xml/sax/Attributes.html" title="org.xml.sax 동안의 인터페이스"><CODE>Attributes</CODE></A>  로 옮겨지고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/DefaultLoaderRepository.html" title="javax.management 안의 클래스">javax.management.DefaultLoaderRepository</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 <A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/loading/DefaultLoaderRepository.html" title="javax.management.loading 안의 클래스">javax.management.loading.DefaultLoaderRepository</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A> 를
 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/DefaultTextUI.html" title="javax.swing.text 안의 클래스">javax.swing.text.DefaultTextUI</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynamicImplementation.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.DynamicImplementation</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>org.omg.CORBA.DynamicImplementation</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/HandlerBase.html" title="org.xml.sax 안의 클래스">org.xml.sax.HandlerBase</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 비추천 <A HREF="org/xml/sax/DocumentHandler.html" title="org.xml.sax 중의 인터페이스"><CODE>DocumentHandler</CODE></A>  인터페이스로 동작합니다. SAX2 에서는
 이 클래스는 <A HREF="org/xml/sax/helpers/DefaultHandler.html" title="org.xml.sax.helpers 안의 클래스"><CODE>DefaultHandler</CODE></A>  클래스에서 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Identity.html" title="java.security 안의 클래스">java.security.Identity</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/IdentityScope.html" title="java.security 안의 클래스">java.security.IdentityScope</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/LineNumberInputStream.html" title="java.io 안의 클래스">java.io.LineNumberInputStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는
 바이트가 적절히 문자를 표현한다고 하는 부정확한 가정을 합니다. JDK&nbsp;1. 1 이후, 문자 스트림의 처리에는
 행 번호를 카운트하기 위한 클래스가 포함되어 있는 새로운 문자 스트림 클래스를 사용하는 것이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html" title="java.rmi.server 안의 클래스">java.rmi.server.LogStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.MetalComboPopup.html" title="javax.swing.plaf.metal 안의 클래스">javax.swing.plaf.metal.MetalComboBoxUI.MetalComboPopup</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html" title="java.rmi.server 안의 클래스">java.rmi.server.Operation</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/xml/sax/helpers/ParserFactory.html" title="org.xml.sax.helpers 안의 클래스">org.xml.sax.helpers.ParserFactory</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는
 비추천 <A HREF="org/xml/sax/Parser.html" title="org.xml.sax 중의 인터페이스"><CODE>Parser</CODE></A>  인터페이스와 함께 동작합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/security/auth/Policy.html" title="javax.security.auth 안의 클래스">javax.security.auth.Policy</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 로 java.security.Policy 로 옮겨졌습니다. java.security.Policy 에는 다음의 메서드가 존재합니다.
 
 <pre>

        public PermissionCollection getPermissions
            (java.security.ProtectionDomain pd)
 
 </pre>
또, ProtectionDomain 에는 다음의 생성자가 있습니다.
 
 <pre>

        public ProtectionDomain
            (CodeSource cs,
             PermissionCollection permissions,
             ClassLoader loader,
             Principal[] principals)
 </pre>

이것들 2 개의 API는

 호출 측에
 Principal 베이스의 Permission 엔트리용 Policy
 문의를 실행하는 수단을 제공합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.Principal</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/PrincipalHolder.html" title="org.omg.CORBA 안의 클래스">org.omg.CORBA.PrincipalHolder</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signer.html" title="java.security 안의 클래스">java.security.Signer</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 현재 사용되고 있지 않습니다. 이 클래스의 기능은,<code>java.security.KeyStore</code> 클래스,<code>java.security.cert</code> 패키지 및 <code>java.security.Principal</code> 클래스로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/StringBufferInputStream.html" title="java.io 안의 클래스">java.io.StringBufferInputStream</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는 문자를 적절히 바이트로 변환할 수 없습니다. JDK 1.1 현재, 캐릭터 라인으로부터 스트림을 작성하려면,
<code>StringReader</code> 클래스를 사용하는 것이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/TableView.TableCell.html" title="javax.swing.text 안의 클래스">javax.swing.text.TableView.TableCell</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>테이블 셀은 임의의 View 구현이 될 수가 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/timer/TimerAlarmClockNotification.html" title="javax.management.timer 안의 클래스">javax.management.timer.TimerAlarmClockNotification</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 클래스는
 호환성을 위해서 보관 유지되고 있는 것만으로 유저 코드에서는 사용되지 않습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="exception"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 예외</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html" title="java.rmi 안의 클래스">java.rmi.RMISecurityException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 <A HREF="java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A> 를
 사용합니다. 어플리케이션 코드로부터 이 클래스를 직접 참조하지 말아 주세요. <code>RMISecurityManager</code>는

 현재는 이 <code>java.lang.SecurityException</code>
 서브 클래스를 Throw 하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/ServerRuntimeException.html" title="java.rmi 안의 클래스">java.rmi.ServerRuntimeException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonMismatchException.html" title="java.rmi.server 안의 클래스">java.rmi.server.SkeletonMismatchException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 리모트 메서드 호출에서는 필요 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonNotFoundException.html" title="java.rmi.server 안의 클래스">java.rmi.server.SkeletonNotFoundException</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. 스켈리턴은, Java 2 플랫폼 1.2 이후의 버젼의 리모트 메서드 호출에서는 필요 없습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="field"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 필드</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#alreadyNotified">javax.management.monitor.Monitor.alreadyNotified</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/monitor/Monitor.html#alreadyNotifieds"><CODE>Monitor.alreadyNotifieds</CODE></A> [0] 으로 동등합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#backingStore">javax.swing.JViewport.backingStore</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#closeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.closeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#CROSSHAIR_CURSOR">java.awt.Frame.CROSSHAIR_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.CROSSHAIR_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#dbgTag">javax.management.monitor.Monitor.dbgTag</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#DEFAULT_CURSOR">java.awt.Frame.DEFAULT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.DEFAULT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#defaultPressAction">javax.swing.JRootPane.defaultPressAction</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#defaultReleaseAction">javax.swing.JRootPane.defaultReleaseAction</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#dividerResizeToggleKey">javax.swing.plaf.basic.BasicSplitPaneUI.dividerResizeToggleKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#downKey">javax.swing.plaf.basic.BasicToolBarUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#downKey">javax.swing.plaf.basic.BasicTabbedPaneUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#downKey">javax.swing.plaf.basic.BasicSplitPaneUI.downKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#E_RESIZE_CURSOR">java.awt.Frame.E_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.E_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#endKey">javax.swing.plaf.basic.BasicSplitPaneUI.endKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#HAND_CURSOR">java.awt.Frame.HAND_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.HAND_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#homeKey">javax.swing.plaf.basic.BasicSplitPaneUI.homeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/HttpURLConnection.html#HTTP_SERVER_ERROR">java.net.HttpURLConnection.HTTP_SERVER_ERROR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>잘못한 필드이며, 존재해야 하는 것이어 선. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inCheck">java.lang.SecurityManager.inCheck</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardDownRightListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardDownRightListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardEndListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardEndListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardHomeListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardHomeListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardResizeToggleListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardResizeToggleListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#keyboardUpLeftListener">javax.swing.plaf.basic.BasicSplitPaneUI.keyboardUpLeftListener</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#leftKey">javax.swing.plaf.basic.BasicToolBarUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#leftKey">javax.swing.plaf.basic.BasicTabbedPaneUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#leftKey">javax.swing.plaf.basic.BasicSplitPaneUI.leftKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#maximizeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.maximizeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#minimizeKey">javax.swing.plaf.basic.BasicDesktopPaneUI.minimizeKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#MOVE_CURSOR">java.awt.Frame.MOVE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.MOVE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#N_RESIZE_CURSOR">java.awt.Frame.N_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.N_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#navigateKey">javax.swing.plaf.basic.BasicDesktopPaneUI.navigateKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicDesktopPaneUI.html#navigateKey2">javax.swing.plaf.basic.BasicDesktopPaneUI.navigateKey2</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#NE_RESIZE_CURSOR">java.awt.Frame.NE_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.NE_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#NW_RESIZE_CURSOR">java.awt.Frame.NW_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.NW_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicInternalFrameUI.html#openMenuKey">javax.swing.plaf.basic.BasicInternalFrameUI.openMenuKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#plainTextFlavor">java.awt.datatransfer.DataFlavor.plainTextFlavor</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.3 에서는
<code>Transferable.getTransferData(DataFlavor.plainTextFlavor)</code>는
 아니고,<code>DataFlavor.getReaderForText(Transferable)</code>를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/FormView.html#RESET">javax.swing.text.html.FormView.RESET</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.3 에 대해서는
 FormView.resetButtonText
 UIManager 프로퍼티로부터의 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#resizedPostingDisableCount">javax.swing.table.TableColumn.resizedPostingDisableCount</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#rightKey">javax.swing.plaf.basic.BasicToolBarUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#rightKey">javax.swing.plaf.basic.BasicTabbedPaneUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#rightKey">javax.swing.plaf.basic.BasicSplitPaneUI.rightKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#S_RESIZE_CURSOR">java.awt.Frame.S_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.S_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#SE_RESIZE_CURSOR">java.awt.Frame.SE_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.SE_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/FormView.html#SUBMIT">javax.swing.text.html.FormView.SUBMIT</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.3 에 대해서는
 FormView.submitButtonText
 UIManager 프로퍼티로부터의 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.UnicodeBlock.html#SURROGATES_AREA">java.lang.Character.UnicodeBlock.SURROGATES_AREA</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 5 에서는
<A HREF="java/lang/Character.UnicodeBlock.html#HIGH_SURROGATES"><CODE>Character.UnicodeBlock.HIGH_SURROGATES</CODE></A>,
<A HREF="java/lang/Character.UnicodeBlock.html#HIGH_PRIVATE_USE_SURROGATES"><CODE>Character.UnicodeBlock.HIGH_PRIVATE_USE_SURROGATES</CODE></A>  및 <A HREF="java/lang/Character.UnicodeBlock.html#LOW_SURROGATES"><CODE>Character.UnicodeBlock.LOW_SURROGATES</CODE></A> 를
 사용합니다. 이러한 새로운 정수는
 Unicode 표준의 블록 정의에 일치합니다. <A HREF="java/lang/Character.UnicodeBlock.html#of(char)"><CODE>Character.UnicodeBlock.of(char)</CODE></A>  메서드와 <A HREF="java/lang/Character.UnicodeBlock.html#of(int)"><CODE>Character.UnicodeBlock.of(int)</CODE></A>  메서드는
 SURROGATES_AREA는
 아니고, 새로운 정수를 돌려줍니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#SW_RESIZE_CURSOR">java.awt.Frame.SW_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.SW_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#TEXT_CURSOR">java.awt.Frame.TEXT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.TEXT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicToolBarUI.html#upKey">javax.swing.plaf.basic.BasicToolBarUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicTabbedPaneUI.html#upKey">javax.swing.plaf.basic.BasicTabbedPaneUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#upKey">javax.swing.plaf.basic.BasicSplitPaneUI.upKey</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#W_RESIZE_CURSOR">java.awt.Frame.W_RESIZE_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.W_RESIZE_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#WAIT_CURSOR">java.awt.Frame.WAIT_CURSOR</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Cursor.WAIT_CURSOR</code> 로 옮겨놓을 수 있고 있습니다. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="method"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 메서드</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#action(java.awt.Event, java.lang.Object)">java.awt.Component.action(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 이 컴퍼넌트를 액션 이벤트를 트리거 하는 컴퍼넌트의 ActionListener 로서 등록할 필요가 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#addItem(java.lang.String)">java.awt.List.addItem(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>add(String)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#addItem(java.lang.String, int)">java.awt.List.addItem(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>add(String, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/BorderLayout.html#addLayoutComponent(java.lang.String, java.awt.Component)">java.awt.BorderLayout.addLayoutComponent(String, Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>addLayoutComponent(Component, Object)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CardLayout.html#addLayoutComponent(java.lang.String, java.awt.Component)">java.awt.CardLayout.addLayoutComponent(String, Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>addLayoutComponent(Component, Object)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#allowsMultipleSelections()">java.awt.List.allowsMultipleSelections()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>isMultipleMode()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#allowThreadSuspension(boolean)">java.lang.ThreadGroup.allowThreadSuspension(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 호출의 정의는
 추천되어 있지 않은 <A HREF="java/lang/ThreadGroup.html#suspend()"><CODE>ThreadGroup.suspend()</CODE></A>  에
존합니다. 또, 이 호출의 동작은 지정되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#appendText(java.lang.String)">java.awt.TextArea.appendText(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>append(String)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#applyResourceBundle(java.util.ResourceBundle)">java.awt.Window.applyResourceBundle(ResourceBundle)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 버젼 1.4 이후는
<A HREF="java/awt/Component.html#applyComponentOrientation(java.awt.ComponentOrientation)"><CODE>Component.applyComponentOrientation</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#applyResourceBundle(java.lang.String)">java.awt.Window.applyResourceBundle(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 버젼 1.4 이후는
<A HREF="java/awt/Component.html#applyComponentOrientation(java.awt.ComponentOrientation)"><CODE>Component.applyComponentOrientation</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#bounds()">java.awt.Component.bounds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getBounds()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#checkMulticast(java.net.InetAddress, byte)">java.lang.SecurityManager.checkMulticast(InetAddress, byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 #checkPermission(java.security.Permission)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#classDepth(java.lang.String)">java.lang.SecurityManager.classDepth(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#classLoaderDepth()">java.lang.SecurityManager.classLoaderDepth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#clear()">java.awt.List.clear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>removeAll()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/image/renderable/RenderContext.html#concetenateTransform(java.awt.geom.AffineTransform)">java.awt.image.renderable.RenderContext.concetenateTransform(AffineTransform)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>ConcatenateTransform(AffineTransform)</code> 로 옮겨지는</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#countComponents()">java.awt.Container.countComponents()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 getComponentCount()를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Menu.html#countItems()">java.awt.Menu.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getItemCount()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#countItems()">java.awt.List.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getItemCount()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Choice.html#countItems()">java.awt.Choice.countItems()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getItemCount()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuBar.html#countMenus()">java.awt.MenuBar.countMenus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMenuCount()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#countStackFrames()">java.lang.Thread.countStackFrames()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 호출의 정의는
 추천 되지 않는 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  에
존합니다. 또, 이 호출의 결과는 보증되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_basic_dyn_any(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_basic_dyn_any(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_any(org.omg.CORBA.Any)">org.omg.CORBA.ORB.create_dyn_any(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_array(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_array(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_enum(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_enum(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_sequence(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_sequence(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_struct(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_struct(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_dyn_union(org.omg.CORBA.TypeCode)">org.omg.CORBA.ORB.create_dyn_union(TypeCode)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 새로운 <a href="org/omg/CORBA/../DynamicAny/DynAnyFactory.html">DynAnyFactory</a>  API를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#create_recursive_sequence_tc(int, int)">org.omg.CORBA.ORB.create_recursive_sequence_tc(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 create_recursive_tc 와 create_sequence_tc
 편성을 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardDownRightListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardDownRightListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardEndListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardEndListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardHomeListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardHomeListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardResizeToggleListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardResizeToggleListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#createKeyboardUpLeftListener()">javax.swing.plaf.basic.BasicSplitPaneUI.createKeyboardUpLeftListener()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JTable.html#createScrollPaneForTable(javax.swing.JTable)">javax.swing.JTable.createScrollPaneForTable(JTable)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/TableView.html#createTableCell(javax.swing.text.Element)">javax.swing.text.TableView.createTableCell(Element)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>테이블 셀은 임의의 View 구현이 될 수가 있습니다만, 테이블은 아니고 ViewFactory 에
해 작성되도록 합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#currentClassLoader()">java.lang.SecurityManager.currentClassLoader()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#currentLoadedClass()">java.lang.SecurityManager.currentLoadedClass()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLDecoder.html#decode(java.lang.String)">java.net.URLDecoder.decode(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>결과의 캐릭터 라인은, 플랫폼의 디폴트의 encode 방식에
해 다른 경우가 있습니다. 혹은, decode(String, String) 메서드를 사용해 encode 방식을 지정합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ClassLoader.html#defineClass(byte[], int, int)">java.lang.ClassLoader.defineClass(byte[], int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/lang/ClassLoader.html#defineClass(java.lang.String, byte[], int, int)"><CODE>defineClass(String, byte[], int, int)</CODE></A>  로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#delItem(int)">java.awt.List.delItem(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>remove(String)</code> 및 <code>remove(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#delItems(int, int)">java.awt.List.delItems(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1
 시점에서는
 장래적으로 일반 이용될 예정은 없습니다. 이 메서드는
 패키지 private 메서드로서만 보관 유지될 예정입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#deliverEvent(java.awt.Event)">java.awt.Component.deliverEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>dispatchEvent(AWTEvent e)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#deliverEvent(java.awt.Event)">java.awt.Container.deliverEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>dispatchEvent(AWTEvent e)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(javax.management.ObjectName, byte[])">javax.management.MBeanServer.deserialize(ObjectName, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoaderFor(javax.management.ObjectName)"><CODE>getClassLoaderFor</CODE></A> 를
 사용해, 직렬화 복원에 사용하는 적절한 클래스 로더를 취득합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(java.lang.String, byte[])">javax.management.MBeanServer.deserialize(String, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoaderRepository()"><CODE>MBeanServer.getClassLoaderRepository()</CODE></A> 를
 사용해 클래스 로더 리포지터리(repository)를 취득해, 이것을 사용해 직렬화 복원을 실시합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/MBeanServer.html#deserialize(java.lang.String, javax.management.ObjectName, byte[])">javax.management.MBeanServer.deserialize(String, ObjectName, byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="javax/management/MBeanServer.html#getClassLoader(javax.management.ObjectName)"><CODE>getClassLoader</CODE></A> 를
 사용해, 직렬화 복원에 사용하는 클래스 로더를 취득합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#destroy()">java.lang.Thread.destroy()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 원래 클린 업없이 파기되도록 설계되고 있었습니다. 보관 유지되는 모니터는 락 된 상태를 유지합니다. 다만, 이 메서드는 구현되지 않았습니다. 구현되고 있으면,<A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  와 거의 똑같이 데드 록이 발생합니다. 타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다. 다른 thread가 이 자원을 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#disable()">java.awt.Component.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#disable()">java.awt.MenuItem.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#disable()">javax.swing.JComponent.disable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#disableResizedPosting()">javax.swing.table.TableColumn.disableResizedPosting()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/FocusManager.html#disableSwingFocusManager()">javax.swing.FocusManager.disableSwingFocusManager()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는 <code>KeyboardFocusManager.setDefaultFocusTraversalPolicy(FocusTraversalPolicy)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html#dispatch(java.rmi.Remote, java.rmi.server.RemoteCall, int, long)">java.rmi.server.Skeleton.dispatch(Remote, RemoteCall, int, long)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#done()">java.rmi.server.RemoteCall.done()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#done(java.rmi.server.RemoteCall)">java.rmi.server.RemoteRef.done(RemoteCall)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 그루터기는
 이 메서드를 사용하지 않습니다. 리모트 참조로 일련의 메서드 호출 (<code>newCall</code>,<code>invoke</code> 및 <code>done</code>)을 사용하는 대신에
 그루터기는 리모트 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메서드만을 사용해 파라미터의 정렬화, 리모트 메서드의 실행 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.html#editablePropertyChanged(java.beans.PropertyChangeEvent)">javax.swing.plaf.metal.MetalComboBoxUI.editablePropertyChanged(PropertyChangeEvent)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#enable()">java.awt.Component.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#enable()">java.awt.MenuItem.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#enable()">javax.swing.JComponent.enable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#enable(boolean)">java.awt.Component.enable(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuItem.html#enable(boolean)">java.awt.MenuItem.enable(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEnabled(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/table/TableColumn.html#enableResizedPosting()">javax.swing.table.TableColumn.enableResizedPosting()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLEncoder.html#encode(java.lang.String)">java.net.URLEncoder.encode(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>결과의 캐릭터 라인은, 플랫폼의 디폴트의 encode 방식에
해 다른 경우가 있습니다. 혹은, encode(String, String) 메서드를 사용해 encode 방식을 지정합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/SignatureSpi.html#engineGetParameter(java.lang.String)">java.security.SignatureSpi.engineGetParameter(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/SignatureSpi.html#engineSetParameter(java.lang.String, java.lang.Object)">java.security.SignatureSpi.engineSetParameter(String, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/security/SignatureSpi.html#engineSetParameter(java.security.spec.AlgorithmParameterSpec)"><CODE>engineSetParameter</CODE></A>  로 옮겨놓습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#equals(java.lang.String)">java.awt.datatransfer.DataFlavor.equals(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>hashCode()</code> 규약과 일관성이 없기 때문에
 대신에 <code>isMimeTypeEqual(String)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#except(org.omg.CORBA.Any)">org.omg.CORBA.ServerRequest.except(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>set_exception()를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#executeCall()">java.rmi.server.RemoteCall.executeCall()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Any.html#extract_Principal()">org.omg.CORBA.Any.extract_Principal()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/SwingUtilities.html#findFocusOwner(java.awt.Component)">javax.swing.SwingUtilities.findFocusOwner(Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>버젼 1.4 이후,<code>KeyboardFocusManager.getFocusOwner()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ORB.html#get_current()">org.omg.CORBA.ORB.get_current()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>resolve_initial_references</code>를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Security.html#getAlgorithmProperty(java.lang.String, java.lang.String)">java.security.Security.getAlgorithmProperty(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는
 SUN 암호화 서비스 프로바이더의 마스터 파일내에 있는 소유 프로퍼티의 값을 돌려주기 위해서 사용됩니다. 이것은, 알고리즘 고유의 파라미터의 구문 분석 방법을 결정하기 위한 처리입니다. 이 메서드 대신에
 새로운 프로바이더를 기본으로 하는 알고리즘에
존하지 않는
<code>AlgorithmParameters</code> 및 <code>KeyFactory</code> 엔진 클래스 (Java 2 플랫폼보다 도입)를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getBigDecimal(int, int)">java.sql.ResultSet.getBigDecimal(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/CallableStatement.html#getBigDecimal(int, int)">java.sql.CallableStatement.getBigDecimal(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getBigDecimal(int parameterIndex)</code> 또는 <code>getBigDecimal(String parameterName)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getBigDecimal(java.lang.String, int)">java.sql.ResultSet.getBigDecimal(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Polygon.html#getBoundingBox()">java.awt.Polygon.getBoundingBox()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getBounds()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#getBytes(int, int, byte[], int)">java.lang.String.getBytes(int, int, byte[], int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드에서는
 문자로부터 바이트에의 변환이 올바르게 행해지지 않습니다. JDK&nbsp;1. 1 에서는
 문자로부터 바이트에의 변환에는
 플랫폼의 디폴트 캐릭터셋를 사용하는 <code>getBytes()</code> 메서드의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Graphics.html#getClipRect()">java.awt.Graphics.getClipRect()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getClipBounds()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JMenuBar.html#getComponentAtIndex(int)">javax.swing.JMenuBar.getComponentAtIndex(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getComponent(int i)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPopupMenu.html#getComponentAtIndex(int)">javax.swing.JPopupMenu.getComponentAtIndex(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getComponent(int i)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CheckboxGroup.html#getCurrent()">java.awt.CheckboxGroup.getCurrent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후에서는 <code>getSelectedCheckbox()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#getCursorType()">java.awt.Frame.getCursorType()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Component.getCursor()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getDate()">java.sql.Time.getDate()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getDate()">java.util.Date.getDate()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.MONTH)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getDay()">java.sql.Time.getDay()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getDay()">java.util.Date.getDay()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.DAY_OF_WEEK)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLConnection.html#getDefaultRequestProperty(java.lang.String)">java.net.URLConnection.getDefaultRequestProperty(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>URLConnection
 해당 인스턴스를 취득한 뒤는
 인스턴스 고유의 getRequestProperty를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#getDefaultStream()">java.rmi.server.LogStream.getDefaultStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGauge()">javax.management.monitor.StringMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>StringMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitor.html#getDerivedGauge()">javax.management.monitor.StringMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/StringMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>StringMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGauge()">javax.management.monitor.GaugeMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>GaugeMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGauge()">javax.management.monitor.GaugeMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>GaugeMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGauge()">javax.management.monitor.CounterMonitorMBean.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGauge(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getDerivedGauge(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGauge()">javax.management.monitor.CounterMonitor.getDerivedGauge()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGauge(javax.management.ObjectName)"><CODE>CounterMonitor.getDerivedGauge(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.StringMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/StringMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>StringMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/StringMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.StringMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/StringMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>StringMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.GaugeMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/GaugeMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>GaugeMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.GaugeMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/GaugeMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>GaugeMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGaugeTimeStamp()">javax.management.monitor.CounterMonitorMBean.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/CounterMonitorMBean.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGaugeTimeStamp()">javax.management.monitor.CounterMonitor.getDerivedGaugeTimeStamp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#getDerivedGaugeTimeStamp(javax.management.ObjectName)"><CODE>CounterMonitor.getDerivedGaugeTimeStamp(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/basic/BasicSplitPaneUI.html#getDividerBorderSize()">javax.swing.plaf.basic.BasicSplitPaneUI.getDividerBorderSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 에서는
 대신에 드라이버에 보더를 설정합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontList()">java.awt.Toolkit.getFontList()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/awt/GraphicsEnvironment.html#getAvailableFontFamilyNames()"><CODE>GraphicsEnvironment.getAvailableFontFamilyNames()</CODE></A> 를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/LabelView.html#getFontMetrics()">javax.swing.text.LabelView.getFontMetrics()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>FontMetrics는

 Java2 SDK 로 실행하는 경우는 그래프
 렌더링에는 사용되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontMetrics(java.awt.Font)">java.awt.Toolkit.getFontMetrics(Font)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.2 이후는
 <code>Font</code> 메서드 <code>getLineMetrics</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Toolkit.html#getFontPeer(java.lang.String, int)">java.awt.Toolkit.getFontPeer(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>java.awt.GraphicsEnvironment#getAllFonts를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getHours()">java.sql.Date.getHours()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getHours()">java.util.Date.getHours()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.HOUR_OF_DAY)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#getInCheck()">java.lang.SecurityManager.getInCheck()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getInputStream()">java.rmi.server.RemoteCall.getInputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/KeyStroke.html#getKeyStroke(char, boolean)">javax.swing.KeyStroke.getKeyStroke(char, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>getKeyStroke(char)를 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/AbstractButton.html#getLabel()">javax.swing.AbstractButton.getLabel()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getText</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getLineIncrement()">java.awt.Scrollbar.getLineIncrement()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getUnitIncrement()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#getLocalizedInputStream(java.io.InputStream)">java.lang.Runtime.getLocalizedInputStream(InputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK&nbsp;1. 1 에서는
 로컬인 인코딩의 바이트 스트림을 Unicode
 문자 스트림로 변환하려면,
<code>InputStreamReader</code> 클래스와 <code>BufferedReader</code> 클래스를 사용하는 (분)편이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#getLocalizedOutputStream(java.io.OutputStream)">java.lang.Runtime.getLocalizedOutputStream(OutputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK&nbsp;1. 1 에서는
 Unicode
 문자 스트림을 로컬인 인코딩의 바이트 스트림로 변환하려면,
<code>OutputStreamWriter</code> 클래스,<code>BufferedWriter</code> 클래스 및 <code>PrintWriter</code> 클래스를 사용하는 (분)편이 적절합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/DriverManager.html#getLogStream()">java.sql.DriverManager.getLogStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@see #setLogStream</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/FontMetrics.html#getMaxDecent()">java.awt.FontMetrics.getMaxDecent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1. 1 이후는 <code>getMaxDescent()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#getMenuBar()">javax.swing.JRootPane.getMenuBar()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 3 으로 <code>getJMenuBar()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JInternalFrame.html#getMenuBar()">javax.swing.JInternalFrame.getMenuBar()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 3 으로 <code>getJMenuBar()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getMinutes()">java.sql.Date.getMinutes()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getMinutes()">java.util.Date.getMinutes()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.MINUTE)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getMonth()">java.sql.Time.getMonth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getMonth()">java.util.Date.getMonth()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.MONTH)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#getNextFocusableComponent()">javax.swing.JComponent.getNextFocusableComponent()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/MonitorMBean.html#getObservedObject()">javax.management.monitor.MonitorMBean.getObservedObject()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/MonitorMBean.html#getObservedObjects()"><CODE>MonitorMBean.getObservedObjects()</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#getObservedObject()">javax.management.monitor.Monitor.getObservedObject()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/Monitor.html#getObservedObjects()"><CODE>Monitor.getObservedObjects()</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#getOperation()">java.rmi.server.Operation.getOperation()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Skeleton.html#getOperations()">java.rmi.server.Skeleton.getOperations()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/ComponentOrientation.html#getOrientation(java.util.ResourceBundle)">java.awt.ComponentOrientation.getOrientation(ResourceBundle)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>J2SE 1.4 로부터는 <A HREF="java/awt/ComponentOrientation.html#getOrientation(java.util.Locale)"><CODE>ComponentOrientation.getOrientation(java.util.Locale)</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getOutputStream()">java.rmi.server.RemoteCall.getOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#getOutputStream()">java.rmi.server.LogStream.getOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getPageIncrement()">java.awt.Scrollbar.getPageIncrement()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getBlockIncrement()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signature.html#getParameter(java.lang.String)">java.security.Signature.getParameter(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#getPeer()">java.awt.Component.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 프로그램은 직접 피어를 조작할 수 없습니다. <code>boolean isDisplayable()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Font.html#getPeer()">java.awt.Font.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>폰트의 렌더링는 현재는 어느 플랫폼으로도 같습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuComponent.html#getPeer()">java.awt.MenuComponent.getPeer()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 프로그램으로부터 피어를 직접 조작할 수 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#getResultStream(boolean)">java.rmi.server.RemoteCall.getResultStream(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#getSeconds()">java.sql.Date.getSeconds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getSeconds()">java.util.Date.getSeconds()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.SECOND)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RMIClassLoader.html#getSecurityContext(java.lang.ClassLoader)">java.rmi.server.RMIClassLoader.getSecurityContext(ClassLoader)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는
 클래스 로더의 시큐러티 컨텍스트
을 취득하기 위해서 이 메서드를 사용하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#getSecurityContext(java.lang.ClassLoader)">java.rmi.server.LoaderHandler.getSecurityContext(ClassLoader)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPasswordField.html#getText()">javax.swing.JPasswordField.getText()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 2 이후,<code>getPassword</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JPasswordField.html#getText(int, int)">javax.swing.JPasswordField.getText(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 2 이후,<code>getPassword</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#getThreshold()">javax.management.monitor.CounterMonitorMBean.getThreshold()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/CounterMonitorMBean.html#getThreshold(javax.management.ObjectName)"><CODE>CounterMonitorMBean.getThreshold(ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#getThreshold()">javax.management.monitor.CounterMonitor.getThreshold()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#getThreshold(javax.management.ObjectName)"><CODE>CounterMonitor.getThreshold(ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getTimezoneOffset()">java.util.Date.getTimezoneOffset()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>-(Calendar.get(Calendar.ZONE_OFFSET) + Calendar.get(Calendar.DST_OFFSET)) / (60 * 1000)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#getTTL()">java.net.MulticastSocket.getTTL()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에
<b>byte</b>는
 아니고 <b>int</b>를
 돌려주는 getTimeToLive 메서드를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/DatagramSocketImpl.html#getTTL()">java.net.DatagramSocketImpl.getTTL()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 getTimeToLive를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getUnicodeStream(int)">java.sql.ResultSet.getUnicodeStream(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>getUnicodeStream</code> 대신에 <code>getCharacterStream</code>를
 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/ResultSet.html#getUnicodeStream(java.lang.String)">java.sql.ResultSet.getUnicodeStream(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 <code>getCharacterStream</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/ScrollPaneLayout.html#getViewportBorderBounds(javax.swing.JScrollPane)">javax.swing.ScrollPaneLayout.getViewportBorderBounds(JScrollPane)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 Swing1. 1 이후는
<code>JScrollPane.getViewportBorderBounds()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#getVisible()">java.awt.Scrollbar.getVisible()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getVisibleAmount()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#getYear()">java.sql.Time.getYear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#getYear()">java.util.Date.getYear()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.get(Calendar.YEAR) - 1900</code> 으로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">java.awt.Component.gotFocus(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processFocusEvent(FocusEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#handleEvent(java.awt.Event)">java.awt.Component.handleEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processEvent(AWTEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#hide()">java.awt.Component.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setVisible(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#hide()">java.awt.Window.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 5 이후에서는 <A HREF="java/awt/Component.html#setVisible(boolean)"><CODE>Component.setVisible(boolean)</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Dialog.html#hide()">java.awt.Dialog.hide()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후에서는 <A HREF="java/awt/Component.html#setVisible(boolean)"><CODE>Component.setVisible(boolean)</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inClass(java.lang.String)">java.lang.SecurityManager.inClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/SecurityManager.html#inClassLoader()">java.lang.SecurityManager.inClassLoader()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 타입의 시큐러티 체크는 추천 되지 않습니다. 대신에 <code>checkPermission</code>
 호출을 사용하는 것을 추천합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Any.html#insert_Principal(org.omg.CORBA.Principal)">org.omg.CORBA.Any.insert_Principal(Principal)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/html/HTMLEditorKit.InsertHTMLTextAction.html#insertAtBoundry(javax.swing.JEditorPane, javax.swing.text.html.HTMLDocument, int, javax.swing.text.Element, java.lang.String, javax.swing.text.html.HTML.Tag, javax.swing.text.html.HTML.Tag)">javax.swing.text.html.HTMLEditorKit.InsertHTMLTextAction.insertAtBoundry(JEditorPane, HTMLDocument, int, Element, String, HTML.Tag, HTML.Tag)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 에 대해 insertAtBoundary를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#insertText(java.lang.String, int)">java.awt.TextArea.insertText(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>insert(String, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#insets()">java.awt.Container.insets()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getInsets()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#inside(int, int)">java.awt.Component.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 contains(int, int)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#inside(int, int)">java.awt.Rectangle.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>contains(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Polygon.html#inside(int, int)">java.awt.Polygon.inside(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>contains(int, int)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#invoke(java.rmi.server.RemoteCall)">java.rmi.server.RemoteRef.invoke(RemoteCall)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 그루터기는
 이 메서드를 사용하지 않습니다. 리모트 참조로 일련의 메서드 호출 (<code>newCall</code>,<code>invoke</code> 및 <code>done</code>)을 사용하는 대신에
 그루터기는 리모트 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메서드만을 사용해 파라미터의 정렬화, 리모트 메서드의 실행 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/DynamicImplementation.html#invoke(org.omg.CORBA.ServerRequest)">org.omg.CORBA.DynamicImplementation.invoke(ServerRequest)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Portable Object Adapter 에서는 추천 되지 않는</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#isBackingStoreEnabled()">javax.swing.JViewport.isBackingStoreEnabled()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후,<code>getScrollMode()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/FocusManager.html#isFocusManagerEnabled()">javax.swing.FocusManager.isFocusManagerEnabled()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는 <code>KeyboardFocusManager.getDefaultFocusTraversalPolicy()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#isFocusTraversable()">java.awt.Component.isFocusTraversable()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는
<code>isFocusable()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isJavaLetter(char)">java.lang.Character.isJavaLetter(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isJavaIdentifierStart(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isJavaLetterOrDigit(char)">java.lang.Character.isJavaLetterOrDigit(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isJavaIdentifierPart(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#isManagingFocus()">javax.swing.JComponent.isManagingFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#isSelected(int)">java.awt.List.isSelected(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>isIndexSelected(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Character.html#isSpace(char)">java.lang.Character.isSpace(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>isWhitespace(char)로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/dgc/VMID.html#isUnique()">java.rmi.dgc.VMID.isUnique()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#keyDown(java.awt.Event, int)">java.awt.Component.keyDown(Event, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processKeyEvent(KeyEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#keyUp(java.awt.Event, int)">java.awt.Component.keyUp(Event, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processKeyEvent(KeyEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#layout()">java.awt.Component.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>doLayout()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#layout()">java.awt.Container.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>doLayout()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/ScrollPane.html#layout()">java.awt.ScrollPane.layout()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>doLayout()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String)">java.rmi.server.RMIClassLoader.loadClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>loadClass(String, String)</code> 메서드로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#loadClass(java.lang.String)">java.rmi.server.LoaderHandler.loadClass(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LoaderHandler.html#loadClass(java.net.URL, java.lang.String)">java.rmi.server.LoaderHandler.loadClass(URL, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#locate(int, int)">java.awt.Component.locate(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 getComponentAt(int, int)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#locate(int, int)">java.awt.Container.locate(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getComponentAt(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#location()">java.awt.Component.location()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getLocation()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#log(java.lang.String)">java.rmi.server.LogStream.log(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">java.awt.Component.lostFocus(Event, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processFocusEvent(FocusEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#minimumSize()">java.awt.Component.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#minimumSize()">java.awt.Container.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#minimumSize()">java.awt.TextField.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#minimumSize()">java.awt.TextArea.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#minimumSize()">java.awt.List.minimumSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#minimumSize(int)">java.awt.TextField.minimumSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#minimumSize(int)">java.awt.List.minimumSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#minimumSize(int, int)">java.awt.TextArea.minimumSize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getMinimumSize(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/View.html#modelToView(int, java.awt.Shape)">javax.swing.text.View.modelToView(int, Shape)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseDown(java.awt.Event, int, int)">java.awt.Component.mouseDown(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">java.awt.Component.mouseDrag(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseMotionEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">java.awt.Component.mouseEnter(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseExit(java.awt.Event, int, int)">java.awt.Component.mouseExit(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseMove(java.awt.Event, int, int)">java.awt.Component.mouseMove(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseMotionEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#mouseUp(java.awt.Event, int, int)">java.awt.Component.mouseUp(Event, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 processMouseEvent(MouseEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#move(int, int)">java.awt.Component.move(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setLocation(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#move(int, int)">java.awt.Rectangle.move(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setLocation(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html#name()">org.omg.CORBA.Principal.name()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/Principal.html#name(byte[])">org.omg.CORBA.Principal.name(byte[])</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteRef.html#newCall(java.rmi.server.RemoteObject, java.rmi.server.Operation[], int, long)">java.rmi.server.RemoteRef.newCall(RemoteObject, Operation[], int, long)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.2 형식의 그루터기는
 이 메서드를 사용하지 않습니다. 그루터기의 리모트 참조로 일련의 메서드 호출 (<code>newCall</code>,<code>invoke</code> 및 <code>done</code>)을 사용하는 대신에
 그루터기는 리모트 참조로 <code>invoke(Remote, Method, Object[], int)</code> 메서드만을 사용해, 파라미터의 정렬화, 리모트 메서드의 실행 및 반환값의 비정렬화를 실행합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#nextFocus()">java.awt.Component.nextFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 transferFocus()를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#normalizeMimeType(java.lang.String)">java.awt.datatransfer.DataFlavor.normalizeMimeType(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/datatransfer/DataFlavor.html#normalizeMimeTypeParameter(java.lang.String, java.lang.String)">java.awt.datatransfer.DataFlavor.normalizeMimeTypeParameter(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#op_name()">org.omg.CORBA.ServerRequest.op_name()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>operation()를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#params(org.omg.CORBA.NVList)">org.omg.CORBA.ServerRequest.params(NVList)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>arguments</code> 메서드를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#parse(java.lang.String)">java.util.Date.parse(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>DateFormat.parse(String s)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#parseLevel(java.lang.String)">java.rmi.server.LogStream.parseLevel(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuContainer.html#postEvent(java.awt.Event)">java.awt.MenuContainer.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 dispatchEvent(AWTEvent)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#postEvent(java.awt.Event)">java.awt.Component.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 dispatchEvent(AWTEvent e)를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#postEvent(java.awt.Event)">java.awt.Window.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>dispatchEvent(AWTEvent)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/MenuComponent.html#postEvent(java.awt.Event)">java.awt.MenuComponent.postEvent(Event)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<A HREF="java/awt/MenuComponent.html#dispatchEvent(java.awt.AWTEvent)"><CODE>dispatchEvent</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/image/renderable/RenderContext.html#preConcetenateTransform(java.awt.geom.AffineTransform)">java.awt.image.renderable.RenderContext.preConcetenateTransform(AffineTransform)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>preConcatenateTransform(AffineTransform)</code> 로 옮겨지는</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#preferredSize()">java.awt.Component.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Container.html#preferredSize()">java.awt.Container.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#preferredSize()">java.awt.TextField.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#preferredSize()">java.awt.TextArea.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#preferredSize()">java.awt.List.preferredSize()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#preferredSize(int)">java.awt.TextField.preferredSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#preferredSize(int)">java.awt.List.preferredSize(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#preferredSize(int, int)">java.awt.TextArea.preferredSize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getPreferredSize(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/portable/InputStream.html#read_Principal()">org.omg.CORBA.portable.InputStream.read_Principal()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/DataInputStream.html#readLine()">java.io.DataInputStream.readLine()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는
 바이트를 적절히 캐릭터 라인으로 변환하지 않습니다. JDK&nbsp;1. 1 에서는
 텍스트행을 읽어들이는 방법으로서는 <code>BufferedReader.readLine()</code> 메서드를 사용하는 것이 추천 되고 있습니다. 행을 읽어들이는데 <code>DataInputStream</code> 클래스를 사용하는 프로그램을,<code>BufferedReader</code> 클래스를 사용하도록 변환하려면,
 다음의 형식의 코드를,<blockquote><pre> DataInputStream d =&nbsp;new&nbsp;DataInputStream(in);</pre></blockquote> 다음의 형식의 코드로 옮겨놓습니다. <blockquote><pre> BufferedReader d =&nbsp;new&nbsp;BufferedReader(new&nbsp;InputStreamReader(in)); </pre></blockquote></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ObjectInputStream.html#readLine()">java.io.ObjectInputStream.readLine()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 바이트를 정확하게 문자로 변환하지 않습니다. 상세 및 대체 메서드에 대해서는 DataInputStream를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html#registryImpl(int)">java.rmi.registry.RegistryHandler.registryImpl(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후는
 RMI는
 레지스트리의 구현을 취득하기 위해서 <code>RegistryHandler</code>를
 사용하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/registry/RegistryHandler.html#registryStub(java.lang.String, int)">java.rmi.registry.RegistryHandler.registryStub(String, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후는
 RMI는
 레지스트리의 그루터기를 취득하기 위해서 <code>RegistryHandler</code>를
 사용하지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#releaseInputStream()">java.rmi.server.RemoteCall.releaseInputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteCall.html#releaseOutputStream()">java.rmi.server.RemoteCall.releaseOutputStream()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/plaf/metal/MetalComboBoxUI.html#removeListeners()">javax.swing.plaf.metal.MetalComboBoxUI.removeListeners()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 4 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextArea.html#replaceText(java.lang.String, int, int)">java.awt.TextArea.replaceText(String, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>replaceRange(String, int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#requestDefaultFocus()">javax.swing.JComponent.requestDefaultFocus()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#reshape(int, int, int, int)">java.awt.Component.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setBounds(int, int, int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#reshape(int, int, int, int)">java.awt.Rectangle.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setBounds(int, int, int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#reshape(int, int, int, int)">javax.swing.JComponent.reshape(int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 5 이후는
<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.
 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#resize(java.awt.Dimension)">java.awt.Component.resize(Dimension)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setSize(Dimension)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#resize(int, int)">java.awt.Component.resize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setSize(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Rectangle.html#resize(int, int)">java.awt.Rectangle.resize(int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setSize(int, int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/ServerRequest.html#result(org.omg.CORBA.Any)">org.omg.CORBA.ServerRequest.result(Any)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>set_result</code> 메서드를 사용하는</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#resume()">java.lang.Thread.resume()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A>  와 함께 사용하기 위해인 만큼 제공되고 있습니다. 자세한 것은,<a href="../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#resume()">java.lang.ThreadGroup.resume()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 단지 <tt>Thread.suspend</tt> 및 <tt>ThreadGroup.suspend</tt> 와 조합해 사용됩니다. 모두 데드 록을 발생시키기 쉽기 때문에 추천 되지 않습니다. 자세한 것은 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A> 를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/System.html#runFinalizersOnExit(boolean)">java.lang.System.runFinalizersOnExit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. 다른 thread가 동시에 그러한 오브젝트를 조작하고 있을 때, 생존중의 오브젝트에 대해서 파이나라이자가 불려 가 이것에
해, 에러 동작 또는 데드 록이 발생합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Runtime.html#runFinalizersOnExit(boolean)">java.lang.Runtime.runFinalizersOnExit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. 다른 thread가 동시에 그러한 오브젝트를 조작하고 있을 때, 생존중의 오브젝트에 대해서 파이나라이자가 불려 가 이것에
해, 에러 동작 또는 데드 록이 발생합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Properties.html#save(java.io.OutputStream, java.lang.String)">java.util.Properties.save(OutputStream, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는
 프로퍼티 리스트의 보존중에 입출력 에러가 발생해도 IOException를
 Throw 하지 않습니다. 프로퍼티 리스트의 보존 방법으로서는
<code>store(OutputStream out, String comments)</code> 메서드 또는 <code>storeToXML(OutputStream os, String comment)</code> 메서드의 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#send(java.net.DatagramPacket, byte)">java.net.MulticastSocket.send(DatagramPacket, byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>다음의 코드 또는 그것과 동등의 코드를 사용한다: ...... int ttl = mcastSocket.getTimeToLive(); mcastSocket.setTimeToLive(newttl); mcastSocket.send(p); mcastSocket.setTimeToLive(ttl); ......</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JViewport.html#setBackingStoreEnabled(boolean)">javax.swing.JViewport.setBackingStoreEnabled(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Java 2 플랫폼 v1. 3 이후,<code>setScrollMode()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/CheckboxGroup.html#setCurrent(java.awt.Checkbox)">java.awt.CheckboxGroup.setCurrent(Checkbox)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후에서는 <code>setSelectedCheckbox(Checkbox)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Frame.html#setCursor(int)">java.awt.Frame.setCursor(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Component.setCursor(Cursor)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setDate(int)">java.sql.Time.setDate(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setDate(int)">java.util.Date.setDate(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.DAY_OF_MONTH, int date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLConnection.html#setDefaultRequestProperty(java.lang.String, java.lang.String)">java.net.URLConnection.setDefaultRequestProperty(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>URLConnection
 해당 인스턴스를 취득한 뒤는
 인스턴스 고유의 setRequestProperty를
 사용합니다. 이 메서드를 호출해도, 아무것도 행해지지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#setDefaultStream(java.io.PrintStream)">java.rmi.server.LogStream.setDefaultStream(PrintStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/TextField.html#setEchoCharacter(char)">java.awt.TextField.setEchoCharacter(char)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setEchoChar(char)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setHours(int)">java.sql.Date.setHours(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setHours(int)">java.util.Date.setHours(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.HOUR_OF_DAY, int hours)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/AbstractButton.html#setLabel(java.lang.String)">javax.swing.AbstractButton.setLabel(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>setText(text)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#setLineIncrement(int)">java.awt.Scrollbar.setLineIncrement(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setUnitIncrement(int)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/DriverManager.html#setLogStream(java.io.PrintStream)">java.sql.DriverManager.setLogStream(PrintStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@throws SecurityException - 시큐러티 매니저가 존재해, 그 <code>checkPermission</code> 메서드가 로그 스트림의 설정을 거부했을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/ValueExp.html#setMBeanServer(javax.management.MBeanServer)">javax.management.ValueExp.setMBeanServer(MBeanServer)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>ValueExp</code>는
 MBean 서버에 접속해,<A HREF="javax/management/QueryEval.html#getMBeanServer()"><CODE>QueryEval.getMBeanServer()</CODE></A> 를
 사용해 평가되므로 이 메서드는 불요</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JRootPane.html#setMenuBar(javax.swing.JMenuBar)">javax.swing.JRootPane.setMenuBar(JMenuBar)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 3 으로 <code>setJMenuBar(JMenuBar menu)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JInternalFrame.html#setMenuBar(javax.swing.JMenuBar)">javax.swing.JInternalFrame.setMenuBar(JMenuBar)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 3 으로 <code>setJMenuBar(JMenuBar m)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setMinutes(int)">java.sql.Date.setMinutes(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setMinutes(int)">java.util.Date.setMinutes(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.MINUTE, int minutes)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/event/KeyEvent.html#setModifiers(int)">java.awt.event.KeyEvent.setModifiers(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK1. 1.4 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setMonth(int)">java.sql.Time.setMonth(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setMonth(int)">java.util.Date.setMonth(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.MONTH, int month)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/List.html#setMultipleSelections(boolean)">java.awt.List.setMultipleSelections(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setMultipleMode(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">javax.swing.JComponent.setNextFocusableComponent(Component)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/MonitorMBean.html#setObservedObject(javax.management.ObjectName)">javax.management.monitor.MonitorMBean.setObservedObject(ObjectName)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/MonitorMBean.html#addObservedObject(javax.management.ObjectName)"><CODE>MonitorMBean.addObservedObject(javax.management.ObjectName)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/Monitor.html#setObservedObject(javax.management.ObjectName)">javax.management.monitor.Monitor.setObservedObject(ObjectName)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/Monitor.html#addObservedObject(javax.management.ObjectName)"><CODE>Monitor.addObservedObject(javax.management.ObjectName)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#setOutputStream(java.io.OutputStream)">java.rmi.server.LogStream.setOutputStream(OutputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Scrollbar.html#setPageIncrement(int)">java.awt.Scrollbar.setPageIncrement(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setBlockIncrement()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/security/Signature.html#setParameter(java.lang.String, java.lang.Object)">java.security.Signature.setParameter(String, Object)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><A HREF="java/security/Signature.html#setParameter(java.security.spec.AlgorithmParameterSpec)"><CODE>setParameter</CODE></A> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/RemoteStub.html#setRef(java.rmi.server.RemoteStub, java.rmi.server.RemoteRef)">java.rmi.server.RemoteStub.setRef(RemoteStub, RemoteRef)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. <code>RemoteStub</code> 은 <code>RemoteStub(RemoteRef)</code> 생성자를 사용해 작성할 수 있기 때문에
<code>setRef</code> 메서드는 필요 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#setSeconds(int)">java.sql.Date.setSeconds(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>@exception java.lang.IllegalArgumentException 이 메서드가 불려 갔을 경우</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setSeconds(int)">java.util.Date.setSeconds(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.SECOND, int seconds)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitorMBean.html#setThreshold(java.lang.Number)">javax.management.monitor.CounterMonitorMBean.setThreshold(Number)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 에서는 <A HREF="javax/management/monitor/CounterMonitorMBean.html#setInitThreshold(java.lang.Number)"><CODE>CounterMonitorMBean.setInitThreshold(java.lang.Number)</CODE></A>  로 치환됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/monitor/CounterMonitor.html#setThreshold(java.lang.Number)">javax.management.monitor.CounterMonitor.setThreshold(Number)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JMX 1.2 이후,<A HREF="javax/management/monitor/CounterMonitor.html#setInitThreshold(java.lang.Number)"><CODE>CounterMonitor.setInitThreshold(java.lang.Number)</CODE></A>  로 치환되고 있습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/MulticastSocket.html#setTTL(byte)">java.net.MulticastSocket.setTTL(byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에
 ttl
 형태로서 <b>byte</b>는
 아니고 <b>int</b>를
 사용하는 setTimeToLive 메서드를 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/DatagramSocketImpl.html#setTTL(byte)">java.net.DatagramSocketImpl.setTTL(byte)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 setTimeToLive를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/PreparedStatement.html#setUnicodeStream(int, java.io.InputStream, int)">java.sql.PreparedStatement.setUnicodeStream(int, InputStream, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/sql/rowset/BaseRowSet.html#setUnicodeStream(int, java.io.InputStream, int)">javax.sql.rowset.BaseRowSet.setUnicodeStream(int, InputStream, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 getCharacterStream를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/URLStreamHandler.html#setURL(java.net.URL, java.lang.String, java.lang.String, int, java.lang.String, java.lang.String)">java.net.URLStreamHandler.setURL(URL, String, String, int, String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>setURL(URL, String, int, String, String, String, String)를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#setYear(int)">java.sql.Time.setYear(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></I>&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#setYear(int)">java.util.Date.setYear(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(Calendar.YEAR, year + 1900)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#show()">java.awt.Component.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setVisible(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Window.html#show()">java.awt.Window.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 5 이후에서는 <A HREF="java/awt/Component.html#setVisible(boolean)"><CODE>Component.setVisible(boolean)</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Dialog.html#show()">java.awt.Dialog.show()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK version 1.5 이후에서는 <A HREF="java/awt/Component.html#setVisible(boolean)"><CODE>Component.setVisible(boolean)</CODE></A> 를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#show(boolean)">java.awt.Component.show(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>setVisible(boolean)</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/Component.html#size()">java.awt.Component.size()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>getSize()</code>를
 사용합니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/JTable.html#sizeColumnsToFit(boolean)">javax.swing.JTable.sizeColumnsToFit(boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>Swing 버젼 1.0. 3 이후는
<code>doLayout()</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#stop()">java.lang.Thread.stop()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. Thread.stop를
 사용해 thread를 정지하면, 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에
해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에
해 직전까지 보호되고 있던 오브젝트가 정합성의 없는 상태에 있었을 경우, 망가진 오브젝트는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면,
<code>stop</code>는
 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는 이 변수를 정기적으로 체크해, 변수가 실행 정지를 지시하고 있는 경우는
 run 메서드로부터 적절히 복귀합니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면,
<code>interrupt</code> 메서드를 사용합니다. 자세한 것은,<a href="../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#stop()">java.lang.ThreadGroup.stop()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. 자세한 것은 <A HREF="java/lang/Thread.html#stop()"><CODE>Thread.stop()</CODE></A> 를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#stop(java.lang.Throwable)">java.lang.Thread.stop(Throwable)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. <A HREF="java/lang/Thread.html#stop()"><CODE>Thread.stop()</CODE></A> 를
 참조하십시오. 게다가 이 메서드는
 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메서드가 없으면 thread에
해 Throw 될리가 없는
 체크된 예외 등). 자세한 것은,<a href="../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/Thread.html#suspend()">java.lang.Thread.suspend()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. 타겟 thread가, 중요한 system resource를 보호하고 있는 모니터의 락을 보관 유지하고 있는 상태로 중단되었을 경우, 타겟 thread가 재개될 때까지, 어느 thread도 이 자원에 액세스 할 수 없습니다. 타겟 thread를 재개하려고 하는 thread가,<code>resume</code>를
 호출하기 전에 이 모니터를 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/ThreadGroup.html#suspend()">java.lang.ThreadGroup.suspend()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 본질적으로 데드 록을 발생시키기 쉬워지고 있습니다. 자세한 것은 <A HREF="java/lang/Thread.html#suspend()"><CODE>Thread.suspend()</CODE></A> 를
 참조하십시오. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#toGMTString()">java.util.Date.toGMTString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
 GMT <code>TimeZone</code>를
 사용하는 것으로써,<code>DateFormat.format(Date date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#toLocaleString()">java.util.Date.toLocaleString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>DateFormat.format(Date date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#toString()">java.rmi.server.Operation.toString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#toString()">java.rmi.server.LogStream.toString()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ByteArrayOutputStream.html#toString(int)">java.io.ByteArrayOutputStream.toString(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 바이트를 캐릭터 라인에 적절히 변환할 수 없습니다. JDK&nbsp;1. 1 현재, 추천 되는 방법은, 인코딩명을 인수에 취하는 <code>toString(String enc)</code> 메서드인가, 플랫폼의 디폴트의 캐릭터셋를 사용하는 <code>toString()</code> 메서드를 사용하는 것입니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#UTC(int, int, int, int, int, int)">java.util.Date.UTC(int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(year + 1900, month, date, hrs, min, sec)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min, sec)</code> 로 옮겨졌습니다. UTC <code>TimeZone</code>를
 사용해,<code>Calendar.getTime(). getTime()</code> 가 나중에 계속됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/swing/text/View.html#viewToModel(float, float, java.awt.Shape)">javax.swing.text.View.viewToModel(float, float, Shape)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I></dl></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/portable/OutputStream.html#write_Principal(org.omg.CORBA.Principal)">org.omg.CORBA.portable.OutputStream.write_Principal(Principal)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>CORBA 2.2 에서는 추천 되지 않습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#write(byte[], int, int)">java.rmi.server.LogStream.write(byte[], int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/LogStream.html#write(int)">java.rmi.server.LogStream.write(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/ObjectOutputStream.PutField.html#write(java.io.ObjectOutput)">java.io.ObjectOutputStream.PutField.write(ObjectOutput)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는
<code>PutField</code> 오브젝트에
해 포함되었을 때의 형식에서 값을 기입하지 않기 때문에
 직렬화 스트림이 파괴되는 일이 있습니다. <code>PutField</code>
 데이터를 기입하려면,
<A HREF="java/io/ObjectOutputStream.html#writeFields()"><CODE>ObjectOutputStream.writeFields()</CODE></A>  메서드를 호출해 주세요. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<A NAME="constructor"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>추천되어 있지 않은 constructor　 　</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="javax/management/AttributeValueExp.html#AttributeValueExp()">javax.management.AttributeValueExp()</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 생성자
으로 작성된 인스턴스는
 쿼리 안에서는 사용할 수 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Date.html#Date(int, int, int)">java.sql.Date(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대신에 생성자
<code>Date(long date)</code>를
 사용</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int)">java.util.Date(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(year + 1900, month, date)</code> 또는 <code>GregorianCalendar(year + 1900, month, date)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int, int, int)">java.util.Date(int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(year + 1900, month, date,  hrs, min)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(int, int, int, int, int, int)">java.util.Date(int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>Calendar.set(year + 1900, month, date, hrs, min, sec)</code> 또는 <code>GregorianCalendar(year + 1900, month, date, hrs, min, sec)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/util/Date.html#Date(java.lang.String)">java.util.Date(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 버젼 1.1 이후는
<code>DateFormat.parse(String s)</code> 로 옮겨졌습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/awt/event/KeyEvent.html#KeyEvent(java.awt.Component, int, long, int, int)">java.awt.event.KeyEvent(Component, int, long, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK1. 1 이후</I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/Operation.html#Operation(java.lang.String)">java.rmi.server.Operation(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html#RMISecurityException(java.lang.String)">java.rmi.RMISecurityException(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/RMISecurityException.html#RMISecurityException(java.lang.String, java.lang.String)">java.rmi.RMISecurityException(String, String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/ServerRuntimeException.html#ServerRuntimeException(java.lang.String, java.lang.Exception)">java.rmi.ServerRuntimeException(String, Exception)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/rmi/server/SkeletonMismatchException.html#SkeletonMismatchException(java.lang.String)">java.rmi.server.SkeletonMismatchException(String)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>대체는 없습니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/Socket.html#Socket(java.net.InetAddress, int, boolean)">java.net.Socket(InetAddress, int, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/net/Socket.html#Socket(java.lang.String, int, boolean)">java.net.Socket(String, int, boolean)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/io/StreamTokenizer.html#StreamTokenizer(java.io.InputStream)">java.io.StreamTokenizer(InputStream)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>JDK 1.1 현재, 입력 스트림을 토큰화하려면,
 다음과 같이 해 입력 스트림을 문자 스트림로 변환할 방법이 적절합니다. <blockquote><pre> Reader r = new BufferedReader(new InputStreamReader(is)); StreamTokenizer st = new StreamTokenizer(r); </pre></blockquote></I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#String(byte[], int)">java.lang.String(byte[], int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드에서는
 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다. JDK&nbsp;1. 1 이후에서는
 바이트로부터 문자에의 변환에는
 인수로서 캐릭터셋의 이름을 취하는 <code>String</code> constructor　 　,
 또는 플랫폼의 디폴트 캐릭터셋를 사용하는 <code>String</code> 생성자 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/lang/String.html#String(byte[], int, int, int)">java.lang.String(byte[], int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드에서는
 바이트로부터 문자에의 변환이 올바르게 행해지지 않습니다. JDK&nbsp;1. 1 이후에서는
 바이트로부터 문자에의 변환에는
 인수로서 캐릭터셋의 이름을 취하는 <code>String</code> constructor　 　,
 또는 플랫폼의 디폴트 캐릭터셋를 사용하는 <code>String</code> 생성자 사용이 추천 됩니다. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="org/omg/CORBA/TCKind.html#TCKind(int)">org.omg.CORBA.TCKind(int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 메서드는 OMG 사양에
하면 private 이기 때문에
 이 생성자는 사용하지 말아 주세요. 대신에 <A HREF="org/omg/CORBA/TCKind.html#from_int(int)"><CODE>TCKind.from_int(int)</CODE></A> 를
 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Time.html#Time(int, int, int)">java.sql.Time(int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I>이 생성자
 대신에 밀리 세컨드의 값을 받는 생성자를 사용해 주세요. </I>&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><A HREF="java/sql/Timestamp.html#Timestamp(int, int, int, int, int, int, int)">java.sql.Timestamp(int, int, int, int, int, int, int)</A> 
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<I><code>Timestamp(long millis)</code> 생성자를 대신에 사용해 주세요. </I>&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<P>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">패키지</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">사용</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="overview-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>비추천 API</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp; 전&nbsp;
&nbsp;다음</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="index.html?deprecated-list.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="deprecated-list.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

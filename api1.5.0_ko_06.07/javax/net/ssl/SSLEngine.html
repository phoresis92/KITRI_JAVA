<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:00:42 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
SSLEngine (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.net.ssl.SSLEngine class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="SSLEngine (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLEngine.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/net/ssl/SSLContextSpi.html" title="javax.net.ssl 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="SSLEngine.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.net.ssl</FONT>
<BR>
클래스 SSLEngine</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.net.ssl.SSLEngine</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>SSLEngine</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
Secure Sockets Layer (SSL)나 <A HREF="http://www.ietf.org/rfc/rfc2246.txt">IETF RFC 2246
 Transport Layer Security (TLS)</A>  프로토콜을 사용해, 전송에
존하는 일 없이 시큐어 통신을 유효하게 하는 클래스입니다.
<P>
 시큐어 통신 모드에서는
 다음의 시큐러티 보호가 실시됩니다.
<UL>
        
 <LI> 정합성의 보호. <em></em>SSL/TLS 에
해, 메세지를 도청에
한 개찬으로부터 보호한다
        
 <LI> 인증<em></em>. 대부분의 모드에 대해, SSL/TLS는
 피어 인증을 제공한다. 일반적으로 서버 인증을 한다. 서버로부터의 요구에 응해, 클라이언트 인증도 행해진다
        
 <LI> 기밀성 (프라이버시의 보호)<em></em>. 대부분의 SSL/TLS 모드에서는
 클라이언트와 서버간에 송신되는 데이터가 암호화되어 데이터의 기밀성이 보호된다. 이 결과, 수동적인 도청에
해, 금융정보나 개인정보등의 기밀성의 높은 데이터가 도청되는 것이 없다
        
</UL>
이러한 시큐러티 보호는
 「encode 방식」을 사용해 지정합니다. encode 방식은, 지정된 SSL 접속으로 사용되는 암호화 알고리즘의 편성입니다. 네고시에이션을 실시하려면,
 2 개의 종단이 같은 encode 방식을 선택해, 그 encode 방식이 양쪽 모두의 환경에서 사용 가능하지 않으면 안됩니다. 공통의 encode 방식이 없는 경우는
 SSL 접속을 확립하지 못하고, 데이터를 교환할 수 없습니다.
<P>
 사용되는 encode 방식은, 「핸드 쉐이크」라고 불리는 네고시에이션 프로세스에
해 확립됩니다. 핸드 쉐이크에서는
 세션의 작성 또는 참가를 합니다. 작성 또는 참가한 세션은, 무효가 될 때까지 다양한 접속을 보호합니다. 핸드 쉐이크가 완료하면,<A HREF="../../../javax/net/ssl/SSLEngine.html#getSession()"><CODE>getSession()</CODE></A>  메서드를 사용해 세션 속성에 액세스 할 수 있습니다.
<P>
 <code>SSLSocket</code> 클래스도 거의 같은 시큐러티 기능을 제공합니다만, 모든 착신 및 발신 데이터는

도적으로 블록 모델을 사용하는 부하 <A HREF="../../../java/net/Socket.html" title="java.net 중의 클래스"><CODE>Socket</CODE></A>  에
해 자동적으로 송신됩니다. 이 처리는 많은 어플리케이션에 대해서 적절합니다만, 이 모델은 대규모 서버에 필요한 확장성을 가져오지 않습니다.
<P>
 <code>SSLEngine</code>
 주된 특장으로서 전송 도구
에
존하는 일 없이 착신/송신 바이트 스트림을 조작할 수 있는 점을 들 수 있습니다. <code>SSLEngine</code> 유저는
 피어에 있어서의 입출력 전송의 신뢰성을 확보할 필요가 있습니다. SSL/TLS 추상화 오브젝트를 입출력 전송 도구
로부터 떼어내는 것으로<code>SSLEngine</code>를
 다양한 입출력으로 광범위하게 이용할 수가 있습니다. 예를 들어,<A HREF="../../../java/nio/channels/spi/AbstractSelectableChannel.html#configureBlocking(boolean)"><CODE>비블록 입출력 (폴링)</CODE></A>,
<A HREF="../../../java/nio/channels/Selector.html" title="java.nio.channels 안의 클래스"><CODE>선택형비블록 입출력</CODE></A> 외,<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A>  및 종래의 Input/OutputStream, 로컬 <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 중의 클래스"><CODE>ByteBuffers</CODE></A>,
 바이트 배열,<A HREF="http://www.jcp.org/en/jsr/detail?id=203">future asynchronous 입출력 모델</a>등의 입출력으로 이용 가능합니다.
<P>
 상층부에서는
<code>SSLEngine</code>는
 다음과 같이 나타내집니다.

 
 <pre>

                   app data

                |           ^
                |     |     |
                v     |     |
           +----+-----|-----+----+
           |          |          |
           |       SSL|Engine    |
   wrap()  |          |          |  unwrap()
           | OUTBOUND | INBOUND  |
           |          |          |
           +----+-----|-----+----+
                |     |     ^
                |     |     |
                v           |

                   net data
 </pre>
어플리케이션 데이터 (별명 「plaintext」또는 「clear text」)는
 어플리케이션에
해 생성 또는 소비되는 데이터입니다. 어플리케이션 데이터와 대가 되는 것으로서 네트워크 데이터가 있습니다. 네트워크 데이터는
 핸드 쉐이크나 암호화 데이터로 구성되어 입출력 도구
를 개입시켜 전송 되는 데이터입니다. 착신 데이터는 피어로부터 수신되는 데이터, 송신 데이터는 피어에 송신되는 데이터입니다.
<P>
 <code>SSLEngine</code>
 컨텍스트
에서는
 시큐어 접속의 확립 및 제어 목적으로 교환되는 데이터를 「핸드 쉐이크 데이터」라고 총칭합니다. 핸드 쉐이크 데이터에는
 SSL/TLS 메세지 alert, change_cipher_spec, handshake 등이 있습니다.
<P>
 <code>SSLEngine</code>는

 다음의 5 개의 단계를 더듬습니다.
<OL> <li> 작성 - <code>SSLEngine</code>
 작성과 초기화는 완료했습니다만, 아직 사용되고는 있지 않습니다. 이 단계에서는
 어플리케이션에
해,<code>SSLEngine</code> 고유의 모든 설정 (암호군의 유효화,<code>SSLEngine</code> 가 클라이언트 모드와 서버 모드의 어디에서 핸드 쉐이크를 실시할까 등)을 실시할 수가 있습니다. 핸드 쉐이크가 시작되면, 다음의 핸드 쉐이크로부터 클라이언트/서버 모드의 설정을 제외한 (아래와 같이 참조) 새로운 설정이 사용됩니다.
<li> 초기 핸드 쉐이크 - SSLSession 가 확립될 때까지, 2 개의 피어가 통신 파라미터를 교환하는 수속입니다. 이 단계에서는
 어플리케이션 데이터는 송신할 수 없습니다.
<li> 어플리케이션 데이터 - 통신 파라미터가 확립되어 핸드 쉐이크가 완료하면,<code>SSLEngine</code> 로부터 어플리케이션 데이터가 송신됩니다. 송신 어플리케이션 메세지는 암호화되어 데이터의 정합성이 확보됩니다. 착신 메세지에서는
 이 반대의 수속을 합니다.
<li>  재핸드 쉐이크 - 「어플리케이션 데이터」단계에서는
 어느 쪽측의 피어로부터에서도, 필요에 따라서 세션의 재네고시에이션을 요구할 수 있습니다. 어플리케이션 데이터에 새로운 핸드 쉐이크 데이터를 혼합할 수가 있습니다. 재핸드 쉐이크를 개시하기 전에
 어플리케이션은, SSL/TLS 통신 파라미터 (예: 유효한 암호군의 리스트)나, 클라이언트 인증을 사용할지 어떨지의 설정을 리셋트 할 수 있습니다. 그러나, 클라이언트 모드와 서버 모드를 바꿀 수 없습니다. 전회와 같게, 핸드 쉐이크가 시작되고 나서 다음의 핸드 쉐이크까지, 새로운 <code>SSLEngine</code> 설정은 사용되지 않습니다.
<li>  종료 - 접속이 불필요하게 되었을 때, 어플리케이션은,<code>SSLEngine</code>를
 종료해, 피어와 송수신 하는 메세지가 남아 있는 경우는 송수신을 완료하고 나서, 부하의 전송 도구
를 종료할 필요가 있습니다. 종료된 엔진은, 재이용할 수 없습니다. 새로운 <code>SSLEngine</code>를
 작성할 필요가 있습니다. </OL> <code>SSLEngine</code>를
 작성하려면,
 초기화된 <code>SSLContext</code> 로부터 <A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine()"><CODE>SSLContext.createSSLEngine()</CODE></A> 를
 호출합니다. 모든 설정 파라미터의 설정을 완료하고 나서,<code>wrap()</code>,<code>unwrap()</code>, 또는 <code>beginHandshake()</code>
 최초의 호출을 실시합니다. 이러한 메서드는 모두, 초기 핸드 쉐이크를 트리거 합니다.
<P>
 데이터는
 송신 데이터에 대해서 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap()</CODE></A> 를
 호출하거나 착신 데이터에 대해서 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap()</CODE></A> 를
 호출하는 것에
해, 엔진으로부터 전송 됩니다. <code>SSLEngine</code> 상태에 따라서는
<code>wrap()</code> 호출에
해 소스 버퍼의 어플리케이션 데이터가 사용되어 행선지 버퍼에 네트워크 데이터가 써내지는 경우도 있습니다. 송신 데이터에는
 어플리케이션 데이터나 핸드 쉐이크 데이터가 포함됩니다. <code>unwrap()</code>를
 호출하면, 소스 버퍼가 체크되어 그 중의 데이터가 핸드 쉐이크 정보이면 핸드 쉐이크가 실시됩니다. 어플리케이션 데이터이면, 행선지 버퍼에 포함됩니다. 부하의 SSL/TLS 알고리즘 상태로부터, 데이터의 사용이나 생성의 타이밍을 판단할 수 있습니다.
<P>
 <code>wrap()</code> 나 <code>unwrap()</code>를
 호출하면, 오퍼레이션 상태와 처리를 속행하는 경우의 엔진과의 교환의 내용 (옵션)을 나타내는 <code>SSLEngineResult</code> 가 돌려주고집니다.
<P>
 <code>SSLEngine</code>는

 완전한 SSL/TLS 패킷 밖에 사용 또는 생성하지 않습니다. 다음의 <code>wrap()</code> 또는 <code>unwrap()</code>
 호출까지의 사이에
 어플리케이션 데이터를 내부에 포함할 것은 없습니다. 따라서, 생성되는 레코드중  제일 사이즈가 큰 것을 포함할 수 있도록, 입출력 <code>ByteBuffer</code>
 사이즈를 결정할 필요가 있습니다. 적절한 버퍼 사이즈를 판정하려면,
<A HREF="../../../javax/net/ssl/SSLSession.html#getPacketBufferSize()"><CODE>SSLSession.getPacketBufferSize()</CODE></A>  및 <A HREF="../../../javax/net/ssl/SSLSession.html#getApplicationBufferSize()"><CODE>SSLSession.getApplicationBufferSize()</CODE></A> 
 호출을 사용합니다. 송신 어플리케이션 데이터 버퍼의 사이즈는
 보통
, 고려할 필요는 없습니다. 데이터의 사용 및 생성에 적절한 버퍼 조건이 아닌 경우, 어플리케이션은  <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 안의 클래스"><CODE>SSLEngineResult</CODE></A>  에
해 문제를 특정해, 수정한 뒤, 재차 호출을 시행하지 않으면 안됩니다.
<P>
 <code>SSLSocket</code> 과는 달리, SSLEngine
 모든 메서드는 비블록 메서드입니다. <code>SSLEngine</code> 구현을 위해서 필요한 태스크는
 완료까지 꽤 시간이 걸리거나 완료전에 블록 될 가능성이 있습니다. 예를 들어, TrustManager는

 리모트 인증서
 확인 서비스에의 접속이 요구되는 일이 있습니다. 또, KeyManager는

 클라이언트 인증의 일환으로서 사용해야 할 인증서
를 결정하도록 유저에게 요구하는 일이 있습니다. 게다가 암호화 서명을 작성해, 이것들을 검증하는 경우, 처리 시간이 꽤 길어져, 처리가 블록 된 것처럼 보이는 일이 있습니다.
<P>
 <code>SSLEngine</code>는

 블록 될 가능성이 있는 모든 오퍼레이션에 대해서,<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  위양 태스크를 생성합니다. <code>SSLEngineResult</code> 에
해, 위양 태스크의 결과의 필요성이 나타났을 경우, 어플리케이션은 <A HREF="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask()"><CODE>getDelegatedTask()</CODE></A> 를
 호출해 미실행의 위양 태스크를 취득해, 그 <A HREF="../../../java/lang/Runnable.html#run()"><CODE>run()</CODE></A>  메서드를 호출할 필요가 있습니다. 호출에 사용되는 thread는
 계산방법에 따라서 다릅니다. 어플리케이션은, 모든 위양 태스크를 취득하면, 최초의 오퍼레이션을 재시행합니다.
<P>
 어플리케이션은, 통신 세션의 종료시에 SSL/TLS 링크를 정상적으로 종료할 필요가 있습니다. SSL/TLS 프로토콜은 핸드 쉐이크 종료 메세지를 가지고 있어 이러한 메세지는
<code>SSLEngine</code> 가 해방되어 부하의 전송 도구
가 종료하기 전에 피어에 송신되게 되어 있습니다. 통신 세션의 종료는
 SSLException, 핸드 쉐이크 종료 메세지의 착신, 또는 임의의 종료 메서드에
해 개시됩니다. 어느 경우에서도, 엔진으로부터 핸드 쉐이크 종료 메세지가 생성되어<code>SSLEngineResult</code> 상태가 CLOSED 가 되는지,<A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A> 
 반환값이 true 가 될 때까지,<code>wrap()</code> 가 반복해 불려 갑니다. <code>wrap()</code> 메서드에
해 취득된 데이터는 모두 피어에 송신됩니다.
<P>
 어플리케이션으로부터 송신되는 데이터가 이제 없는 것을 엔진에 통지하려면,
<A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A> 를
 사용합니다.
<P>
 피어는
 고유의 핸드 쉐이크 종료 메세지를 송신하는 것으로 종료의
도를 통지합니다. 이 메세지가 로컬의 <code>SSLEngine</code>
 <code>unwrap()</code> 호출에
해 수신 및 처리되면, 어플리케이션은,<code>unwrap()</code>를
 호출해, 상태가 CLOSED
 <code>SSLEngineResult</code>를
 검색합니다. 조건에 맞는 것이 발견되는지,<A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()"><CODE>isInboundDone()</CODE></A> 
 반환값이 true 이면, 종료가 확인됩니다. 피어가 통신 링크를 종료할 때, 어떠한 이유로써 정상적인 SSL/TLS 종료 메세지가 송신되지 않았던 경우, 어플리케이션은 스트림의 종료 위치를 검출해, 더 이상 처리해야 할 착신 메세지가 없는 것을,<A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A> 를
 개입시켜 엔진에 통지합니다. 어플리케이션에 따라서는
 피어로부터의 슛다운 메세지를 보통
대로 받는 설정이 되어 있는 일이 있습니다. 이러한 어플리케이션은, 스트림의 종료 위치는 아니고, 핸드 쉐이크 메세지에
해 종료를 체크합니다.
<P>
 encode 방식을 사용할 때는
 2 개의 그룹에 대해 이해할 필요가 있습니다.

<UL>    
 <LI> 서포트되고 있는<em></em>encode 방식. SSL 구현으로 서포트되는 모든 encode 방식. 이 리스트는
<A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A> 를
 사용해 보고된다
        
 <LI> 사용 가능한<em></em>encode 방식. 서포트되고 있는 encode 방식보다 적은 것이 있다. 이 그룹은,<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A>  메서드를 사용해 설정해,<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>  메서드를 사용해 조회한다. 새로운 엔진에서는
 최소한의 추천 구성을 나타내는 디폴트의 encode 방식이 사용 가능하게 되어 있다 
</UL>
디폴트의 구현으로 사용 가능하게 하는 encode 방식으로는
 서버를 인증해, 기밀성이 보증되지 않으면 안됩니다. 서버 인증을 하지 않고 기밀성이 보증되지 않는 encode 방식을 선택하는 경우는
 서버 인증을 하지 않고 비공개성이 보증되지 않는 (암호화되지 않는다) 통신이 사용되는 것에 2 개의 종단이 명시적으로 동의 할 필요가 있습니다.
<P>
 각 SSL/TLS 접속에는 클라이언트와 서버가 1 대씩 필요합니다. 이 때문에
 각 종단으로 담당하는 롤을 결정할 필요가 있습니다. 이 선택 내용에
해, 어느 쪽측으로부터 핸드 쉐이크 처리를 개시하는지, 또, 서로 어떠한 메세지를 송신할지가 정해집니다. 모드의 설정은,<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A>  메서드로 실시합니다. 일단 초기 핸드 쉐이크가 개시되고 나서는
 재네고시에이션의 경우에서도,<code>SSLEngine</code>
 모드를 클라이언트로부터 서버, 서버로부터 클라이언트로 전환할 수 없습니다.
<P>
 위양 태스크는 별thread로 처리할 수가 있습니다. <code>SSLEngine</code> 가 작성되면, 현재 <A HREF="../../../java/security/AccessControlContext.html" title="java.security 중의 클래스"><CODE>AccessControlContext</CODE></A>  가 보존됩니다. 그 후, 모든 위양 태스크는 이 컨텍스트
으로 처리됩니다. 즉, 액세스 제어의
사결정은 모두, 엔진의 작성시의 컨텍스트
으로 행해집니다.  
<P>
 <HR>
<B>concurrent processing에 대해</B>: 다음의 2 점에 주의해 주세요.
<OL>    <li><code>wrap()</code> 메서드와 <code>unwrap()</code> 메서드는
 병렬 실행이 가능합니다.
        <li> SSL/TLS 프로토콜은 패킷을 차례로 이용합니다. 어플리케이션은, 생성된 패킷이 올바른 차례로 전달할 필요가 있습니다. 패킷의 도착 순서가 올바르지 않으면 예기치 않은 결과 또는 치명적인 결과를 부르는 일이 있습니다. <P> 다음에 예를 나타냅니다. <P>     
 <pre>
                synchronized (outboundLock) {               sslEngine.wrap(src, dst);
                    outboundQueue.put(dst);
                }       </pre>
        최종적인 패킷의 순서를 보증할 수가 없기 때문에
 결과적으로 2 개의 thread가 같은 메서드 (<code>wrap()</code> 또는 <code>unwrap()</code>)를 동시에 호출할 수 없습니다. </OL>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html" title="javax.net.ssl 내의 클래스"><CODE>SSLContext</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLSocket</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLServerSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLServerSocket</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSession</CODE></A>,
 
<A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스"><CODE>Socket</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#SSLEngine()">SSLEngine</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;내부 세션의 재이용에 관한 힌트를 제공하지 않는 <code>SSLEngine</code>
 생성자
입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#SSLEngine(java.lang.String, int)">SSLEngine</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;peerHost,
          int&nbsp;peerPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>SSLEngine</code> 용 생성자
입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#beginHandshake()">beginHandshake</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 SSLEngine
 초기 핸드 쉐이크 또는 재네고시에이션의 핸드 쉐이크를 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()">closeInbound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;더 이상 이 <code>SSLEngine</code> 에 송신되는 착신 네트워크 데이터가 없는 것을 나타내는 신호입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()">closeOutbound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;더 이상 이 <code>SSLEngine</code> 에 송신되는 송신 어플리케이션 데이터가 없는 것을 나타내는 신호입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getDelegatedTask()">getDelegatedTask</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code>를
 위해서 위양 된 <code>Runnable</code> 태스크를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()">getEnabledCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 현재 사용 가능하게 되어 있는 SSL encode 방식의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols()">getEnabledProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 현재 사용 가능하게 되어 있는 프로토콜의 버젼을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation()">getEnableSessionCreation</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 새로운 SSL 세션을 확립할 수 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="javax.net.ssl 내의 열거형">SSLEngineResult.HandshakeStatus</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getHandshakeStatus()">getHandshakeStatus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code>
 현재의 핸드 쉐이크 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()">getNeedClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진에 클라이언트 인증이 필수인<i></i>경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getPeerHost()">getPeerHost</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어의 호스트명을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getPeerPort()">getPeerPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어의 포트 번호를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSession()">getSession</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 사용중의 <code>SSLSession</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()">getSupportedCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능하게 할 수 있는 encode 방식의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedProtocols()">getSupportedProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>SSLEngine</code> 로 사용할 수가 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getUseClientMode()">getUseClientMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시에 클라이언트 모드를 사용하도록 엔진이 설정되어 있는 경우는 true</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()">getWantClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진이 클라이언트 인증을 요구하는<i></i>경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()">isInboundDone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap(ByteBuffer, ByteBuffer)</CODE></A>  가 받아들이는 착신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()">isOutboundDone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A>  가 생성하는 송신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])">setEnabledCipherSuites</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능한 encode 방식을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols(java.lang.String[])">setEnabledProtocols</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 사용 가능한 프로토콜의 버젼을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation(boolean)">setEnableSessionCreation</A> </B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 엔진으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)">setNeedClientAuth</A> </B>(boolean&nbsp;need)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증이 필수가 되는 것<i></i>같게 엔진을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)">setUseClientMode</A> </B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시, 엔진이 클라이언트 (또는 서버) 모드를 사용하도록 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)">setWantClientAuth</A> </B>(boolean&nbsp;want)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록 엔진을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[])">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 순서에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)">unwrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
       int&nbsp;offset,
       int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 서브 순서에 복호화 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext 바이트를 데이터 버퍼 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
     int&nbsp;offset,
     int&nbsp;length,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext 바이트를 데이터 버퍼의 서브 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)">wrap</A> </B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plaintext의 어플리케이션 데이터의 버퍼를 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SSLEngine()"><!-- --></A> <H3>
SSLEngine</H3>
<PRE>
protected <B>SSLEngine</B>()</PRE>
<DL>
<DD>내부 세션의 재이용에 관한 힌트를 제공하지 않는 <code>SSLEngine</code>
 생성자
입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine()"><CODE>SSLContext.createSSLEngine()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSessionContext</CODE></A> </DL>
</DL>
<HR>

<A NAME="SSLEngine(java.lang.String, int)"><!-- --></A> <H3>
SSLEngine</H3>
<PRE>
protected <B>SSLEngine</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;peerHost,
                    int&nbsp;peerPort)</PRE>
<DL>
<DD><code>SSLEngine</code> 용 생성자
입니다.
<P>
 <code>SSLEngine</code> 구현은, 내부 세션을 재이용하기 위한 힌트로서<code>peerHost</code> 파라미터와 <code>peerPort</code> 파라미터를 사용할 수 있습니다.
<P>
 Kerberos 등, 리모트 호스트명의 정보를 필요로 하는 암호군도 있습니다. 이 클래스의 구현은, 이 생성자를 사용해 Kerberos를
 사용합니다.
<P>
 파라미터는
<code>SSLEngine</code> 에
한 인증을 받지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>peerHost</CODE> - 피어의 호스트명<DD><CODE>peerPort</CODE> - 피어의 포트 번호<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLContext.html#createSSLEngine(java.lang.String, int)"><CODE>SSLContext.createSSLEngine(String, int)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 안의 인터페이스"><CODE>SSLSessionContext</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getPeerHost()"><!-- --></A> <H3>
getPeerHost</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getPeerHost</B>()</PRE>
<DL>
<DD>피어의 호스트명을 돌려줍니다.
<P>
 이 값은 인증되어 있지 않기 때문에
 실제로 사용할 수 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>피어의 호스트명. 사용할 수 있는 것이 없는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="getPeerPort()"><!-- --></A> <H3>
getPeerPort</H3>
<PRE>
public int <B>getPeerPort</B>()</PRE>
<DL>
<DD>피어의 포트 번호를 돌려줍니다.
<P>
 이 값은 인증되어 있지 않기 때문에
 실제로 사용할 수 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>피어의 포트 번호. 사용할 수 있는 것이 없는 경우는 -1</DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                            <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                     throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext의 어플리케이션 데이터의 버퍼를 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. <P> 이 메서드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다. <blockquote>
 <pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>engine.wrap(new ByteBuffer [] { src }, 0, 1, dst);</CODE></A>  </pre</blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>src</code> 또는 <code>dst</code> 가 null
 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer [], int, int, ByteBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer[], java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                            <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                     throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext 바이트를 데이터 버퍼 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. <P> 이 메서드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다. <blockquote>
 <pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>engine.wrap(srcs, 0, srcs.length, dst);</CODE></A>  </pre</blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
 배열<DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>src</code> 와 <code>dsts</code>
 어느 쪽인지 한편이 null
 경우, 또는 <code>srcs</code> 에 null
 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer [], int, int, ByteBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.nio.ByteBuffer[], int, int, java.nio.ByteBuffer)"><!-- --></A> <H3>
wrap</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>wrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;srcs,
                                     int&nbsp;offset,
                                     int&nbsp;length,
                                     <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                              throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>plaintext 바이트를 데이터 버퍼의 서브 순서로부터 SSL/TLS 네트워크 데이터에 encode 하려고 합니다. 이 「수집」<i></i>오퍼레이션은, 1 회의 호출로 단일의 바이트 순서를 1 개 이상의 지정의 버퍼 순서에 encode 할 수 있습니다. 랩 수집은, 보통
, 네트워크 프로토콜이나 파일 형식 (예를 들어, 데이터를 1 개 이상의 고정장의 헤더와 가변장의 본체로부터 완성되는 세그먼트(segment)에 그룹화 하는 것 같은 파일 형식)을 구현할 때에 편리합니다. 수집의 자세한 것은 <A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>GatheringByteChannel</CODE></A>,
 수집 후의 동작의 자세한 것은 <A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)"><CODE>GatheringByteChannel.write(ByteBuffer[], int, int)</CODE></A> 를
 참조하십시오.
<P>
 SSLEngine 상태에 따라서는
 이 메서드는
 어플리케이션 데이터를 일절 사용하지 않고 네트워크 데이터를 생성하는 일이 있습니다. 예를 들어, 핸드 쉐이크 데이터가 이것에 해당합니다.  
<P>
 어플리케이션은, 네트워크 데이터를 피어에 안전하게 전송 할 필요가 있습니다. 또, 몇회인가의 wrap()의 호출에
해 생성된 데이터를 생성순서에 전송 할 필요가 있습니다. 게다가 이 메서드의 복수의 호출을 올바르고 동기화할 필요가 있습니다.
<P>
 이 <code>SSLEngine</code> 가 아직 초기 핸드 쉐이크를 개시하고 있지 않는 경우, 이 메서드에
해 초기 핸드 쉐이크가 자동적으로 개시됩니다.
<P>
 이 메서드는
 단일의 SSL/TLS 패킷을 생성하려고 해, 가능한 한 많은 소스 데이터를 소비합니다. 그러나, 각 버퍼에 남아 있는 합계 바이트수이상을 소비할 것은 없습니다. 각 <code>ByteBuffer</code>
 위치는
 소비 또는 생성된 데이터량에 맞추어 갱신됩니다. 상한/하한치는 바뀌지 않습니다.
<P>
 <code>srcs</code> 및 <code>dst</code>
 ByteBuffer는

 부하에게 있는 각각 다른 메모리를 사용할 필요가 있습니다.
<P>
 엔진의 종료의 자세한 것은, 클래스의 설명을 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcs</CODE> - 송신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
 배열<DD><CODE>offset</CODE> - 최초의 바이트의 취득처가 되는 버퍼 배열내의 오프셋(offset). <code>srcs.length</code> 이하의 제로 또는 정의 수<DD><CODE>length</CODE> - 액세스 가능한 최대 버퍼수. <code>srcs.length</code>&nbsp;-&nbsp;<code>offset</code> 이하의 제로 또는 정의 수<DD><CODE>dst</CODE> - 송신 네트워크 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>offset</code> 파라미터와 <code>length</code> 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>srcs</code> 와 <code>dst</code>
 어느 쪽인지 한편이 null
 경우, 또는 지정된 <code>srcs</code> 서브 순서에 null
 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/GatheringByteChannel.html" title="java.nio.channels 내의 인터페이스"><CODE>GatheringByteChannel</CODE></A>,
 
<A HREF="../../../java/nio/channels/GatheringByteChannel.html#write(java.nio.ByteBuffer[], int, int)"><CODE>GatheringByteChannel.write(		    ByteBuffer[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                              <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;dst)
                       throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼에 복호화 하려고 합니다. <P> 이 메서드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다. <blockquote>
 <pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>engine.unwrap(src, new ByteBuffer [] { dst }, 0, 1);</CODE></A>  </pre</blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dst</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - <code>dst</code> 버퍼가 읽어내 전용의 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>src</code> 또는 <code>dst</code> 가 null
 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>unwrap(ByteBuffer, ByteBuffer [], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[])"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                              <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts)
                       throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 순서에 복호화 하려고 합니다. <P> 이 메서드 호출의 동작은, 다음의 호출의 동작과 완전히 같습니다. <blockquote>
 <pre>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>engine.unwrap(src, dsts, 0, dsts.length);</CODE></A>  </pre</blockquote>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dsts</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
 배열
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - 독해 전용의 <code>dst</code> 버퍼가 존재하는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>srcs</code> 와 <code>dst</code>
 어느 쪽인지 한편이 null
 경우, 또는 <code>dsts</code> 에 null
 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><CODE>unwrap(ByteBuffer, ByteBuffer [], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer[], int, int)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스">SSLEngineResult</A>  <B>unwrap</B>(<A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> &nbsp;src,
                                       <A HREF="../../../java/nio/ByteBuffer.html" title="java.nio 안의 클래스">ByteBuffer</A> []&nbsp;dsts,
                                       int&nbsp;offset,
                                       int&nbsp;length)
                                throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>SSL/TLS 네트워크 데이터를 plaintext의 어플리케이션 데이터 버퍼의 서브 순서에 복호화 하려고 합니다. 이 「살포」<i></i>오퍼레이션은, 1 회의 호출로 단일의 바이트 순서를 1 개 이상의 지정의 버퍼 순서에 복호화 할 수 있습니다. 분산하는 안 랩은, 보통
, 네트워크 프로토콜이나 파일 형식 (예를 들어, 데이터를 1 개 이상의 고정장의 헤더와 가변장의 본체로부터 완성되는 세그먼트(segment)에 그룹화 하는 것 같은 파일 형식)을 구현할 때에 편리합니다. 살포의 자세한 것은 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 안의 인터페이스"><CODE>ScatteringByteChannel</CODE></A>,
 살포 후의 동작의 자세한 것은 <A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)"><CODE>ScatteringByteChannel.read(ByteBuffer[], int, int)</CODE></A> 를
 참조하십시오.
<P>
 SSLEngine 상태에 따라서는
 이 메서드는
 어플리케이션 데이터를 일절 생성하지 않고 네트워크 데이터를 사용하는 일이 있습니다. 예를 들어, 핸드 쉐이크 데이터가 이것에 해당합니다.  
<P>
 어플리케이션은, 피어로부터 네트워크 데이터를 안전하게 취득할 필요가 있습니다. 또, 수신한 순서에 데이터의 랩을 해제 (unwrap() 호출) 할 필요가 있습니다. 어플리케이션은, 이 메서드의 복수의 호출을 올바르고 동기화할 필요가 있습니다.
<P>
 이 <code>SSLEngine</code> 가 아직 초기 핸드 쉐이크를 개시하고 있지 않는 경우, 이 메서드에
해 초기 핸드 쉐이크가 자동적으로 개시됩니다.
<P>
 이 메서드는
 단일의 완전한 SSL/TLS 네트워크 패킷을 소비하려고 합니다만, 버퍼에 남아 있는 합계 바이트수이상을 소비할 것은 없습니다. 각 <code>ByteBuffer</code>
 위치는
 소비 또는 생성된 데이터량에 맞추어 갱신됩니다. 상한/하한치는 바뀌지 않습니다.
<P>
 <code>src</code> 및 <code>dsts</code>
 ByteBuffer는

 부하에게 있는 각각 다른 메모리를 사용할 필요가 있습니다.
<P>
 이 호출의 결과, 착신 네트워크버퍼가 변경되는 일이 있습니다. 이 때문에
 이차적인 목적으로 네트워크 데이터 패킷이 필요한 경우는
 이 메서드의 호출전에 데이터를 복제할 필요가 있습니다. 주: 네트워크 데이터를 2 번째의 SSLEngine 로 사용할 수 없습니다. 각 SSLEngine 가, SSL/TLS 메세지에 영향을 미치는 일의의 랜덤인 상태를 가지고 있기 때문입니다.
<P>
 엔진의 종료의 자세한 것은, 클래스의 설명을 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>src</CODE> - 착신 네트워크 데이터를 포함하는 <code>ByteBuffer</code><DD><CODE>dsts</CODE> - 착신 어플리케이션 데이터를 포함하는 <code>ByteBuffer</code>
 배열<DD><CODE>offset</CODE> - 최초의 바이트의 전송처가 되는 버퍼 배열내의 오프셋(offset). <code>dsts.length</code> 이하의 제로 또는 정의 수<DD><CODE>length</CODE> - 액세스 가능한 최대 버퍼수. <code>dsts.length</code>&nbsp;-&nbsp;<code>offset</code> 이하의 제로 또는 정의 수
<DT><B>반환값:</B><DD>이 오퍼레이션의 결과를 설명하는 <code>SSLEngineResult</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 데이터 처리중에 발생해,<code>SSLEngine</code>
 이상종료(ABEND)의 원인이 된 문제. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>offset</code> 파라미터와 <code>length</code> 파라미터의 전제 조건이 채워지지 않은 경우
<DD><CODE><A HREF="../../../java/nio/ReadOnlyBufferException.html" title="java.nio 안의 클래스">ReadOnlyBufferException</A> </CODE> - 독해 전용의 <code>dst</code> 버퍼가 존재하는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>src</code> 와 <code>dsts</code>
 어느 쪽인지 한편이 null
 경우, 또는 지정된 <code>dsts</code> 서브 순서에 null
 요소가 포함되는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/nio/channels/ScatteringByteChannel.html" title="java.nio.channels 내의 인터페이스"><CODE>ScatteringByteChannel</CODE></A>,
 
<A HREF="../../../java/nio/channels/ScatteringByteChannel.html#read(java.nio.ByteBuffer[], int, int)"><CODE>ScatteringByteChannel.read(		    ByteBuffer[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDelegatedTask()"><!-- --></A> <H3>
getDelegatedTask</H3>
<PRE>
public abstract <A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A>  <B>getDelegatedTask</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code>를
 위해서 위양 된 <code>Runnable</code> 태스크를 돌려줍니다.  
<P>
 <code>SSLEngine</code> 오퍼레이션에 필요한 오퍼레이션의 결과가 블록 되거나 완료까지 상당한 시간이 걸리는 일이 있습니다. 이 메서드는
 미처리 <A HREF="../../../java/lang/Runnable.html" title="java.lang 중의 인터페이스"><CODE>Runnable</CODE></A>  오퍼레이션 (태스크)을 취득하기 위해서 사용됩니다. 각 태스크에는
<A HREF="../../../java/lang/Runnable.html#run()"><CODE>run</CODE></A>  오퍼레이션을 실행하는 thread (현재의 thread도 가능)를 할당할 필요가 있습니다. <code>run</code> 메서드가 종료한 뒤, 불필요하게 된 <code>Runnable</code> 오브젝트는 폐기 가능합니다.
<P>
 위양 된 태스크는
<code>AccessControlContext</code> 내에서, 이 오브젝트가 작성되었을 때에 실행됩니다.
<P>
 이 메서드의 호출은, 미처리의 태스크를 각각 1 회만 돌려줍니다.
<P>
 위양 된 복수의 태스크를 병렬 실행할 수도 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>위양 된 <code>Runnable</code> 태스크. 사용할 수 있는 것이 없는 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="closeInbound()"><!-- --></A> <H3>
closeInbound</H3>
<PRE>
public abstract void <B>closeInbound</B>()
                           throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>더 이상 이 <code>SSLEngine</code> 에 송신되는 착신 네트워크 데이터가 없는 것을 나타내는 신호입니다.
<P>
 어플리케이션이 <A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A> 를
 호출해 종료 처리를 개시했을 때, 피어의 대응하는 종료 메세지를 기다릴 필요가 없는 경우가 있습니다 (종료의 경고의 대기에 관한 자세한 것은, TLS 사양의 섹션 7.2. 1(<A HREF="http://www.ietf.org/rfc/rfc2246.txt">RFC 2246</A> )을 참조). 이 경우, 이 메서드의 호출은 불필요합니다.
<P>
 이것에 대해서, 어플리케이션이 종료 처리를 개시하지 않았던 경우나, 상기의 상황에 들어맞지 않는 경우는
 SSL/TLS 데이터 스트림의 종료 부분이 착신할 때마다 이 메서드를 호출할 필요가 있습니다. 이것에
해, 착신측의 종료가 보증되어 피어가 SSL/TLS 종료 수속을 적절히 실행한 것을 확인해, 값의 절약해에
한 공격의 가능성을 검출할 수가 있습니다.
<P>
 이 메서드는
 나무등입니다. 착신측이 벌써 종료하고 있는 경우는
 아무것도 실시하지 않습니다.
<P>
 나머지의 핸드 쉐이크 데이터를 플래시 하려면,
<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap()</CODE></A> 를
 호출합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - 이 엔진이 피어로부터 적절한 SSL/TLS 종료 통지 메세지를 받아들이지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#isInboundDone()"><CODE>isInboundDone()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInboundDone()"><!-- --></A> <H3>
isInboundDone</H3>
<PRE>
public abstract boolean <B>isInboundDone</B>()</PRE>
<DL>
<DD><A HREF="../../../javax/net/ssl/SSLEngine.html#unwrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>unwrap(ByteBuffer, ByteBuffer)</CODE></A>  가 받아들이는 착신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLEngine</code> 가 더 이상 네트워크 데이터를 사용하지 않는 경우 (바꾸어 말하면, 더 이상 어플리케이션 데이터를 생성하지 않는 경우)는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="closeOutbound()"><!-- --></A> <H3>
closeOutbound</H3>
<PRE>
public abstract void <B>closeOutbound</B>()</PRE>
<DL>
<DD>더 이상 이 <code>SSLEngine</code> 에 송신되는 송신 어플리케이션 데이터가 없는 것을 나타내는 신호입니다.
<P>
 이 메서드는
 나무등입니다. 송신측이 벌써 종료하고 있는 경우는
 아무것도 실시하지 않습니다.
<P>
 나머지의 핸드 쉐이크 데이터를 플래시 하려면,
<A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A> 를
 호출합니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#isOutboundDone()"><CODE>isOutboundDone()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOutboundDone()"><!-- --></A> <H3>
isOutboundDone</H3>
<PRE>
public abstract boolean <B>isOutboundDone</B>()</PRE>
<DL>
<DD><A HREF="../../../javax/net/ssl/SSLEngine.html#wrap(java.nio.ByteBuffer, java.nio.ByteBuffer)"><CODE>wrap(ByteBuffer, ByteBuffer)</CODE></A>  가 생성하는 송신 데이터 메세지가 아직 있을지 어떨지를 돌려줍니다.
<P>
 종료 단계에서,<code>SSLEngine</code>는

 피어에 송신하는 핸드 쉐이크 종료 데이터를 생성합니다. 이 데이터를 생성하려면,
<code>wrap()</code>를
 호출할 필요가 있습니다. 이 메서드의 반환값이 true
 경우, 더 이상 송신 데이터는 생성되지 않습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLEngine</code> 가 더 이상 네트워크 데이터를 생성하지 않는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#closeOutbound()"><CODE>closeOutbound()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#closeInbound()"><CODE>closeInbound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedCipherSuites()"><!-- --></A> <H3>
getSupportedCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedCipherSuites</B>()</PRE>
<DL>
<DD>이 엔진으로 사용 가능하게 할 수 있는 encode 방식의 이름을 돌려줍니다. 일반적으로 이러한 encode 방식의 일부만이, 디폴트 구현으로 사용 가능하게 됩니다. 일부의 encode 방식은, 디폴트 구현의 서비스 품질 요건을 채우지 않은 것이 있기 때문에입니다. 이러한 encode 방식은, 특수한 어플리케이션으로 사용됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>encode 방식명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledCipherSuites()"><!-- --></A> <H3>
getEnabledCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledCipherSuites</B>()</PRE>
<DL>
<DD>이 엔진으로 현재 사용 가능하게 되어 있는 SSL encode 방식의 이름을 돌려줍니다. SSL 엔진이 최초로 작성되었을 때에
 사용 가능하게는 모든 encode 방식에서, 최소한의 서비스 품질이 보증됩니다. 환경에 따라서는
 이 값은 하늘의 경우도 있습니다.
<P>
 encode 방식은, 비록 유효해도 사용되지 않는 것이 있습니다. 예를 들어, 피어가 encode 방식을 서포트하지 않는 경우, 이 encode에 필요한 인증서
나 비공개키를 사용할 수가 없는 경우, 또는
 익명의 encode 방식이 이용 가능해도 인증이 요구되는 경우 등입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>encode 방식명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledCipherSuites(java.lang.String[])"><!-- --></A> <H3>
setEnabledCipherSuites</H3>
<PRE>
public abstract void <B>setEnabledCipherSuites</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</PRE>
<DL>
<DD>이 엔진으로 사용 가능한 encode 방식을 설정합니다.
<P>
 <code>suites</code> 파라미터로 지정된 각 encode 방식은, getSupportedCipherSuites()로 리스트되어 있지 않으면 안됩니다. 그렇지 않은 경우, 메서드는 실패합니다. 이 메서드의 호출이 정상적으로 행해졌을 때,<code>suites</code> 파라미터에 리스트 된 encode 방식만, 사용할 수가 있습니다.
<P>
 왜 특정의 encode 방식을 엔진으로 사용할 수가 없는 것처럼 붙어서는
<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> 를
 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>suites</CODE> - 사용 가능하게 하는 모든 encode 방식의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 encode 방식의 일부가 서포트되지 않는 경우, 또는 파라미터가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedProtocols()"><!-- --></A> <H3>
getSupportedProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedProtocols</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 사용할 수가 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>서포트되고 있는 프로토콜의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledProtocols()"><!-- --></A> <H3>
getEnabledProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledProtocols</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 현재 사용 가능하게 되어 있는 프로토콜의 버젼을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>프로토콜의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnabledProtocols(java.lang.String[])"><CODE>setEnabledProtocols(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledProtocols(java.lang.String[])"><!-- --></A> <H3>
setEnabledProtocols</H3>
<PRE>
public abstract void <B>setEnabledProtocols</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</PRE>
<DL>
<DD>이 엔진으로 사용 가능한 프로토콜의 버젼을 설정합니다.
<P>
 프로토콜은, getSupportedProtocols()에
해, 서포트 대상으로 해 리스트되어 있지 않으면 안됩니다. 이 메서드의 호출이 정상적으로 행해졌을 때,<code>protocols</code> 파라미터에 리스트 된 프로토콜만, 사용할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocols</CODE> - 사용 가능하게 하는 모든 프로토콜의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 프로토콜의 일부가 서포트되지 않는 경우, 또는 파라미터가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnabledProtocols()"><CODE>getEnabledProtocols()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSession()"><!-- --></A> <H3>
getSession</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A>  <B>getSession</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code> 로 사용중의 <code>SSLSession</code>를
 돌려줍니다.
<P>
 SSL 세션은 유효기간이 길고, 유저에 따라서는 로그인 세션 전체에 대응하는 일도 있습니다. 세션에는
 세션내의 모든 접속으로 사용되는 encode 방식과 세션의 클라이언트와 서버의 식별 정보가 지정되고 있습니다.
<P>
 이 메서드는
<A HREF="../../../javax/net/ssl/SSLSocket.html#getSession()"><CODE>SSLSocket.getSession()</CODE></A>  과는 달리, 핸드 쉐이크가 완료할 때까지 블록 되지 않습니다.
<P>
 초기 핸드 쉐이크가 완료하면, 무효인 암호군 SSL_NULL_WITH_NULL_NULL를
 보고하는 세션 오브젝트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>SSLEngine</code>
 <code>SSLSession</code><DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스"><CODE>SSLSession</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="beginHandshake()"><!-- --></A> <H3>
beginHandshake</H3>
<PRE>
public abstract void <B>beginHandshake</B>()
                             throws <A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 내의 클래스">SSLException</A> </PRE>
<DL>
<DD>이 SSLEngine
 초기 핸드 쉐이크 또는 재네고시에이션의 핸드 쉐이크를 개시합니다.
<P>
 이 메서드는
 초기 핸드 쉐이크시에는 필요 없습니다. 핸드 쉐이크가 아직 개시되어 있지 않은 경우는
<code>wrap()</code> 메서드와 <code>unwrap()</code> 메서드에
해 암묵적으로 이 메서드가 불려 가기 때문입니다.  
<P>
 피어도, 적절한 세션재네고시에이션의 핸드 쉐이크 메세지를 송신하는 것으로써, 이 <code>SSLEngine</code> 와의 세션의 재네고시에이션을 요구하는 일이 있습니다.
<P>
 이 메서드는
<A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()"><CODE>SSLSocket#startHandshake()</CODE></A>  메서드와는 달라, 핸드 쉐이크가 완료할 때까지 블록 되지 않습니다.
<P>
 강제적으로 SSL/TLS 세션의 재네고시에이션을 실시하는 경우는
 현재의 세션을 무효로 하고 나서 이 메서드를 호출할 필요가 있습니다.
<P>
 기존의 엔진상에서 복수의 핸드 쉐이크를 서포트하지 않고,<code>SSLException</code>를
 Throw 하는 프로토콜도 있습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../javax/net/ssl/SSLException.html" title="javax.net.ssl 안의 클래스">SSLException</A> </CODE> - <code>SSLEngine</code> 에 새롭고 핸드 쉐이크를 개시하도록 통지하고 있을 때, 문제가 발생했을 경우. 엔진의 종료의 자세한 것은, 클래스의 설명을 참조
<DD><CODE><A HREF="../../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 클라이언트/서버 모드가 미설정의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSession.html#invalidate()"><CODE>SSLSession.invalidate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getHandshakeStatus()"><!-- --></A> <H3>
getHandshakeStatus</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLEngineResult.HandshakeStatus.html" title="javax.net.ssl 내의 열거형">SSLEngineResult.HandshakeStatus</A>  <B>getHandshakeStatus</B>()</PRE>
<DL>
<DD>이 <code>SSLEngine</code>
 현재의 핸드 쉐이크 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 <code>SSLEngineResult.HandshakeStatus</code></DL>
</DD>
</DL>
<HR>

<A NAME="setUseClientMode(boolean)"><!-- --></A> <H3>
setUseClientMode</H3>
<PRE>
public abstract void <B>setUseClientMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>핸드 쉐이크시, 엔진이 클라이언트 (또는 서버) 모드를 사용하도록 설정합니다.
<P>
 이 메서드는
 모든 핸드 쉐이크의 전에 호출할 필요가 있습니다. 일단 핸드 쉐이크가 개시되면, 이 엔진의 수명이 다할 때까지, 현재의 모드를 리셋트 할 수 없습니다.
<P>
 보통
, 서버는 자신을 인증합니다만, 클라이언트는 반드시 그렇다고는 할 수 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 핸드 쉐이크를 클라이언트 모드로 개시하는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 최초의 핸드 쉐이크가 개시되고 나서 모드를 변경하려고 했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getUseClientMode()"><CODE>getUseClientMode()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUseClientMode()"><!-- --></A> <H3>
getUseClientMode</H3>
<PRE>
public abstract boolean <B>getUseClientMode</B>()</PRE>
<DL>
<DD>핸드 쉐이크시에 클라이언트 모드를 사용하도록 엔진이 설정되어 있는 경우는 true
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 모드로 핸드 쉐이크를 실시하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNeedClientAuth(boolean)"><!-- --></A> <H3>
setNeedClientAuth</H3>
<PRE>
public abstract void <B>setNeedClientAuth</B>(boolean&nbsp;need)</PRE>
<DL>
<DD>클라이언트 인증이 필수가 되는 것<i></i>같게 엔진을 설정합니다. 이 옵션은, 서버 모드의 엔진만으로 사용할 수 있습니다.
<P>
 엔진의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다. <ul> <li> 클라이언트 인증을 필수로 한다<li> 클라이언트 인증을 요구한다<li> 클라이언트 인증을 불필요하게 한다
</ul>
 
<P>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A> 
 경우와는 달라, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우는
 네고시에이션이 정지해, 엔진은, 종료 프로시저를 개시합니다. <i></i>
<P>
 이 메서드를 호출하면, 지금까지 이 메서드 또는 <A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  에
해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>need</CODE> - 클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNeedClientAuth()"><!-- --></A> <H3>
getNeedClientAuth</H3>
<PRE>
public abstract boolean <B>getNeedClientAuth</B>()</PRE>
<DL>
<DD>이 엔진에 클라이언트 인증이 필수인<i></i>경우는 true를
 돌려줍니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setWantClientAuth(boolean)"><!-- --></A> <H3>
setWantClientAuth</H3>
<PRE>
public abstract void <B>setWantClientAuth</B>(boolean&nbsp;want)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록 엔진을 설정합니다. 이 옵션은, 서버 모드의 엔진만으로 사용할 수 있습니다.
<P>
 엔진의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다. <ul> <li> 클라이언트 인증을 필수로 한다<li> 클라이언트 인증을 요구한다<li> 클라이언트 인증을 불필요하게 한다
</ul>
 
<P>
 <A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우에서도, 네고시에이션은 속행됩니다. <i></i>
<P>
 이 메서드를 호출하면, 지금까지 이 메서드 또는 <A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  에
해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>want</CODE> - 클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWantClientAuth()"><!-- --></A> <H3>
getWantClientAuth</H3>
<PRE>
public abstract boolean <B>getWantClientAuth</B>()</PRE>
<DL>
<DD>이 엔진이 클라이언트 인증을 요구하는<i></i>경우는 true를
 돌려줍니다. 이 옵션은, 서버 모드의 엔진만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLEngine.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnableSessionCreation(boolean)"><!-- --></A> <H3>
setEnableSessionCreation</H3>
<PRE>
public abstract void <B>setEnableSessionCreation</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>이 엔진으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. 세션을 작성하지 못하고, 재개할 수 있는 기존의 세션이 없는 경우, 핸드 쉐이크는 성공하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flag</CODE> - 세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#getEnableSessionCreation()"><CODE>getEnableSessionCreation()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnableSessionCreation()"><!-- --></A> <H3>
getEnableSessionCreation</H3>
<PRE>
public abstract boolean <B>getEnableSessionCreation</B>()</PRE>
<DL>
<DD>이 엔진으로 새로운 SSL 세션을 확립할 수 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLEngine.html#setEnableSessionCreation(boolean)"><CODE>setEnableSessionCreation(boolean)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLEngine.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/net/ssl/SSLContextSpi.html" title="javax.net.ssl 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLEngineResult.html" title="javax.net.ssl 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/net/ssl/SSLEngine.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="SSLEngine.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:00:44 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
SSLSocket (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.net.ssl.SSLSocket class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="SSLSocket (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLSocket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/net/ssl/SSLSocket.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="SSLSocket.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.net.ssl</FONT>
<BR>
클래스 SSLSocket</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">java.net.Socket</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.net.ssl.SSLSocket</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>SSLSocket</B><DT>extends <A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스">Socket</A> </DL>
</PRE>

<P>
이 클래스는 <code>Socket</code>를
 확장해, Secure Sockets Layer (SSL)나 IETF Transport Layer Security (TLS)등의 프로토콜을 사용하는 시큐어 소켓을 제공합니다.
<P>
 이러한 소켓은, 보통
의 스트림 소켓입니다만, TCP 등의 기본이 되는 네트워크 트랜스폴트 프로토콜상에 시큐러티 보호층을 추가합니다. 다음의 시큐러티 보호를 합니다.  
<UL>
        
 <LI> 정합성의 보호. <em></em>SSL 가 메세지를 도청에
한 개찬으로부터 보호한다
        
 <LI> 인증<em></em>. 대부분의 SSL 모드에서는
 피어 인증이 제공된다. 일반적으로 서버 인증을 한다. 서버로부터의 요구에 응해, 클라이언트 인증도 행해진다
        
 <LI> 기밀성 (프라이버시의 보호)<em></em>. 대부분의 SSL 모드에서는
 클라이언트와 서버간에 송신되는 데이터가 암호화되어 데이터의 기밀성이 보호된다. 이 결과, 수동적인 도청에
해, 금융정보나 개인정보등의 기밀성의 높은 데이터가 도청되는 것이 없다
        
</UL>

<P>
이러한 시큐러티 보호는
 「encode 방식」을 사용해 지정합니다. encode 방식은, 지정된 SSL 접속으로 사용되는 암호화 알고리즘의 편성입니다. 네고시에이션을 실시하려면,
 2 개의 종단이 같은 encode 방식을 선택해, 그 encode 방식이 양쪽 모두의 환경에서 사용 가능하지 않으면 안됩니다. 공통의 encode 방식이 없는 경우는
 SSL 접속을 확립하지 못하고, 데이터를 교환할 수 없습니다.

<P>
 사용되는 encode 방식은, 「핸드 쉐이크」라고 불리는 네고시에이션 프로세스에
해 확립됩니다. 핸드 쉐이크에서는
 세션의 작성 또는 참가를 합니다. 작성 또는 참가한 세션은, 무효가 될 때까지 다양한 접속을 보호합니다. 핸드 쉐이크가 완료하면,<em>getSession</em> 메서드를 사용해 세션 속성에 액세스 할 수 있습니다. 접속의 최초의 핸드 쉐이크는
 다음의 몇개의 방법으로 개시할 수 있습니다.  
<UL>

 <LI> <code>startHandshake</code>를
 호출해, 핸드 쉐이크를 명시적으로 개시한다
 <LI> 이 소켓에 대해서 어플리케이션 데이터의 읽어들여 또는 write를
 실시하면, 핸드 쉐이크가 암묵적으로 개시된다
 <LI> <code>getSession</code>를
 호출하면, 유효한 세션이 현재 존재하지 않는 경우는 세션이 설정되어 핸드 쉐이크가 암묵적으로 개시된다 
</UL>

<P>
하등의 이유로써 핸드 쉐이크가 실패했을 경우,<code>SSLSocket</code> 가 닫아 통신할 수 없게 됩니다.

<P>
encode 방식을 사용할 때는
 2 개의 그룹에 대해 이해할 필요가 있습니다.  
<UL>
        
 <LI> 서포트되고 있는<em></em>encode 방식. SSL 구현으로 서포트되는 모든 encode 방식. 이 리스트는
<em>getSupportedCipherSuites</em>를
 사용해 보고된다
        
 <LI> 사용 가능한<em></em>encode 방식. 서포트되고 있는 encode 방식보다 적은 것이 있다. 이 그룹은,<em>setEnabledCipherSuites</em> 메서드를 사용해 설정해,<em>getEnabledCipherSuites</em> 메서드를 사용해 조회한다. 새로운 소켓에서는
 최소한의 추천 구성을 나타내는 디폴트의 encode 방식이 사용 가능하게 되어 있다
        
</UL>

<P>
 디폴트의 구현으로 사용 가능하게 하는 encode 방식으로는
 서버를 인증해, 기밀성이 보증되지 않으면 안됩니다. 서버 인증을 하지 않고 기밀성이 보증되지 않는 encode 방식을 선택하는 경우는
 서버 인증을 하지 않고 비공개성이 보증되지 않는 (암호화되지 않는다) 통신이 사용되는 것에 2 개의 종단이 명시적으로 동의 할 필요가 있습니다.

<P>
<code>SSLSocket</code> 가 최초로 작성될 때는
 핸드 쉐이크는 행해지지 않습니다. 이 때문에
 사용하는 encode 방식이나 소켓 모드 (클라이언트 모드 또는 서버 모드)등의 통신 설정은, 어플리케이션으로부터 실시합니다. 다만, 그 접속을 사용해 어플리케이션 데이터를 송신할 때는
 항상 시큐러티가 보증됩니다.

<P>
 핸드 쉐이크의 완료를 전하는 이벤트 통지를 수신하는 설정으로 할 수 있습니다. 이 경우, 2 개의 추가 클래스를 이용할 필요가 있습니다. <em>HandshakeCompletedEvent</em> 오브젝트는
 이 API
 유저에
해 등록된 <em>HandshakeCompletedListener</em> 인스턴스에게 건네집니다.
<code>SSLSocket</code>는

<code>SSLSocketFactory</code> 에
해 작성됩니다. 이 외,
<code>SSLServerSocket</code> 로부터의 접속을 받아들였을 경우에도 작성됩니다. <code></code>

<P>
SSL 소켓의 동작에는
 클라이언트 모드 또는 서버 모드가 있습니다. 핸드 쉐이크 프로세스를 개시하는 피어 및 각 피어로부터 송신되는 메세지는
 모드에
해 정해집니다. 다만, 접속에는
 클라이언트와 서버가 1 개씩 필요합니다. 이 요건을 채우지 않은 경우, 핸드 쉐이크는 올바르게 행해지지 않습니다. 최초의 핸드 쉐이크가 개시되고 나서는
 네고시에이션을 다시 하는 경우여도, 클라이언트 모드와 서버 모드를 바꿀 수 없습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/net/Socket.html" title="java.net 내의 클래스"><CODE>Socket</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLServerSocket.html" title="javax.net.ssl 안의 클래스"><CODE>SSLServerSocket</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 안의 클래스"><CODE>SSLSocketFactory</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket()">SSLSocket</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
          int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.net.InetAddress, int, java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
          int&nbsp;port,
          <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
          int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.lang.String, int)">SSLSocket</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
          int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#SSLSocket(java.lang.String, int, java.net.InetAddress, int)">SSLSocket</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
          int&nbsp;port,
          <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
          int&nbsp;clientPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에서만 사용됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)">addHandshakeCompletedListener</A> </B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속의 SSL 핸드 쉐이크의 완료 통지를 받기 위한 이벤트 리스너를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()">getEnabledCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 현재 사용 가능하게 되어 있는 SSL encode 방식의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledProtocols()">getEnabledProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속에 대해서 현재 사용 가능하게 되어 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnableSessionCreation()">getEnableSessionCreation</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로 새로운 SSL 세션을 확립할 수 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()">getNeedClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓에 클라이언트 인증이 필수인<i></i>경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSession()">getSession</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용되고 있는 SSL 세션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()">getSupportedCipherSuites</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능하게 할 수 있는 encode 방식의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedProtocols()">getSupportedProtocols</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SSL 접속으로 사용 가능하게 할 수 있는 프로토콜의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getUseClientMode()">getUseClientMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시에 클라이언트 모드를 사용하도록 소켓이 설정되어 있는 경우는 true</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()">getWantClientAuth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 클라이언트 인증을 요구<i></i>하는 경우는
 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)">removeHandshakeCompletedListener</A> </B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이전에 등록된 핸드 쉐이크 완료 리스너를 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])">setEnabledCipherSuites</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능한 encode 방식을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])">setEnabledProtocols</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속으로 사용 가능한 프로토콜의 버젼을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnableSessionCreation(boolean)">setEnableSessionCreation</A> </B>(boolean&nbsp;flag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)">setNeedClientAuth</A> </B>(boolean&nbsp;need)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록 소켓을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)">setUseClientMode</A> </B>(boolean&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;핸드 쉐이크시, 소켓이 클라이언트 (또는 서버) 모드를 사용하도록 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)">setWantClientAuth</A> </B>(boolean&nbsp;want)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클라이언트 인증을 요구<i></i>하도록 소켓을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()">startHandshake</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 접속상에서 SSL 핸드 쉐이크를 개시합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.net.Socket"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.net. <A HREF="../../../java/net/Socket.html" title="java.net 안의 클래스">Socket</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/net/Socket.html#bind(java.net.SocketAddress)">bind</A>,
 <A HREF="../../../java/net/Socket.html#close()">close</A>,
 <A HREF="../../../java/net/Socket.html#connect(java.net.SocketAddress)">connect</A>,
 <A HREF="../../../java/net/Socket.html#connect(java.net.SocketAddress, int)">connect</A>,
 <A HREF="../../../java/net/Socket.html#getChannel()">getChannel</A>,
 <A HREF="../../../java/net/Socket.html#getInetAddress()">getInetAddress</A>,
 <A HREF="../../../java/net/Socket.html#getInputStream()">getInputStream</A>,
 <A HREF="../../../java/net/Socket.html#getKeepAlive()">getKeepAlive</A>,
 <A HREF="../../../java/net/Socket.html#getLocalAddress()">getLocalAddress</A>,
 <A HREF="../../../java/net/Socket.html#getLocalPort()">getLocalPort</A>,
 <A HREF="../../../java/net/Socket.html#getLocalSocketAddress()">getLocalSocketAddress</A>,
 <A HREF="../../../java/net/Socket.html#getOOBInline()">getOOBInline</A>,
 <A HREF="../../../java/net/Socket.html#getOutputStream()">getOutputStream</A>,
 <A HREF="../../../java/net/Socket.html#getPort()">getPort</A>,
 <A HREF="../../../java/net/Socket.html#getReceiveBufferSize()">getReceiveBufferSize</A>,
 <A HREF="../../../java/net/Socket.html#getRemoteSocketAddress()">getRemoteSocketAddress</A>,
 <A HREF="../../../java/net/Socket.html#getReuseAddress()">getReuseAddress</A>,
 <A HREF="../../../java/net/Socket.html#getSendBufferSize()">getSendBufferSize</A>,
 <A HREF="../../../java/net/Socket.html#getSoLinger()">getSoLinger</A>,
 <A HREF="../../../java/net/Socket.html#getSoTimeout()">getSoTimeout</A>,
 <A HREF="../../../java/net/Socket.html#getTcpNoDelay()">getTcpNoDelay</A>,
 <A HREF="../../../java/net/Socket.html#getTrafficClass()">getTrafficClass</A>,
 <A HREF="../../../java/net/Socket.html#isBound()">isBound</A>,
 <A HREF="../../../java/net/Socket.html#isClosed()">isClosed</A>,
 <A HREF="../../../java/net/Socket.html#isConnected()">isConnected</A>,
 <A HREF="../../../java/net/Socket.html#isInputShutdown()">isInputShutdown</A>,
 <A HREF="../../../java/net/Socket.html#isOutputShutdown()">isOutputShutdown</A>,
 <A HREF="../../../java/net/Socket.html#sendUrgentData(int)">sendUrgentData</A>,
 <A HREF="../../../java/net/Socket.html#setKeepAlive(boolean)">setKeepAlive</A>,
 <A HREF="../../../java/net/Socket.html#setOOBInline(boolean)">setOOBInline</A>,
 <A HREF="../../../java/net/Socket.html#setPerformancePreferences(int, int, int)">setPerformancePreferences</A>,
 <A HREF="../../../java/net/Socket.html#setReceiveBufferSize(int)">setReceiveBufferSize</A>,
 <A HREF="../../../java/net/Socket.html#setReuseAddress(boolean)">setReuseAddress</A>,
 <A HREF="../../../java/net/Socket.html#setSendBufferSize(int)">setSendBufferSize</A>,
 <A HREF="../../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)">setSocketImplFactory</A>,
 <A HREF="../../../java/net/Socket.html#setSoLinger(boolean, int)">setSoLinger</A>,
 <A HREF="../../../java/net/Socket.html#setSoTimeout(int)">setSoTimeout</A>,
 <A HREF="../../../java/net/Socket.html#setTcpNoDelay(boolean)">setTcpNoDelay</A>,
 <A HREF="../../../java/net/Socket.html#setTrafficClass(int)">setTrafficClass</A>,
 <A HREF="../../../java/net/Socket.html#shutdownInput()">shutdownInput</A>,
 <A HREF="../../../java/net/Socket.html#shutdownOutput()">shutdownOutput</A>,
 <A HREF="../../../java/net/Socket.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="SSLSocket()"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>()</PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 초기화되어 있지 않은 미접속의 TCP 소켓을 작성합니다.
<P>
</DL>
<HR>

<A NAME="SSLSocket(java.lang.String, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                    int&nbsp;port)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                    <A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 포트의 지명된 호스트에 대한 TCP 접속을 작성합니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 접속하는 호스트의 이름<DD><CODE>port</CODE> - 서버의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트가 불명의 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
                    int&nbsp;port)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 주소와 포트의 서버에 대한 TCP 접속을 작성합니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 서버의 호스트<DD><CODE>port</CODE> - 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.lang.String, int, java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                    int&nbsp;port,
                    <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
                    int&nbsp;clientPort)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                    <A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 포트의 지명된 호스트에 대한 SSL 접속을 작성합니다. 접속의 클라이언트측은, 지정된 주소와 포트에 바인드 됩니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 접속하는 호스트의 이름<DD><CODE>port</CODE> - 서버의 포트 번호<DD><CODE>clientAddress</CODE> - 클라이언트의 호스트<DD><CODE>clientPort</CODE> - 클라이언트의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트가 불명의 경우</DL>
</DL>
<HR>

<A NAME="SSLSocket(java.net.InetAddress, int, java.net.InetAddress, int)"><!-- --></A> <H3>
SSLSocket</H3>
<PRE>
protected <B>SSLSocket</B>(<A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
                    int&nbsp;port,
                    <A HREF="../../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;clientAddress,
                    int&nbsp;clientPort)
             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스에서만 사용됩니다. 지정된 주소와 TCP 포트의 서버에 대한 SSL 접속을 작성합니다. 접속의 클라이언트측은, 지정된 주소와 포트에 바인드 됩니다. 이 소켓은, SSL 클라이언트로서 동작합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 서버의 호스트<DD><CODE>port</CODE> - 포트<DD><CODE>clientAddress</CODE> - 클라이언트의 호스트<DD><CODE>clientPort</CODE> - 클라이언트의 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getSupportedCipherSuites()"><!-- --></A> <H3>
getSupportedCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedCipherSuites</B>()</PRE>
<DL>
<DD>이 접속으로 사용 가능하게 할 수 있는 encode 방식의 이름을 돌려줍니다. 일반적으로 이러한 encode 방식의 일부만이, 디폴트 구현으로 사용 가능하게 됩니다. 일부의 encode 방식은, 디폴트 구현의 서비스 품질 요건을 채우지 않은 것이 있기 때문에입니다. 이러한 encode 방식은, 특수한 어플리케이션으로 사용됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>encode 방식명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledCipherSuites()"><!-- --></A> <H3>
getEnabledCipherSuites</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledCipherSuites</B>()</PRE>
<DL>
<DD>이 접속으로 현재 사용 가능하게 되어 있는 SSL encode 방식의 이름을 돌려줍니다. SSL 소켓이 최초로 작성되었을 때에
 사용 가능하게는 모든 encode 방식에서, 최소한의 서비스 품질이 보증됩니다. 환경에 따라서는
 이 값은 하늘의 경우도 있습니다.
<P>
 encode 방식은, 비록 유효해도 사용되지 않는 것이 있습니다. 예를 들어, 피어가 encode 방식을 서포트하지 않는 경우, 이 encode에 필요한 인증서
 ( 및 비공개키)를 사용할 수가 없는 경우, 또는
 익명의 encode 방식이 이용 가능해도 인증이 요구되는 경우 등입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>encode 방식명의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledCipherSuites(java.lang.String[])"><CODE>setEnabledCipherSuites(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledCipherSuites(java.lang.String[])"><!-- --></A> <H3>
setEnabledCipherSuites</H3>
<PRE>
public abstract void <B>setEnabledCipherSuites</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;suites)</PRE>
<DL>
<DD>이 접속으로 사용 가능한 encode 방식을 설정합니다.
<P>
 <code>suites</code> 파라미터로 지정된 각 encode 방식은, getSupportedCipherSuites()로 리스트되어 있지 않으면 안됩니다. 그렇지 않은 경우, 메서드는 실패합니다. 이 메서드의 호출이 정상적으로 행해졌을 때,<code>suites</code> 파라미터에 리스트 된 encode 방식만, 사용할 수가 있습니다.
<P>
 왜 특정의 encode 방식을 접속으로 사용할 수가 없는 것처럼 붙어서는
<A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> 를
 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>suites</CODE> - 사용 가능하게 하는 모든 encode 방식의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 encode 방식의 일부가 서포트되지 않는 경우, 또는 파라미터가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getSupportedCipherSuites()"><CODE>getSupportedCipherSuites()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledCipherSuites()"><CODE>getEnabledCipherSuites()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSupportedProtocols()"><!-- --></A> <H3>
getSupportedProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getSupportedProtocols</B>()</PRE>
<DL>
<DD>SSL 접속으로 사용 가능하게 할 수 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>서포트되고 있는 프로토콜의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getEnabledProtocols()"><!-- --></A> <H3>
getEnabledProtocols</H3>
<PRE>
public abstract <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>getEnabledProtocols</B>()</PRE>
<DL>
<DD>이 접속에 대해서 현재 사용 가능하게 되어 있는 프로토콜의 이름을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>프로토콜의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnabledProtocols(java.lang.String[])"><CODE>setEnabledProtocols(String [])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabledProtocols(java.lang.String[])"><!-- --></A> <H3>
setEnabledProtocols</H3>
<PRE>
public abstract void <B>setEnabledProtocols</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;protocols)</PRE>
<DL>
<DD>이 접속으로 사용 가능한 프로토콜의 버젼을 설정합니다.
<P>
 프로토콜은,<code>getSupportedProtocols()</code> 에
해, 서포트 대상으로 해 리스트되어 있지 않으면 안됩니다. 이 메서드의 호출이 정상적으로 행해졌을 때,<code>protocols</code> 파라미터에 리스트 된 프로토콜만, 사용할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>protocols</CODE> - 사용 가능하게 하는 모든 프로토콜의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 파라미터로 지정된 프로토콜의 일부가 서포트되지 않는 경우, 또는 파라미터가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnabledProtocols()"><CODE>getEnabledProtocols()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSession()"><!-- --></A> <H3>
getSession</H3>
<PRE>
public abstract <A HREF="../../../javax/net/ssl/SSLSession.html" title="javax.net.ssl 내의 인터페이스">SSLSession</A>  <B>getSession</B>()</PRE>
<DL>
<DD>이 접속으로 사용되고 있는 SSL 세션을 돌려줍니다. SSL 세션은 유효기간이 길고, 유저에 따라서는 로그인 세션 전체에 대응하는 일도 있습니다. 세션에는
 세션내의 모든 접속으로 사용되는 encode 방식과 세션의 클라이언트와 서버의 식별 정보가 지정되고 있습니다.
<P>
 이 메서드는
 필요에 따라서 초기 핸드 쉐이크를 개시해, 핸드 쉐이크가 확립했을 때에 블록을 해제합니다.
<P>
 초기 핸드 쉐이크로 에러가 발생하면, 무효인 세션 오브젝트가 돌려주고져 「SSL_NULL_WITH_NULL_NULL」라고 하는 무효인 encode 방식이 보고됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>SSLSession</code></DL>
</DD>
</DL>
<HR>

<A NAME="addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><!-- --></A> <H3>
addHandshakeCompletedListener</H3>
<PRE>
public abstract void <B>addHandshakeCompletedListener</B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</PRE>
<DL>
<DD>이 접속의 SSL 핸드 쉐이크의 완료 통지를 받기 위한 이벤트 리스너를 등록합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - HandShakeCompleted 이벤트 리스너
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 인수가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#startHandshake()"><CODE>startHandshake()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>removeHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><!-- --></A> <H3>
removeHandshakeCompletedListener</H3>
<PRE>
public abstract void <B>removeHandshakeCompletedListener</B>(<A HREF="../../../javax/net/ssl/HandshakeCompletedListener.html" title="javax.net.ssl 안의 인터페이스">HandshakeCompletedListener</A> &nbsp;listener)</PRE>
<DL>
<DD>이전에 등록된 핸드 쉐이크 완료 리스너를 삭제합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - HandShakeCompleted 이벤트 리스너
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 리스너가 등록되지 않은 경우, 또는 인수가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>addHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="startHandshake()"><!-- --></A> <H3>
startHandshake</H3>
<PRE>
public abstract void <B>startHandshake</B>()
                             throws <A HREF="../../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 접속상에서 SSL 핸드 쉐이크를 개시합니다. 예를 들어, 새로운 암호화키를 사용할 때, encode 방식을 변경할 때, 새로운 세션을 개시할 때 등에
 SSL 핸드 쉐이크를 개시합니다. 완전한 재인식증을 강제적으로 실행하려면,
 핸드 쉐이크를 개시하기 전에
 현재의 세션을 무효로 할 필요가 있습니다.

<P>
 벌써 접속상에 송신된 데이터는
 이 핸드 쉐이크가 완료할 때까지는 그대로의 상태를 유지해, 핸드 쉐이크가 완료하면 이벤트로부터 신호를 받습니다.
이 메서드는
 접속상의 최초의 핸드 쉐이크와 동시에 개시되어 핸드 쉐이크의 네고시에이션이 완료하면 종료합니다. 기존의 소켓상에서의 복수의 핸드 쉐이크를 서포트하지 않는 프로토콜은, IOException를
 Throw 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 네트워크 레벨의 에러<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#addHandshakeCompletedListener(javax.net.ssl.HandshakeCompletedListener)"><CODE>addHandshakeCompletedListener(HandshakeCompletedListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setUseClientMode(boolean)"><!-- --></A> <H3>
setUseClientMode</H3>
<PRE>
public abstract void <B>setUseClientMode</B>(boolean&nbsp;mode)</PRE>
<DL>
<DD>핸드 쉐이크시, 소켓이 클라이언트 (또는 서버) 모드를 사용하도록 설정합니다.
<P>
 이 메서드는
 모든 핸드 쉐이크의 전에 호출할 필요가 있습니다. 일단 핸드 쉐이크가 개시되면, 이 소켓의 수명이 다할 때까지, 현재의 모드를 리셋트 할 수 없습니다.
<P>
 보통
, 서버는 자신을 인증합니다만, 클라이언트는 반드시 그렇다고는 할 수 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 핸드 쉐이크를 클라이언트 모드로 개시하는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 최초의 핸드 쉐이크가 개시되고 나서 모드를 변경하려고 했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getUseClientMode()"><CODE>getUseClientMode()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUseClientMode()"><!-- --></A> <H3>
getUseClientMode</H3>
<PRE>
public abstract boolean <B>getUseClientMode</B>()</PRE>
<DL>
<DD>핸드 쉐이크시에 클라이언트 모드를 사용하도록 소켓이 설정되어 있는 경우는 true
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 모드로 핸드 쉐이크를 실시하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNeedClientAuth(boolean)"><!-- --></A> <H3>
setNeedClientAuth</H3>
<PRE>
public abstract void <B>setNeedClientAuth</B>(boolean&nbsp;need)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록 소켓을 설정합니다. 이 옵션은, 서버 모드의 소켓만으로 사용할 수 있습니다.
<P>
 소켓의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다. <ul> <li> 클라이언트 인증을 필수로 한다<li> 클라이언트 인증을 요구한다<li> 클라이언트 인증을 불필요하게 한다
</ul>
 
<P>
 <A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우는
 네고시에이션이 정지해, 접속이 절단 됩니다. <i></i>
<P>
 이 메서드를 호출하면, 지금까지 이 메서드 또는 <A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>  에
해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>need</CODE> - 클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNeedClientAuth()"><!-- --></A> <H3>
getNeedClientAuth</H3>
<PRE>
public abstract boolean <B>getNeedClientAuth</B>()</PRE>
<DL>
<DD>이 소켓에 클라이언트 인증이 필수인<i></i>경우는 true를
 돌려줍니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 필수의 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setWantClientAuth(boolean)"><!-- --></A> <H3>
setWantClientAuth</H3>
<PRE>
public abstract void <B>setWantClientAuth</B>(boolean&nbsp;want)</PRE>
<DL>
<DD>클라이언트 인증을 요구<i></i>하도록 소켓을 설정합니다. 이 옵션은, 서버 모드의 소켓만으로 사용할 수 있습니다.
<P>
 소켓의 클라이언트 인증 설정은, 다음의 어느 쪽인가에 됩니다. <ul> <li> 클라이언트 인증을 필수로 한다<li> 클라이언트 인증을 요구한다<li> 클라이언트 인증을 불필요하게 한다
</ul>
 
<P>
 <A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  와 달리, 이 옵션이 설정되어 있어, 한편 클라이언트 인증 정보가 제공되지 않는 경우에서도, 네고시에이션은 속행됩니다. <i></i>
<P>
 이 메서드를 호출하면, 지금까지 이 메서드 또는 <A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>  에
해 설정된 내용이 오버라이드(override) 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>want</CODE> - 클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getWantClientAuth()"><CODE>getWantClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWantClientAuth()"><!-- --></A> <H3>
getWantClientAuth</H3>
<PRE>
public abstract boolean <B>getWantClientAuth</B>()</PRE>
<DL>
<DD>이 소켓이 클라이언트 인증을 요구<i></i>하는 경우는
 true를
 돌려줍니다. 이 옵션은, 서버 모드의 소켓만으로 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>클라이언트 인증이 요구되었을 경우는 true, 클라이언트 인증이 불필요한 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setNeedClientAuth(boolean)"><CODE>setNeedClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#getNeedClientAuth()"><CODE>getNeedClientAuth()</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setWantClientAuth(boolean)"><CODE>setWantClientAuth(boolean)</CODE></A>,
 
<A HREF="../../../javax/net/ssl/SSLSocket.html#setUseClientMode(boolean)"><CODE>setUseClientMode(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnableSessionCreation(boolean)"><!-- --></A> <H3>
setEnableSessionCreation</H3>
<PRE>
public abstract void <B>setEnableSessionCreation</B>(boolean&nbsp;flag)</PRE>
<DL>
<DD>이 소켓으로 새로운 SSL 세션을 확립할 수 있을지 어떨지를 제어합니다. 세션을 작성하지 못하고, 재개할 수 있는 기존의 세션이 없는 경우, 핸드 쉐이크는 성공하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flag</CODE> - 세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#getEnableSessionCreation()"><CODE>getEnableSessionCreation()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEnableSessionCreation()"><!-- --></A> <H3>
getEnableSessionCreation</H3>
<PRE>
public abstract boolean <B>getEnableSessionCreation</B>()</PRE>
<DL>
<DD>이 소켓으로 새로운 SSL 세션을 확립할 수 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>세션을 작성할 수 있는 경우는 true (디폴트). 기존의 세션을 재개하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../javax/net/ssl/SSLSocket.html#setEnableSessionCreation(boolean)"><CODE>setEnableSessionCreation(boolean)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SSLSocket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/net/ssl/SSLSessionContext.html" title="javax.net.ssl 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/net/ssl/SSLSocketFactory.html" title="javax.net.ssl 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/net/ssl/SSLSocket.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="SSLSocket.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

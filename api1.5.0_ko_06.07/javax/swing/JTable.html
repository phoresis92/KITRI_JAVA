<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:12:06 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
JTable (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.swing.JTable class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="JTable (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JTable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/swing/JTabbedPane.ModelListener.html" title="javax.swing 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/swing/JTable.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="JTable.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
클래스 JTable</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">java.awt.Component</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">java.awt.Container</A> 
          <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">javax.swing.JComponent</A> 
              <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.JTable</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 내의 인터페이스">ImageObserver</A>,
 <A HREF="../../java/awt/MenuContainer.html" title="java.awt 안의 인터페이스">MenuContainer</A>,
 <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A>,
 <A HREF="../../java/util/EventListener.html" title="java.util 안의 인터페이스">EventListener</A>,
 <A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 안의 인터페이스">Accessible</A>,
 <A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 안의 인터페이스">CellEditorListener</A>,
 <A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 안의 인터페이스">ListSelectionListener</A>,
 <A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 안의 인터페이스">TableColumnModelListener</A>,
 <A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 안의 인터페이스">TableModelListener</A>,
 <A HREF="../../javax/swing/Scrollable.html" title="javax.swing 안의 인터페이스">Scrollable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>JTable</B><DT>extends <A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> <DT>implements <A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 내의 인터페이스">TableModelListener</A>,
 <A HREF="../../javax/swing/Scrollable.html" title="javax.swing 안의 인터페이스">Scrollable</A>,
 <A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 안의 인터페이스">TableColumnModelListener</A>,
 <A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 안의 인터페이스">ListSelectionListener</A>,
 <A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 안의 인터페이스">CellEditorListener</A>,
 <A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 안의 인터페이스">Accessible</A> </DL>
</PRE>

<P>
<code>JTable</code>는

 셀의 보통
의 2 차원 테이블 형식을 표시해, 편집하기 위해서 사용합니다. <code>JTable</code> 사용의 태스크 지향의 메뉴얼과 예에 대해서는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/table.html">「How to Use Tables」</a>를 참조하십시오.

 <p>
<code>JTable</code>는

 그 렌더링 및 편집을 커스터마이즈 할 수 있도록 하는 다수의 기능을 갖추는 한편으로 이러한 기능의 디폴트를 제공해 간단한 테이블을 용이하게 설정할 수 있도록 하고 있습니다. 예를 들어, 10 행 10 열로부터 구성되는 테이블은 다음과 같이 설정할 수 있습니다.
 <p>

 
 <pre>

      TableModel dataModel = new AbstractTableModel() {
          public int getColumnCount() { return 10; }
          public int getRowCount() { return 10;}
          public Object getValueAt(int row, int col) { return new Integer(row*col); }
      };
      JTable table = new JTable(dataModel);
      JScrollPane scrollpane = new JScrollPane(table);
 </pre>

 <p>
스탠드얼론의 뷰 (<code>JScrollPane</code>
 외측) 내에서 <code>JTable</code>를
 사용해, 헤더를 표시하는 경우는
<A HREF="../../javax/swing/JTable.html#getTableHeader()"><CODE>getTableHeader()</CODE></A> 를
 사용해 헤더를 취득해, 개별적으로 표시할 수 있습니다.
 <p>
<code>JTable</code>를
 사용하는 어플리케이션을 설계하는 경우, 테이블의 데이터를 표현하는 데이터 구조에 충분히 주의할 필요가 있습니다. <code>DefaultTableModel</code>는
 <code>Object</code>
 <code>Vector</code>
 <code>Vector</code>를
 사용해 셀의 값을 포함하는 구현의 모델입니다. 어플리케이션으로부터 <code>DefaultTableModel</code> 에 데이터를 카피함과 함께, 상기의 예의 통과해, 데이터가 직접 <code>JTable</code> 에게 건네지도록,<code>TableModel</code> 인터페이스의 메서드내의 데이터를 랩 할 수도 있습니다. 이것에
해, 모델이 데이터에 가장 적합한 내부 표현을 자유롭게 선택할 수 있는 것으로부터, 한층 더 효과적인 어플리케이션을 작성할 수 있습니다. <code>AbstractTableModel</code> 또는 <code>DefaultTableModel</code>
 어느 쪽을 사용할까를 결정하는 대범한 지침에서는
 서브 클래스를 작성하기 위한 base class로서 <code>AbstractTableModel</code> 가 사용되어 서브 클래스화가 불필요한 경우에 <code>DefaultTableModel</code> 가 사용됩니다.
 <p>
소스로서 배포되는 demo 영역의 「TableExample」디렉토리는
 다수의 <code>JTable</code>
 사용 방법에 관한 완전한 예를 제공합니다. 이 예에는
 데이타베이스로부터 얻는
 데이터의 편집 가능한 뷰를 제공하기 위해서 <code>JTable</code>를
 사용하는 방법이나, 특수한 렌더링이나 에디터를 사용하기 위해서 디스플레이내의 열을 변경하는 방법등이 있습니다.
 <p>
<code>JTable</code>는
 정수형을 배타적으로 사용해, 그것이 표시하는 모델의 행과 열을 어느쪽이나 참조합니다. <code>JTable</code>는
 단지 탭 형식 범위의 셀을 취득해 <code>getValueAt(int, int)</code>를
 사용해, 렌더링시에 모델로부터 값을 꺼냅니다.
 <p>
디폴트로 열은 <code>JTable</code> 로 다시 배열해,
 뷰의 열이 모델내의 열과는 다른 차례로 표시되게 됩니다. 이것은, 모델의 구현에 전혀 영향을 주지 않습니다. 열이 늘어놓고 바꾸고를 실시할 때는
<code>JTable</code>는
 열의 새로운 차례를 내부적으로 유지해, 그 열인덱스를 모델의 조회전으로 변환합니다.
 <p>
이 때문에
<code>TableModel</code>를
 기술할 때는
 뷰로 무엇이 일어나고 있을까에 관계없이 모델은 그것 자신의 좌표계로 조회되므로 열 늘어놓고 바꾸고 이벤트에 대기할 필요는 없습니다. examples 부하에게는
 열은 아니고 행의 차례를 변경하는 이제(벌써) 1 개의 좌표계를 삽입하기 위한,
 이 방법을 이용한 늘어놓고 바꾸고 알고리즘의 샘플이 준비되어 있습니다.
 <p>
J2SE 5 에서는
<code>JTable</code> 에
 일반적인 인쇄 요구를 실현할 수 있는 편리한 메서드를 추가하고 있습니다. 새로운 <A HREF="../../javax/swing/JTable.html#print()"><CODE>print()</CODE></A>  메서드를 사용하는 것만으로 신속하고 용이하게 인쇄 기능을 어플리케이션에 추가할 수 있습니다. 또, 한층 더 고도의 인쇄 요구에는
 새로운 <A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A>  메서드를 사용할 수 있습니다.
 <p>
모든 <code>JComponent</code> 클래스에 관해서는
<A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스"><CODE>InputMap</CODE></A>  와 <A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스"><CODE>ActionMap</CODE></A> 를
 사용해 <A HREF="../../javax/swing/Action.html" title="javax.swing 동안의 인터페이스"><CODE>Action</CODE></A>  오브젝트와 <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스"><CODE>KeyStroke</CODE></A> 를
 관련지어 지정한 조건으로 액션을 실행할 수 있습니다.
 <p>
<strong>경고:</strong> 이 클래스의 직렬화 된 오브젝트는
 향후의 Swing 릴리스와 호환은 아니게 될 예정입니다. 현재의 직렬화의 서포트는
 단기간의 운용이나, 같은 버젼의 Swing를
 실행하는 어플리케이션간의 RMI 에 적절하고 있습니다. JDK 버젼 1.4 이후, 모든 JavaBeans<sup><font size="-2">&trade;</font></sup>
 장기간의 운용 서포트는
<code>java.beans</code> 패키지에 추가되고 있습니다. 자세한 것은,<A HREF="../../java/beans/XMLEncoder.html" title="java.beans 안의 클래스"><CODE>XMLEncoder</CODE></A> 를
 참조하십시오.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 안의 클래스">JTable.AccessibleJTable</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스는 <code>JTable</code> 클래스용의 유저 보조 기능의 서포트를 구현하고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JTable</code>
 인쇄에 사용하는 인쇄 모드입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 중첩(Nested) 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 안의 클래스">JComponent.AccessibleJComponent</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 중첩(Nested) 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 안의 클래스">Container.AccessibleAWTContainer</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 중첩(Nested) 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.AccessibleAWTComponent.html" title="java.awt 안의 클래스">Component.AccessibleAWTComponent</A>,
 <A HREF="../../java/awt/Component.BltBufferStrategy.html" title="java.awt 안의 클래스">Component.BltBufferStrategy</A>,
 <A HREF="../../java/awt/Component.FlipBufferStrategy.html" title="java.awt 안의 클래스">Component.FlipBufferStrategy</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_ALL_COLUMNS">AUTO_RESIZE_ALL_COLUMNS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 사이즈 변경 조작으로 각 열을 균등하게 사이즈 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_LAST_COLUMN">AUTO_RESIZE_LAST_COLUMN</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 사이즈 변경 조작으로 최종열인 만큼 조정을 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_NEXT_COLUMN">AUTO_RESIZE_NEXT_COLUMN</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열을 UI 로 조정할 때는
 다음의 열을 역방향으로 조정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_OFF">AUTO_RESIZE_OFF</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렬폭의 조정은 자동적으로 실시하지 않고,
 스크롤 바를 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#AUTO_RESIZE_SUBSEQUENT_COLUMNS">AUTO_RESIZE_SUBSEQUENT_COLUMNS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI를
 조정할 때는
 그 이후의 열을 변경해 열의 합계폭을 유지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#autoCreateColumnsFromModel">autoCreateColumnsFromModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true
 경우, 열의 디폴트 세트를 구축하도록 <code>TableModel</code> 에 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#autoResizeMode">autoResizeMode</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 폭의 사이즈를 자동 변경해 각 열로 테이블폭전체를 차지하도록 할지 어떨지를 지정해, 그 사이즈 변경의 방법을 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#cellEditor">cellEditor</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 셀이 차지하는 화면상의 장소를 덧쓰기해, 유저가 그 내용을 변경할 수 있도록 하는 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#cellSelectionEnabled">cellSelectionEnabled</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 2 플랫폼 v1. 3 에서는 사용하지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnModel">columnModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableColumnModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#dataModel">dataModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#defaultEditorsByColumnClass">defaultEditorsByColumnClass</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 내용을 표시 및 편집하는 오브젝트의 테이블입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#defaultRenderersByColumnClass">defaultRenderersByColumnClass</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 내용을 표시하는 오브젝트의 테이블입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingColumn">editingColumn</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집중의 셀의 열을 식별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingRow">editingRow</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집중의 셀의 행을 식별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editorComp">editorComp</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집시이면, 편집을 처리하고 있는 <code>Component</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#gridColor">gridColor</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두의 색입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#preferredViewportSize">preferredViewportSize</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Scrollable</code> 인터페이스에
해 사용되어 가시 영역의 초기설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowHeight">rowHeight</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 각 행의 높이를 픽셀로 나타낸 것입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowMargin">rowMargin</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;각 행의 셀간의 마진의 높이를 픽셀로 나타낸 것입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowSelectionAllowed">rowSelectionAllowed</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블로 행 선택이 허가되고 있는 경우는 true 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionBackground">selectionBackground</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 컬러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionForeground">selectionForeground</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 foreground 컬러입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectionModel">selectionModel</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택의 추적에 사용하는
 테이블의 <code>ListSelectionModel</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#showHorizontalLines">showHorizontalLines</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showHorizontalLines</code> 가 true
 경우, 테이블은 셀간에 수평선을 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#showVerticalLines">showVerticalLines</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showVerticalLines</code> 가 true
 경우, 테이블은 셀간에 수직선을 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#tableHeader">tableHeader</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 <code>TableHeader</code> 입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.html#accessibleContext">accessibleContext</A>,
 <A HREF="../../javax/swing/JComponent.html#listenerList">listenerList</A>,
 <A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY">TOOL_TIP_TEXT_KEY</A>,
 <A HREF="../../javax/swing/JComponent.html#ui">ui</A>,
 <A HREF="../../javax/swing/JComponent.html#UNDEFINED_CONDITION">UNDEFINED_CONDITION</A>,
 <A HREF="../../javax/swing/JComponent.html#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</A>,
 <A HREF="../../javax/swing/JComponent.html#WHEN_FOCUSED">WHEN_FOCUSED</A>,
 <A HREF="../../javax/swing/JComponent.html#WHEN_IN_FOCUSED_WINDOW">WHEN_IN_FOCUSED_WINDOW</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#BOTTOM_ALIGNMENT">BOTTOM_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#CENTER_ALIGNMENT">CENTER_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#LEFT_ALIGNMENT">LEFT_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#RIGHT_ALIGNMENT">RIGHT_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#TOP_ALIGNMENT">TOP_ALIGNMENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt.image. <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/image/ImageObserver.html#ABORT">ABORT</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#ALLBITS">ALLBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#ERROR">ERROR</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#FRAMEBITS">FRAMEBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#HEIGHT">HEIGHT</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#PROPERTIES">PROPERTIES</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#SOMEBITS">SOMEBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#WIDTH">WIDTH</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable()">JTable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트 데이터 모델, 디폴트열모델 및 디폴트 선택 모델로 초기화되는
 디폴트의 <code>JTable</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(int, int)">JTable</A> </B>(int&nbsp;numRows,
       int&nbsp;numColumns)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableModel</code>를
 사용해, 하늘의 셀의 <code>numRows</code> 와 <code>numColumns</code> 로 <code>JTable</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(java.lang.Object[][], java.lang.Object[])">JTable</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> [][]&nbsp;rowData,
       <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 차원 배열 <code>rowData</code>
 값을 표시하는 <code>JTable</code>를
, 렬명 <code>columnNames</code> 로 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 디폴트열모델 및 디폴트 선택 모델로 초기화되는 <code>JTable</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
       <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 열모델 <code>cm</code> 및 디폴트 선택 모델로 초기화되는 <code>JTable</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel, javax.swing.ListSelectionModel)">JTable</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
       <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm,
       <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;sm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 모델 <code>dm</code>, 열모델 <code>cm</code> 및 선택 모델 <code>sm</code> 로 초기화되는 <code>JTable</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#JTable(java.util.Vector, java.util.Vector)">JTable</A> </B>(<A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;rowData,
       <A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;columnNames)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Vectors</code>
 <code>Vector</code>
 값을 표시하는 <code>JTable</code>, 즉 <code>rowData</code>를
, 렬명 <code>columnNames</code> 로 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addColumn(javax.swing.table.TableColumn)">addColumn</A> </B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code>
 열모델이 보관 유지하는 열의 배열의 말미에 <code>aColumn</code>를
 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addColumnSelectionInterval(int, int)">addColumnSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addNotify()">addNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>configureEnclosingScrollPane</code> 메서드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#addRowSelectionInterval(int, int)">addRowSelectionInterval</A> </B>(int&nbsp;index0,
                        int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#changeSelection(int, int, boolean, boolean)">changeSelection</A> </B>(int&nbsp;rowIndex,
                int&nbsp;columnIndex,
                boolean&nbsp;toggle,
                boolean&nbsp;extend)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>toggle</code> 와 <code>extend</code>
 2 개의 플래그 상태에
해, 테이블의 선택 모델을 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#clearSelection()">clearSelection</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택 떠날 수 있어 모든 열 및 행을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnAdded(javax.swing.event.TableColumnModelEvent)">columnAdded</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블열모델에 열이 추가될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnAtPoint(java.awt.Point)">columnAtPoint</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1]
 범위내에 없는 경우는 -1을
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnMarginChanged(javax.swing.event.ChangeEvent)">columnMarginChanged</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마진 변경을 위해서 열이 이동되었을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnMoved(javax.swing.event.TableColumnModelEvent)">columnMoved</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열이 다시 배치했을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnRemoved(javax.swing.event.TableColumnModelEvent)">columnRemoved</A> </B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열이 테이블열모델로부터 삭제될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#columnSelectionChanged(javax.swing.event.ListSelectionEvent)">columnSelectionChanged</A> </B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumnModel</code>
 선택 모델이 변경될 때 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()">configureEnclosingScrollPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;일반적으로 이 <code>JTable</code> 가 둘러싸 옆 <code>JScrollPane</code>
 <code>viewportView</code> 입니다만, 그 경우, 특히 테이블의 <code>tableHeader</code>을
 스크롤 구획의 <code>columnHeaderView</code> 로서 인스톨 하는 것에
해, 이 <code>ScrollPane</code>
 설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertColumnIndexToModel(int)">convertColumnIndexToModel</A> </B>(int&nbsp;viewColumnIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>viewColumnIndex</code>
 뷰내의 열의 인덱스를, 테이블 모델내의 열의 인덱스에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)">convertColumnIndexToView</A> </B>(int&nbsp;modelColumnIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>modelColumnIndex</code>
 테이블 모델내의 열의 인덱스를, 뷰내의 열의 인덱스에 매핑 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()">createDefaultColumnModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableColumnModel</code> 인 디폴트의 열모델 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()">createDefaultColumnsFromModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 <code>TableModel</code> 인터페이스로 정의된 <code>getColumnCount</code> 메서드를 사용해, 데이터 모델로부터 테이블의 디폴트의 열을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()">createDefaultDataModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultTableModel</code> 인 디폴트의 테이블 모델 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultEditors()">createDefaultEditors</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트, 수 및 boolean 치의 디폴트의 셀 에디터를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultRenderers()">createDefaultRenderers</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트, 수, double 치, 일자, boolean 치 및 아이콘의 디폴트의 셀 렌더링을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()">createDefaultSelectionModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>DefaultListSelectionModel</code> 인 디폴트의 선택 모델 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createDefaultTableHeader()">createDefaultTableHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JTableHeader</code> 인 디폴트의 테이블 헤더 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 내의 클래스">JScrollPane</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#createScrollPaneForTable(javax.swing.JTable)">createScrollPaneForTable</A> </B>(<A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A> &nbsp;aTable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>Swing 버젼 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#doLayout()">doLayout</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블에 행과 열을 레이아웃 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editCellAt(int, int)">editCellAt</A> </B>(int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 및 <code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는
 셀의 편집을 프로그램에 근거해 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editCellAt(int, int, java.util.EventObject)">editCellAt</A> </B>(int&nbsp;row,
           int&nbsp;column,
           <A HREF="../../java/util/EventObject.html" title="java.util 안의 클래스">EventObject</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는
 셀의 편집을 프로그램에 근거해 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingCanceled(javax.swing.event.ChangeEvent)">editingCanceled</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집이 삭제되면 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#editingStopped(javax.swing.event.ChangeEvent)">editingStopped</A> </B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집이 완료했을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAccessibleContext()">getAccessibleContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 JTable 에 관련한 AccessibleContext를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()">getAutoCreateColumnsFromModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 디폴트의 열을 모델로부터 작성할지 어떨지를 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getAutoResizeMode()">getAutoResizeMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 자동 사이즈 변경 모드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellEditor()">getCellEditor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀 에디터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellEditor(int, int)">getCellEditor</A> </B>(int&nbsp;row,
              int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 와 <code>column</code> 가 지정하는 셀의 적절한 에디터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellRect(int, int, boolean)">getCellRect</A> </B>(int&nbsp;row,
            int&nbsp;column,
            boolean&nbsp;includeSpacing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code> 와 <code>column</code> 가 교차하는 위치의 셀의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellRenderer(int, int)">getCellRenderer</A> </B>(int&nbsp;row,
                int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 행과 열로 지정하는 셀의 적절한 렌더링을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getCellSelectionEnabled()">getCellSelectionEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 내의 클래스">TableColumn</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumn(java.lang.Object)">getColumn</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;identifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>equals</code>를
 사용해 비교해, 식별자가 <code>identifier</code> 에 동일한 테이블내의 열의 <code>TableColumn</code> 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnClass(int)">getColumnClass</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열위치 <code>column</code>
 뷰에 표시되는 열의 형태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnCount()">getColumnCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열모델내의 렬수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnModel()">getColumnModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 모든 열정보를 보관 유지하는 <code>TableColumnModel</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnName(int)">getColumnName</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열위치 <code>column</code>
 뷰에 표시되는 열의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getColumnSelectionAllowed()">getColumnSelectionAllowed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열을 선택할 수 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDefaultEditor(java.lang.Class)">getDefaultEditor</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는 에디터를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDefaultRenderer(java.lang.Class)">getDefaultRenderer</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는
 셀 렌더링을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getDragEnabled()">getDragEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>dragEnabled</code> 프로퍼티의 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditingColumn()">getEditingColumn</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 편집중의 셀을 포함한 열의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditingRow()">getEditingRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 편집중의 셀을 포함한 행의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getEditorComponent()">getEditorComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;편집 세션을 처리하고 있는 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getGridColor()">getGridColor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두선의 렌더링에 사용하는 색을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getIntercellSpacing()">getIntercellSpacing</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀간의 수평 간격과 수직 간격을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getModel()">getModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getPreferredScrollableViewportSize()">getPreferredScrollableViewportSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 뷰포트의 적절한 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/print/Printable.html" title="java.awt.print 내의 인터페이스">Printable</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)">getPrintable</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
             <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
             <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 JTable
 인쇄에 사용하는 <code>Printable</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowCount()">getRowCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 모델내의 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowHeight()">getRowHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블행의 높이를 픽셀로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowHeight(int)">getRowHeight</A> </B>(int&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>
 셀의 높이를 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowMargin()">getRowMargin</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀의 간격을 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getRowSelectionAllowed()">getRowSelectionAllowed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행을 선택할 수 있는 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)">getScrollableBlockIncrement</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                            int&nbsp;orientation,
                            int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 방향에
해 <code>visibleRect.height</code> 또는 <code>visibleRect.width</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableTracksViewportHeight()">getScrollableTracksViewportHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;false를
 돌려주고, 뷰포트의 높이가 테이블의 높이를 결정하지 않는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableTracksViewportWidth()">getScrollableTracksViewportWidth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoResizeMode</code> 가 <code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)">getScrollableUnitIncrement</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                           int&nbsp;orientation,
                           int&nbsp;direction)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 1 행 또는 1 열을 완전하게 표시하는 스크롤 증분치를 (방향에 근거해) 픽셀 단위로 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumn()">getSelectedColumn</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초로 선택된 열의 인덱스를 돌려주는지, 열이 선택되어 있지 않은 경우는 -1을
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumnCount()">getSelectedColumnCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택되고 있는 열의 수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedColumns()">getSelectedColumns</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 모든 열의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRow()">getSelectedRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초로 선택된 행의 인덱스를 돌려주는지, 행이 선택되어 있지 않은 경우는 -1을
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRowCount()">getSelectedRowCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectedRows()">getSelectedRows</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 모든 행의 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionBackground()">getSelectionBackground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 컬러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionForeground()">getSelectionForeground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택되고 있는 셀의 foreground 컬러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSelectionModel()">getSelectionModel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행 선택 상태의 유지에 사용하는 <code>ListSelectionModel</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getShowHorizontalLines()">getShowHorizontalLines</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수평선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getShowVerticalLines()">getShowVerticalLines</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수직선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getSurrendersFocusOnKeystroke()">getSurrendersFocusOnKeystroke</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 얻는
 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getTableHeader()">getTableHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code> 가 사용하는 <code>tableHeader</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>JComponent</code>
 <code>getToolTipText</code> 메서드를 오버라이드(override) 해, 텍스트 세트가 있는 경우, 렌더링의 힌트를 사용할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 내의 클래스">TableUI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getUI()">getUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 렌더링 하는 L&F 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getUIClassID()">getUIClassID</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Look & Feel 클래스의 이름의 구축에 사용된 접미말을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#getValueAt(int, int)">getValueAt</A> </B>(int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#initializeLocalVars()">initializeLocalVars</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 테이블 프로퍼티를 디폴트치에 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isCellEditable(int, int)">isCellEditable</A> </B>(int&nbsp;row,
               int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code> 에 위치하는 셀이 편집 가능한 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isCellSelected(int, int)">isCellSelected</A> </B>(int&nbsp;row,
               int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 행 및 열의 범위내에 있어, 지정된 위치에 있는 셀이 선택되고 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isColumnSelected(int)">isColumnSelected</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 열의 범위내에 있어, 그 인덱스로 나타나는 열이 선택되고 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isEditing()">isEditing</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셀을 편집중의 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#isRowSelected(int)">isRowSelected</A> </B>(int&nbsp;row)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 인덱스가 유효한 행의 범위내에 있어, 그 인덱스로 나타나는 행이 선택되고 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#moveColumn(int, int)">moveColumn</A> </B>(int&nbsp;column,
           int&nbsp;targetColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>column</code>
 열을, 뷰내의 <code>targetColumn</code>
 열이 현재 차지하는 위치로 이동합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#paramString()">paramString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#prepareEditor(javax.swing.table.TableCellEditor, int, int)">prepareEditor</A> </B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor,
              int&nbsp;row,
              int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code>
 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 에디터를 준비합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#prepareRenderer(javax.swing.table.TableCellRenderer, int, int)">prepareRenderer</A> </B>(<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer,
                int&nbsp;row,
                int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>,<code>column</code>
 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 렌더링을 준비합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print()">print</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 모드 <code>PrintMode.FIT_WIDTH</code> 로 헤더 텍스트 또는 footer 텍스트를 지정하지 않고 인쇄하는 간이 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 지정된 인쇄 모드로 헤더 텍스트 또는 footer 텍스트를 지정하지 않고 인쇄하는 간이 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 지정된 인쇄 모드로 헤더 텍스트 또는 footer 텍스트를 지정해 인쇄하는 간이 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)">print</A> </B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
      <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
      boolean&nbsp;showPrintDialog,
      <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
      boolean&nbsp;interactive)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code>를
 인쇄합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                  <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                  int&nbsp;condition,
                  boolean&nbsp;pressed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>KeyEvent</code> <code>e</code>
 결과로서 <code>ks</code>
 키 바인드를 처리하기 위해서 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeColumn(javax.swing.table.TableColumn)">removeColumn</A> </B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>aColumn</code>를
 이 <code>JTable</code>
 열배열로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeColumnSelectionInterval(int, int)">removeColumnSelectionInterval</A> </B>(int&nbsp;index0,
                              int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeEditor()">removeEditor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;에디터 오브젝트를 파기해, 그 오브젝트가 셀 렌더링에 사용한 장소를 해방합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeNotify()">removeNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>unconfigureEnclosingScrollPane</code> 메서드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#removeRowSelectionInterval(int, int)">removeRowSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#resizeAndRepaint()">resizeAndRepaint</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>revalidate</code>
 후에 <code>repaint</code>를
 호출하는 것과 동등합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#rowAtPoint(java.awt.Point)">rowAtPoint</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>point</code> 가 존재하는 경우는 그 행의 인덱스, 결과가 [0, <code>getRowCount()</code>-1]
 범위내에 없는 경우는 -1을
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#selectAll()">selectAll</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 모든 행, 열 및 셀을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setAutoCreateColumnsFromModel(boolean)">setAutoCreateColumnsFromModel</A> </B>(boolean&nbsp;autoCreateColumnsFromModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 <code>autoCreateColumnsFromModel</code> 플래그를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setAutoResizeMode(int)">setAutoResizeMode</A> </B>(int&nbsp;mode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 사이즈 변경시에 테이블의 자동 사이즈 변경 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setCellEditor(javax.swing.table.TableCellEditor)">setCellEditor</A> </B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;anEditor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>cellEditor</code> 변수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setCellSelectionEnabled(boolean)">setCellSelectionEnabled</A> </B>(boolean&nbsp;cellSelectionEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;열선택과 행 선택의 동시 실행을 이 테이블이 허가할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnModel(javax.swing.table.TableColumnModel)">setColumnModel</A> </B>(<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;columnModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 열모델을 <code>newModel</code> 로 설정해, 새로운 열모델로부터의 리스너 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnSelectionAllowed(boolean)">setColumnSelectionAllowed</A> </B>(boolean&nbsp;columnSelectionAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 모델의 열을 선택할 수 있을지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setColumnSelectionInterval(int, int)">setColumnSelectionInterval</A> </B>(int&nbsp;index0,
                           int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)">setDefaultEditor</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                 <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는
 디폴트의 셀 에디터를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)">setDefaultRenderer</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                   <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는
 디폴트의 셀 렌더링을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setDragEnabled(boolean)">setDragEnabled</A> </B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>dragEnabled</code> 프로퍼티를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setEditingColumn(int)">setEditingColumn</A> </B>(int&nbsp;aColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>editingColumn</code> 변수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setEditingRow(int)">setEditingRow</A> </B>(int&nbsp;aRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>editingRow</code> 변수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setGridColor(java.awt.Color)">setGridColor</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;gridColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;구라두선의 렌더링에 사용하는 색을 <code>gridColor</code> 로 설정해, 재표시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setIntercellSpacing(java.awt.Dimension)">setIntercellSpacing</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;intercellSpacing)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>rowMargin</code> 와 <code>columnMargin</code>, 즉 셀간의 스페이스의 높이와 폭을,<code>intercellSpacing</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setModel(javax.swing.table.TableModel)">setModel</A> </B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dataModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 데이터 모델을 <code>newModel</code> 로 설정해, 거기에 새로운 데이터 모델로부터의 리스너 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setPreferredScrollableViewportSize(java.awt.Dimension)">setPreferredScrollableViewportSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 뷰포트의 바람직한 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowHeight(int)">setRowHeight</A> </B>(int&nbsp;rowHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 셀의 높이를 픽셀로 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowHeight(int, int)">setRowHeight</A> </B>(int&nbsp;row,
             int&nbsp;rowHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>row</code>
 높이를 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowMargin(int)">setRowMargin</A> </B>(int&nbsp;rowMargin)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인접하는 행의 셀의 간격을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowSelectionAllowed(boolean)">setRowSelectionAllowed</A> </B>(boolean&nbsp;rowSelectionAllowed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 모델의 행을 선택할 수 있을지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setRowSelectionInterval(int, int)">setRowSelectionInterval</A> </B>(int&nbsp;index0,
                        int&nbsp;index1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)">setSelectionBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionBackground)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 백그라운드 컬러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)">setSelectionForeground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionForeground)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;선택된 셀의 foreground 컬러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionMode(int)">setSelectionMode</A> </B>(int&nbsp;selectionMode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블의 선택 모드를 설정하면, 단일 항목 선택, 연속 구간의 선택, 또는 연속 구간의 복수 선택을 가능하게 할 수 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSelectionModel(javax.swing.ListSelectionModel)">setSelectionModel</A> </B>(<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;newModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 행 선택 모델을 <code>newModel</code> 로 설정해, 새로운 선택 모델로부터의 리스너 통지를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)">setShowGrid</A> </B>(boolean&nbsp;showGrid)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀의 주위에 구라두선을 렌더링 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)">setShowHorizontalLines</A> </B>(boolean&nbsp;showHorizontalLines)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수평선을 렌더링 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)">setShowVerticalLines</A> </B>(boolean&nbsp;showVerticalLines)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블이 셀간에 수직선을 렌더링 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setSurrendersFocusOnKeystroke(boolean)">setSurrendersFocusOnKeystroke</A> </B>(boolean&nbsp;surrendersFocusOnKeystroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JTable 가 셀의 키보드 이벤트를 전송 한 결과적으로 이 JTable
 에디터가 키보드 포커스를 취득할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setTableHeader(javax.swing.table.JTableHeader)">setTableHeader</A> </B>(<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A> &nbsp;tableHeader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JTable</code>
 <code>tableHeader</code>를
 <code>newHeader</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setUI(javax.swing.plaf.TableUI)">setUI</A> </B>(<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 안의 클래스">TableUI</A> &nbsp;ui)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 렌더링 해 페인트 다시 하는 L&F 오브젝트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#setValueAt(java.lang.Object, int, int)">setValueAt</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;aValue,
           int&nbsp;row,
           int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;테이블 모델내의 <code>row</code>,<code>column</code> 에 위치하는 셀의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#sizeColumnsToFit(boolean)">sizeColumnsToFit</A> </B>(boolean&nbsp;lastColumnOnly)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>Swing 버젼 1.0. 3 이후는
<code>doLayout()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#sizeColumnsToFit(int)">sizeColumnsToFit</A> </B>(int&nbsp;resizingColumn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java 2 플랫폼 v1. 4 에서는 사용하지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#tableChanged(javax.swing.event.TableModelEvent)">tableChanged</A> </B>(<A HREF="../../javax/swing/event/TableModelEvent.html" title="javax.swing.event 안의 클래스">TableModelEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 테이블의 <code>TableModel</code> 이 <code>TableModelEvent</code>를
 생성할 경우에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#unconfigureEnclosingScrollPane()">unconfigureEnclosingScrollPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;포위측의 스크롤 구획의 <code>columnHeaderView</code>를
 <code>null</code> 에 옮겨놓는 것에
해,<code>configureEnclosingScrollPane</code>
 효과를 취소합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#updateUI()">updateUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&F 가 변경되었다고 하는 <code>UIManager</code> 로부터의 통지입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JTable.html#valueChanged(javax.swing.event.ListSelectionEvent)">valueChanged</A> </B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행의 선택 영역이 변경되었을 때에 불려 가 페인트 다시 해 새로운 선택 영역을 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.swing.JComponent"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing. <A HREF="../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)">addAncestorListener</A>,
 <A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)">addVetoableChangeListener</A>,
 <A HREF="../../javax/swing/JComponent.html#computeVisibleRect(java.awt.Rectangle)">computeVisibleRect</A>,
 <A HREF="../../javax/swing/JComponent.html#contains(int, int)">contains</A>,
 <A HREF="../../javax/swing/JComponent.html#createToolTip()">createToolTip</A>,
 <A HREF="../../javax/swing/JComponent.html#disable()">disable</A>,
 <A HREF="../../javax/swing/JComponent.html#enable()">enable</A>,
 <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A>,
 <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A>,
 <A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A>,
 <A HREF="../../javax/swing/JComponent.html#fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)">fireVetoableChange</A>,
 <A HREF="../../javax/swing/JComponent.html#getActionForKeyStroke(javax.swing.KeyStroke)">getActionForKeyStroke</A>,
 <A HREF="../../javax/swing/JComponent.html#getActionMap()">getActionMap</A>,
 <A HREF="../../javax/swing/JComponent.html#getAlignmentX()">getAlignmentX</A>,
 <A HREF="../../javax/swing/JComponent.html#getAlignmentY()">getAlignmentY</A>,
 <A HREF="../../javax/swing/JComponent.html#getAncestorListeners()">getAncestorListeners</A>,
 <A HREF="../../javax/swing/JComponent.html#getAutoscrolls()">getAutoscrolls</A>,
 <A HREF="../../javax/swing/JComponent.html#getBorder()">getBorder</A>,
 <A HREF="../../javax/swing/JComponent.html#getBounds(java.awt.Rectangle)">getBounds</A>,
 <A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)">getClientProperty</A>,
 <A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)">getComponentGraphics</A>,
 <A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()">getComponentPopupMenu</A>,
 <A HREF="../../javax/swing/JComponent.html#getConditionForKeyStroke(javax.swing.KeyStroke)">getConditionForKeyStroke</A>,
 <A HREF="../../javax/swing/JComponent.html#getDebugGraphicsOptions()">getDebugGraphicsOptions</A>,
 <A HREF="../../javax/swing/JComponent.html#getDefaultLocale()">getDefaultLocale</A>,
 <A HREF="../../javax/swing/JComponent.html#getFontMetrics(java.awt.Font)">getFontMetrics</A>,
 <A HREF="../../javax/swing/JComponent.html#getGraphics()">getGraphics</A>,
 <A HREF="../../javax/swing/JComponent.html#getHeight()">getHeight</A>,
 <A HREF="../../javax/swing/JComponent.html#getInheritsPopupMenu()">getInheritsPopupMenu</A>,
 <A HREF="../../javax/swing/JComponent.html#getInputMap()">getInputMap</A>,
 <A HREF="../../javax/swing/JComponent.html#getInputMap(int)">getInputMap</A>,
 <A HREF="../../javax/swing/JComponent.html#getInputVerifier()">getInputVerifier</A>,
 <A HREF="../../javax/swing/JComponent.html#getInsets()">getInsets</A>,
 <A HREF="../../javax/swing/JComponent.html#getInsets(java.awt.Insets)">getInsets</A>,
 <A HREF="../../javax/swing/JComponent.html#getListeners(java.lang.Class)">getListeners</A>,
 <A HREF="../../javax/swing/JComponent.html#getLocation(java.awt.Point)">getLocation</A>,
 <A HREF="../../javax/swing/JComponent.html#getMaximumSize()">getMaximumSize</A>,
 <A HREF="../../javax/swing/JComponent.html#getMinimumSize()">getMinimumSize</A>,
 <A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()">getNextFocusableComponent</A>,
 <A HREF="../../javax/swing/JComponent.html#getPopupLocation(java.awt.event.MouseEvent)">getPopupLocation</A>,
 <A HREF="../../javax/swing/JComponent.html#getPreferredSize()">getPreferredSize</A>,
 <A HREF="../../javax/swing/JComponent.html#getRegisteredKeyStrokes()">getRegisteredKeyStrokes</A>,
 <A HREF="../../javax/swing/JComponent.html#getRootPane()">getRootPane</A>,
 <A HREF="../../javax/swing/JComponent.html#getSize(java.awt.Dimension)">getSize</A>,
 <A HREF="../../javax/swing/JComponent.html#getToolTipLocation(java.awt.event.MouseEvent)">getToolTipLocation</A>,
 <A HREF="../../javax/swing/JComponent.html#getToolTipText()">getToolTipText</A>,
 <A HREF="../../javax/swing/JComponent.html#getTopLevelAncestor()">getTopLevelAncestor</A>,
 <A HREF="../../javax/swing/JComponent.html#getTransferHandler()">getTransferHandler</A>,
 <A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()">getVerifyInputWhenFocusTarget</A>,
 <A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()">getVetoableChangeListeners</A>,
 <A HREF="../../javax/swing/JComponent.html#getVisibleRect()">getVisibleRect</A>,
 <A HREF="../../javax/swing/JComponent.html#getWidth()">getWidth</A>,
 <A HREF="../../javax/swing/JComponent.html#getX()">getX</A>,
 <A HREF="../../javax/swing/JComponent.html#getY()">getY</A>,
 <A HREF="../../javax/swing/JComponent.html#grabFocus()">grabFocus</A>,
 <A HREF="../../javax/swing/JComponent.html#isDoubleBuffered()">isDoubleBuffered</A>,
 <A HREF="../../javax/swing/JComponent.html#isLightweightComponent(java.awt.Component)">isLightweightComponent</A>,
 <A HREF="../../javax/swing/JComponent.html#isManagingFocus()">isManagingFocus</A>,
 <A HREF="../../javax/swing/JComponent.html#isOpaque()">isOpaque</A>,
 <A HREF="../../javax/swing/JComponent.html#isOptimizedDrawingEnabled()">isOptimizedDrawingEnabled</A>,
 <A HREF="../../javax/swing/JComponent.html#isPaintingTile()">isPaintingTile</A>,
 <A HREF="../../javax/swing/JComponent.html#isRequestFocusEnabled()">isRequestFocusEnabled</A>,
 <A HREF="../../javax/swing/JComponent.html#isValidateRoot()">isValidateRoot</A>,
 <A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)">paint</A>,
 <A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)">paintBorder</A>,
 <A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)">paintChildren</A>,
 <A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)">paintComponent</A>,
 <A HREF="../../javax/swing/JComponent.html#paintImmediately(int, int, int, int)">paintImmediately</A>,
 <A HREF="../../javax/swing/JComponent.html#paintImmediately(java.awt.Rectangle)">paintImmediately</A>,
 <A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)">print</A>,
 <A HREF="../../javax/swing/JComponent.html#printAll(java.awt.Graphics)">printAll</A>,
 <A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)">printBorder</A>,
 <A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)">printChildren</A>,
 <A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)">printComponent</A>,
 <A HREF="../../javax/swing/JComponent.html#processComponentKeyEvent(java.awt.event.KeyEvent)">processComponentKeyEvent</A>,
 <A HREF="../../javax/swing/JComponent.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A>,
 <A HREF="../../javax/swing/JComponent.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A>,
 <A HREF="../../javax/swing/JComponent.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A>,
 <A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)">putClientProperty</A>,
 <A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)">registerKeyboardAction</A>,
 <A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)">registerKeyboardAction</A>,
 <A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)">removeAncestorListener</A>,
 <A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)">removeVetoableChangeListener</A>,
 <A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)">repaint</A>,
 <A HREF="../../javax/swing/JComponent.html#repaint(java.awt.Rectangle)">repaint</A>,
 <A HREF="../../javax/swing/JComponent.html#requestDefaultFocus()">requestDefaultFocus</A>,
 <A HREF="../../javax/swing/JComponent.html#requestFocus()">requestFocus</A>,
 <A HREF="../../javax/swing/JComponent.html#requestFocus(boolean)">requestFocus</A>,
 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()">requestFocusInWindow</A>,
 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)">requestFocusInWindow</A>,
 <A HREF="../../javax/swing/JComponent.html#resetKeyboardActions()">resetKeyboardActions</A>,
 <A HREF="../../javax/swing/JComponent.html#reshape(int, int, int, int)">reshape</A>,
 <A HREF="../../javax/swing/JComponent.html#revalidate()">revalidate</A>,
 <A HREF="../../javax/swing/JComponent.html#scrollRectToVisible(java.awt.Rectangle)">scrollRectToVisible</A>,
 <A HREF="../../javax/swing/JComponent.html#setActionMap(javax.swing.ActionMap)">setActionMap</A>,
 <A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)">setAlignmentX</A>,
 <A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)">setAlignmentY</A>,
 <A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)">setAutoscrolls</A>,
 <A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)">setBackground</A>,
 <A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)">setBorder</A>,
 <A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)">setComponentPopupMenu</A>,
 <A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)">setDebugGraphicsOptions</A>,
 <A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)">setDefaultLocale</A>,
 <A HREF="../../javax/swing/JComponent.html#setDoubleBuffered(boolean)">setDoubleBuffered</A>,
 <A HREF="../../javax/swing/JComponent.html#setEnabled(boolean)">setEnabled</A>,
 <A HREF="../../javax/swing/JComponent.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A>,
 <A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)">setFont</A>,
 <A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)">setForeground</A>,
 <A HREF="../../javax/swing/JComponent.html#setInheritsPopupMenu(boolean)">setInheritsPopupMenu</A>,
 <A HREF="../../javax/swing/JComponent.html#setInputMap(int, javax.swing.InputMap)">setInputMap</A>,
 <A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)">setInputVerifier</A>,
 <A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A>,
 <A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A>,
 <A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">setNextFocusableComponent</A>,
 <A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)">setOpaque</A>,
 <A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A>,
 <A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)">setRequestFocusEnabled</A>,
 <A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)">setToolTipText</A>,
 <A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)">setTransferHandler</A>,
 <A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)">setUI</A>,
 <A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)">setVerifyInputWhenFocusTarget</A>,
 <A HREF="../../javax/swing/JComponent.html#setVisible(boolean)">setVisible</A>,
 <A HREF="../../javax/swing/JComponent.html#unregisterKeyboardAction(javax.swing.KeyStroke)">unregisterKeyboardAction</A>,
 <A HREF="../../javax/swing/JComponent.html#update(java.awt.Graphics)">update</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.html#add(java.awt.Component)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, int)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object, int)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.lang.String, java.awt.Component)">add</A>,
 <A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)">addContainerListener</A>,
 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)">addImpl</A>,
 <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A>,
 <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A>,
 <A HREF="../../java/awt/Container.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A>,
 <A HREF="../../java/awt/Container.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A>,
 <A HREF="../../java/awt/Container.html#countComponents()">countComponents</A>,
 <A HREF="../../java/awt/Container.html#deliverEvent(java.awt.Event)">deliverEvent</A>,
 <A HREF="../../java/awt/Container.html#findComponentAt(int, int)">findComponentAt</A>,
 <A HREF="../../java/awt/Container.html#findComponentAt(java.awt.Point)">findComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponent(int)">getComponent</A>,
 <A HREF="../../java/awt/Container.html#getComponentAt(int, int)">getComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponentAt(java.awt.Point)">getComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponentCount()">getComponentCount</A>,
 <A HREF="../../java/awt/Container.html#getComponents()">getComponents</A>,
 <A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)">getComponentZOrder</A>,
 <A HREF="../../java/awt/Container.html#getContainerListeners()">getContainerListeners</A>,
 <A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A>,
 <A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()">getFocusTraversalPolicy</A>,
 <A HREF="../../java/awt/Container.html#getLayout()">getLayout</A>,
 <A HREF="../../java/awt/Container.html#getMousePosition(boolean)">getMousePosition</A>,
 <A HREF="../../java/awt/Container.html#insets()">insets</A>,
 <A HREF="../../java/awt/Container.html#invalidate()">invalidate</A>,
 <A HREF="../../java/awt/Container.html#isAncestorOf(java.awt.Component)">isAncestorOf</A>,
 <A HREF="../../java/awt/Container.html#isFocusCycleRoot()">isFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()">isFocusTraversalPolicyProvider</A>,
 <A HREF="../../java/awt/Container.html#isFocusTraversalPolicySet()">isFocusTraversalPolicySet</A>,
 <A HREF="../../java/awt/Container.html#layout()">layout</A>,
 <A HREF="../../java/awt/Container.html#list(java.io.PrintStream, int)">list</A>,
 <A HREF="../../java/awt/Container.html#list(java.io.PrintWriter, int)">list</A>,
 <A HREF="../../java/awt/Container.html#locate(int, int)">locate</A>,
 <A HREF="../../java/awt/Container.html#minimumSize()">minimumSize</A>,
 <A HREF="../../java/awt/Container.html#paintComponents(java.awt.Graphics)">paintComponents</A>,
 <A HREF="../../java/awt/Container.html#preferredSize()">preferredSize</A>,
 <A HREF="../../java/awt/Container.html#printComponents(java.awt.Graphics)">printComponents</A>,
 <A HREF="../../java/awt/Container.html#processContainerEvent(java.awt.event.ContainerEvent)">processContainerEvent</A>,
 <A HREF="../../java/awt/Container.html#processEvent(java.awt.AWTEvent)">processEvent</A>,
 <A HREF="../../java/awt/Container.html#remove(java.awt.Component)">remove</A>,
 <A HREF="../../java/awt/Container.html#remove(int)">remove</A>,
 <A HREF="../../java/awt/Container.html#removeAll()">removeAll</A>,
 <A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)">removeContainerListener</A>,
 <A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)">setComponentZOrder</A>,
 <A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)">setFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setFocusTraversalPolicy</A>,
 <A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)">setFocusTraversalPolicyProvider</A>,
 <A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)">setLayout</A>,
 <A HREF="../../java/awt/Container.html#transferFocusBackward()">transferFocusBackward</A>,
 <A HREF="../../java/awt/Container.html#transferFocusDownCycle()">transferFocusDownCycle</A>,
 <A HREF="../../java/awt/Container.html#validate()">validate</A>,
 <A HREF="../../java/awt/Container.html#validateTree()">validateTree</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#action(java.awt.Event, java.lang.Object)">action</A>,
 <A HREF="../../java/awt/Component.html#add(java.awt.PopupMenu)">add</A>,
 <A HREF="../../java/awt/Component.html#addComponentListener(java.awt.event.ComponentListener)">addComponentListener</A>,
 <A HREF="../../java/awt/Component.html#addFocusListener(java.awt.event.FocusListener)">addFocusListener</A>,
 <A HREF="../../java/awt/Component.html#addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">addHierarchyBoundsListener</A>,
 <A HREF="../../java/awt/Component.html#addHierarchyListener(java.awt.event.HierarchyListener)">addHierarchyListener</A>,
 <A HREF="../../java/awt/Component.html#addInputMethodListener(java.awt.event.InputMethodListener)">addInputMethodListener</A>,
 <A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)">addKeyListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseListener(java.awt.event.MouseListener)">addMouseListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseMotionListener(java.awt.event.MouseMotionListener)">addMouseMotionListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener</A>,
 <A HREF="../../java/awt/Component.html#bounds()">bounds</A>,
 <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, java.awt.image.ImageObserver)">checkImage</A>,
 <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">checkImage</A>,
 <A HREF="../../java/awt/Component.html#coalesceEvents(java.awt.AWTEvent, java.awt.AWTEvent)">coalesceEvents</A>,
 <A HREF="../../java/awt/Component.html#contains(java.awt.Point)">contains</A>,
 <A HREF="../../java/awt/Component.html#createImage(java.awt.image.ImageProducer)">createImage</A>,
 <A HREF="../../java/awt/Component.html#createImage(int, int)">createImage</A>,
 <A HREF="../../java/awt/Component.html#createVolatileImage(int, int)">createVolatileImage</A>,
 <A HREF="../../java/awt/Component.html#createVolatileImage(int, int, java.awt.ImageCapabilities)">createVolatileImage</A>,
 <A HREF="../../java/awt/Component.html#disableEvents(long)">disableEvents</A>,
 <A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A>,
 <A HREF="../../java/awt/Component.html#enable(boolean)">enable</A>,
 <A HREF="../../java/awt/Component.html#enableEvents(long)">enableEvents</A>,
 <A HREF="../../java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, byte, byte)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, double, double)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, float, float)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, long, long)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, short, short)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#getBackground()">getBackground</A>,
 <A HREF="../../java/awt/Component.html#getBounds()">getBounds</A>,
 <A HREF="../../java/awt/Component.html#getColorModel()">getColorModel</A>,
 <A HREF="../../java/awt/Component.html#getComponentListeners()">getComponentListeners</A>,
 <A HREF="../../java/awt/Component.html#getComponentOrientation()">getComponentOrientation</A>,
 <A HREF="../../java/awt/Component.html#getCursor()">getCursor</A>,
 <A HREF="../../java/awt/Component.html#getDropTarget()">getDropTarget</A>,
 <A HREF="../../java/awt/Component.html#getFocusCycleRootAncestor()">getFocusCycleRootAncestor</A>,
 <A HREF="../../java/awt/Component.html#getFocusListeners()">getFocusListeners</A>,
 <A HREF="../../java/awt/Component.html#getFocusTraversalKeysEnabled()">getFocusTraversalKeysEnabled</A>,
 <A HREF="../../java/awt/Component.html#getFont()">getFont</A>,
 <A HREF="../../java/awt/Component.html#getForeground()">getForeground</A>,
 <A HREF="../../java/awt/Component.html#getGraphicsConfiguration()">getGraphicsConfiguration</A>,
 <A HREF="../../java/awt/Component.html#getHierarchyBoundsListeners()">getHierarchyBoundsListeners</A>,
 <A HREF="../../java/awt/Component.html#getHierarchyListeners()">getHierarchyListeners</A>,
 <A HREF="../../java/awt/Component.html#getIgnoreRepaint()">getIgnoreRepaint</A>,
 <A HREF="../../java/awt/Component.html#getInputContext()">getInputContext</A>,
 <A HREF="../../java/awt/Component.html#getInputMethodListeners()">getInputMethodListeners</A>,
 <A HREF="../../java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A>,
 <A HREF="../../java/awt/Component.html#getKeyListeners()">getKeyListeners</A>,
 <A HREF="../../java/awt/Component.html#getLocale()">getLocale</A>,
 <A HREF="../../java/awt/Component.html#getLocation()">getLocation</A>,
 <A HREF="../../java/awt/Component.html#getLocationOnScreen()">getLocationOnScreen</A>,
 <A HREF="../../java/awt/Component.html#getMouseListeners()">getMouseListeners</A>,
 <A HREF="../../java/awt/Component.html#getMouseMotionListeners()">getMouseMotionListeners</A>,
 <A HREF="../../java/awt/Component.html#getMousePosition()">getMousePosition</A>,
 <A HREF="../../java/awt/Component.html#getMouseWheelListeners()">getMouseWheelListeners</A>,
 <A HREF="../../java/awt/Component.html#getName()">getName</A>,
 <A HREF="../../java/awt/Component.html#getParent()">getParent</A>,
 <A HREF="../../java/awt/Component.html#getPeer()">getPeer</A>,
 <A HREF="../../java/awt/Component.html#getPropertyChangeListeners()">getPropertyChangeListeners</A>,
 <A HREF="../../java/awt/Component.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A>,
 <A HREF="../../java/awt/Component.html#getSize()">getSize</A>,
 <A HREF="../../java/awt/Component.html#getToolkit()">getToolkit</A>,
 <A HREF="../../java/awt/Component.html#getTreeLock()">getTreeLock</A>,
 <A HREF="../../java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">gotFocus</A>,
 <A HREF="../../java/awt/Component.html#handleEvent(java.awt.Event)">handleEvent</A>,
 <A HREF="../../java/awt/Component.html#hasFocus()">hasFocus</A>,
 <A HREF="../../java/awt/Component.html#hide()">hide</A>,
 <A HREF="../../java/awt/Component.html#imageUpdate(java.awt.Image, int, int, int, int, int)">imageUpdate</A>,
 <A HREF="../../java/awt/Component.html#inside(int, int)">inside</A>,
 <A HREF="../../java/awt/Component.html#isBackgroundSet()">isBackgroundSet</A>,
 <A HREF="../../java/awt/Component.html#isCursorSet()">isCursorSet</A>,
 <A HREF="../../java/awt/Component.html#isDisplayable()">isDisplayable</A>,
 <A HREF="../../java/awt/Component.html#isEnabled()">isEnabled</A>,
 <A HREF="../../java/awt/Component.html#isFocusable()">isFocusable</A>,
 <A HREF="../../java/awt/Component.html#isFocusOwner()">isFocusOwner</A>,
 <A HREF="../../java/awt/Component.html#isFocusTraversable()">isFocusTraversable</A>,
 <A HREF="../../java/awt/Component.html#isFontSet()">isFontSet</A>,
 <A HREF="../../java/awt/Component.html#isForegroundSet()">isForegroundSet</A>,
 <A HREF="../../java/awt/Component.html#isLightweight()">isLightweight</A>,
 <A HREF="../../java/awt/Component.html#isMaximumSizeSet()">isMaximumSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isMinimumSizeSet()">isMinimumSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isPreferredSizeSet()">isPreferredSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isShowing()">isShowing</A>,
 <A HREF="../../java/awt/Component.html#isValid()">isValid</A>,
 <A HREF="../../java/awt/Component.html#isVisible()">isVisible</A>,
 <A HREF="../../java/awt/Component.html#keyDown(java.awt.Event, int)">keyDown</A>,
 <A HREF="../../java/awt/Component.html#keyUp(java.awt.Event, int)">keyUp</A>,
 <A HREF="../../java/awt/Component.html#list()">list</A>,
 <A HREF="../../java/awt/Component.html#list(java.io.PrintStream)">list</A>,
 <A HREF="../../java/awt/Component.html#list(java.io.PrintWriter)">list</A>,
 <A HREF="../../java/awt/Component.html#location()">location</A>,
 <A HREF="../../java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">lostFocus</A>,
 <A HREF="../../java/awt/Component.html#mouseDown(java.awt.Event, int, int)">mouseDown</A>,
 <A HREF="../../java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">mouseDrag</A>,
 <A HREF="../../java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">mouseEnter</A>,
 <A HREF="../../java/awt/Component.html#mouseExit(java.awt.Event, int, int)">mouseExit</A>,
 <A HREF="../../java/awt/Component.html#mouseMove(java.awt.Event, int, int)">mouseMove</A>,
 <A HREF="../../java/awt/Component.html#mouseUp(java.awt.Event, int, int)">mouseUp</A>,
 <A HREF="../../java/awt/Component.html#move(int, int)">move</A>,
 <A HREF="../../java/awt/Component.html#nextFocus()">nextFocus</A>,
 <A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)">paintAll</A>,
 <A HREF="../../java/awt/Component.html#postEvent(java.awt.Event)">postEvent</A>,
 <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, java.awt.image.ImageObserver)">prepareImage</A>,
 <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">prepareImage</A>,
 <A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)">processComponentEvent</A>,
 <A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)">processFocusEvent</A>,
 <A HREF="../../java/awt/Component.html#processHierarchyBoundsEvent(java.awt.event.HierarchyEvent)">processHierarchyBoundsEvent</A>,
 <A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)">processHierarchyEvent</A>,
 <A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)">processInputMethodEvent</A>,
 <A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)">processMouseWheelEvent</A>,
 <A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)">remove</A>,
 <A HREF="../../java/awt/Component.html#removeComponentListener(java.awt.event.ComponentListener)">removeComponentListener</A>,
 <A HREF="../../java/awt/Component.html#removeFocusListener(java.awt.event.FocusListener)">removeFocusListener</A>,
 <A HREF="../../java/awt/Component.html#removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">removeHierarchyBoundsListener</A>,
 <A HREF="../../java/awt/Component.html#removeHierarchyListener(java.awt.event.HierarchyListener)">removeHierarchyListener</A>,
 <A HREF="../../java/awt/Component.html#removeInputMethodListener(java.awt.event.InputMethodListener)">removeInputMethodListener</A>,
 <A HREF="../../java/awt/Component.html#removeKeyListener(java.awt.event.KeyListener)">removeKeyListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseListener(java.awt.event.MouseListener)">removeMouseListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseMotionListener(java.awt.event.MouseMotionListener)">removeMouseMotionListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener</A>,
 <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A>,
 <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A>,
 <A HREF="../../java/awt/Component.html#repaint()">repaint</A>,
 <A HREF="../../java/awt/Component.html#repaint(int, int, int, int)">repaint</A>,
 <A HREF="../../java/awt/Component.html#repaint(long)">repaint</A>,
 <A HREF="../../java/awt/Component.html#resize(java.awt.Dimension)">resize</A>,
 <A HREF="../../java/awt/Component.html#resize(int, int)">resize</A>,
 <A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)">setBounds</A>,
 <A HREF="../../java/awt/Component.html#setBounds(java.awt.Rectangle)">setBounds</A>,
 <A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)">setComponentOrientation</A>,
 <A HREF="../../java/awt/Component.html#setCursor(java.awt.Cursor)">setCursor</A>,
 <A HREF="../../java/awt/Component.html#setDropTarget(java.awt.dnd.DropTarget)">setDropTarget</A>,
 <A HREF="../../java/awt/Component.html#setFocusable(boolean)">setFocusable</A>,
 <A HREF="../../java/awt/Component.html#setFocusTraversalKeysEnabled(boolean)">setFocusTraversalKeysEnabled</A>,
 <A HREF="../../java/awt/Component.html#setIgnoreRepaint(boolean)">setIgnoreRepaint</A>,
 <A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)">setLocale</A>,
 <A HREF="../../java/awt/Component.html#setLocation(int, int)">setLocation</A>,
 <A HREF="../../java/awt/Component.html#setLocation(java.awt.Point)">setLocation</A>,
 <A HREF="../../java/awt/Component.html#setName(java.lang.String)">setName</A>,
 <A HREF="../../java/awt/Component.html#setSize(java.awt.Dimension)">setSize</A>,
 <A HREF="../../java/awt/Component.html#setSize(int, int)">setSize</A>,
 <A HREF="../../java/awt/Component.html#show()">show</A>,
 <A HREF="../../java/awt/Component.html#show(boolean)">show</A>,
 <A HREF="../../java/awt/Component.html#size()">size</A>,
 <A HREF="../../java/awt/Component.html#toString()">toString</A>,
 <A HREF="../../java/awt/Component.html#transferFocus()">transferFocus</A>,
 <A HREF="../../java/awt/Component.html#transferFocusUpCycle()">transferFocusUpCycle</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AUTO_RESIZE_OFF"><!-- --></A> <H3>
AUTO_RESIZE_OFF</H3>
<PRE>
public static final int <B>AUTO_RESIZE_OFF</B></PRE>
<DL>
<DD>렬폭의 조정은 자동적으로 실시하지 않고,
 스크롤 바를 사용합니다.  </dl>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_OFF">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_NEXT_COLUMN"><!-- --></A> <H3>
AUTO_RESIZE_NEXT_COLUMN</H3>
<PRE>
public static final int <B>AUTO_RESIZE_NEXT_COLUMN</B></PRE>
<DL>
<DD>열을 UI 로 조정할 때는
 다음의 열을 역방향으로 조정합니다.  </dl>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_NEXT_COLUMN">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_SUBSEQUENT_COLUMNS"><!-- --></A> <H3>
AUTO_RESIZE_SUBSEQUENT_COLUMNS</H3>
<PRE>
public static final int <B>AUTO_RESIZE_SUBSEQUENT_COLUMNS</B></PRE>
<DL>
<DD>UI를
 조정할 때는
 그 이후의 열을 변경해 열의 합계폭을 유지합니다. 이것은 디폴트의 동작입니다.  </dl>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_LAST_COLUMN"><!-- --></A> <H3>
AUTO_RESIZE_LAST_COLUMN</H3>
<PRE>
public static final int <B>AUTO_RESIZE_LAST_COLUMN</B></PRE>
<DL>
<DD>모든 사이즈 변경 조작으로 최종열인 만큼 조정을 적용합니다.  </dl>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_LAST_COLUMN">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="AUTO_RESIZE_ALL_COLUMNS"><!-- --></A> <H3>
AUTO_RESIZE_ALL_COLUMNS</H3>
<PRE>
public static final int <B>AUTO_RESIZE_ALL_COLUMNS</B></PRE>
<DL>
<DD>모든 사이즈 변경 조작으로 각 열을 균등하게 사이즈 변경합니다.  </dl>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="dataModel"><!-- --></A> <H3>
dataModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>dataModel</B></PRE>
<DL>
<DD>테이블의 <code>TableModel</code> 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="columnModel"><!-- --></A> <H3>
columnModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>columnModel</B></PRE>
<DL>
<DD>테이블의 <code>TableColumnModel</code> 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionModel"><!-- --></A> <H3>
selectionModel</H3>
<PRE>
protected <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>selectionModel</B></PRE>
<DL>
<DD>행 선택의 추적에 사용하는
 테이블의 <code>ListSelectionModel</code> 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="tableHeader"><!-- --></A> <H3>
tableHeader</H3>
<PRE>
protected <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>tableHeader</B></PRE>
<DL>
<DD>테이블의 <code>TableHeader</code> 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowHeight"><!-- --></A> <H3>
rowHeight</H3>
<PRE>
protected int <B>rowHeight</B></PRE>
<DL>
<DD>테이블의 각 행의 높이를 픽셀로 나타낸 것입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowMargin"><!-- --></A> <H3>
rowMargin</H3>
<PRE>
protected int <B>rowMargin</B></PRE>
<DL>
<DD>각 행의 셀간의 마진의 높이를 픽셀로 나타낸 것입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="gridColor"><!-- --></A> <H3>
gridColor</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>gridColor</B></PRE>
<DL>
<DD>구라두의 색입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="showHorizontalLines"><!-- --></A> <H3>
showHorizontalLines</H3>
<PRE>
protected boolean <B>showHorizontalLines</B></PRE>
<DL>
<DD><code>showHorizontalLines</code> 가 true
 경우, 테이블은 셀간에 수평선을 렌더링 합니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="showVerticalLines"><!-- --></A> <H3>
showVerticalLines</H3>
<PRE>
protected boolean <B>showVerticalLines</B></PRE>
<DL>
<DD><code>showVerticalLines</code> 가 true
 경우, 테이블은 셀간에 수직선을 렌더링 합니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoResizeMode"><!-- --></A> <H3>
autoResizeMode</H3>
<PRE>
protected int <B>autoResizeMode</B></PRE>
<DL>
<DD>테이블이 폭의 사이즈를 자동 변경해 각 열로 테이블폭전체를 차지하도록 할지 어떨지를 지정해, 그 사이즈 변경의 방법을 지정합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="autoCreateColumnsFromModel"><!-- --></A> <H3>
autoCreateColumnsFromModel</H3>
<PRE>
protected boolean <B>autoCreateColumnsFromModel</B></PRE>
<DL>
<DD>true
 경우, 열의 디폴트 세트를 구축하도록 <code>TableModel</code> 에 조회합니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="preferredViewportSize"><!-- --></A> <H3>
preferredViewportSize</H3>
<PRE>
protected <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>preferredViewportSize</B></PRE>
<DL>
<DD><code>Scrollable</code> 인터페이스에
해 사용되어 가시 영역의 초기설정을 실시합니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="rowSelectionAllowed"><!-- --></A> <H3>
rowSelectionAllowed</H3>
<PRE>
protected boolean <B>rowSelectionAllowed</B></PRE>
<DL>
<DD>이 테이블로 행 선택이 허가되고 있는 경우는 true 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cellSelectionEnabled"><!-- --></A> <H3>
cellSelectionEnabled</H3>
<PRE>
protected boolean <B>cellSelectionEnabled</B></PRE>
<DL>
<DD>Java 2 플랫폼 v1. 3 에서는 사용하지 않습니다. 대신에 <code>columnModel</code>
 <code>rowSelectionAllowed</code> 프로퍼티 및 <code>columnSelectionAllowed</code> 프로퍼티를 사용해 주세요. 혹은 <code>getCellSelectionEnabled</code> 메서드를 사용해 주세요.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editorComp"><!-- --></A> <H3>
editorComp</H3>
<PRE>
protected transient <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>editorComp</B></PRE>
<DL>
<DD>편집시이면, 편집을 처리하고 있는 <code>Component</code> 입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="cellEditor"><!-- --></A> <H3>
cellEditor</H3>
<PRE>
protected transient <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>cellEditor</B></PRE>
<DL>
<DD>현재의 셀이 차지하는 화면상의 장소를 덧쓰기해, 유저가 그 내용을 변경할 수 있도록 하는 오브젝트입니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editingColumn"><!-- --></A> <H3>
editingColumn</H3>
<PRE>
protected transient int <B>editingColumn</B></PRE>
<DL>
<DD>편집중의 셀의 열을 식별합니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="editingRow"><!-- --></A> <H3>
editingRow</H3>
<PRE>
protected transient int <B>editingRow</B></PRE>
<DL>
<DD>편집중의 셀의 행을 식별합니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultRenderersByColumnClass"><!-- --></A> <H3>
defaultRenderersByColumnClass</H3>
<PRE>
protected transient <A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A>  <B>defaultRenderersByColumnClass</B></PRE>
<DL>
<DD>셀의 내용을 표시하는 오브젝트의 테이블입니다. <code>TableModel</code> 인터페이스의 <code>getColumnClass</code> 로 선언된 클래스에
한 인덱스가 붙어 있습니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="defaultEditorsByColumnClass"><!-- --></A> <H3>
defaultEditorsByColumnClass</H3>
<PRE>
protected transient <A HREF="../../java/util/Hashtable.html" title="java.util 내의 클래스">Hashtable</A>  <B>defaultEditorsByColumnClass</B></PRE>
<DL>
<DD>셀의 내용을 표시 및 편집하는 오브젝트의 테이블입니다. <code>TableModel</code> 인터페이스의 <code>getColumnClass</code> 로 선언된 클래스에
한 인덱스가 붙어 있습니다.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionForeground"><!-- --></A> <H3>
selectionForeground</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>selectionForeground</B></PRE>
<DL>
<DD>선택된 셀의 foreground 컬러입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="selectionBackground"><!-- --></A> <H3>
selectionBackground</H3>
<PRE>
protected <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>selectionBackground</B></PRE>
<DL>
<DD>선택된 셀의 백그라운드 컬러입니다.  </dl>
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JTable()"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>()</PRE>
<DL>
<DD>디폴트 데이터 모델, 디폴트열모델 및 디폴트 선택 모델로 초기화되는
 디폴트의 <code>JTable</code>를
 구축합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()"><CODE>createDefaultDataModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 디폴트열모델 및 디폴트 선택 모델로 초기화되는 <code>JTable</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
              <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 열모델 <code>cm</code> 및 디폴트 선택 모델로 초기화되는 <code>JTable</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DD><CODE>cm</CODE> - 테이블의 열모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(javax.swing.table.TableModel, javax.swing.table.TableColumnModel, javax.swing.ListSelectionModel)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dm,
              <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;cm,
              <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;sm)</PRE>
<DL>
<DD>데이터 모델 <code>dm</code>, 열모델 <code>cm</code> 및 선택 모델 <code>sm</code> 로 초기화되는 <code>JTable</code>를
 구축합니다. 파라미터의 어떤 것인가가 <code>null</code>
 경우, 이 메서드는 대응하는 디폴트 모델로 테이블을 초기화합니다. <code>autoCreateColumnsFromModel</code> 플래그는 <code>cm</code> 가 null 이외의 경우는 false 에
 그렇지 않은 경우는 true 로 설정되어 열모델에게는 <code>dm</code> 내의 열에 적절한 <code>TableColumns</code> 가 들어갑니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>dm</CODE> - 테이블의 데이터 모델<DD><CODE>cm</CODE> - 테이블의 열모델<DD><CODE>sm</CODE> - 테이블의 행 선택 모델<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#createDefaultDataModel()"><CODE>createDefaultDataModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnModel()"><CODE>createDefaultColumnModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultSelectionModel()"><CODE>createDefaultSelectionModel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(int, int)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(int&nbsp;numRows,
              int&nbsp;numColumns)</PRE>
<DL>
<DD><code>DefaultTableModel</code>를
 사용해, 하늘의 셀의 <code>numRows</code> 와 <code>numColumns</code> 로 <code>JTable</code>를
 구축합니다. 열은, 「A」, 「B」, 「C」라고 한 형식의 이름을 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>numRows</CODE> - 테이블이 보관 유지하는 행수<DD><CODE>numColumns</CODE> - 테이블이 보관 유지하는 렬수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableModel</CODE></A> </DL>
</DL>
<HR>

<A NAME="JTable(java.util.Vector, java.util.Vector)"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;rowData,
              <A HREF="../../java/util/Vector.html" title="java.util 안의 클래스">Vector</A> &nbsp;columnNames)</PRE>
<DL>
<DD><code>Vectors</code>
 <code>Vector</code>
 값을 표시하는 <code>JTable</code>, 즉 <code>rowData</code>를
, 렬명 <code>columnNames</code> 로 구축합니다. <code>rowData</code> 에 포함된 <code>Vectors</code>는

 그 행의 값을 보관 유지할 필요가 있습니다. 즉, 행 1, 열 5 에 위치하는 셀의 값은 다음의 코드로 취득할 수 있습니다.
 <p>


 <pre>
((Vector) rowData.elementAt(1)). elementAt(5);</pre>

 <p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>rowData</CODE> - 새로운 테이블의 데이터<DD><CODE>columnNames</CODE> - 각 열의 이름</DL>
</DL>
<HR>

<A NAME="JTable(java.lang.Object[][], java.lang.Object[])"><!-- --></A> <H3>
JTable</H3>
<PRE>
public <B>JTable</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> [][]&nbsp;rowData,
              <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;columnNames)</PRE>
<DL>
<DD>2 차원 배열 <code>rowData</code>
 값을 표시하는 <code>JTable</code>를
, 렬명 <code>columnNames</code> 으로 구축합니다. <code>rowData</code> 하행의 배열이므로 행 1, 열 5 에 위치하는 셀의 값은 다음의 코드로 취득할 수 있습니다.
 <p>


 <pre>
 rowData[1][5];
 </pre>


 <p>
모든 행은,<code>columnNames</code> 와 같은 길이가 될 필요가 있습니다.
 <p>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>rowData</CODE> - 새로운 테이블의 데이터<DD><CODE>columnNames</CODE> - 각 열의 이름</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addNotify()"><!-- --></A> <H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD><code>configureEnclosingScrollPane</code> 메서드를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#addNotify()">addNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()"><CODE>configureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="configureEnclosingScrollPane()"><!-- --></A> <H3>
configureEnclosingScrollPane</H3>
<PRE>
protected void <B>configureEnclosingScrollPane</B>()</PRE>
<DL>
<DD>일반적으로 이 <code>JTable</code> 가 둘러싸 옆 <code>JScrollPane</code>
 <code>viewportView</code> 입니다만, 그 경우, 특히 테이블의 <code>tableHeader</code>을
 스크롤 구획의 <code>columnHeaderView</code> 로서 인스톨 하는 것에
해, 이 <code>ScrollPane</code>
 설정을 실시합니다. <code>new JScrollPane(myTable)</code>을
 사용해 보통
의 방법으로 <code>JTable</code>를
 <code>JScrollPane</code> 에 추가하면, 테이블이 뷰포트에 추가될 때 <code>addNotify</code> 가 <code>JTable</code> 로 불려 갑니다. 다음에 <code>JTable</code>
 <code>addNotify</code> 메서드가 이 메서드를 호출합니다. 이 메서드는
 디폴트의 인스톨 프로시저를 서브 클래스를 오버라이드(override) 할 수 있도록 보호되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#addNotify()"><CODE>addNotify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A> <H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD><code>unconfigureEnclosingScrollPane</code> 메서드를 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#removeNotify()">removeNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#unconfigureEnclosingScrollPane()"><CODE>unconfigureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unconfigureEnclosingScrollPane()"><!-- --></A> <H3>
unconfigureEnclosingScrollPane</H3>
<PRE>
protected void <B>unconfigureEnclosingScrollPane</B>()</PRE>
<DL>
<DD>포위측의 스크롤 구획의 <code>columnHeaderView</code>를
 <code>null</code> 에 옮겨놓는 것에
해,<code>configureEnclosingScrollPane</code>
 효과를 취소합니다. <code>JTable</code>
 <code>removeNotify</code> 메서드가 이 메서드를 호출합니다. 이 메서드는
 이 디폴트의 인스톨 해제 프로시저를 서브 클래스를 오버라이드(override) 할 수 있도록 보호되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#removeNotify()"><CODE>removeNotify()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#configureEnclosingScrollPane()"><CODE>configureEnclosingScrollPane()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createScrollPaneForTable(javax.swing.JTable)"><!-- --></A> <H3>
createScrollPaneForTable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 내의 클래스">JScrollPane</A>  <B>createScrollPaneForTable</B>(<A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A> &nbsp;aTable)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>Swing 버젼 1.0. 2 로 <code>new JScrollPane(aTable)</code> 로 옮겨졌습니다. </I>
<P>
<DD><code>new JScrollPane(aTable)</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTableHeader(javax.swing.table.JTableHeader)"><!-- --></A> <H3>
setTableHeader</H3>
<PRE>
public void <B>setTableHeader</B>(<A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A> &nbsp;tableHeader)</PRE>
<DL>
<DD>이 <code>JTable</code>
 <code>tableHeader</code>를
 <code>newHeader</code> 로 설정합니다. <code>null</code>
 <code>tableHeader</code>는
 유효합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tableHeader</CODE> - 새로운 tableHeader<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getTableHeader()"><CODE>getTableHeader()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTableHeader()"><!-- --></A> <H3>
getTableHeader</H3>
<PRE>
public <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>getTableHeader</B>()</PRE>
<DL>
<DD>이 <code>JTable</code> 가 사용하는 <code>tableHeader</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블이 사용하는 <code>tableHeader</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setTableHeader(javax.swing.table.JTableHeader)"><CODE>setTableHeader(javax.swing.table.JTableHeader)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowHeight(int)"><!-- --></A> <H3>
setRowHeight</H3>
<PRE>
public void <B>setRowHeight</B>(int&nbsp;rowHeight)</PRE>
<DL>
<DD>모든 셀의 높이를 픽셀로 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. 이 셀의 높이는
 행의 높이로부터 행 마진을 깎은 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowHeight</CODE> - 새로운 행의 높이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>rowHeight</code> 가 1 미만의 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowHeight()"><CODE>getRowHeight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowHeight()"><!-- --></A> <H3>
getRowHeight</H3>
<PRE>
public int <B>getRowHeight</B>()</PRE>
<DL>
<DD>테이블행의 높이를 픽셀로 돌려줍니다. 디폴트의 행의 높이는 16.0 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>픽셀 단위의 테이블행의 높이<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowHeight(int)"><CODE>setRowHeight(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowHeight(int, int)"><!-- --></A> <H3>
setRowHeight</H3>
<PRE>
public void <B>setRowHeight</B>(int&nbsp;row,
                         int&nbsp;rowHeight)</PRE>
<DL>
<DD><code>row</code>
 높이를 <code>rowHeight</code> 로 설정해, 재확인해, 페인트 다시 합니다. 이 행의 셀의 높이는
 행의 높이로부터 행 마진을 깎은 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 높이가 변경되는 행<DD><CODE>rowHeight</CODE> - 픽셀 단위에서의 새로운 행의 높이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>rowHeight</code> 가 1 미만의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getRowHeight(int)"><!-- --></A> <H3>
getRowHeight</H3>
<PRE>
public int <B>getRowHeight</B>(int&nbsp;row)</PRE>
<DL>
<DD><code>row</code>
 셀의 높이를 픽셀 단위로 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 높이가 돌려주고지는 행
<DT><B>반환값:</B><DD>픽셀 단위에서의 행의 셀의 높이</DL>
</DD>
</DL>
<HR>

<A NAME="setRowMargin(int)"><!-- --></A> <H3>
setRowMargin</H3>
<PRE>
public void <B>setRowMargin</B>(int&nbsp;rowMargin)</PRE>
<DL>
<DD>인접하는 행의 셀의 간격을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowMargin</CODE> - 행의 셀간의 픽셀수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowMargin()"><CODE>getRowMargin()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowMargin()"><!-- --></A> <H3>
getRowMargin</H3>
<PRE>
public int <B>getRowMargin</B>()</PRE>
<DL>
<DD>셀의 간격을 픽셀 단위로 돌려줍니다. <code>getIntercellSpacing(). height</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 셀간의 픽셀수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowMargin(int)"><CODE>setRowMargin(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setIntercellSpacing(java.awt.Dimension)"><!-- --></A> <H3>
setIntercellSpacing</H3>
<PRE>
public void <B>setIntercellSpacing</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;intercellSpacing)</PRE>
<DL>
<DD><code>rowMargin</code> 와 <code>columnMargin</code>, 즉 셀간의 스페이스의 높이와 폭을,<code>intercellSpacing</code> 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>intercellSpacing</CODE> - 셀간의 새로운 폭과 높이를 지정하는 <code>Dimension</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getIntercellSpacing()"><CODE>getIntercellSpacing()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getIntercellSpacing()"><!-- --></A> <H3>
getIntercellSpacing</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getIntercellSpacing</B>()</PRE>
<DL>
<DD>셀간의 수평 간격과 수직 간격을 돌려줍니다. 디폴트 간격은, 구라두를 렌더링 하는 스페이스를 제공하는 (1, 1)입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>셀간의 수평 간격과 수직 간격<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setIntercellSpacing(java.awt.Dimension)"><CODE>setIntercellSpacing(java.awt.Dimension)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setGridColor(java.awt.Color)"><!-- --></A> <H3>
setGridColor</H3>
<PRE>
public void <B>setGridColor</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;gridColor)</PRE>
<DL>
<DD>구라두선의 렌더링에 사용하는 색을 <code>gridColor</code> 로 설정해, 재표시합니다. 디폴트의 색은 Look & Feel 에
존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>gridColor</CODE> - 구라두선의 새로운 색
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>gridColor</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getGridColor()"><CODE>getGridColor()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getGridColor()"><!-- --></A> <H3>
getGridColor</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getGridColor</B>()</PRE>
<DL>
<DD>구라두선의 렌더링에 사용하는 색을 돌려줍니다. 디폴트의 색은 Look & Feel 에
존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>구라두선의 렌더링에 사용하는 색<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setGridColor(java.awt.Color)"><CODE>setGridColor(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowGrid(boolean)"><!-- --></A> <H3>
setShowGrid</H3>
<PRE>
public void <B>setShowGrid</B>(boolean&nbsp;showGrid)</PRE>
<DL>
<DD>테이블이 셀의 주위에 구라두선을 렌더링 할지 어떨지를 설정합니다. <code>showGrid</code> 가 true
 경우는 렌더링 해, false
 경우는 렌더링 하지 않습니다. 이 상태는 각각이 따로 따로 조회되는 <code>showHorizontalLines</code> 와 <code>showVerticalLines</code> 라고 하는 2 개의 변수로 보관 유지되므로<code>getShowGrid</code> 메서드는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showGrid</CODE> - 테이브르뷰가 구라두선을 렌더링 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowHorizontalLines(boolean)"><!-- --></A> <H3>
setShowHorizontalLines</H3>
<PRE>
public void <B>setShowHorizontalLines</B>(boolean&nbsp;showHorizontalLines)</PRE>
<DL>
<DD>테이블이 셀간에 수평선을 렌더링 할지 어떨지를 설정합니다. <code>showHorizontalLines</code> 가 true
 경우는 렌더링 해, false
 경우는 렌더링 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showHorizontalLines</CODE> - 테이브르뷰가 수평선을 렌더링 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getShowHorizontalLines()"><CODE>getShowHorizontalLines()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)"><CODE>setShowGrid(boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowVerticalLines(boolean)"><!-- --></A> <H3>
setShowVerticalLines</H3>
<PRE>
public void <B>setShowVerticalLines</B>(boolean&nbsp;showVerticalLines)</PRE>
<DL>
<DD>테이블이 셀간에 수직선을 렌더링 할지 어떨지를 설정합니다. <code>showVerticalLines</code> 가 true
 경우는 렌더링 해, false
 경우는 렌더링 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>showVerticalLines</CODE> - 테이브르뷰가 수직선을 렌더링 하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getShowVerticalLines()"><CODE>getShowVerticalLines()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setShowGrid(boolean)"><CODE>setShowGrid(boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowHorizontalLines()"><!-- --></A> <H3>
getShowHorizontalLines</H3>
<PRE>
public boolean <B>getShowHorizontalLines</B>()</PRE>
<DL>
<DD>테이블이 셀간에 수평선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false를
 돌려줍니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀간에 수평선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowHorizontalLines(boolean)"><CODE>setShowHorizontalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowVerticalLines()"><!-- --></A> <H3>
getShowVerticalLines</H3>
<PRE>
public boolean <B>getShowVerticalLines</B>()</PRE>
<DL>
<DD>테이블이 셀간에 수직선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false를
 돌려줍니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀간에 수직선을 렌더링 하는 경우는 true, 렌더링 하지 않는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setShowVerticalLines(boolean)"><CODE>setShowVerticalLines(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoResizeMode(int)"><!-- --></A> <H3>
setAutoResizeMode</H3>
<PRE>
public void <B>setAutoResizeMode</B>(int&nbsp;mode)</PRE>
<DL>
<DD>테이블의 사이즈 변경시에 테이블의 자동 사이즈 변경 모드를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>mode</CODE> - 다음의 5 개의 유효치의 어떤 것인가. AUTO_RESIZE_OFF, AUTO_RESIZE_NEXT_COLUMN, AUTO_RESIZE_SUBSEQUENT_COLUMNS, AUTO_RESIZE_LAST_COLUMN, AUTO_RESIZE_ALL_COLUMNS<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoResizeMode()"><CODE>getAutoResizeMode()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoResizeMode()"><!-- --></A> <H3>
getAutoResizeMode</H3>
<PRE>
public int <B>getAutoResizeMode</B>()</PRE>
<DL>
<DD>테이블의 자동 사이즈 변경 모드를 돌려줍니다. 디폴트 모드는 AUTO_RESIZE_SUBSEQUENT_COLUMNS 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 autoResizeMode<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setAutoResizeMode(int)"><CODE>setAutoResizeMode(int)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoCreateColumnsFromModel(boolean)"><!-- --></A> <H3>
setAutoCreateColumnsFromModel</H3>
<PRE>
public void <B>setAutoCreateColumnsFromModel</B>(boolean&nbsp;autoCreateColumnsFromModel)</PRE>
<DL>
<DD>이 테이블의 <code>autoCreateColumnsFromModel</code> 플래그를 설정합니다. 이 메서드는
<code>autoCreateColumnsFromModel</code> 가 false 로부터 true 로 변경되었을 경우에 <code>createDefaultColumnsFromModel</code>를
 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>autoCreateColumnsFromModel</CODE> - <code>JTable</code> 가 열을 자동 작성하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()"><CODE>getAutoCreateColumnsFromModel()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()"><CODE>createDefaultColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoCreateColumnsFromModel()"><!-- --></A> <H3>
getAutoCreateColumnsFromModel</H3>
<PRE>
public boolean <B>getAutoCreateColumnsFromModel</B>()</PRE>
<DL>
<DD>테이블이 디폴트의 열을 모델로부터 작성할지 어떨지를 지정합니다. true
 경우,<code>setModel</code>는
 기존의 열을 클리어 해, 새로운 모델로부터 새로운 열을 작성합니다. 또,<code>tableChanged</code> 통지의 이벤트가, 테이블 전체가 변경된 것을 나타내고 있는 경우는
 열이 재구축 됩니다. 디폴트는 true 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 autoCreateColumnsFromModel<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setAutoCreateColumnsFromModel(boolean)"><CODE>setAutoCreateColumnsFromModel(boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#createDefaultColumnsFromModel()"><CODE>createDefaultColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultColumnsFromModel()"><!-- --></A> <H3>
createDefaultColumnsFromModel</H3>
<PRE>
public void <B>createDefaultColumnsFromModel</B>()</PRE>
<DL>
<DD>이 메서드는 <code>TableModel</code> 인터페이스로 정의된 <code>getColumnCount</code> 메서드를 사용해, 데이터 모델로부터 테이블의 디폴트의 열을 작성합니다.
 <p>
모델로부터의 정보에 근거해 새로운 열을 작성하기 전에
 기존의 열이 있으면 그것을 클리어 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getAutoCreateColumnsFromModel()"><CODE>getAutoCreateColumnsFromModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><!-- --></A> <H3>
setDefaultRenderer</H3>
<PRE>
public void <B>setDefaultRenderer</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                               <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer)</PRE>
<DL>
<DD><code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는
 디폴트의 셀 렌더링을 설정합니다. 렌더링이 <code>null</code>
 경우는
 이 열클래스의 디폴트의 렌더링을 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 에 디폴트의 셀 렌더링을 설정<DD><CODE>renderer</CODE> - 이 columnClass 에 사용하는 디폴트의 셀 렌더링<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getDefaultRenderer(java.lang.Class)"><CODE>getDefaultRenderer(java.lang.Class<? >)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><CODE>setDefaultEditor(java.lang.Class<? >, javax.swing.table.TableCellEditor)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultRenderer(java.lang.Class)"><!-- --></A> <H3>
getDefaultRenderer</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A>  <B>getDefaultRenderer</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</PRE>
<DL>
<DD><code>TableColumn</code> 에 렌더링이 설정되어 있지 않은 경우에 사용하는
 셀 렌더링을 돌려줍니다. 셀의 렌더링시에는
 렌더링은 렬내의 셀의 클래스에 근거해 엔트리의 <code>Hashtable</code> 로부터 취득됩니다. 이 <code>columnClass</code> 에 엔트리가 없는 경우, 이 메서드는 가장 명확한 슈퍼 클래스의 엔트리를 돌려줍니다. <code>JTable</code>는

 그 모든 것을 변경 또는 치환할 수 있는 <code>Object</code>,<code>Number</code> 및 <code>Boolean</code>
 엔트리를 인스톨 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass
 디폴트의 셀 렌더링을 돌려준다
<DT><B>반환값:</B><DD>이 columnClass
 렌더링<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getColumnClass(int)"><CODE>getColumnClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><!-- --></A> <H3>
setDefaultEditor</H3>
<PRE>
public void <B>setDefaultEditor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass,
                             <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor)</PRE>
<DL>
<DD><code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는
 디폴트의 셀 에디터를 설정합니다. 테이블 또는 테이블내의 특정의 열로 편집이 필요없는 경우는
<code>TableModel</code> 인터페이스의 <code>isCellEditable</code> 메서드를 사용해, 이 <code>JTable</code> 가 이러한 열로 에디터를 시작할리가 없게 합니다. 에디터가 <code>null</code>
 경우는
 이 열클래스로부터 디폴트의 에디터를 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass 에 디폴트의 셀 에디터를 설정하는<DD><CODE>editor</CODE> - 이 columnClass 에 사용하는 디폴트의 셀 에디터<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/TableModel.html#isCellEditable(int, int)"><CODE>TableModel.isCellEditable(int, int)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getDefaultEditor(java.lang.Class)"><CODE>getDefaultEditor(java.lang.Class<? >)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultEditor(java.lang.Class)"><!-- --></A> <H3>
getDefaultEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getDefaultEditor</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;columnClass)</PRE>
<DL>
<DD><code>TableColumn</code> 에 에디터가 설정되어 있지 않은 경우에 사용하는 에디터를 돌려줍니다. 셀의 편집시에는
 에디터는 렬내의 셀의 클래스에 근거해 엔트리의 <code>Hashtable</code> 로부터 취득됩니다. 이 <code>columnClass</code> 에 엔트리가 없는 경우, 이 메서드는 가장 명확한 슈퍼 클래스의 엔트리를 돌려줍니다. <code>JTable</code>는

 그 모든 것을 변경 또는 치환할 수 있는 <code>Object</code>,<code>Number</code> 및 <code>Boolean</code>
 엔트리를 인스톨 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnClass</CODE> - 이 columnClass
 디폴트의 셀 에디터를 돌려준다
<DT><B>반환값:</B><DD>이 columnClass 에 사용하는 디폴트의 셀 에디터<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDefaultEditor(java.lang.Class, javax.swing.table.TableCellEditor)"><CODE>setDefaultEditor(java.lang.Class<? >, javax.swing.table.TableCellEditor)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getColumnClass(int)"><CODE>getColumnClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDragEnabled(boolean)"><!-- --></A> <H3>
setDragEnabled</H3>
<PRE>
public void <B>setDragEnabled</B>(boolean&nbsp;b)</PRE>
<DL>
<DD><code>dragEnabled</code> 프로퍼티를 설정합니다. 이 프로퍼티는
 이 컴퍼넌트의 자동 드래그
 처리 (드래그＆드롭의 최초의 처리)를 유효하게 하기 위해서 <code>true</code> 가 되어 있을 필요가 있습니다. <code>transferHandler</code> 프로퍼티는
 드래그
로 뭐든지 할 수 있도록 <code>null</code> 이외의 값으로 설정할 필요가 있습니다. <code>dragEnabled</code> 프로퍼티의 디폴트의 값은 <code>false</code> 입니다.

 <p>

자동 드래그
 처리가 유효의 경우, 대부분의 Look & Feel는

 유저가 선택을 위해서 mouse button를 눌러, 마우스를 수픽셀 이동하면 항상 드래그＆드롭 조작이 시작됩니다. 따라서, 이 프로퍼티를 <code>true</code> 로 설정하는 것으로써, 선택의 동작에 미묘한 효과가 있습니다.

 <p>

일부의 Look & Feel는
 자동 드래그＆드롭 조작을 서포트하지 않는 경우가 있습니다. 이것들은 이 프로퍼티를 무시합니다. 직접 <code>TransferHandler</code>
 <code>exportAsDrag</code> 메서드를 호출해 컴퍼넌트를 변경하는 것으로써, 이러한 Look & Feel를
 조작할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>b</CODE> - <code>dragEnabled</code> 프로퍼티로 설정되는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </CODE> - <code>b</code> 가 <code>true</code>
 경우로 <code>GraphicsEnvironment.isHeadless()</code> 가 <code>true</code>를
 돌려주는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/GraphicsEnvironment.html#isHeadless()"><CODE>GraphicsEnvironment.isHeadless()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getDragEnabled()"><CODE>getDragEnabled()</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)"><CODE>JComponent.setTransferHandler(javax.swing.TransferHandler)</CODE></A>,
 
<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스"><CODE>TransferHandler</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDragEnabled()"><!-- --></A> <H3>
getDragEnabled</H3>
<PRE>
public boolean <B>getDragEnabled</B>()</PRE>
<DL>
<DD><code>dragEnabled</code> 프로퍼티의 값을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>dragEnabled</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setDragEnabled(boolean)"><CODE>setDragEnabled(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionMode(int)"><!-- --></A> <H3>
setSelectionMode</H3>
<PRE>
public void <B>setSelectionMode</B>(int&nbsp;selectionMode)</PRE>
<DL>
<DD>테이블의 선택 모드를 설정하면, 단일 항목 선택, 연속 구간의 선택, 또는 연속 구간의 복수 선택을 가능하게 할 수 있습니다.
<P>
 <bold>주:</bold> <code>JTable</code>는

 열과 행의 선택을 처리하는 모든 메서드를 제공합니다. <code>setSelectionMode</code> 등의 상태를 설정할 때,<code>JTable</code> 하행 선택 모델의 모드를 갱신할 뿐만 아니라,<code>columnModel</code>
 선택 모델로 같은 값을 설정합니다. 행 및 열의 선택 모델을 다른 모드로 기능시키려면,
 그것들을 양쪽 모두 직접 설정합니다.
 <p>
<code>JTable</code>
 행 선택 모델과 열선택 모델은 어느 쪽과도 디폴트로 <code>DefaultListSelectionModel</code>를
 사용하므로<code>JTable</code>는
 <code>JList</code> 와 같이 동작합니다. 모드의 자세한 것은,<code>JList</code>
 <code>setSelectionMode</code>를
 참조하십시오.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JList.html#setSelectionMode(int)"><CODE>JList.setSelectionMode(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRowSelectionAllowed(boolean)"><!-- --></A> <H3>
setRowSelectionAllowed</H3>
<PRE>
public void <B>setRowSelectionAllowed</B>(boolean&nbsp;rowSelectionAllowed)</PRE>
<DL>
<DD>이 모델의 행을 선택할 수 있을지 어떨지를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowSelectionAllowed</CODE> - 이 모델이 행 선택을 허가하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowSelectionAllowed()"><CODE>getRowSelectionAllowed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowSelectionAllowed()"><!-- --></A> <H3>
getRowSelectionAllowed</H3>
<PRE>
public boolean <B>getRowSelectionAllowed</B>()</PRE>
<DL>
<DD>행을 선택할 수 있는 경우에 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행을 선택 가능한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setRowSelectionAllowed(boolean)"><CODE>setRowSelectionAllowed(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColumnSelectionAllowed(boolean)"><!-- --></A> <H3>
setColumnSelectionAllowed</H3>
<PRE>
public void <B>setColumnSelectionAllowed</B>(boolean&nbsp;columnSelectionAllowed)</PRE>
<DL>
<DD>이 모델의 열을 선택할 수 있을지 어떨지를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnSelectionAllowed</CODE> - 이 모델이 열선택을 허가하는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnSelectionAllowed()"><CODE>getColumnSelectionAllowed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnSelectionAllowed()"><!-- --></A> <H3>
getColumnSelectionAllowed</H3>
<PRE>
public boolean <B>getColumnSelectionAllowed</B>()</PRE>
<DL>
<DD>열을 선택할 수 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>열을 선택 가능한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setColumnSelectionAllowed(boolean)"><CODE>setColumnSelectionAllowed(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setCellSelectionEnabled(boolean)"><!-- --></A> <H3>
setCellSelectionEnabled</H3>
<PRE>
public void <B>setCellSelectionEnabled</B>(boolean&nbsp;cellSelectionEnabled)</PRE>
<DL>
<DD>열선택과 행 선택의 동시 실행을 이 테이블이 허가할지 어떨지를 설정합니다. 설정되면, 테이블은 행 선택 모델과 열선택 모델의 교차하는 부분을, 선택된 셀로서 처리합니다. 이 디폴트의 동작을 변경하려면,
<code>isCellSelected</code>를
 오버라이드(override) 합니다. 이 메서드는
<code>columnModel</code>
 <code>rowSelectionAllowed</code> 프로퍼티 및 <code>columnSelectionAllowed</code> 프로퍼티가 지정된 값으로 설정하는 것과 같은 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cellSelectionEnabled</CODE> - 행과 열의 동시 선택을 허가하는 경우에 true를
 돌려줍니다. <DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getCellSelectionEnabled()"><CODE>getCellSelectionEnabled()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#isCellSelected(int, int)"><CODE>isCellSelected(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellSelectionEnabled()"><!-- --></A> <H3>
getCellSelectionEnabled</H3>
<PRE>
public boolean <B>getCellSelectionEnabled</B>()</PRE>
<DL>
<DD>행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true를
 돌려줍니다. <code>getRowSelectionAllowed() && getColumnSelectionAllowed()</code> 와 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 선택 모델과 열선택 모델의 양쪽 모두가 가능한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setCellSelectionEnabled(boolean)"><CODE>setCellSelectionEnabled(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="selectAll()"><!-- --></A> <H3>
selectAll</H3>
<PRE>
public void <B>selectAll</B>()</PRE>
<DL>
<DD>테이블의 모든 행, 열 및 셀을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clearSelection()"><!-- --></A> <H3>
clearSelection</H3>
<PRE>
public void <B>clearSelection</B>()</PRE>
<DL>
<DD>선택 떠날 수 있어 모든 열 및 행을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setRowSelectionInterval(int, int)"><!-- --></A> <H3>
setRowSelectionInterval</H3>
<PRE>
public void <B>setRowSelectionInterval</B>(int&nbsp;index0,
                                    int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="setColumnSelectionInterval(int, int)"><!-- --></A> <H3>
setColumnSelectionInterval</H3>
<PRE>
public void <B>setColumnSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addRowSelectionInterval(int, int)"><!-- --></A> <H3>
addRowSelectionInterval</H3>
<PRE>
public void <B>addRowSelectionInterval</B>(int&nbsp;index0,
                                    int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addColumnSelectionInterval(int, int)"><!-- --></A> <H3>
addColumnSelectionInterval</H3>
<PRE>
public void <B>addColumnSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 현재의 선택 영역에 추가합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeRowSelectionInterval(int, int)"><!-- --></A> <H3>
removeRowSelectionInterval</H3>
<PRE>
public void <B>removeRowSelectionInterval</B>(int&nbsp;index0,
                                       int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 행 (상하한치를 포함한다)을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getRowCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeColumnSelectionInterval(int, int)"><!-- --></A> <H3>
removeColumnSelectionInterval</H3>
<PRE>
public void <B>removeColumnSelectionInterval</B>(int&nbsp;index0,
                                          int&nbsp;index1)</PRE>
<DL>
<DD><code>index0</code> 로부터 <code>index1</code> 까지의 열 (상하한치를 포함한다)을 선택 해제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index0</CODE> - 구간의 한편의 구석의 값<DD><CODE>index1</CODE> - 구간의 한편의 구석의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>index0</code> 또는 <code>index1</code> 가 [0, <code>getColumnCount()</code>-1]
 범위외의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRow()"><!-- --></A> <H3>
getSelectedRow</H3>
<PRE>
public int <B>getSelectedRow</B>()</PRE>
<DL>
<DD>최초로 선택된 행의 인덱스를 돌려주는지, 행이 선택되어 있지 않은 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초로 선택된 행의 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumn()"><!-- --></A> <H3>
getSelectedColumn</H3>
<PRE>
public int <B>getSelectedColumn</B>()</PRE>
<DL>
<DD>최초로 선택된 열의 인덱스를 돌려주는지, 열이 선택되어 있지 않은 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초로 선택된 열의 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRows()"><!-- --></A> <H3>
getSelectedRows</H3>
<PRE>
public int[] <B>getSelectedRows</B>()</PRE>
<DL>
<DD>선택된 모든 행의 인덱스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 모든 행의 인덱스를 포함하는 정수의 배열. 선택되고 있는 행이 없는 경우는 하늘의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectedRow()"><CODE>getSelectedRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumns()"><!-- --></A> <H3>
getSelectedColumns</H3>
<PRE>
public int[] <B>getSelectedColumns</B>()</PRE>
<DL>
<DD>선택된 모든 열의 인덱스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 모든 열의 인덱스를 포함하는 정수의 배열. 선택되고 있는 열이 없는 경우는 하늘의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectedColumn()"><CODE>getSelectedColumn()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedRowCount()"><!-- --></A> <H3>
getSelectedRowCount</H3>
<PRE>
public int <B>getSelectedRowCount</B>()</PRE>
<DL>
<DD>선택된 행수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 행의 수. 선택되고 있는 행이 없는 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectedColumnCount()"><!-- --></A> <H3>
getSelectedColumnCount</H3>
<PRE>
public int <B>getSelectedColumnCount</B>()</PRE>
<DL>
<DD>선택되고 있는 열의 수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 열의 수. 선택되고 있는 열이 없는 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="isRowSelected(int)"><!-- --></A> <H3>
isRowSelected</H3>
<PRE>
public boolean <B>isRowSelected</B>(int&nbsp;row)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 행의 범위내에 있어, 그 인덱스로 나타나는 행이 선택되고 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>row</code> 가 유효한 인덱스이며, 그 인덱스로 나타나는 행이 선택되고 있는 경우는 true (0 은 최초의 행)</DL>
</DD>
</DL>
<HR>

<A NAME="isColumnSelected(int)"><!-- --></A> <H3>
isColumnSelected</H3>
<PRE>
public boolean <B>isColumnSelected</B>(int&nbsp;column)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 열의 범위내에 있어, 그 인덱스로 나타나는 열이 선택되고 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 열모델의 열
<DT><B>반환값:</B><DD><code>column</code> 가 유효한 인덱스이며, 그 인덱스에 있는 열이 선택되고 있는 경우는 true (0 은 최초의 열)</DL>
</DD>
</DL>
<HR>

<A NAME="isCellSelected(int, int)"><!-- --></A> <H3>
isCellSelected</H3>
<PRE>
public boolean <B>isCellSelected</B>(int&nbsp;row,
                              int&nbsp;column)</PRE>
<DL>
<DD>지정된 인덱스가 유효한 행 및 열의 범위내에 있어, 지정된 위치에 있는 셀이 선택되고 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 조회되는 행<DD><CODE>column</CODE> - 조회되는 열
<DT><B>반환값:</B><DD><code>row</code> 및 <code>column</code> 가 유효한 인덱스이며, 인덱스 <code>(row, column)</code> 로 나타나는 셀이 선택되고 있는 경우는 true. 최초의 행과 최초의 열은 인덱스 0 에 있다</DL>
</DD>
</DL>
<HR>

<A NAME="changeSelection(int, int, boolean, boolean)"><!-- --></A> <H3>
changeSelection</H3>
<PRE>
public void <B>changeSelection</B>(int&nbsp;rowIndex,
                            int&nbsp;columnIndex,
                            boolean&nbsp;toggle,
                            boolean&nbsp;extend)</PRE>
<DL>
<DD><code>toggle</code> 와 <code>extend</code>
 2 개의 플래그 상태에
해, 테이블의 선택 모델을 갱신합니다. UI 가 받은 키보드 이벤트 또는 마우스 이벤트에
해 행해진 선택 범위의 변경은 이 메서드에
해 처리되어 서브 클래스가 동작을 오버라이드(override) 할 수 있게 됩니다. UI 에는
 불연속인 선택 범위의 선두를 조작하는 경우 등, 이 메서드가 제공하는 것보다도 고도의 기능을 필요로 하는 것도 있어, 일부의 선택 범위의 변경에서는 그러한 UI 가 이 메서드에 불러 들여지지 않은 것이 있습니다.
 <p>
구현은 다음의 규칙을 사용합니다. <ul> <li> <code>toggle</code>: <em>false</em>,<code>extend</code>: <em>false</em>. 기존의 선택을 클리어 해, 새로운 셀이 확실히 선택되도록 한다<li> <code>toggle</code>: <em>false</em>,<code>extend</code>: <em>true</em>. 기존의 선택을 엥커로부터 지정의 셀까지 확장해, 다른 모든 선택을 클리어 한다<li> <code>toggle</code>: <em>true</em>,<code>extend</code>: <em>false</em>. 지정된 셀이 선택되고 있는 경우, 그 셀을 선택 해제한다. 선택되어 있지 않은 경우, 그 셀을 선택한다<li> <code>toggle</code>: <em>true</em>,<code>extend</code>: <em>true</em>. 기존의 선택 상태를 그대로 하지만, 엥커 인덱스가 지정된 위치에 이동시킨다 
</ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rowIndex</CODE> - <code>row</code>
 선택에 영향을 주는<DD><CODE>columnIndex</CODE> - <code>column</code>
 선택에 영향을 주는<DD><CODE>toggle</CODE> - 상기 참조<DD><CODE>extend</CODE> - true
 경우, 현재의 선택을 확장한다</DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionForeground()"><!-- --></A> <H3>
getSelectionForeground</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getSelectionForeground</B>()</PRE>
<DL>
<DD>선택되고 있는 셀의 foreground 컬러를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>foreground 프로퍼티의 <code>Color</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionForeground(java.awt.Color)"><!-- --></A> <H3>
setSelectionForeground</H3>
<PRE>
public void <B>setSelectionForeground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionForeground)</PRE>
<DL>
<DD>선택된 셀의 foreground 컬러를 설정합니다. 셀 렌더링은 이 색을 사용해, 선택된 셀의 텍스트와 그래픽스를 렌더링 합니다.
 <p>
이 프로퍼티의 디폴트치는
 Look & Feel
 구현에
해 정의됩니다.
 <p>
이것은 <a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">JavaBeans</a>  바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>selectionForeground</CODE> - 선택된 리스트 항목의 foreground로 사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionForeground()"><CODE>getSelectionForeground()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)"><CODE>JComponent.setForeground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)"><CODE>JComponent.setBackground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)"><CODE>JComponent.setFont(java.awt.Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionBackground()"><!-- --></A> <H3>
getSelectionBackground</H3>
<PRE>
public <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getSelectionBackground</B>()</PRE>
<DL>
<DD>선택된 셀의 백그라운드 컬러를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>선택된 리스트 항목의 백그라운드에서 사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionBackground(java.awt.Color)"><CODE>setSelectionBackground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionBackground(java.awt.Color)"><!-- --></A> <H3>
setSelectionBackground</H3>
<PRE>
public void <B>setSelectionBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;selectionBackground)</PRE>
<DL>
<DD>선택된 셀의 백그라운드 컬러를 설정합니다. 셀 렌더링은 이 색을 사용해, 선택된 셀을 전부 칠할 수가 있습니다.
 <p>
이 프로퍼티의 디폴트치는
 Look & Feel
 구현에
해 정의됩니다.
 <p>
이것은 <a href="http://java.sun.com/docs/books/tutorial/javabeans/whatis/beanDefinition.html">JavaBeans</a>  바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>selectionBackground</CODE> - 선택된 셀의 백그라운드에서 사용하는 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionBackground()"><CODE>getSelectionBackground()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setSelectionForeground(java.awt.Color)"><CODE>setSelectionForeground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)"><CODE>JComponent.setForeground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)"><CODE>JComponent.setBackground(java.awt.Color)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)"><CODE>JComponent.setFont(java.awt.Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumn(java.lang.Object)"><!-- --></A> <H3>
getColumn</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 내의 클래스">TableColumn</A>  <B>getColumn</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;identifier)</PRE>
<DL>
<DD><code>equals</code>를
 사용해 비교해, 식별자가 <code>identifier</code> 에 동일한 테이블내의 열의 <code>TableColumn</code> 오브젝트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>identifier</CODE> - 식별자 오브젝트
<DT><B>반환값:</B><DD>식별자가 일치하는 <code>TableColumn</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>identifier</code> 이 <code>null</code>
 경우, 또는 이 식별자를 가지는 <code>TableColumn</code> 가 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="convertColumnIndexToModel(int)"><!-- --></A> <H3>
convertColumnIndexToModel</H3>
<PRE>
public int <B>convertColumnIndexToModel</B>(int&nbsp;viewColumnIndex)</PRE>
<DL>
<DD><code>viewColumnIndex</code>
 뷰내의 열의 인덱스를, 테이블 모델내의 열의 인덱스에 매핑 합니다. 모델내의 대응하는 열의 인덱스를 돌려줍니다. <code>viewColumnIndex</code> 가 제로보다 작은 경우는
<code>viewColumnIndex</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>viewColumnIndex</CODE> - 뷰내의 열의 인덱스
<DT><B>반환값:</B><DD>모델내의 대응하는 열의 인덱스<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)"><CODE>convertColumnIndexToView(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="convertColumnIndexToView(int)"><!-- --></A> <H3>
convertColumnIndexToView</H3>
<PRE>
public int <B>convertColumnIndexToView</B>(int&nbsp;modelColumnIndex)</PRE>
<DL>
<DD><code>modelColumnIndex</code>
 테이블 모델내의 열의 인덱스를, 뷰내의 열의 인덱스에 매핑 합니다. 뷰내의 대응하는 열의 인덱스를 돌려줍니다. 이 열이 표시되어 있지 않은 경우는 -1을
 돌려줍니다. <code>modelColumnIndex</code> 가 제로보다 작은 경우는
<code>modelColumnIndex</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>modelColumnIndex</CODE> - 모델내의 열의 인덱스
<DT><B>반환값:</B><DD>뷰내의 대응하는 열의 인덱스<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#convertColumnIndexToModel(int)"><CODE>convertColumnIndexToModel(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowCount()"><!-- --></A> <H3>
getRowCount</H3>
<PRE>
public int <B>getRowCount</B>()</PRE>
<DL>
<DD>이 테이블의 모델내의 행수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블의 모델내의 행수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnCount()"><CODE>getColumnCount()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnCount()"><!-- --></A> <H3>
getColumnCount</H3>
<PRE>
public int <B>getColumnCount</B>()</PRE>
<DL>
<DD>열모델내의 렬수를 돌려줍니다. 다만, 이것은 테이블 모델내의 렬수와는 다른 경우가 있을테니 주의해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블내의 렬수<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getRowCount()"><CODE>getRowCount()</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#removeColumn(javax.swing.table.TableColumn)"><CODE>removeColumn(javax.swing.table.TableColumn)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnName(int)"><!-- --></A> <H3>
getColumnName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getColumnName</B>(int&nbsp;column)</PRE>
<DL>
<DD>열위치 <code>column</code>
 뷰에 표시되는 열의 이름을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 조회되는 뷰의 열
<DT><B>반환값:</B><DD>뷰내의 <code>column</code> 위치의 렬명. 최초의 열은 column 0</DL>
</DD>
</DL>
<HR>

<A NAME="getColumnClass(int)"><!-- --></A> <H3>
getColumnClass</H3>
<PRE>
public <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>getColumnClass</B>(int&nbsp;column)</PRE>
<DL>
<DD>열위치 <code>column</code>
 뷰에 표시되는 열의 형태를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 조회되는 뷰의 열
<DT><B>반환값:</B><DD>뷰내의 <code>column</code> 위치의 열의 형태. 최초의 열은 column 0</DL>
</DD>
</DL>
<HR>

<A NAME="getValueAt(int, int)"><!-- --></A> <H3>
getValueAt</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getValueAt</B>(int&nbsp;row,
                         int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀치를 돌려줍니다.
 <p>
<b>주:</b> 렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code>
 렬순에서는 지정되지 않습니다. 유저가 테이블내의 열을 다시 배열하면 뷰내의 지정된 인덱스의 열이 변경되기 때문에
 이것은 중요한 상위가 됩니다. 한편, 유저의 액션은 모델의 열순서부에 영향을 미치지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 치가 조회되는 행<DD><CODE>column</CODE> - 치가 조회되는 열
<DT><B>반환값:</B><DD>지정된 셀의 Object</DL>
</DD>
</DL>
<HR>

<A NAME="setValueAt(java.lang.Object, int, int)"><!-- --></A> <H3>
setValueAt</H3>
<PRE>
public void <B>setValueAt</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;aValue,
                       int&nbsp;row,
                       int&nbsp;column)</PRE>
<DL>
<DD>테이블 모델내의 <code>row</code>,<code>column</code> 에 위치하는 셀의 값을 설정합니다.
 <p>
<b>주:</b> 렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code>
 렬순에서는 지정되지 않습니다. 유저가 테이블내의 열을 다시 배열하면 뷰내의 지정된 인덱스의 열이 변경되기 때문에
 이것은 중요한 상위가 됩니다. 한편, 유저의 액션은 모델의 열순서부에 영향을 미치지 않습니다.
<code>aValue</code>는
 새로운 값입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aValue</CODE> - 새로운 값<DD><CODE>row</CODE> - 변경되는 셀의 행<DD><CODE>column</CODE> - 변경되는 셀의 열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getValueAt(int, int)"><CODE>getValueAt(int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isCellEditable(int, int)"><!-- --></A> <H3>
isCellEditable</H3>
<PRE>
public boolean <B>isCellEditable</B>(int&nbsp;row,
                              int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀이 편집 가능한 경우에 true를
 돌려줍니다. 그렇지 않은 경우는
 셀의 <code>setValueAt</code>를
 호출해도 영향을 주지 않습니다.
 <p>
<b>주:</b> 렬은 테이브르뷰의 표시순서로 지정되어<code>TableModel</code>
 렬순에서는 지정되지 않습니다. 유저가 테이블내의 열을 다시 배열하면 뷰내의 지정된 인덱스의 열이 변경되기 때문에
 이것은 중요한 상위가 됩니다. 한편, 유저의 액션은 모델의 열순서부에 영향을 미치지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 치가 조회되는 행<DD><CODE>column</CODE> - 치가 조회되는 열
<DT><B>반환값:</B><DD>셀이 편집 가능한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setValueAt(java.lang.Object, int, int)"><CODE>setValueAt(java.lang.Object, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addColumn(javax.swing.table.TableColumn)"><!-- --></A> <H3>
addColumn</H3>
<PRE>
public void <B>addColumn</B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</PRE>
<DL>
<DD>이 <code>JTable</code>
 열모델이 보관 유지하는 열의 배열의 말미에 <code>aColumn</code>를
 추가합니다. <code>aColumn</code>
 렬명이 <code>null</code>
 경우,<code>aColumn</code>
 렬명을 <code>getModel(). getColumnName()</code> 가 돌려주는 이름으로 설정합니다. <p> 이 <code>JTable</code> 에 열을 추가해, 지정된 <code>width</code>,<code>cellRenderer</code> 및 <code>cellEditor</code>을
 사용해 모델내의 <code>modelColumn</code> 번째의 열의 데이터를 표시하는 경우는
 이하를 사용할 수 있습니다.  
 <pre>

addColumn(new TableColumn(modelColumn, width, cellRenderer, cellEditor));
</pre> <code>TableColumn</code> 생성자를 어떤 것에서도 대신에 사용할 수 있습니다. 모델열번호는 <code>TableColumn</code> 내부에 포함되어 모델내의 적절한 데이터치를 찾아내기 위해서 렌더링시와 편집시에 사용됩니다. 모델열번호는
 열을 뷰내로 나란해질 수 있는 바꿀 때도 변경되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 추가되는 <code>TableColumn</code> @see    #removeColumn</DL>
</DD>
</DL>
<HR>

<A NAME="removeColumn(javax.swing.table.TableColumn)"><!-- --></A> <H3>
removeColumn</H3>
<PRE>
public void <B>removeColumn</B>(<A HREF="../../javax/swing/table/TableColumn.html" title="javax.swing.table 안의 클래스">TableColumn</A> &nbsp;aColumn)</PRE>
<DL>
<DD><code>aColumn</code>를
 이 <code>JTable</code>
 열배열로부터 삭제합니다. 주: 이 메서드는
 모델로부터 열의 데이터를 삭제할 것은 없습니다. 열의 데이터의 표시를 행하고 있던 <code>TableColumn</code> 만을 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 삭제되는 <code>TableColumn</code> @see    #addColumn</DL>
</DD>
</DL>
<HR>

<A NAME="moveColumn(int, int)"><!-- --></A> <H3>
moveColumn</H3>
<PRE>
public void <B>moveColumn</B>(int&nbsp;column,
                       int&nbsp;targetColumn)</PRE>
<DL>
<DD><code>column</code>
 열을, 뷰내의 <code>targetColumn</code>
 열이 현재 차지하는 위치로 이동합니다. <code>targetColumn</code>
 종래의 열은 빈 곳을 만들기 위해서 왼쪽 또는 오른쪽으로 쉬프트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 이동하는 열의 인덱스<DD><CODE>targetColumn</CODE> - 열의 새로운 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="columnAtPoint(java.awt.Point)"><!-- --></A> <H3>
columnAtPoint</H3>
<PRE>
public int <B>columnAtPoint</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</PRE>
<DL>
<DD><code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1]
 범위내에 없는 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>point</CODE> - 대상의 위치
<DT><B>반환값:</B><DD><code>point</code> 가 존재하는 경우는 그 열의 인덱스, 결과가 [0, <code>getColumnCount()</code>-1]
 범위내에 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#rowAtPoint(java.awt.Point)"><CODE>rowAtPoint(java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="rowAtPoint(java.awt.Point)"><!-- --></A> <H3>
rowAtPoint</H3>
<PRE>
public int <B>rowAtPoint</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;point)</PRE>
<DL>
<DD><code>point</code> 가 존재하는 경우는 그 행의 인덱스, 결과가 [0, <code>getRowCount()</code>-1]
 범위내에 없는 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>point</CODE> - 대상의 위치
<DT><B>반환값:</B><DD><code>point</code> 가 존재하는 경우는 그 행의 인덱스, 결과가 [0, <code>getRowCount()</code>-1]
 범위내에 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#columnAtPoint(java.awt.Point)"><CODE>columnAtPoint(java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellRect(int, int, boolean)"><!-- --></A> <H3>
getCellRect</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getCellRect</B>(int&nbsp;row,
                             int&nbsp;column,
                             boolean&nbsp;includeSpacing)</PRE>
<DL>
<DD><code>row</code> 와 <code>column</code> 가 교차하는 위치의 셀의 구형을 돌려줍니다. <code>includeSpacing</code> 가 true
 경우, 돌려주고지는 값은 지정된 행과 열의 전높이로 전폭을 포함합니다. false
 경우, 돌려주고지는 구형은 셀의 간격에
해 인 세트 되어 렌더링때 설정되는 렌더링 컴퍼넌트 또는 편집 컴퍼넌트의 진정한 경계가 돌려주고집니다.
 <p>
열인덱스가 유효해 행 인덱스가 제로보다 작은 경우, 메서드는
<code>y</code> 치와 <code>height</code> 치가 적절히 설정되어<code>x</code> 치와 <code>width</code> 치가 함께 제로로 설정된 구형을 돌려줍니다. 일반적으로 행과 열의 어느 쪽인가의 인덱스가 적절한 범위외의 셀을 나타내는 경우, 메서드는 테이블의 범위내에서 가장 가까운 셀의 가장 가까운 인연을 그리는 구형을 돌려줍니다. 행과 열의 인덱스가 어느쪽이나 범위외의 경우, 돌려주고지는 구형은 가장 가까운 셀의 가장 가까운 점을 나타내고 있습니다.
 <p>
어느 케이스에서도, 이 메서드를 사용해 1 개의 축으로 맞추어 결과를 요구하는 계산은, 한편의 축에서는 변칙적인 계산을 실시하므로 실패할 것은 없습니다. 셀이 유효하지 않은 경우,<code>includeSpacing</code> 파라미터는 무시됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 목적의 셀이 놓여져 있는 행 인덱스<DD><CODE>column</CODE> - 화면내에서 목적의 셀이 놓여져 있는 열인덱스. 이 값은, 테이블의 데이터 모델내의 열인덱스와 같다라고는 한정되지 않는다. 데이터 모델의 열인덱스를 화면의 열인덱스로 변환하는 경우는
<A HREF="../../javax/swing/JTable.html#convertColumnIndexToView(int)"><CODE>convertColumnIndexToView(int)</CODE></A>  메서드를 사용할 수 있는<DD><CODE>includeSpacing</CODE> - false
 경우, 진정한 셀의 경계를 돌려준다. 이 경계는
 열모델과 행 모델의 높이와 폭으로부터 셀의 간격을 당기는 것에
해 계산된다
<DT><B>반환값:</B><DD><code>row</code>,<code>column</code>
 위치의 셀을 보관 유지하는 구형</DL>
</DD>
</DL>
<HR>

<A NAME="doLayout()"><!-- --></A> <H3>
doLayout</H3>
<PRE>
public void <B>doLayout</B>()</PRE>
<DL>
<DD>이 테이블에 행과 열을 레이아웃 시킵니다. 포함하는 부모의 사이즈의 변경에 맞추어 열을 사이즈 변경할 수 있도록, 오버라이드(override) 됩니다. 테이블내의 1 개 또는 복수의 열의 사이즈를 변경해, 이 <code>JTable</code>
 모든 열의 전폭이 테이블의 폭과 동일해지도록 합니다.
 <p>
배치가 개시되기 전에
 메서드는 <code>tableHeader</code>
 <code>resizingColumn</code>를
 취득합니다. 포위측 윈도우의 사이즈 변경의 결과로서, 메서드가 불려 가는 경우는
<code>resizingColumn</code>는
 <code>null</code> 가 됩니다. 이것은, 사이즈 변경이 <code>JTable</code>
 「외측」에서 일어난 것 및 변경 (델타)이 이 <code>JTable</code>
 자동 사이즈 변경 모드에 관계없이 모든 열에 반영되는 것을
미합니다.
 <p>
<code>resizingColumn</code> 가 <code>null</code> 가 아닌 경우는
 테이블 사이즈의 변경은 아니고, 테이블내가 있는 열의 사이즈가 변경된 것을 나타냅니다. 이 경우, 자동 사이즈 변경 모드에
해, 여분의, 또는 부족한 스페이스가 이용 가능한 모든 열로 배분될 방법이 결정됩니다.
 <p>
다음에
 각 모드를 나타냅니다. <ul> <li>  AUTO_RESIZE_OFF - 열의 폭을 자동조정 하지 않는다. 열의 합계가 <code>Viewport</code>
 폭을 넘는 경우는
 수평 스크롤 바를 사용해 그러한 열에 대응한다. <code>JTable</code> 가 <code>JScrollPane</code> 에 둘러싸이지 않은 경우, 테이블의 일부를 불가시대로 하는 일이 있다<li>  AUTO_RESIZE_NEXT_COLUMN - 사이즈가 변경된 열의 직후의 열을 사용한다. 이 경우, 인접하는 셀의 사이의 「경계」즉 디바이더를 단독으로 조정할 수 있다<li>  AUTO_RESIZE_SUBSEQUENT_COLUMNS - 조정중의 열의 뒤의 모든 열을 사용해, 변경을 흡수한다. 이것은 디폴트의 동작<li>  AUTO_RESIZE_LAST_COLUMN - 마지막 열의 사이즈만을 자동조정 한다. 최종열의 경계를 위해서 바람직한 사이즈의 할당을 할 수 없는 경우는
 최종열의 폭을 적절한 한도로 설정해 그 이상의 조정은 실시하지 않는다<li>  AUTO_RESIZE_ALL_COLUMNS - 조정중의 열을 포함한 <code>JTable</code> 내의 모든 열에 델타를 분산시킨다 
</ul>

 <p>
<bold>주:</bold> <code>JTable</code> 가 렬폭을 조정할 때는
 최소치와 최대치를 무조건 고려에 넣습니다. 이 때문에
 이 메서드를 호출한 후에도, 모든 열의 합계폭이 테이블폭에 동일하지 않은 경우가 있습니다. 이 경우,<code>JTable</code>는
 그것 자신으로 AUTO_RESIZE_OFF 모드에 들어가 스크롤 바를 호출하거나 현재의 자동 사이즈 변경 모드에
한 그 외의 기능을 중단시키거나 할 것은 없습니다. 그 대신해, 경계를 각 열의 최소 또는 최대의 합계보다 크고, 또는 작게 설정할 수 있도록 합니다. 즉, 모든 열을 표시할 여유가 없는지, 열이 <code>JTable</code>
 경계 기에 부족한가의 어느 쪽인지를
미합니다. 결국, 전자는 일부의 열의 클리핑을 실행해, 후자는 페인트시에 <code>JTable</code>
 백그라운드 컬러로 영역을 페인트 하게 됩니다.
 <p>
유효한 열의 사이에 델타를 분산시키는 도구
는
<code>JTable</code> 클래스의 private 메서드로 제공됩니다.
 
 <pre>

   adjustSizes(long targetSize, final Resizable3 r, boolean inverse)
 </pre>
이 메서드에 대해서는 다음의 섹션으로 설명합니다. <code>Resizable3</code>는
 private 인터페이스이며, 이 인터페이스에
해, 사이즈, 적절한 사이즈, 최대 사이즈 및 최소 사이즈를 가지는 요소의 집합을 포함하는 모든 데이터 구조가 알고리즘에
해 그 요소를 조작할 수 있게 됩니다.
 <p>
<H3> 델타의 분산 </H3>
 <p>
<H4> 개요</H4> 
<P>
 타겟 사이즈와 r 내의 요소의 적절한 사이즈의 합계와의 차이를 「DELTA」라고 합니다. 각 사이즈는
 원의 적절한 사이즈의 각각 DELTA
 할당분을 더해 산출합니다. 각 할당분은, 적절한 사이즈와 그 최소치 또는 최대치 제한 경계와의 사이의 거리에 근거해 정해집니다.
 <p>
<H4>정의</H4> 
<P>
 각 제약을 min[i], max[i] 및 pref[i] 로 합니다.
 <p>
각각의 합계를 MIN, MAX 및 PREF 로 합니다.
 <p>
새로운 사이즈의 계산방법은 다음과 같습니다.
 <p>

 
 <pre>

          size[i] = pref[i] + delta[i]
 </pre>
delta[i]
 계산방법은 다음과 같습니다.
 <p>
(DELTA &lt; 0)의 경우는
 다음과 같은 축소 모드가 됩니다.
 <p>
<PRE> DELTA delta[i] = ------------ * (pref[i] - min[i]) (PREF - MIN)</PRE> (DELTA > 0)의 경우는
 다음과 같은 확대 모드가 됩니다.
 <p>
<PRE> DELTA delta[i] = ------------ * (max[i] - pref[i]) (MAX - PREF)</PRE> 
<P>
 전체적으로 합계 사이즈는 같은 비율 k 로 합계 최소치 또는 합계 최대치에 가까워져, 그 비율이 필요한 스페이스 DELTA 에 대응하는 것을 보증합니다.
<H4>상세</H4> 
<P>
 여기서 제시한 공식의 단순한 평가는
 유한 정밀도 (int를
 사용)로 이 처리를 하는 것에
해 생기는 사사오입 오차의 영향을 받습니다. 이것에 대응하기 위해서, 전술의 승률이 반복해 계산되어 그 때에 전회의 사사오입 오차가 고려됩니다. 그 결과, 지정된 모든 요소로 균등하게 사사오입 오차를 분산하는 것에
해, 값의 합계가 정확하게 <code>targetSize</code> 가 되는 일련의 정수를 생성하는 알고리즘이 됩니다.
<H4>MAX 경계 및 MIN 경계에 이르렀을 경우</H4> 
<P>
 <code>targetSize</code> 가 [MIN, MAX]
 범위외의 경우, 이 알고리즘에
해 모든 사이즈가 각각의 적절한 최대치 또는 최소치의 제한치로 설정됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#doLayout()">doLayout</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/LayoutManager.html#layoutContainer(java.awt.Container)"><CODE>LayoutManager.layoutContainer(java.awt.Container)</CODE></A>,
 
<A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)"><CODE>Container.setLayout(java.awt.LayoutManager)</CODE></A>,
 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sizeColumnsToFit(boolean)"><!-- --></A> <H3>
sizeColumnsToFit</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>sizeColumnsToFit</B>(boolean&nbsp;lastColumnOnly)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>Swing 버젼 1.0. 3 이후는
<code>doLayout()</code> 로 옮겨졌습니다. </I>
<P>
<DD>이용 가능한 스페이스에 맞추어 테이블의 열의 사이즈를 변경합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sizeColumnsToFit(int)"><!-- --></A> <H3>
sizeColumnsToFit</H3>
<PRE>
public void <B>sizeColumnsToFit</B>(int&nbsp;resizingColumn)</PRE>
<DL>
<DD>Java 2 플랫폼 v1. 4 에서는 사용하지 않습니다. 대신에 <code>doLayout()</code> 메서드를 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>resizingColumn</CODE> - 사이즈 변경으로 이 조정을 필요로 하는 열. 들어맞는 열이 없는 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#doLayout()"><CODE>doLayout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD><code>JComponent</code>
 <code>getToolTipText</code> 메서드를 오버라이드(override) 해, 텍스트 세트가 있는 경우, 렌더링의 힌트를 사용할 수 있도록 합니다.
 <p>
<bold>주:</bold> <code>JTable</code> 가 렌더링의 툴 힌트를 적절히 표시할 수 있도록 하려면,
<code>JTable</code> 가 <code>ToolTipManager</code> 에 등록을 마친 컴퍼넌트가 아니면 안됩니다. 이것은 <code>initializeLocalVars</code> 로 자동적으로 행해집니다만, 나중에 <code>JTable</code> 에 <code>setToolTipText(null)</code>를
 통지하면, 테이블 컴퍼넌트를 등록 해제하므로 렌더링으로부터의 힌트는 그 이상 표시되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getToolTipText()"><CODE>JComponent.getToolTipText()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSurrendersFocusOnKeystroke(boolean)"><!-- --></A> <H3>
setSurrendersFocusOnKeystroke</H3>
<PRE>
public void <B>setSurrendersFocusOnKeystroke</B>(boolean&nbsp;surrendersFocusOnKeystroke)</PRE>
<DL>
<DD>JTable 가 셀의 키보드 이벤트를 전송 한 결과적으로 이 JTable
 에디터가 키보드 포커스를 취득할지 어떨지를 설정합니다. 디폴트에서는
 이 프로퍼티는 false 입니다. JTable는
 셀이 클릭될 때까지 포커스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>surrendersFocusOnKeystroke</CODE> - 키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 얻는
 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSurrendersFocusOnKeystroke()"><CODE>getSurrendersFocusOnKeystroke()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSurrendersFocusOnKeystroke()"><!-- --></A> <H3>
getSurrendersFocusOnKeystroke</H3>
<PRE>
public boolean <B>getSurrendersFocusOnKeystroke</B>()</PRE>
<DL>
<DD>키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 얻는
 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키보드가 에디터를 액티브화했을 때에 에디터가 포커스를 얻는
 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSurrendersFocusOnKeystroke(boolean)"><CODE>setSurrendersFocusOnKeystroke(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editCellAt(int, int)"><!-- --></A> <H3>
editCellAt</H3>
<PRE>
public boolean <B>editCellAt</B>(int&nbsp;row,
                          int&nbsp;column)</PRE>
<DL>
<DD><code>row</code> 및 <code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는
 셀의 편집을 프로그램에 근거해 개시합니다. 이것은 <code>editCellAt(int, int, null)</code>
 간이 메서드입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 행<DD><CODE>column</CODE> - 편집하는 열
<DT><B>반환값:</B><DD>하등의 이유로써 셀을 편집할 수 없는 경우, 또는 인덱스가 무효인 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="editCellAt(int, int, java.util.EventObject)"><!-- --></A> <H3>
editCellAt</H3>
<PRE>
public boolean <B>editCellAt</B>(int&nbsp;row,
                          int&nbsp;column,
                          <A HREF="../../java/util/EventObject.html" title="java.util 안의 클래스">EventObject</A> &nbsp;e)</PRE>
<DL>
<DD><code>row</code>,<code>column</code> 에 위치하는 셀의 인덱스가 유효한 범위내에 있어, 그 위치에 있는 셀이 편집 가능한 경우는
 셀의 편집을 프로그램에 근거해 개시합니다. <code>JTable</code> 가 특정의 테이블, 열, 또는 셀의 값을 편집할 수 없게 하려면,
<code>TableModel</code> 인터페이스의 <code>isCellEditable</code> 메서드로부터 false를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 행<DD><CODE>column</CODE> - 편집하는 열<DD><CODE>e</CODE> - <code>shouldSelectCell</code> 에 건네주는 이벤트. Java 2 플랫폼 v1. 2 이후,<code>shouldSelectCell</code>
 호출은 행해지지 않는다
<DT><B>반환값:</B><DD>하등의 이유로써 셀을 편집할 수 없는 경우, 또는 인덱스가 무효인 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="isEditing()"><!-- --></A> <H3>
isEditing</H3>
<PRE>
public boolean <B>isEditing</B>()</PRE>
<DL>
<DD>셀을 편집중의 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블이 셀을 편집중의 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEditorComponent()"><!-- --></A> <H3>
getEditorComponent</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>getEditorComponent</B>()</PRE>
<DL>
<DD>편집 세션을 처리하고 있는 컴퍼넌트를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 null를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>편집 세션을 처리하는 Component</DL>
</DD>
</DL>
<HR>

<A NAME="getEditingColumn()"><!-- --></A> <H3>
getEditingColumn</H3>
<PRE>
public int <B>getEditingColumn</B>()</PRE>
<DL>
<DD>현재 편집중의 셀을 포함한 열의 인덱스를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 편집중의 셀을 포함한 열의 인덱스. 아무것도 편집하고 있지 않는 경우는 -1을
 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getEditingRow()"><!-- --></A> <H3>
getEditingRow</H3>
<PRE>
public int <B>getEditingRow</B>()</PRE>
<DL>
<DD>현재 편집중의 셀을 포함한 행의 인덱스를 돌려줍니다. 아무것도 편집하고 있지 않는 경우는 -1을
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 편집중의 셀을 포함한 행의 인덱스. 아무것도 편집하고 있지 않는 경우는 -1을
 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUI()"><!-- --></A> <H3>
getUI</H3>
<PRE>
public <A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 내의 클래스">TableUI</A>  <B>getUI</B>()</PRE>
<DL>
<DD>이 컴퍼넌트를 렌더링 하는 L&F 오브젝트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트를 렌더링 하는 <code>TableUI</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="setUI(javax.swing.plaf.TableUI)"><!-- --></A> <H3>
setUI</H3>
<PRE>
public void <B>setUI</B>(<A HREF="../../javax/swing/plaf/TableUI.html" title="javax.swing.plaf 안의 클래스">TableUI</A> &nbsp;ui)</PRE>
<DL>
<DD>이 컴퍼넌트를 렌더링 해 페인트 다시 하는 L&F 오브젝트를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ui</CODE> - TableUI L&F 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="updateUI()"><!-- --></A> <H3>
updateUI</H3>
<PRE>
public void <B>updateUI</B>()</PRE>
<DL>
<DD>L&F 가 변경되었다고 하는 <code>UIManager</code> 로부터의 통지입니다. 현재의 UI 오브젝트를 <code>UIManager</code> 로부터의 최신 버젼에 옮겨놓습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#updateUI()">updateUI</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#updateUI()"><CODE>JComponent.updateUI()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUIClassID()"><!-- --></A> <H3>
getUIClassID</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUIClassID</B>()</PRE>
<DL>
<DD>Look & Feel 클래스의 이름의 구축에 사용된 접미말을 돌려줍니다. 이 클래스는
 이 컴퍼넌트를 렌더링 하는데 사용됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getUIClassID()">getUIClassID</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>캐릭터 라인 「TableUI」<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getUIClassID()"><CODE>JComponent.getUIClassID()</CODE></A>,
 
<A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setModel(javax.swing.table.TableModel)"><!-- --></A> <H3>
setModel</H3>
<PRE>
public void <B>setModel</B>(<A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 안의 인터페이스">TableModel</A> &nbsp;dataModel)</PRE>
<DL>
<DD>이 테이블의 데이터 모델을 <code>newModel</code> 로 설정해, 거기에 새로운 데이터 모델로부터의 리스너 통지를 등록합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>dataModel</CODE> - 이 테이블의 새로운 데이터 소스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>newModel</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getModel()"><CODE>getModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getModel()"><!-- --></A> <H3>
getModel</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>getModel</B>()</PRE>
<DL>
<DD>이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JTable</code> 가 표시하는 데이터를 제공하는 <code>TableModel</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setModel(javax.swing.table.TableModel)"><CODE>setModel(javax.swing.table.TableModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColumnModel(javax.swing.table.TableColumnModel)"><!-- --></A> <H3>
setColumnModel</H3>
<PRE>
public void <B>setColumnModel</B>(<A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 안의 인터페이스">TableColumnModel</A> &nbsp;columnModel)</PRE>
<DL>
<DD>이 테이블의 열모델을 <code>newModel</code> 로 설정해, 새로운 열모델로부터의 리스너 통지를 등록합니다. 또,<code>JTableHeader</code>
 열모델을 <code>columnModel</code> 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnModel</CODE> - 이 테이블의 새로운 데이터 소스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>columnModel</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getColumnModel()"><CODE>getColumnModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getColumnModel()"><!-- --></A> <H3>
getColumnModel</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>getColumnModel</B>()</PRE>
<DL>
<DD>이 테이블의 모든 열정보를 보관 유지하는 <code>TableColumnModel</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>테이블의 열 상태를 제공하는 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setColumnModel(javax.swing.table.TableColumnModel)"><CODE>setColumnModel(javax.swing.table.TableColumnModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSelectionModel(javax.swing.ListSelectionModel)"><!-- --></A> <H3>
setSelectionModel</H3>
<PRE>
public void <B>setSelectionModel</B>(<A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 안의 인터페이스">ListSelectionModel</A> &nbsp;newModel)</PRE>
<DL>
<DD>이 테이블의 행 선택 모델을 <code>newModel</code> 로 설정해, 새로운 선택 모델로부터의 리스너 통지를 등록합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newModel</CODE> - 새로운 선택 모델
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>newModel</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getSelectionModel()"><CODE>getSelectionModel()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSelectionModel()"><!-- --></A> <H3>
getSelectionModel</H3>
<PRE>
public <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>getSelectionModel</B>()</PRE>
<DL>
<DD>행 선택 상태의 유지에 사용하는 <code>ListSelectionModel</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 선택 상태를 제공하는 오브젝트. 행 선택이 허가되어 있지 않은 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#setSelectionModel(javax.swing.ListSelectionModel)"><CODE>setSelectionModel(javax.swing.ListSelectionModel)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="tableChanged(javax.swing.event.TableModelEvent)"><!-- --></A> <H3>
tableChanged</H3>
<PRE>
public void <B>tableChanged</B>(<A HREF="../../javax/swing/event/TableModelEvent.html" title="javax.swing.event 안의 클래스">TableModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이 테이블의 <code>TableModel</code> 이 <code>TableModelEvent</code>를
 생성할 경우에 불려 갑니다. <code>TableModelEvent</code>는
 모델의 좌표계로 구축되어 이벤트 수신시에 <code>JTable</code> 가 뷰 좌표계에의 적절한 매핑을 실행합니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 <code>JTable</code> 가 내부적으로 사용합니다.
 <p>
JDK 버젼 1.3 에서는
 이 메서드는
 필요에 따라서 선택 상태가 해제됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableModelListener.html" title="javax.swing.event 내의 인터페이스">TableModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableModelListener.html#tableChanged(javax.swing.event.TableModelEvent)">tableChanged</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="columnAdded(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnAdded</H3>
<PRE>
public void <B>columnAdded</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>테이블열모델에 열이 추가될 때 불려 갑니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnAdded(javax.swing.event.TableColumnModelEvent)">columnAdded</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnRemoved(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnRemoved</H3>
<PRE>
public void <B>columnRemoved</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>열이 테이블열모델로부터 삭제될 때 불려 갑니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnRemoved(javax.swing.event.TableColumnModelEvent)">columnRemoved</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnMoved(javax.swing.event.TableColumnModelEvent)"><!-- --></A> <H3>
columnMoved</H3>
<PRE>
public void <B>columnMoved</B>(<A HREF="../../javax/swing/event/TableColumnModelEvent.html" title="javax.swing.event 안의 클래스">TableColumnModelEvent</A> &nbsp;e)</PRE>
<DL>
<DD>열이 다시 배치했을 때에 불려 갑니다. 셀이 편집중의 경우, 편집은 정지해 셀이 재차 렌더링 됩니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnMoved(javax.swing.event.TableColumnModelEvent)">columnMoved</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnMarginChanged(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
columnMarginChanged</H3>
<PRE>
public void <B>columnMarginChanged</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>마진 변경을 위해서 열이 이동되었을 때에 불려 갑니다. 셀이 편집중의 경우, 편집은 정지해 셀이 재차 렌더링 됩니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnMarginChanged(javax.swing.event.ChangeEvent)">columnMarginChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnSelectionChanged(javax.swing.event.ListSelectionEvent)"><!-- --></A> <H3>
columnSelectionChanged</H3>
<PRE>
public void <B>columnSelectionChanged</B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</PRE>
<DL>
<DD><code>TableColumnModel</code>
 선택 모델이 변경될 때 불려 갑니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스">TableColumnModelListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/TableColumnModelListener.html#columnSelectionChanged(javax.swing.event.ListSelectionEvent)">columnSelectionChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/TableColumnModelListener.html" title="javax.swing.event 내의 인터페이스"><CODE>TableColumnModelListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="valueChanged(javax.swing.event.ListSelectionEvent)"><!-- --></A> <H3>
valueChanged</H3>
<PRE>
public void <B>valueChanged</B>(<A HREF="../../javax/swing/event/ListSelectionEvent.html" title="javax.swing.event 안의 클래스">ListSelectionEvent</A> &nbsp;e)</PRE>
<DL>
<DD>행의 선택 영역이 변경되었을 때에 불려 가 페인트 다시 해 새로운 선택 영역을 나타냅니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 내의 인터페이스">ListSelectionListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/ListSelectionListener.html#valueChanged(javax.swing.event.ListSelectionEvent)">valueChanged</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/ListSelectionListener.html" title="javax.swing.event 내의 인터페이스"><CODE>ListSelectionListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editingStopped(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
editingStopped</H3>
<PRE>
public void <B>editingStopped</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>편집이 완료했을 때에 불려 갑니다. 변경은 보존되어 에디터는 파기됩니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스">CellEditorListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html#editingStopped(javax.swing.event.ChangeEvent)">editingStopped</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스"><CODE>CellEditorListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="editingCanceled(javax.swing.event.ChangeEvent)"><!-- --></A> <H3>
editingCanceled</H3>
<PRE>
public void <B>editingCanceled</B>(<A HREF="../../javax/swing/event/ChangeEvent.html" title="javax.swing.event 안의 클래스">ChangeEvent</A> &nbsp;e)</PRE>
<DL>
<DD>편집이 삭제되면 불려 갑니다. 에디터 오브젝트가 파기되어 셀이 한번 더 렌더링 됩니다.
 <p>
어플리케이션 코드는 이러한 메서드를 명시적으로는 사용하지 않습니다. 이러한 메서드는 JTable 가 내부적으로 사용합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스">CellEditorListener</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/event/CellEditorListener.html#editingCanceled(javax.swing.event.ChangeEvent)">editingCanceled</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 받은 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/CellEditorListener.html" title="javax.swing.event 내의 인터페이스"><CODE>CellEditorListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredScrollableViewportSize(java.awt.Dimension)"><!-- --></A> <H3>
setPreferredScrollableViewportSize</H3>
<PRE>
public void <B>setPreferredScrollableViewportSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;size)</PRE>
<DL>
<DD>이 테이블의 뷰포트의 바람직한 사이즈를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 뷰가 이 테이블인 <code>JViewport</code>
 <code>preferredSize</code>를
 지정하는 <code>Dimension</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()"><CODE>Scrollable.getPreferredScrollableViewportSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredScrollableViewportSize()"><!-- --></A> <H3>
getPreferredScrollableViewportSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getPreferredScrollableViewportSize</B>()</PRE>
<DL>
<DD>이 테이블의 뷰포트의 적절한 사이즈를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()">getPreferredScrollableViewportSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블을 표시하는 <code>JViewport</code>
 <code>preferredSize</code>를
 보관 유지하는 <code>Dimension</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getPreferredScrollableViewportSize()"><CODE>Scrollable.getPreferredScrollableViewportSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableUnitIncrement(java.awt.Rectangle, int, int)"><!-- --></A> <H3>
getScrollableUnitIncrement</H3>
<PRE>
public int <B>getScrollableUnitIncrement</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                                      int&nbsp;orientation,
                                      int&nbsp;direction)</PRE>
<DL>
<DD>새로운 1 행 또는 1 열을 완전하게 표시하는 스크롤 증분치를 (방향에 근거해) 픽셀 단위로 돌려줍니다.
 <p>
이 메서드는
 유저가 단위 스크롤을 요구할 때마다 불려 갑니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)">getScrollableUnitIncrement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 뷰포트내의 가시의 뷰 영역<DD><CODE>orientation</CODE> - <code>SwingConstants.VERTICAL</code> 또는 <code>SwingConstants.HORIZONTAL</code><DD><CODE>direction</CODE> - 상또는왼쪽으로 스크롤 하는 경우는 0 보다 작고, 아래 또는 오른쪽으로 스크롤 하는 경우는 0 보다 크다
<DT><B>반환값:</B><DD>지정된 방향으로 스크롤하기 위한 「유니트」증분치<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableUnitIncrement(java.awt.Rectangle, int, int)"><CODE>Scrollable.getScrollableUnitIncrement(java.awt.Rectangle, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableBlockIncrement(java.awt.Rectangle, int, int)"><!-- --></A> <H3>
getScrollableBlockIncrement</H3>
<PRE>
public int <B>getScrollableBlockIncrement</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect,
                                       int&nbsp;orientation,
                                       int&nbsp;direction)</PRE>
<DL>
<DD>이 테이블의 방향에
해 <code>visibleRect.height</code> 또는 <code>visibleRect.width</code>를
 돌려줍니다. Swing 1.1. 1 (Java 2 v 1.2. 2)로부터는
 돌려주고지는 값에
해 관점(전망)이 행의 경계에 명확하게 배치되게 되었습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)">getScrollableBlockIncrement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 뷰포트내의 가시의 뷰 영역<DD><CODE>orientation</CODE> - SwingConstants.VERTICAL 또는 SwingConstants.HORIZONTAL<DD><CODE>direction</CODE> - 상또는왼쪽으로 스크롤 하는 경우는 0 보다 작고, 아래 또는 오른쪽으로 스크롤 하는 경우는 0 보다 크다
<DT><B>반환값:</B><DD>방향에 근거한 <code>visibleRect.height</code> 또는 <code>visibleRect.width</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableBlockIncrement(java.awt.Rectangle, int, int)"><CODE>Scrollable.getScrollableBlockIncrement(java.awt.Rectangle, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableTracksViewportWidth()"><!-- --></A> <H3>
getScrollableTracksViewportWidth</H3>
<PRE>
public boolean <B>getScrollableTracksViewportWidth</B>()</PRE>
<DL>
<DD><code>autoResizeMode</code> 가 <code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false를
 돌려줍니다. 이것은 뷰포트의 폭이 테이블의 폭을 결정하지 않는 것을 나타냅니다. 그 외의 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportWidth()">getScrollableTracksViewportWidth</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>autoResizeMode</code> 가 <code>AUTO_RESIZE_OFF</code> 로 설정되어 있는 경우는 false, 그렇지 않은 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportWidth()"><CODE>Scrollable.getScrollableTracksViewportWidth()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScrollableTracksViewportHeight()"><!-- --></A> <H3>
getScrollableTracksViewportHeight</H3>
<PRE>
public boolean <B>getScrollableTracksViewportHeight</B>()</PRE>
<DL>
<DD>false를
 돌려주고, 뷰포트의 높이가 테이블의 높이를 결정하지 않는 것을 나타냅니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/swing/Scrollable.html" title="javax.swing 내의 인터페이스">Scrollable</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportHeight()">getScrollableTracksViewportHeight</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>false<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/Scrollable.html#getScrollableTracksViewportHeight()"><CODE>Scrollable.getScrollableTracksViewportHeight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)"><!-- --></A> <H3>
processKeyBinding</H3>
<PRE>
protected boolean <B>processKeyBinding</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                                    <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                                    int&nbsp;condition,
                                    boolean&nbsp;pressed)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">JComponent</A> </CODE>
 기술: </B></DD>
<DD><code>KeyEvent</code> <code>e</code>
 결과로서 <code>ks</code>
 키 바인드를 처리하기 위해서 불려 갑니다. 이 메서드는 적절한 <code>InputMap</code>,
 그 바인딩,<code>ActionMap</code>
 액션을 취득해, (액션이 발견되어, 수신측이 유효한 경우) 액션을 통지하기 위해서 <code>notifyAction</code>를
 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ks</CODE> - 조회하는 <code>KeyStroke</code><DD><CODE>e</CODE> - <code>KeyEvent</code><DD><CODE>condition</CODE> - 다음의 값의 어떤 것인가<ul> <li>JComponent.WHEN_FOCUSED<li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT<li>JComponent.WHEN_IN_FOCUSED_WINDOW </ul><DD><CODE>pressed</CODE> - 키가 밀리고 있는 경우는 true
<DT><B>반환값:</B><DD>액션에 바인딩이 있어, 액션이 유효했던 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultRenderers()"><!-- --></A> <H3>
createDefaultRenderers</H3>
<PRE>
protected void <B>createDefaultRenderers</B>()</PRE>
<DL>
<DD>오브젝트, 수, double 치, 일자, boolean 치 및 아이콘의 디폴트의 셀 렌더링을 작성합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableCellRenderer.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableCellRenderer</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultEditors()"><!-- --></A> <H3>
createDefaultEditors</H3>
<PRE>
protected void <B>createDefaultEditors</B>()</PRE>
<DL>
<DD>오브젝트, 수 및 boolean 치의 디폴트의 셀 에디터를 작성합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultCellEditor.html" title="javax.swing 내의 클래스"><CODE>DefaultCellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="initializeLocalVars()"><!-- --></A> <H3>
initializeLocalVars</H3>
<PRE>
protected void <B>initializeLocalVars</B>()</PRE>
<DL>
<DD>각 테이블 프로퍼티를 디폴트치에 초기화합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultDataModel()"><!-- --></A> <H3>
createDefaultDataModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableModel.html" title="javax.swing.table 내의 인터페이스">TableModel</A>  <B>createDefaultDataModel</B>()</PRE>
<DL>
<DD><code>DefaultTableModel</code> 인 디폴트의 테이블 모델 오브젝트를 돌려줍니다. 서브 클래스는 이 메서드를 오버라이드(override) 해, 다른 테이블 모델 오브젝트를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 테이블 모델 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultColumnModel()"><!-- --></A> <H3>
createDefaultColumnModel</H3>
<PRE>
protected <A HREF="../../javax/swing/table/TableColumnModel.html" title="javax.swing.table 내의 인터페이스">TableColumnModel</A>  <B>createDefaultColumnModel</B>()</PRE>
<DL>
<DD><code>DefaultTableColumnModel</code> 인 디폴트의 열모델 오브젝트를 돌려줍니다. 서브 클래스는 이 메서드를 오버라이드(override) 해, 다른 열모델 오브젝트를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 열모델 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableColumnModel.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableColumnModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultSelectionModel()"><!-- --></A> <H3>
createDefaultSelectionModel</H3>
<PRE>
protected <A HREF="../../javax/swing/ListSelectionModel.html" title="javax.swing 내의 인터페이스">ListSelectionModel</A>  <B>createDefaultSelectionModel</B>()</PRE>
<DL>
<DD><code>DefaultListSelectionModel</code> 인 디폴트의 선택 모델 오브젝트를 돌려줍니다. 서브 클래스는 이 메서드를 오버라이드(override) 해, 다른 선택 모델 오브젝트를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 선택 모델 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultListSelectionModel.html" title="javax.swing 내의 클래스"><CODE>DefaultListSelectionModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createDefaultTableHeader()"><!-- --></A> <H3>
createDefaultTableHeader</H3>
<PRE>
protected <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스">JTableHeader</A>  <B>createDefaultTableHeader</B>()</PRE>
<DL>
<DD><code>JTableHeader</code> 인 디폴트의 테이블 헤더 오브젝트를 돌려줍니다. 서브 클래스는 이 메서드를 오버라이드(override) 해, 다른 테이블 헤더 오브젝트를 돌려줄 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 테이블 헤더 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 내의 클래스"><CODE>JTableHeader</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resizeAndRepaint()"><!-- --></A> <H3>
resizeAndRepaint</H3>
<PRE>
protected void <B>resizeAndRepaint</B>()</PRE>
<DL>
<DD><code>revalidate</code>
 후에 <code>repaint</code>를
 호출하는 것과 동등합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getCellEditor()"><!-- --></A> <H3>
getCellEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getCellEditor</B>()</PRE>
<DL>
<DD>셀 에디터를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>편집을 실시하는 <code>TableCellEditor</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#cellEditor"><CODE>cellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setCellEditor(javax.swing.table.TableCellEditor)"><!-- --></A> <H3>
setCellEditor</H3>
<PRE>
public void <B>setCellEditor</B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;anEditor)</PRE>
<DL>
<DD><code>cellEditor</code> 변수를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>anEditor</CODE> - 편집을 실시하는 TableCellEditor<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#cellEditor"><CODE>cellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEditingColumn(int)"><!-- --></A> <H3>
setEditingColumn</H3>
<PRE>
public void <B>setEditingColumn</B>(int&nbsp;aColumn)</PRE>
<DL>
<DD><code>editingColumn</code> 변수를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aColumn</CODE> - 편집되는 셀의 열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingColumn"><CODE>editingColumn</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEditingRow(int)"><!-- --></A> <H3>
setEditingRow</H3>
<PRE>
public void <B>setEditingRow</B>(int&nbsp;aRow)</PRE>
<DL>
<DD><code>editingRow</code> 변수를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aRow</CODE> - 편집되는 셀의 행<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#editingRow"><CODE>editingRow</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCellRenderer(int, int)"><!-- --></A> <H3>
getCellRenderer</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 내의 인터페이스">TableCellRenderer</A>  <B>getCellRenderer</B>(int&nbsp;row,
                                         int&nbsp;column)</PRE>
<DL>
<DD>이 행과 열로 지정하는 셀의 적절한 렌더링을 돌려줍니다. 이 열의 <code>TableColumn</code> 가 null 이외의 렌더링을 가지는 경우는
 그 렌더링을 돌려줍니다. 그렇지 않은 경우는
<code>getColumnClass</code>를
 사용해 이 열의 데이터의 클래스를 찾아내, 이 형태의 데이터의 디폴트 렌더링을 돌려줍니다.
 <p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메서드를 사용해 렌더링을 제공해, 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 렌더링 하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - 렌더링 하는 셀의 열. 0 은 최초의 열
<DT><B>반환값:</B><DD>할당할 수 있었던 렌더링. <code>null</code>
 경우, 이 형태의 오브젝트의 디폴트의 렌더링을 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/table/DefaultTableCellRenderer.html" title="javax.swing.table 내의 클래스"><CODE>DefaultTableCellRenderer</CODE></A>,
 
<A HREF="../../javax/swing/table/TableColumn.html#setCellRenderer(javax.swing.table.TableCellRenderer)"><CODE>TableColumn.setCellRenderer(javax.swing.table.TableCellRenderer)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#setDefaultRenderer(java.lang.Class, javax.swing.table.TableCellRenderer)"><CODE>setDefaultRenderer(java.lang.Class<? >, javax.swing.table.TableCellRenderer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prepareRenderer(javax.swing.table.TableCellRenderer, int, int)"><!-- --></A> <H3>
prepareRenderer</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>prepareRenderer</B>(<A HREF="../../javax/swing/table/TableCellRenderer.html" title="javax.swing.table 안의 인터페이스">TableCellRenderer</A> &nbsp;renderer,
                                 int&nbsp;row,
                                 int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code>
 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 렌더링을 준비합니다. 이벤트의 위치에 있는 컴퍼넌트 (<code>Component</code> 또는 <code>JComponent</code>)를 돌려줍니다.
 <p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메서드를 사용해 렌더링을 준비해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>renderer</CODE> - 준비하는 <code>TableCellRenderer</code><DD><CODE>row</CODE> - 렌더링 하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - 렌더링 하는 셀의 열. 0 은 최초의 열
<DT><B>반환값:</B><DD>이벤트의 위치에 있는 <code>Component</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCellEditor(int, int)"><!-- --></A> <H3>
getCellEditor</H3>
<PRE>
public <A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 내의 인터페이스">TableCellEditor</A>  <B>getCellEditor</B>(int&nbsp;row,
                                     int&nbsp;column)</PRE>
<DL>
<DD><code>row</code> 와 <code>column</code> 가 지정하는 셀의 적절한 에디터를 돌려줍니다. 이 열의 <code>TableColumn</code> 가 null 이외의 에디터를 가지는 경우는
 그 에디터를 돌려줍니다. 그렇지 않은 경우는
<code>getColumnClass</code>를
 사용해 이 열의 데이터의 클래스를 찾아내, 이 형태의 데이터의 디폴트 에디터를 돌려줍니다.
 <p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메서드를 사용해 에디터를 제공해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>row</CODE> - 편집하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - 편집하는 셀의 열. 0 은 최초의 열
<DT><B>반환값:</B><DD>이 셀의 에디터. <code>null</code>
 경우, 이 형태의 셀의 디폴트의 에디터를 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/DefaultCellEditor.html" title="javax.swing 내의 클래스"><CODE>DefaultCellEditor</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prepareEditor(javax.swing.table.TableCellEditor, int, int)"><!-- --></A> <H3>
prepareEditor</H3>
<PRE>
public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>prepareEditor</B>(<A HREF="../../javax/swing/table/TableCellEditor.html" title="javax.swing.table 안의 인터페이스">TableCellEditor</A> &nbsp;editor,
                               int&nbsp;row,
                               int&nbsp;column)</PRE>
<DL>
<DD><code>row</code>,<code>column</code>
 위치에 있는 셀의 값 및 선택 상태를 데이터 모델에 조회해, 에디터를 준비합니다.
 <p>
<b>주:</b> 테이블 패키지 전체를 통해, 내부 구현은 항상 이 메서드를 사용해 에디터를 준비해, 이 디폴트의 동작을 서브 클래스가 안전하게 오버라이드(override) 할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>editor</CODE> - 설정하는 <code>TableCellEditor</code><DD><CODE>row</CODE> - 편집하는 셀의 행. 0 은 최초의 행<DD><CODE>column</CODE> - 편집하는 셀의 열. 0 은 최초의 열
<DT><B>반환값:</B><DD>the <code>Component</code> being edited</DL>
</DD>
</DL>
<HR>

<A NAME="removeEditor()"><!-- --></A> <H3>
removeEditor</H3>
<PRE>
public void <B>removeEditor</B>()</PRE>
<DL>
<DD>에디터 오브젝트를 파기해, 그 오브젝트가 셀 렌더링에 사용한 장소를 해방합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="paramString()"><!-- --></A> <H3>
paramString</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>paramString</B>()</PRE>
<DL>
<DD>이 테이블의 캐릭터 라인 표현을 돌려줍니다. 이 메서드는 디버그 전용이며, 돌려주고지는 캐릭터 라인의 내용 및 형식은 구현에 따라서 다릅니다. 돌려주고지는 캐릭터 라인은 하늘의 경우가 있습니다만,<code>null</code> 로는 되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#paramString()">paramString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 테이블의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="print()"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>()
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 모드 <code>PrintMode.FIT_WIDTH</code> 로 헤더 텍스트 또는 footer 텍스트를 지정하지 않고 인쇄하는 간이 메서드입니다. 인쇄중은, 중지 옵션이 붙은 모덜인 진척 다이얼로그가 표시됩니다.
 <p>
주: 헷드레스모드에서는
 다이얼로그는 표시되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>유저가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)"><CODE>print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 지정된 인쇄 모드로 헤더 텍스트 또는 footer 텍스트를 지정하지 않고 인쇄하는 간이 메서드입니다. 인쇄중은, 중지 옵션이 붙은 모덜인 진척 다이얼로그가 표시됩니다.
 <p>
주: 헷드레스모드에서는
 다이얼로그는 표시되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드
<DT><B>반환값:</B><DD>유저가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)"><CODE>print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A> </PRE>
<DL>
<DD>인쇄 다이얼로그를 표시해, 이 <code>JTable</code>를
, 지정된 인쇄 모드로 헤더 텍스트 또는 footer 텍스트를 지정해 인쇄하는 간이 메서드입니다. 인쇄중은, 중지 옵션 첨부의 모덜인 진척 다이얼로그가 표시됩니다.
 <p>
주: 헷드레스모드에서는
 다이얼로그는 표시되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 null<DD><CODE>footerFormat</CODE> - footer의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. footer가 없는 경우는 null
<DT><B>반환값:</B><DD>유저가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)"><CODE>print(JTable.PrintMode, MessageFormat, MessageFormat, boolean, PrintRequestAttributeSet, boolean)</CODE></A>,
 
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat, boolean, javax.print.attribute.PrintRequestAttributeSet, boolean)"><!-- --></A> <H3>
print</H3>
<PRE>
public boolean <B>print</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                     <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat,
                     boolean&nbsp;showPrintDialog,
                     <A HREF="../../javax/print/attribute/PrintRequestAttributeSet.html" title="javax.print.attribute 안의 인터페이스">PrintRequestAttributeSet</A> &nbsp;attr,
                     boolean&nbsp;interactive)
              throws <A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 내의 클래스">PrinterException</A>,

                     <A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </PRE>
<DL>
<DD>이 <code>JTable</code>를
 인쇄합니다. 대부분의 개발자가 <code>JTable</code>
 인쇄에 사용하는 순서를 실행합니다. 간략하게 말하면, 테이블을 준비해,<code>getPrintable</code>를
 호출해 적절한 <code>Printable</code>를
 꺼내, 그것을 프린터에 보냅니다.
 <p>
<code>boolean</code> 파라미터를 사용하면, 인쇄 다이얼로그가 유저에게 표시될지 어떨지를 지정할 수 있습니다. 다이얼로그가 표시되면, 유저는 그것을 사용해 인쇄 속성을 변경하거나 인쇄를 취소하거나 할 수가 있습니다. 다른 파라미터에서는
 인쇄 속성을 직접 지정할 수 있습니다. 이 파라미터는
 인쇄 다이얼로그의 초기치를 지정하거나 다이얼로그가 표시되지 않을 때에 필요한 속성을 제공하기 위해서 사용할 수 있습니다.
 <p>
2 번째의 <code>boolean</code> 파라미터를 사용하면, 대화형 모드로 인쇄를 실행할지 어떨지를 지정할 수 있습니다. <code>true</code>
 경우는
 인쇄중에 중지 옵션이 붙은 모덜인 진척 다이얼로그가 표시됩니다. 이 다이얼로그에서는
 테이블에 영향을 미치는 유저 액션을 방지할 수도 있습니다. 다만, 테이블이 코드 (<code>SwingUtilities.invokeLater</code>를
 사용해 갱신 내용을 보내는 다른 thread등)에
해 변경되지 않게 할 수 없습니다. 이 때문에
 개발자는 인쇄중에 테이블이 다른 코드에
해 결코 변경되지 않게 할 필요가 있습니다 (부정한 변경에는
 사이즈, 렌더링, 기본이 되는 데이터의 변경이 있다). 인쇄중으로 테이블이 변경되면, 인쇄 동작은 보증되지 않습니다.
 <p>
이 파라미터를 <code>false</code> 로 지정하면, 다이얼로그는 표시되지 않고, 이벤트디스패치스렛드로 즉석에서 인쇄가 개시됩니다. 이것에
해, 인쇄가 완료할 때까지 다른 모든 이벤트 (재페인트등)의 처리가 중단됩니다. 이것은, 테이블이 변경되지 않게 하려면  효과적입니다만, 유저측의 순서가 없습니다. 이 이유로부터, 표시할 수 있는 GUI 가 없는 어플리케이션으로부터 인쇄할 경우에 마셔 <code>false</code>를
 지정하는 것을 추천합니다.
 <p>
주: 헷드레스모드로 인쇄 다이얼로그를 표시하는지, 대화형으로 실행하려고 하면,<code>HeadlessException</code> 가 Throw 됩니다.
 <p>
Printable를
 꺼내기 전에
 이 메서드는 최적인 인쇄 결과를 얻을 수 있도록 테이블을 준비합니다. 테이블이 현재 편집 모드가 되어 있는 경우는
 가능한 한 보통
의 순서로 편집을 종료합니다. 또, 인쇄된 출력내에 테이블의 현재의 선택 범위나 포커스 된 셀이 지시받지 않은 것을 확인합니다. 이 조작은 뷰레벨로 인쇄중에게만 처리되기 때문에
 선택 모델에 통지를 송신할 필요는 없습니다.
 <p>
테이블의 인쇄 방법의 상세한 것에 대하여는
<A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A> 를
 참조하십시오.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 null<DD><CODE>footerFormat</CODE> - footer의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. footer가 없는 경우는 null<DD><CODE>showPrintDialog</CODE> - 인쇄 다이얼로그를 표시할지 어떨지<DD><CODE>attr</CODE> - 인쇄 속성을 나타내는 <code>PrintRequestAttributeSet</code>. 인쇄 속성이 없는 경우는 null<DD><CODE>interactive</CODE> - 대화형 모드로 인쇄할지 어떨지
<DT><B>반환값:</B><DD>유저가 인쇄를 취소하지 않는 한 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/awt/print/PrinterException.html" title="java.awt.print 안의 클래스">PrinterException</A> </CODE> - 인쇄 시스템의 에러가 원인으로 작업이 정지했을 경우
<DD><CODE><A HREF="../../java/awt/HeadlessException.html" title="java.awt 안의 클래스">HeadlessException</A> </CODE> - 메서드가 인쇄 다이얼로그를 표시하는지, 대화형으로 실행하도록 요구되어<code>GraphicsEnvironment.isHeadless</code> 가 true를
 돌려주었을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JTable.html#getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><CODE>getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)</CODE></A>,
 
<A HREF="../../java/awt/GraphicsEnvironment.html#isHeadless()"><CODE>GraphicsEnvironment.isHeadless()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPrintable(javax.swing.JTable.PrintMode, java.text.MessageFormat, java.text.MessageFormat)"><!-- --></A> <H3>
getPrintable</H3>
<PRE>
public <A HREF="../../java/awt/print/Printable.html" title="java.awt.print 내의 인터페이스">Printable</A>  <B>getPrintable</B>(<A HREF="../../javax/swing/JTable.PrintMode.html" title="javax.swing 안의 열거형">JTable.PrintMode</A> &nbsp;printMode,
                              <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;headerFormat,
                              <A HREF="../../java/text/MessageFormat.html" title="java.text 안의 클래스">MessageFormat</A> &nbsp;footerFormat)</PRE>
<DL>
<DD>이 JTable
 인쇄에 사용하는 <code>Printable</code>를
 돌려줍니다.
 <p>
<code>Printable</code>는

 2 개의 인쇄 모드의 어느 쪽인지로 요구할 수 있습니다. 어느 쪽의 모드에서도, 1 페이지 근처의 행수를 가능한 한 많이 해, 테이블의 행을 순서에 복수 페이지에 걸쳐서 자연스럽게 분산시킵니다. <code>PrintMode.NORMAL</code>는

 테이블이 현재의 사이즈로 인쇄되는 것을 나타냅니다. 이 모드에서는
 행의 경우와 같게 열도 복수 페이지에 걸쳐서 분산시킬 필요가 있습니다. 필요에 따라서, 테이블의 <code>ComponentOrientation</code> 에 알맞은 순서로 열이 분산됩니다. <code>PrintMode.FIT_WIDTH</code>는

 필요에 따라서, 각 페이지에 테이블의 폭전체 (모든 열)가 들어가도록 출력이 축소되는 것을 나타냅니다. 폭과 높이는 균일하게 슬캘링 되어 출력의 종횡비가 유지됩니다.
 <p>
<code>Printable</code>는

 각 페이지의 테이블 부분의 선두에 테이블의 <code>JTableHeader</code> 로부터의 적절한 섹션 (존재하는 경우)을 붙입니다.
 <p>
<code>MessageFormat</code> 인수를 지정하면, 헤더 텍스트와 footer 텍스트를 출력에 추가할 수 있습니다. 인쇄 코드는
 그러한 형식으로부터 String를
 요구해, 서식 첨부 캐릭터 라인에 포함되는 단일의 항목 (현재의 페이지 번호를 나타내는 <code>Integer</code>)을 제공합니다.
 <p>
홑겹 인용부호등의 일부의 특수 문자에는 이스케이프가 필요하기 때문에
<code>MessageFormat</code>
 문서를 자주 읽어 주세요.
 <p>
다음에
 「Duke's Table: Page - 」라고 현재의 페이지 번호의 인쇄에 사용할 수 있는 <code>MessageFormat</code>
 작성예를 나타냅니다.
 <p>

 
 <pre>

     // notice the escaping of the single quote
     // notice how the page number is included with "{0}"
     MessageFormat format = new MessageFormat("Duke''s Table: Page - {0}");
 </pre>

 <p>
<code>Printable</code> 에서는
 렌더링 하는 내용을, 인쇄하는 각 페이지의 인쇄 가능 영역에 제한합니다. 경우에 따라서는
 페이지의 모든 내용이 그 영역에 들어가지 않는 것이 있습니다. 이 경우는
 출력이 클립 되는 일이 있습니다만, 구현은 어떠한 타당한 처리를 하려고 시도합니다. 다음에
 이러한 상황의 몇개의 발생예와 이 구현에
한 그러한 대처 방법을 나타냅니다. <ul> <li>모든 모드로 헤더 텍스트 또는 footer 텍스트가 너무 커 인쇄 가능 영역에 완전하게 들어가지 않는 경우 -- 테이블의 <code>ComponentOrientation</code> 에
해 결정할 수 있었던 대로 텍스트의 선두로부터 한도 가득까지 인쇄한다<li>모든 모드로 행이 너무 길어 인쇄 가능 영역에 들어가지 않는 경우 -- 행의 최상 부분을 인쇄해, 움푹한 곳 보더는 테이블에 페인트 하지 않는다<li><code>PrintMode.NORMAL</code> 로 열이 너무 넓어 인쇄 가능 영역에 들어가지 않는 경우 -- 열의 중앙 부분을 인쇄해, 왼쪽 및 오른쪽의 보더를 테이블에서 제외한다 
</ul>

 <p>
복잡한 리포트나 문서를 작성하기 위해서, 이 <code>Printable</code>를
 다른 <code>Printable</code> 내에감싸는 것은 전혀 문제 없습니다. 또, 다른 페이지가 사이즈의 다른 인쇄 가능 영역에 렌더링 되도록 요구할 수도 있습니다. 구현은, 이러한 상황에 대처할 수 있는 것 (아마 실행중에 그 레이아웃 계산을 실시하는 것으로) 같게 준비되어 있을 필요가 있습니다. 다만,<code>PrintMode.NORMAL</code> 로 복수 페이지에 열을 분산시킬 필요가 있는 경우는
 각 페이지에 다른 높이를 지정하면, 올바르게 동작하지 않을 가능성이 있습니다.
 <p>
이 <code>Printable</code> 가 테이블을, 그 현재의 시각 상태로 테이블의 기존의 렌더링을 사용해 인쇄하는 것에 주의해 주세요. 이 메서드를 호출하기 전에
 우선 테이블 상태를 변경하는 (렌더링의 변경, 편집의 취소해, 선택 범위의 비표시 등) 일을 추천합니다.
 <p>
다만, 이 <code>Printable</code> 가 꺼내진 뒤는 테이블을 일절 변경하지 말아 주세요 (부정한 변경에는
 사이즈, 렌더링, 기본이 되는 데이터의 변경등이 있다).
 <p>
다음에 나타내는 간단한 예에서는
 이 메서드를 호출해 <code>Printable</code>를
 꺼내, 공통 플랫폼의 인쇄 다이얼로그를 표시해, 유저가 다이얼로그를 취소하지 않는 한 <code>Printable</code>를
 인쇄합니다.
 <p>

 
 <pre>

     // prepare the table for printing here first (for example, hide selection)

     // wrap in a try/finally so table can be restored even if something fails
     try {
         // fetch the printable
         Printable printable = table.getPrintable(JTable.PrintMode.FIT_WIDTH,
                                                  new MessageFormat("My Table"),
                                                  new MessageFormat("Page - {0}"));

         // fetch a PrinterJob
         PrinterJob job = PrinterJob.getPrinterJob();

         // set the Printable on the PrinterJob
         job.setPrintable(printable);

         // create an attribute set to store attributes from the print dialog
         PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();

         // display a print dialog and record whether or not the user cancels it
         boolean printAccepted = job.printDialog(attr);

         // if the user didn't cancel the dialog
         if (printAccepted) {
             // do the printing (may need to handle PrinterException)
             job.print(attr);
         }
     } finally {
         // restore the original table state here (for example, restore selection)
     }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>printMode</CODE> - Printable 가 사용하는 인쇄 모드<DD><CODE>headerFormat</CODE> - 헤더의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. 헤더가 없는 경우는 null<DD><CODE>footerFormat</CODE> - footer의 인쇄에 사용되는 텍스트를 나타내는 <code>MessageFormat</code>. footer가 없는 경우는 null
<DT><B>반환값:</B><DD>이 JTable를
 인쇄하기 위한 <code>Printable</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/print/Printable.html" title="java.awt.print 내의 인터페이스"><CODE>Printable</CODE></A>,
 
<A HREF="../../java/awt/print/PrinterJob.html" title="java.awt.print 안의 클래스"><CODE>PrinterJob</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleContext()"><!-- --></A> <H3>
getAccessibleContext</H3>
<PRE>
public <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>getAccessibleContext</B>()</PRE>
<DL>
<DD>이 JTable 에 관련한 AccessibleContext를
 돌려줍니다. 테이블의 경우, AccessibleContext는
 AccessibleJTable 
 형식을 취합니다. 필요에 따라서, 새로운의 AccessibleJTable 인스턴스가 작성됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../javax/accessibility/Accessible.html" title="javax.accessibility 내의 인터페이스">Accessible</A> </CODE> 내의 <CODE><A HREF="../../javax/accessibility/Accessible.html#getAccessibleContext()">getAccessibleContext</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../javax/swing/JComponent.html" title="javax.swing 내의 클래스">JComponent</A> </CODE> 내의 <CODE><A HREF="../../javax/swing/JComponent.html#getAccessibleContext()">getAccessibleContext</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 JTable
 AccessibleContext 로서 기능하는 AccessibleJTable</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JTable.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/swing/JTabbedPane.ModelListener.html" title="javax.swing 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JTable.AccessibleJTable.html" title="javax.swing 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/swing/JTable.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="JTable.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

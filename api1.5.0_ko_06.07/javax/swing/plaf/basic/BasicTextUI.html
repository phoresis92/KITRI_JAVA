<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:19:19 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
BasicTextUI (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.swing.plaf.basic.BasicTextUI class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="BasicTextUI (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BasicTextUI.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../javax/swing/plaf/basic/BasicTextPaneUI.html" title="javax.swing.plaf.basic 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.BasicCaret.html" title="javax.swing.plaf.basic 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?javax/swing/plaf/basic/BasicTextUI.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="BasicTextUI.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing.plaf.basic</FONT>
<BR>
클래스 BasicTextUI</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">javax.swing.plaf.ComponentUI</A> 
      <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">javax.swing.plaf.TextUI</A> 
          <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.plaf.basic.BasicTextUI</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../javax/swing/text/ViewFactory.html" title="javax.swing.text 내의 인터페이스">ViewFactory</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../../../javax/swing/plaf/basic/BasicEditorPaneUI.html" title="javax.swing.plaf.basic 내의 클래스">BasicEditorPaneUI</A>,
 <A HREF="../../../../javax/swing/plaf/basic/BasicTextAreaUI.html" title="javax.swing.plaf.basic 안의 클래스">BasicTextAreaUI</A>,
 <A HREF="../../../../javax/swing/plaf/basic/BasicTextFieldUI.html" title="javax.swing.plaf.basic 안의 클래스">BasicTextFieldUI</A>,
 <A HREF="../../../../javax/swing/text/DefaultTextUI.html" title="javax.swing.text 안의 클래스">DefaultTextUI</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>BasicTextUI</B><DT>extends <A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> <DT>implements <A HREF="../../../../javax/swing/text/ViewFactory.html" title="javax.swing.text 내의 인터페이스">ViewFactory</A> </DL>
</PRE>

<P>
<p>
텍스트 컴퍼넌트의 Look & Feel
 기초가 되는 클래스입니다. 이 클래스는
<code>JTextComponent</code>
 확장을 위한 Look & Feel를
 작성할 경우에 편리한, 에디터의 뷰 및 콘트롤러의 기본적인 서비스를 제공합니다.
 <p>
많은 경우, 상태는 관련된 <code>JTextComponent</code> 에 바운드 프로퍼티로서 보관 유지되고 있어 UI 에서는 각 프로퍼티의 디폴트치가 인스톨 됩니다. 이 디폴트의 동작에
해, 모든 프로퍼티에 대해서 값이 인스톨 됩니다만, 보통
, Look & Feel
 구현에서는 한층 더 많은 일을 합니다. Look & Feel
 구현에
해, 적어도 키 바인딩이 인스톨 되는 것이 보통입니다.
 <p>
또, JTextComponent 에 관련한 <code>Document</code> 가 <code>AbstractDocument</code>
 서브 클래스인 경우, 이 클래스는 병행 서포트도 제공합니다. View 또는 View 계층에의 액세스는
 모델을 변경하는 thread와 렌더링 하고 싶은 모델과 뷰간의 좌표변화를 행하거나하기 위한 Swing 이벤트 thread와의 사이에 직렬화 됩니다. 르트뷰에 액세스 하려면,
 최초로 AbstractDocument
 독해 락을 취득해, 그 락을 최종 블록으로 해방할 필요가 있습니다.
 <p>
정의할 필요가 있는 중요한 메서드는
 UIManager 로부터 디폴트의 값을 꺼내기 위해서 사용되는 키의 기초인 <A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getPropertyPrefix()"><CODE>getPropertyPrefix()</CODE></A>  메서드입니다. 취득한 캐릭터 라인은, 이름의 특정의 Look & Feel 부분 (Metal, Motif 등)이 없는 TextUI
 형태 (TextField, TextArea 등)를 반영합니다.
 <p>
모델의 뷰를 구축하려면,
 다음에 나타내는 방법의 어떤 것인지를 사용합니다. <ol> <li> 1 개의 방법은, 단순하게 UI 로 ViewFactory 인터페이스를 다시 정의하는 것 입니다. 디폴트에서는
 이 UI는
 그 자체가 View
 구현의 팩토리로서 동작합니다. 이것은, 단순한 팩토리에 편리합니다. 이 방법을 실행하려면,
<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#create(javax.swing.text.Element)"><CODE>create(javax.swing.text.Element)</CODE></A>  메서드를 다시 구현합니다. <li> 한층 더 복잡한 문서를 작성하는 경우의 일반적인 방법은, EditorKit
 구현이 팩토리를 돌려주도록(듯이) 하는 것입니다. EditorKit는
 어떤 종류의 문서를 유지하기 위해서 필요한 것을 모두 연결시키므로 보통
, 팩토리는 중요한 역할을 담당합니다. 이 경우, 팩토리는 EditorKit
 구현에
해 작성됩니다. <li> 너무 일반적이지 않는 방법으로서 UI
 구현에 팩토리의 다른 오브젝트를 작성시키는 방법이 있습니다. 그 때문에(위해)는
 팩토리를 돌려주도록(듯이) <CODE>#createViewFactory</CODE> 메서드를 다시 구현할 필요가 있습니다.  </ol>
 <p>
<strong>경고:</strong> 이 클래스의 직렬화 된 오브젝트는
 향후의 Swing 릴리스와 호환은 아니게 될 예정입니다. 현재의 직렬화의 서포트는
 단기간의 운용이나, 같은 버젼의 Swing를
 실행하는 어플리케이션간의 RMI 에 적절하고 있습니다. JDK 버젼 1.4 이후, 모든 JavaBeans<sup><font size="-2">TM</font></sup>
 장기간의 운용 서포트는
<code>java.beans</code> 패키지에 추가되고 있습니다. 자세한 것은,<A HREF="../../../../java/beans/XMLEncoder.html" title="java.beans 안의 클래스"><CODE>XMLEncoder</CODE></A> 를
 참조하십시오.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.BasicCaret.html" title="javax.swing.plaf.basic 안의 클래스">BasicTextUI.BasicCaret</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.BasicHighlighter.html" title="javax.swing.plaf.basic 안의 클래스">BasicTextUI.BasicHighlighter</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#BasicTextUI()">BasicTextUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 UI를
 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#create(javax.swing.text.Element)">create</A> </B>(<A HREF="../../../../javax/swing/text/Element.html" title="javax.swing.text 안의 인터페이스">Element</A> &nbsp;elem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 뷰를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#create(javax.swing.text.Element, int, int)">create</A> </B>(<A HREF="../../../../javax/swing/text/Element.html" title="javax.swing.text 안의 인터페이스">Element</A> &nbsp;elem,
       int&nbsp;p0,
       int&nbsp;p1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 뷰를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../javax/swing/text/Caret.html" title="javax.swing.text 내의 인터페이스">Caret</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#createCaret()">createCaret</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caret에 사용하는 오브젝트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../javax/swing/text/Highlighter.html" title="javax.swing.text 내의 인터페이스">Highlighter</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#createHighlighter()">createHighlighter</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;하이라이트를 추가하기 위해서 사용하는 오브젝트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../javax/swing/text/Keymap.html" title="javax.swing.text 내의 인터페이스">Keymap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#createKeymap()">createKeymap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;텍스트 컴퍼넌트에 사용하는 키 맵을 작성해, 거기에 필요한 바인딩을 인스톨 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#damageRange(javax.swing.text.JTextComponent, int, int)">damageRange</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
            int&nbsp;p0,
            int&nbsp;p1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델의 지정된 부분에 대응하는 뷰의 부분이 페인트 다시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#damageRange(javax.swing.text.JTextComponent, int, int, javax.swing.text.Position.Bias, javax.swing.text.Position.Bias)">damageRange</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
            int&nbsp;p0,
            int&nbsp;p1,
            <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;p0Bias,
            <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;p1Bias)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델내의 지정된 일부분에 대응하는 뷰의 부분이 렌더링 다시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 내의 클래스">JTextComponent</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getComponent()">getComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 UI
 구현에 관련한 텍스트 컴퍼넌트를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/swing/text/EditorKit.html" title="javax.swing.text 내의 클래스">EditorKit</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getEditorKit(javax.swing.text.JTextComponent)">getEditorKit</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI
 EditorKit를
 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getKeymapName()">getKeymapName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 UI 에 디폴트로 인스톨 또는 사용되는 키 맵의 이름을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getMaximumSize(javax.swing.JComponent)">getMaximumSize</A> </B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;에디터 컴퍼넌트의 최대 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getMinimumSize(javax.swing.JComponent)">getMinimumSize</A> </B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;에디터 컴퍼넌트의 최소 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getNextVisualPositionFrom(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias, int, javax.swing.text.Position.Bias[])">getNextVisualPositionFrom</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
                          int&nbsp;pos,
                          <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;b,
                          int&nbsp;direction,
                          <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> []&nbsp;biasRet)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;caret가 배치될 가능성이 있는
 시각적으로 나타내진 다음의 모델 위치를 결정하는 수단을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getPreferredSize(javax.swing.JComponent)">getPreferredSize</A> </B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;에디터 컴퍼넌트의 적절한 사이즈를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected abstract &nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getPropertyPrefix()">getPropertyPrefix</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UIManager를
 개입시켜 프로퍼티를 참조하기 위한 키로서 사용되는 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getRootView(javax.swing.text.JTextComponent)">getRootView</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델이 공간적으로 어떻게 표현되고 있는지를 판정하기 위해서 암벽 횡단 할 수 있는
 관련한 텍스트 컴퍼넌트 (즉 계층 루트)를 할당할 수 있었던 View를
 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getToolTipText(javax.swing.text.JTextComponent, java.awt.Point)">getToolTipText</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
               <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;건네받은 위치에서 툴 힌트로서 사용되는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getVisibleEditorRect()">getVisibleEditorRect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;루트 View 로 지정하는 할당을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installDefaults()">installDefaults</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;폰트, foreground, 백그라운드, caret의 색, 선택의 색, 선택된 텍스트의 색, 무효가 된 텍스트의 색, 보더의 색등의 컴퍼넌트 프로퍼티를 초기화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installKeyboardActions()">installKeyboardActions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installListeners()">installListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI
 리스너를 인스톨 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installUI(javax.swing.JComponent)">installUI</A> </B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 UI를
 인스톨 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#modelChanged()">modelChanged</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델의 변경에 플래그를 세웁니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#modelToView(javax.swing.text.JTextComponent, int)">modelToView</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
            int&nbsp;pos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델내의 지정된 위치를, 뷰 좌표 체계내의 장소로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#modelToView(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias)">modelToView</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
            int&nbsp;pos,
            <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;bias)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모델내의 지정된 위치를, 뷰 좌표 체계내의 장소로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#paint(java.awt.Graphics, javax.swing.JComponent)">paint</A> </B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g,
      <A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터페이스를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#paintBackground(java.awt.Graphics)">paintBackground</A> </B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;뷰의 백그라운드를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#paintSafely(java.awt.Graphics)">paintSafely</A> </B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 뷰로부터 모델이 변경되지 않는다고 하는 보증 첨부로 안전하게 인터페이스를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#propertyChange(java.beans.PropertyChangeEvent)">propertyChange</A> </B>(<A HREF="../../../../java/beans/PropertyChangeEvent.html" title="java.beans 안의 클래스">PropertyChangeEvent</A> &nbsp;evt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;관련된 JTextComponent 로 바운드 프로퍼티가 변경되었을 때에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#setView(javax.swing.text.View)">setView</A> </B>(<A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 안의 클래스">View</A> &nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;뷰 계층의 현재의 루트를 설정해, invalidate()를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallDefaults()">uninstallDefaults</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null 에 명시적으로 오버라이드(override)되어 있지 않은 컴퍼넌트 프로퍼티를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallKeyboardActions()">uninstallKeyboardActions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallListeners()">uninstallListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI
 리스너를 언인스톨합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallUI(javax.swing.JComponent)">uninstallUI</A> </B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 UI를
 언인스톨합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#update(java.awt.Graphics, javax.swing.JComponent)">update</A> </B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g,
       <A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;슈퍼 클래스는 제어 불가능한 방법으로 백그라운드를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point)">viewToModel</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
            <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;뷰 좌표 체계내의 지정된 위치를, 모델내의 가장 가까운 장소로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point, javax.swing.text.Position.Bias[])">viewToModel</A> </B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
            <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt,
            <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> []&nbsp;biasReturn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;뷰 좌표 체계내의 지정된 위치를, 모델내의 가장 가까운 장소로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.swing.plaf.ComponentUI"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 javax.swing.plaf. <A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스">ComponentUI</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#contains(javax.swing.JComponent, int, int)">contains</A>,
 <A HREF="../../../../javax/swing/plaf/ComponentUI.html#createUI(javax.swing.JComponent)">createUI</A>,
 <A HREF="../../../../javax/swing/plaf/ComponentUI.html#getAccessibleChild(javax.swing.JComponent, int)">getAccessibleChild</A>,
 <A HREF="../../../../javax/swing/plaf/ComponentUI.html#getAccessibleChildrenCount(javax.swing.JComponent)">getAccessibleChildrenCount</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BasicTextUI()"><!-- --></A> <H3>
BasicTextUI</H3>
<PRE>
public <B>BasicTextUI</B>()</PRE>
<DL>
<DD>새로운 UI를
 작성합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="createCaret()"><!-- --></A> <H3>
createCaret</H3>
<PRE>
protected <A HREF="../../../../javax/swing/text/Caret.html" title="javax.swing.text 내의 인터페이스">Caret</A>  <B>createCaret</B>()</PRE>
<DL>
<DD>caret에 사용하는 오브젝트를 작성합니다. 디폴트에서는
 BasicCaret
 인스턴스가 생성됩니다. 이 메서드를 다시 정의하면, InputPosition 인터페이스를 구현하는 것 외의 클래스, 또는 JCaret
 서브 클래스를 제공할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>caret 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="createHighlighter()"><!-- --></A> <H3>
createHighlighter</H3>
<PRE>
protected <A HREF="../../../../javax/swing/text/Highlighter.html" title="javax.swing.text 내의 인터페이스">Highlighter</A>  <B>createHighlighter</B>()</PRE>
<DL>
<DD>하이라이트를 추가하기 위해서 사용하는 오브젝트를 작성합니다. 디폴트에서는
 BasicHighlighter
 인스턴스가 생성됩니다. 이 메서드를 다시 정의하면, Highlighter 인터페이스를 구현하는 것 외의 클래스, 또는 DefaultHighlighter
 서브 클래스를 제공할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>하이 라이터</DL>
</DD>
</DL>
<HR>

<A NAME="getKeymapName()"><!-- --></A> <H3>
getKeymapName</H3>
<PRE>
protected <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getKeymapName</B>()</PRE>
<DL>
<DD>이 UI 에 디폴트로 인스톨 또는 사용되는 키 맵의 이름을 취득합니다. 이것은, 클래스명에 근거해 이름을 작성하기 위해서 구현됩니다. 이름은, 패키지의 접두사가 삭제된 클래스명입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이름</DL>
</DD>
</DL>
<HR>

<A NAME="createKeymap()"><!-- --></A> <H3>
createKeymap</H3>
<PRE>
protected <A HREF="../../../../javax/swing/text/Keymap.html" title="javax.swing.text 내의 인터페이스">Keymap</A>  <B>createKeymap</B>()</PRE>
<DL>
<DD>텍스트 컴퍼넌트에 사용하는 키 맵을 작성해, 거기에 필요한 바인딩을 인스톨 합니다. 디폴트에서는
 키 맵은 이 형태의 TextUI
 모든 인스턴스로 공유됩니다. 키 맵의 이름은, getKeymapName 메서드로 정의됩니다. 키 맵이 발견되지 않는 경우는
 JTextComponent
 DEFAULT_KEYMAP 가 사용됩니다.
 <p>
키 맵을 작성하기 위해서 사용되는 바인딩세트는
<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getPropertyPrefix()"><CODE>getPropertyPrefix()</CODE></A>  메서드와 캐릭터 라인 <code>. keyBindings</code>를
 결합한 키를 사용해 UIManager 로부터 취득됩니다. 형태는
<code>JTextComponent.KeyBinding[]</code> 이다고 보여집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키 맵<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#getKeymapName()"><CODE>getKeymapName()</CODE></A>,
 
<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스"><CODE>JTextComponent</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="propertyChange(java.beans.PropertyChangeEvent)"><!-- --></A> <H3>
propertyChange</H3>
<PRE>
protected void <B>propertyChange</B>(<A HREF="../../../../java/beans/PropertyChangeEvent.html" title="java.beans 안의 클래스">PropertyChangeEvent</A> &nbsp;evt)</PRE>
<DL>
<DD>관련된 JTextComponent 로 바운드 프로퍼티가 변경되었을 때에 불려 갑니다. 이것은, UI 가 JTextComponent
 서브 클래스의 바운드 프로퍼티를 어떻게 표시하는지를 반영하기 위해서 UI
 구현에
해 변경되는 훅입니다. 이 메서드는
 구현되어도 아무것도 실행하지 않습니다. 즉, JTextComponent 자체에서의 프로퍼티에 대한 응답은, 이 메서드의 호출전에 처리됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>evt</CODE> - 프로퍼티 변경 이벤트</DL>
</DD>
</DL>
<HR>

<A NAME="getPropertyPrefix()"><!-- --></A> <H3>
getPropertyPrefix</H3>
<PRE>
protected abstract <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getPropertyPrefix</B>()</PRE>
<DL>
<DD>UIManager를
 개입시켜 프로퍼티를 참조하기 위한 키로서 사용되는 이름을 돌려줍니다. 이 이름은, 모든 표준 텍스트 프로퍼티의 접두사로서 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이름</DL>
</DD>
</DL>
<HR>

<A NAME="installDefaults()"><!-- --></A> <H3>
installDefaults</H3>
<PRE>
protected void <B>installDefaults</B>()</PRE>
<DL>
<DD>폰트, foreground, 백그라운드, caret의 색, 선택의 색, 선택된 텍스트의 색, 무효가 된 텍스트의 색, 보더의 색등의 컴퍼넌트 프로퍼티를 초기화합니다. 폰트, foreground, 백그라운드의 프로퍼티는 현재의 값이 null 또는 UIResource
 경우에만 설정되어 다른 프로퍼티는 현재의 값이 null
 경우로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallDefaults()"><CODE>uninstallDefaults()</CODE></A>,
 
<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installUI(javax.swing.JComponent)"><CODE>installUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="uninstallDefaults()"><!-- --></A> <H3>
uninstallDefaults</H3>
<PRE>
protected void <B>uninstallDefaults</B>()</PRE>
<DL>
<DD>null 에 명시적으로 오버라이드(override)되어 있지 않은 컴퍼넌트 프로퍼티를 설정합니다. 현재의 값이 UIResouce 가 아니면, 프로퍼티는 오버라이드(override) 되었다고 판단됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#installDefaults()"><CODE>installDefaults()</CODE></A>,
 
<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.html#uninstallUI(javax.swing.JComponent)"><CODE>uninstallUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="installListeners()"><!-- --></A> <H3>
installListeners</H3>
<PRE>
protected void <B>installListeners</B>()</PRE>
<DL>
<DD>UI
 리스너를 인스톨 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="uninstallListeners()"><!-- --></A> <H3>
uninstallListeners</H3>
<PRE>
protected void <B>uninstallListeners</B>()</PRE>
<DL>
<DD>UI
 리스너를 언인스톨합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="installKeyboardActions()"><!-- --></A> <H3>
installKeyboardActions</H3>
<PRE>
protected void <B>installKeyboardActions</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="uninstallKeyboardActions()"><!-- --></A> <H3>
uninstallKeyboardActions</H3>
<PRE>
protected void <B>uninstallKeyboardActions</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="paintBackground(java.awt.Graphics)"><!-- --></A> <H3>
paintBackground</H3>
<PRE>
protected void <B>paintBackground</B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>뷰의 백그라운드를 페인트 합니다. 이 메서드는
 관련된 컴퍼넌트로 isOpaque()가 true
 경우에만 불려 갑니다. 디폴트에서는
 컴퍼넌트의 백그라운드 컬러를 페인트 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 그래픽스 컨텍스트
</DL>
</DD>
</DL>
<HR>

<A NAME="getComponent()"><!-- --></A> <H3>
getComponent</H3>
<PRE>
protected final <A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 내의 클래스">JTextComponent</A>  <B>getComponent</B>()</PRE>
<DL>
<DD>이 UI
 구현에 관련한 텍스트 컴퍼넌트를 취득합니다. 이것은, UI 가 인스톨 될 때까지 null 가 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>에디터 컴퍼넌트</DL>
</DD>
</DL>
<HR>

<A NAME="modelChanged()"><!-- --></A> <H3>
modelChanged</H3>
<PRE>
protected void <B>modelChanged</B>()</PRE>
<DL>
<DD>모델의 변경에 플래그를 세웁니다. 이 메서드는
 모델이 변경되면 불려 갑니다. 관련된 모델의 디폴트의 루트 요소를 나타내도록(듯이), 뷰 계층을 재구축 하기 위해서 구현됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setView(javax.swing.text.View)"><!-- --></A> <H3>
setView</H3>
<PRE>
protected final void <B>setView</B>(<A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 안의 클래스">View</A> &nbsp;v)</PRE>
<DL>
<DD>뷰 계층의 현재의 루트를 설정해, invalidate()를 호출합니다. 아이 컴퍼넌트가 있는 경우, 그것들은 삭제됩니다. 즉, 그것들은 뷰에 파묻힌 컴퍼넌트로부터 파생하고 있다고 보여집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>v</CODE> - 르트뷰</DL>
</DD>
</DL>
<HR>

<A NAME="paintSafely(java.awt.Graphics)"><!-- --></A> <H3>
paintSafely</H3>
<PRE>
protected void <B>paintSafely</B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 thread의 뷰로부터 모델이 변경되지 않는다고 하는 보증 첨부로 안전하게 인터페이스를 페인트 합니다. 이 메서드는
 후방에서 전방을 향해 렌더링 하면서 다음 일을 실행합니다. <ol> <li> 컴퍼넌트가 불투명과 마크 되고 있는 경우, 백그라운드는 컴퍼넌트의 현재의 백그라운드 컬러로 페인트 된다<li> 하이라이트 (존재하는 경우)가 페인트 된다<li> 뷰 계층이 페인트 된다<li> caret가 페인트 된다 </ol>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 그래픽스 컨텍스트
</DL>
</DD>
</DL>
<HR>

<A NAME="installUI(javax.swing.JComponent)"><!-- --></A> <H3>
installUI</H3>
<PRE>
public void <B>installUI</B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>컴퍼넌트의 UI를
 인스톨 합니다. 이 메서드는
 다음 일을 실행합니다. <ol> <li> 관련된 컴퍼넌트를 불투명하게 설정한다. 이것은 가장 일반적인 경우이며, 서브 클래스에서 또는 JTextComponent 로 직접 간단하게 변경할 수 있다. 이것에
해, 컴퍼넌트의 백그라운드 컬러가 페인트 된다<li> 관련된 컴퍼넌트에 디폴트의 caret 및 하이 라이터를 인스톨 한다<li> 에디터 및 모델에 접속한다. 모델이 없는 경우는
 디폴트의 모델을 작성한다<li> 모델을 나타내기 위해서 사용되는 뷰파크트리 및 뷰 계층을 작성한다 </ol>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#installUI(javax.swing.JComponent)">installUI</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 에디터 컴퍼넌트<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/ComponentUI.html#installUI(javax.swing.JComponent)"><CODE>ComponentUI.installUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="uninstallUI(javax.swing.JComponent)"><!-- --></A> <H3>
uninstallUI</H3>
<PRE>
public void <B>uninstallUI</B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>컴퍼넌트의 UI를
 언인스톨합니다. 이 메서드는
 리스너의 삭제, 하이 라이터의 언인스톨, 뷰의 삭제를 실시해, 키 맵을 무효로 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#uninstallUI(javax.swing.JComponent)">uninstallUI</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 에디터 컴퍼넌트<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/ComponentUI.html#uninstallUI(javax.swing.JComponent)"><CODE>ComponentUI.uninstallUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="update(java.awt.Graphics, javax.swing.JComponent)"><!-- --></A> <H3>
update</H3>
<PRE>
public void <B>update</B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g,
                   <A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>슈퍼 클래스는 제어 불가능한 방법으로 백그라운드를 페인트 합니다. 즉, 이미지를 백그라운드에 타일링 합니다. 이것이 2 번 행해지지 않게 하기 위해서는
 이 메서드를 다시 구현해 페인트만을 실시합니다.
 <p>
주: 또, 디폴트의 렌더링의 경우는 문제 없습니다만, 슈퍼 클래스의 경우는 백그라운드 렌더링시에 thread 세이프가 아닙니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#update(java.awt.Graphics, javax.swing.JComponent)">update</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DD><CODE>c</CODE> - 페인트 되는 컴퍼넌트. 이 인수는 자주 무시되지만, UI 오브젝트가 상태없이 복수의 컴퍼넌트에 공유되는 경우에 사용되는 일이 있는<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/ComponentUI.html#paint(java.awt.Graphics, javax.swing.JComponent)"><CODE>ComponentUI.paint(java.awt.Graphics, javax.swing.JComponent)</CODE></A>,
 
<A HREF="../../../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)"><CODE>JComponent.paintComponent(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paint(java.awt.Graphics, javax.swing.JComponent)"><!-- --></A> <H3>
paint</H3>
<PRE>
public final void <B>paint</B>(<A HREF="../../../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g,
                        <A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>인터페이스를 페인트 합니다. 이 메서드는
 렌더링시에 이 thread의 뷰로부터 모델이 변경되지 않는다고 하는 보증아래에 paintSafely 메서드에 보내집니다 (관련 모델이 AbstractDocument 로부터 나타나는 경우). 이것에
해, 모델이 비동기에 갱신되도록 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#paint(java.awt.Graphics, javax.swing.JComponent)">paint</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 그래픽스 컨텍스트
<DD><CODE>c</CODE> - 에디터 컴퍼넌트<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/ComponentUI.html#update(java.awt.Graphics, javax.swing.JComponent)"><CODE>ComponentUI.update(java.awt.Graphics, javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredSize(javax.swing.JComponent)"><!-- --></A> <H3>
getPreferredSize</H3>
<PRE>
public <A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getPreferredSize</B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>에디터 컴퍼넌트의 적절한 사이즈를 취득합니다. 이 요구의 수신전에 컴퍼넌트의 사이즈가 지정되고 있는 경우, 뷰 계층의 적절한 사이즈를 요구하기 전에
 컴퍼넌트의 사이즈를 반영하도록 뷰 계층의 사이즈가 설정됩니다. 이것에
해, 서식 첨부 뷰는
 요구의 응답전에 현재의 컴퍼넌트의 사이즈에 서식 설정됩니다. 다른 뷰는
 현재의 서식 설정되어 있는 사이즈를 무시해, 어느 쪽의 경우에서도 같은 응답을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#getPreferredSize(javax.swing.JComponent)">getPreferredSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 에디터 컴퍼넌트
<DT><B>반환값:</B><DD>사이즈<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/JComponent.html#getPreferredSize()"><CODE>JComponent.getPreferredSize()</CODE></A>,
 
<A HREF="../../../../java/awt/LayoutManager.html#preferredLayoutSize(java.awt.Container)"><CODE>LayoutManager.preferredLayoutSize(java.awt.Container)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumSize(javax.swing.JComponent)"><!-- --></A> <H3>
getMinimumSize</H3>
<PRE>
public <A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMinimumSize</B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>에디터 컴퍼넌트의 최소 사이즈를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#getMinimumSize(javax.swing.JComponent)">getMinimumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 에디터 컴퍼넌트
<DT><B>반환값:</B><DD>사이즈<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/JComponent.html#getMinimumSize()"><CODE>JComponent.getMinimumSize()</CODE></A>,
 
<A HREF="../../../../java/awt/LayoutManager.html#minimumLayoutSize(java.awt.Container)"><CODE>LayoutManager.minimumLayoutSize(java.awt.Container)</CODE></A>,
 
<A HREF="../../../../javax/swing/plaf/ComponentUI.html#getPreferredSize(javax.swing.JComponent)"><CODE>ComponentUI.getPreferredSize(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize(javax.swing.JComponent)"><!-- --></A> <H3>
getMaximumSize</H3>
<PRE>
public <A HREF="../../../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMaximumSize</B>(<A HREF="../../../../javax/swing/JComponent.html" title="javax.swing 안의 클래스">JComponent</A> &nbsp;c)</PRE>
<DL>
<DD>에디터 컴퍼넌트의 최대 사이즈를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/ComponentUI.html#getMaximumSize(javax.swing.JComponent)">getMaximumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 에디터 컴퍼넌트
<DT><B>반환값:</B><DD>사이즈<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/JComponent.html#getMaximumSize()"><CODE>JComponent.getMaximumSize()</CODE></A>,
 
<A HREF="../../../../java/awt/LayoutManager2.html#maximumLayoutSize(java.awt.Container)"><CODE>LayoutManager2.maximumLayoutSize(java.awt.Container)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleEditorRect()"><!-- --></A> <H3>
getVisibleEditorRect</H3>
<PRE>
protected <A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getVisibleEditorRect</B>()</PRE>
<DL>
<DD>루트 View 로 지정하는 할당을 취득합니다. 계층 이벤트세트의 관계로 이 메서드에는 적절하지 않은 이름이 붙어 있습니다. 돌려주고지는 Rectangle는
 가시성과는 전혀 관계가 없습니다. 이 변환을 계산하기 위해서, 컴퍼넌트는 제로가 아닌 정의 사이즈를 가질 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>르트뷰의 바운딘그복스</DL>
</DD>
</DL>
<HR>

<A NAME="modelToView(javax.swing.text.JTextComponent, int)"><!-- --></A> <H3>
modelToView</H3>
<PRE>
public <A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>modelToView</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
                             int&nbsp;pos)
                      throws <A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 내의 클래스">BadLocationException</A> </PRE>
<DL>
<DD>모델내의 지정된 위치를, 뷰 좌표 체계내의 장소로 변환합니다. 이 변환을 계산하기 위해서, 컴퍼넌트는 제로가 아닌 정의 사이즈를 가질 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#modelToView(javax.swing.text.JTextComponent, int)">modelToView</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트<DD><CODE>pos</CODE> - 변환 대상의 모델내에서의 로컬 위치 &gt;= 0
<DT><B>반환값:</B><DD>구형의 좌표. 모델이 페인트되어 있지 않은 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 안의 클래스">BadLocationException</A> </CODE> - 지정된 위치가, 관련된 문서내의 유효한 위치를 나타내지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#modelToView(javax.swing.text.JTextComponent, int)"><CODE>TextUI.modelToView(javax.swing.text.JTextComponent, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="modelToView(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias)"><!-- --></A> <H3>
modelToView</H3>
<PRE>
public <A HREF="../../../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>modelToView</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
                             int&nbsp;pos,
                             <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;bias)
                      throws <A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 내의 클래스">BadLocationException</A> </PRE>
<DL>
<DD>모델내의 지정된 위치를, 뷰 좌표 체계내의 장소로 변환합니다. 이 변환을 계산하기 위해서, 컴퍼넌트는 제로가 아닌 정의 사이즈를 가질 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#modelToView(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias)">modelToView</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트<DD><CODE>pos</CODE> - 변환 대상의 모델내에서의 로컬 위치 &gt;= 0
<DT><B>반환값:</B><DD>구형의 좌표. 모델이 페인트되어 있지 않은 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 안의 클래스">BadLocationException</A> </CODE> - 지정된 위치가, 관련된 문서내의 유효한 위치를 나타내지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#modelToView(javax.swing.text.JTextComponent, int)"><CODE>TextUI.modelToView(javax.swing.text.JTextComponent, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="viewToModel(javax.swing.text.JTextComponent, java.awt.Point)"><!-- --></A> <H3>
viewToModel</H3>
<PRE>
public int <B>viewToModel</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
                       <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt)</PRE>
<DL>
<DD>뷰 좌표 체계내의 지정된 위치를, 모델내의 가장 가까운 장소로 변환합니다. 이 변환을 계산하기 위해서, 컴퍼넌트는 제로가 아닌 정의 사이즈를 가질 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point)">viewToModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트<DD><CODE>pt</CODE> - 변환 대상의 뷰의 좌표계에서의 위치. 이 경우의 좌표계는
 마우스 이벤트와 같은 좌표계가 아니면 안된다
<DT><B>반환값:</B><DD>문서의 선두로부터의 오프셋(offset) &gt;= 0. 페인트되어 있지 않은 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point)"><CODE>TextUI.viewToModel(javax.swing.text.JTextComponent, java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="viewToModel(javax.swing.text.JTextComponent, java.awt.Point, javax.swing.text.Position.Bias[])"><!-- --></A> <H3>
viewToModel</H3>
<PRE>
public int <B>viewToModel</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
                       <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt,
                       <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> []&nbsp;biasReturn)</PRE>
<DL>
<DD>뷰 좌표 체계내의 지정된 위치를, 모델내의 가장 가까운 장소로 변환합니다. 이 변환을 계산하기 위해서, 컴퍼넌트는 제로가 아닌 정의 사이즈를 가질 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point, javax.swing.text.Position.Bias[])">viewToModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트<DD><CODE>pt</CODE> - 변환 대상의 뷰의 좌표계에서의 위치. 이 경우의 좌표계는
 마우스 이벤트와 같은 좌표계가 아니면 안되는<DD><CODE>biasReturn</CODE> - 지정된 점이 모델의 전의 문자, 혹은 다음의 문자에 가까운 것인지를 나타내기 위해서, 이 메서드에
해 기입해진다
<DT><B>반환값:</B><DD>문서의 선두로부터의 오프셋(offset) &gt;= 0. 컴퍼넌트가 아직 정의 사이즈를 가지고 있지 않은 경우는 -1<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#viewToModel(javax.swing.text.JTextComponent, java.awt.Point)"><CODE>TextUI.viewToModel(javax.swing.text.JTextComponent, java.awt.Point)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNextVisualPositionFrom(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias, int, javax.swing.text.Position.Bias[])"><!-- --></A> <H3>
getNextVisualPositionFrom</H3>
<PRE>
public int <B>getNextVisualPositionFrom</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
                                     int&nbsp;pos,
                                     <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;b,
                                     int&nbsp;direction,
                                     <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> []&nbsp;biasRet)
                              throws <A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 내의 클래스">BadLocationException</A> </PRE>
<DL>
<DD>caret가 배치될 가능성이 있는
 시각적으로 나타내진 다음의 모델 위치를 결정하는 수단을 제공합니다. 뷰에 따라서는
 가시가 아닌지, 모델내와 같은 순서가 아닌지, 또는 모델내의 위치에의 액세스를 허가하지 않는 경우가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#getNextVisualPositionFrom(javax.swing.text.JTextComponent, int, javax.swing.text.Position.Bias, int, javax.swing.text.Position.Bias[])">getNextVisualPositionFrom</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pos</CODE> - 변환 대상의 위치 &gt;= 0<DD><CODE>b</CODE> - 렌더링를 위해서 할당할 수 있었던 영역<DD><CODE>direction</CODE> - 키보드상에 보통
 있는 커서 키라고 볼 수가 있는
 현재의 위치로부터의 방향. SwingConstants.WEST, SwingConstants.EAST, SwingConstants.NORTH, 또는 SwingConstants.SOUTH
<DT><B>반환값:</B><DD>다음의 가시의 위치를 가장 자주 나타내는 모델내의 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../javax/swing/text/BadLocationException.html" title="javax.swing.text 안의 클래스">BadLocationException</A> </CODE> - @exception IllegalArgumentException 방향이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="damageRange(javax.swing.text.JTextComponent, int, int)"><!-- --></A> <H3>
damageRange</H3>
<PRE>
public void <B>damageRange</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc,
                        int&nbsp;p0,
                        int&nbsp;p1)</PRE>
<DL>
<DD>모델의 지정된 부분에 대응하는 뷰의 부분이 페인트 다시 합니다. 뷰가 현재 페인트되어 있지 않은 경우는 아무것도 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#damageRange(javax.swing.text.JTextComponent, int, int)">damageRange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트<DD><CODE>p0</CODE> - 범위의 시점 &gt;= 0<DD><CODE>p1</CODE> - 범위의 종점 &gt;= p0<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#damageRange(javax.swing.text.JTextComponent, int, int)"><CODE>TextUI.damageRange(javax.swing.text.JTextComponent, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="damageRange(javax.swing.text.JTextComponent, int, int, javax.swing.text.Position.Bias, javax.swing.text.Position.Bias)"><!-- --></A> <H3>
damageRange</H3>
<PRE>
public void <B>damageRange</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
                        int&nbsp;p0,
                        int&nbsp;p1,
                        <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;p0Bias,
                        <A HREF="../../../../javax/swing/text/Position.Bias.html" title="javax.swing.text 안의 클래스">Position.Bias</A> &nbsp;p1Bias)</PRE>
<DL>
<DD>모델내의 지정된 일부분에 대응하는 뷰의 부분이 렌더링 다시 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#damageRange(javax.swing.text.JTextComponent, int, int, javax.swing.text.Position.Bias, javax.swing.text.Position.Bias)">damageRange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p0</CODE> - 범위의 시점 &gt;= 0<DD><CODE>p1</CODE> - 범위의 종점 &gt;= p0</DL>
</DD>
</DL>
<HR>

<A NAME="getEditorKit(javax.swing.text.JTextComponent)"><!-- --></A> <H3>
getEditorKit</H3>
<PRE>
public <A HREF="../../../../javax/swing/text/EditorKit.html" title="javax.swing.text 내의 클래스">EditorKit</A>  <B>getEditorKit</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc)</PRE>
<DL>
<DD>UI
 EditorKit를
 취득합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#getEditorKit(javax.swing.text.JTextComponent)">getEditorKit</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트
<DT><B>반환값:</B><DD>에디터 기능<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#getEditorKit(javax.swing.text.JTextComponent)"><CODE>TextUI.getEditorKit(javax.swing.text.JTextComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRootView(javax.swing.text.JTextComponent)"><!-- --></A> <H3>
getRootView</H3>
<PRE>
public <A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A>  <B>getRootView</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;tc)</PRE>
<DL>
<DD>모델이 공간적으로 어떻게 표현되고 있는지를 판정하기 위해서 암벽 횡단 할 수 있는
 관련한 텍스트 컴퍼넌트 (즉 계층 루트)를 할당할 수 있었던 View를
 취득합니다.
 <p>
<font color=red><b>주:</b> View 계층은 르트뷰로부터 암벽 횡단 할 수가 있어 다른 일도 이와 같이 할 수 있습니다. 이와 같이 행해졌던 것은, TextUI를
 통한 단순한 메서드 호출과 같이 보호할 수가 없습니다. 따라서, 병행성을 생각되는 적절한 조작은, 이 메서드를 호출하는 논리로 처리를 하도록 할 필요가 있습니다. </font>
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#getRootView(javax.swing.text.JTextComponent)">getRootView</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 이 UI 가 인스톨 되고 있는 텍스트 컴퍼넌트
<DT><B>반환값:</B><DD>뷰<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/plaf/TextUI.html#getRootView(javax.swing.text.JTextComponent)"><CODE>TextUI.getRootView(javax.swing.text.JTextComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText(javax.swing.text.JTextComponent, java.awt.Point)"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>(<A HREF="../../../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A> &nbsp;t,
                             <A HREF="../../../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;pt)</PRE>
<DL>
<DD>건네받은 위치에서 툴 힌트로서 사용되는 캐릭터 라인을 돌려줍니다. 루트 View 에 메서드를 전송 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html" title="javax.swing.plaf 내의 클래스">TextUI</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/plaf/TextUI.html#getToolTipText(javax.swing.text.JTextComponent, java.awt.Point)">getToolTipText</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/text/JTextComponent.html#getToolTipText(java.awt.event.MouseEvent)"><CODE>JTextComponent.getToolTipText(java.awt.event.MouseEvent)</CODE></A>,
 
<A HREF="../../../../javax/swing/text/View.html#getToolTipText(float, float, java.awt.Shape)"><CODE>View.getToolTipText(float, float, java.awt.Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="create(javax.swing.text.Element)"><!-- --></A> <H3>
create</H3>
<PRE>
public <A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A>  <B>create</B>(<A HREF="../../../../javax/swing/text/Element.html" title="javax.swing.text 안의 인터페이스">Element</A> &nbsp;elem)</PRE>
<DL>
<DD>요소의 뷰를 작성합니다. 뷰를 작성하는 팩토리를 서브 클래스에 직접 구현하려면,
 이 메서드를 다시 구현할 필요가 있습니다. 디폴트에서는
 요소를 나타내지 못하는 것을 나타내는 null를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../javax/swing/text/ViewFactory.html" title="javax.swing.text 내의 인터페이스">ViewFactory</A> </CODE> 내의 <CODE><A HREF="../../../../javax/swing/text/ViewFactory.html#create(javax.swing.text.Element)">create</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>elem</CODE> - 요소
<DT><B>반환값:</B><DD>뷰<DT><B>관련 항목:</B><DD><A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스"><CODE>View</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="create(javax.swing.text.Element, int, int)"><!-- --></A> <H3>
create</H3>
<PRE>
public <A HREF="../../../../javax/swing/text/View.html" title="javax.swing.text 내의 클래스">View</A>  <B>create</B>(<A HREF="../../../../javax/swing/text/Element.html" title="javax.swing.text 안의 인터페이스">Element</A> &nbsp;elem,
                   int&nbsp;p0,
                   int&nbsp;p1)</PRE>
<DL>
<DD>요소의 뷰를 작성합니다. 뷰를 작성하는 팩토리를 서브 클래스에 직접 구현하려면,
 이 메서드를 다시 구현할 필요가 있습니다. 디폴트에서는
 요소의 부분을 표현할 수 없는 것을 나타내는 null를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>elem</CODE> - 요소<DD><CODE>p0</CODE> - 개시 오프셋(offset) &gt;= 0<DD><CODE>p1</CODE> - 종료 오프셋(offset) &gt;= p0
<DT><B>반환값:</B><DD>뷰</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BasicTextUI.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../javax/swing/plaf/basic/BasicTextPaneUI.html" title="javax.swing.plaf.basic 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/plaf/basic/BasicTextUI.BasicCaret.html" title="javax.swing.plaf.basic 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?javax/swing/plaf/basic/BasicTextUI.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="BasicTextUI.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:04:16 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
JComponent (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.swing.JComponent class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="JComponent (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JComponent.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/swing/JComboBox.KeySelectionManager.html" title="javax.swing 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/swing/JComponent.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="JComponent.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.swing</FONT>
<BR>
클래스 JComponent</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">java.awt.Component</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">java.awt.Container</A> 
          <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.swing.JComponent</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 내의 인터페이스">ImageObserver</A>,
 <A HREF="../../java/awt/MenuContainer.html" title="java.awt 안의 인터페이스">MenuContainer</A>,
 <A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../javax/swing/AbstractButton.html" title="javax.swing 내의 클래스">AbstractButton</A>,
 <A HREF="../../javax/swing/plaf/basic/BasicInternalFrameTitlePane.html" title="javax.swing.plaf.basic 안의 클래스">BasicInternalFrameTitlePane</A>,
 <A HREF="../../javax/swing/Box.html" title="javax.swing 안의 클래스">Box</A>,
 <A HREF="../../javax/swing/Box.Filler.html" title="javax.swing 안의 클래스">Box.Filler</A>,
 <A HREF="../../javax/swing/JColorChooser.html" title="javax.swing 안의 클래스">JColorChooser</A>,
 <A HREF="../../javax/swing/JComboBox.html" title="javax.swing 안의 클래스">JComboBox</A>,
 <A HREF="../../javax/swing/JFileChooser.html" title="javax.swing 안의 클래스">JFileChooser</A>,
 <A HREF="../../javax/swing/JInternalFrame.html" title="javax.swing 안의 클래스">JInternalFrame</A>,
 <A HREF="../../javax/swing/JInternalFrame.JDesktopIcon.html" title="javax.swing 안의 클래스">JInternalFrame.JDesktopIcon</A>,
 <A HREF="../../javax/swing/JLabel.html" title="javax.swing 안의 클래스">JLabel</A>,
 <A HREF="../../javax/swing/JLayeredPane.html" title="javax.swing 안의 클래스">JLayeredPane</A>,
 <A HREF="../../javax/swing/JList.html" title="javax.swing 안의 클래스">JList</A>,
 <A HREF="../../javax/swing/JMenuBar.html" title="javax.swing 안의 클래스">JMenuBar</A>,
 <A HREF="../../javax/swing/JOptionPane.html" title="javax.swing 안의 클래스">JOptionPane</A>,
 <A HREF="../../javax/swing/JPanel.html" title="javax.swing 안의 클래스">JPanel</A>,
 <A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A>,
 <A HREF="../../javax/swing/JProgressBar.html" title="javax.swing 안의 클래스">JProgressBar</A>,
 <A HREF="../../javax/swing/JRootPane.html" title="javax.swing 안의 클래스">JRootPane</A>,
 <A HREF="../../javax/swing/JScrollBar.html" title="javax.swing 안의 클래스">JScrollBar</A>,
 <A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 안의 클래스">JScrollPane</A>,
 <A HREF="../../javax/swing/JSeparator.html" title="javax.swing 안의 클래스">JSeparator</A>,
 <A HREF="../../javax/swing/JSlider.html" title="javax.swing 안의 클래스">JSlider</A>,
 <A HREF="../../javax/swing/JSpinner.html" title="javax.swing 안의 클래스">JSpinner</A>,
 <A HREF="../../javax/swing/JSplitPane.html" title="javax.swing 안의 클래스">JSplitPane</A>,
 <A HREF="../../javax/swing/JTabbedPane.html" title="javax.swing 안의 클래스">JTabbedPane</A>,
 <A HREF="../../javax/swing/JTable.html" title="javax.swing 안의 클래스">JTable</A>,
 <A HREF="../../javax/swing/table/JTableHeader.html" title="javax.swing.table 안의 클래스">JTableHeader</A>,
 <A HREF="../../javax/swing/text/JTextComponent.html" title="javax.swing.text 안의 클래스">JTextComponent</A>,
 <A HREF="../../javax/swing/JToolBar.html" title="javax.swing 안의 클래스">JToolBar</A>,
 <A HREF="../../javax/swing/JToolTip.html" title="javax.swing 안의 클래스">JToolTip</A>,
 <A HREF="../../javax/swing/JTree.html" title="javax.swing 안의 클래스">JTree</A>,
 <A HREF="../../javax/swing/JViewport.html" title="javax.swing 안의 클래스">JViewport</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>JComponent</B><DT>extends <A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
톱 레벨의 컨테이너를 제외한 모든 Swing 컴퍼넌트의 base class입니다. <code>JComponent</code> 로부터 상속하는 컴퍼넌트를 사용하려면,
 루트가 톱 레벨의 Swing 컨테이너인 포함 관계의 계층에 컴퍼넌트를 자리 매김을 할 필요가 있습니다. <code>JFrame</code>,<code>JDialog</code>,<code>JApplet</code> 등의 톱 레벨의 Swing 컨테이너는
 다른 Swing 컴퍼넌트가 그것 자신을 렌더링하기 위한 장소를 제공하는 특수한 컴퍼넌트입니다. 포함 관계의 계층에 대해서는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/overview/hierarchy.html">「Swing Components and the Containment Hierarchy」</a>를 참조하십시오.

 <p>
<code>JComponent</code> 클래스는 이하의 기능을 제공합니다. <ul> <li>Swing 아키텍쳐를 사용하는
 표준 컴퍼넌트 및 커스텀 컴퍼넌트 양쪽 모두의 base class<li>프로그래머가 지정, 또는 옵션으로 유저가 실행시에 선택할 수 있는 「플러그 인 가능한 Look & Feel (L&F)」. 각 컴퍼넌트의 Look & Feel는
 「UI 위양」, 즉 <A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A>  로부터 파생하는 오브젝트로 제공된다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/plaf.html">「How to Set the Look and Feel」</a>를 참조<li>포괄적인 키스트로크(keystroke) 처리. 상세한 것에 대하여는
 「The Swing Connection」의<a href="http://java.sun.com/products/jfc/tsc/special_report/kestrel/keybindings.html">「Keyboard Bindings in Swing」</a>를 참조<li>툴 힌트의 서포트. 툴 힌트는 커서가 컴퍼넌트상에 있을 때 표시되는 짧은 설명. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html">「How to Use Tool Tips」</a>를 참조<em></em><li>유저 보조 기능의 서포트. <code>JComponent</code>는
 인터페이스 <code>Accessible</code> 에 모든 메서드를 포함하지만, 인터페이스를 실제로는 구현하지 않는다. 구현은 <code>JComponent</code>를
 확장하는 개개의 클래스에
존<li>컴퍼넌트 고유의 프로퍼티의 서포트. <A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)"><CODE>putClientProperty(java.lang.Object, java.lang.Object)</CODE></A>  와 <A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)"><CODE>getClientProperty(java.lang.Object)</CODE></A> 
 메서드의 경우, 이름과 오브젝트의 페어를 <code>JComponent</code> 로부터 파생하는 어느 오브젝트에도 관련짓는 것이 가능<li>더블 버퍼링과 보더의 서포트에 대응하고 있는
 페인트를 위한 인프라스트럭쳐. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/overview/draw.html">「Painting」라고</a> <a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/border.html">「How to Use Borders」</a>를 참조<em></em>
</ul>
 상기의 기능의 상세한 것에 대하여는
<a href="package-summary.html#package_description">Swing 패키지의 설명</a>과 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/jcomponent.html">「The JComponent Class」</a>를 참조하십시오. <em></em>
 <p>
<code>JComponent</code> 와 그 서브 클래스는
 특정의 프로퍼티의 디폴트치를 문서화합니다. 예를 들어,<code>JTable</code>는
 디폴트의 행의 높이를 16 으로서 문서화합니다. <code>ComponentUI</code>를
 가지는 <code>JComponent</code>
 각 서브 클래스는
<code>ComponentUI</code>를
 그 생성자 일부로서 생성합니다. 각 <code>ComponentUI</code> 에서는
 특수한 Look & Feel를
 제공하기 위해서, 생성원의 <code>JComponent</code> 로 프로퍼티를 다시 설정하는 일이 있습니다. 예를 들어, 커스텀의 Look & Feel 에서는
<code>JTable</code>
 행의 높이를 24 로 할 필요가 있습니다. 문서화 된 디폴트는
<code>ComponentUI</code>를
 인스톨 하기 전의 프로퍼티의 값입니다. 특정의 프로퍼티에 특정의 값이 필요한 경우는
 그것을 명시적으로 설정해 주세요.
 <p>
릴리스 1.4 에서는
 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오.
 <p>
<strong>경고:</strong> 이 클래스의 직렬화 된 오브젝트는
 향후의 Swing 릴리스와 호환은 아니게 될 예정입니다. 현재의 직렬화의 서포트는
 단기간의 운용이나, 같은 버젼의 Swing를
 실행하는 어플리케이션간의 RMI 에 적절하고 있습니다. JDK 버젼 1.4 이후, 모든 JavaBeans<sup><font size="-2">&trade;</font></sup>
 장기간의 운용 서포트는
<code>java.beans</code> 패키지에 추가되고 있습니다. 자세한 것은,<A HREF="../../java/beans/XMLEncoder.html" title="java.beans 안의 클래스"><CODE>XMLEncoder</CODE></A> 를
 참조하십시오.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스"><CODE>KeyStroke</CODE></A>,
 
<A HREF="../../javax/swing/Action.html" title="javax.swing 안의 인터페이스"><CODE>Action</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A>,
 
<A HREF="../../javax/swing/JOptionPane.html" title="javax.swing 안의 클래스"><CODE>JOptionPane</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)"><CODE>setDebugGraphicsOptions(int)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)"><CODE>setToolTipText(java.lang.String)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)"><CODE>setAutoscrolls(boolean)</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 안의 클래스">JComponent.AccessibleJComponent</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;유저 보조 기능의 디폴트 서포트의 제공에 사용하는 JComponent
 내부 클래스입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="nested_classes_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 중첩(Nested) 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.AccessibleAWTContainer.html" title="java.awt 안의 클래스">Container.AccessibleAWTContainer</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<A NAME="nested_classes_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 중첩(Nested) 클래스/인터페이스</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.AccessibleAWTComponent.html" title="java.awt 안의 클래스">Component.AccessibleAWTComponent</A>,
 <A HREF="../../java/awt/Component.BltBufferStrategy.html" title="java.awt 안의 클래스">Component.BltBufferStrategy</A>,
 <A HREF="../../java/awt/Component.FlipBufferStrategy.html" title="java.awt 안의 클래스">Component.FlipBufferStrategy</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#accessibleContext">accessibleContext</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code> 입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/event/EventListenerList.html" title="javax.swing.event 내의 클래스">EventListenerList</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#listenerList">listenerList</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 이벤트 리스너 리스트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY">TOOL_TIP_TEXT_KEY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;커서가 컴퍼넌트상에 있을 때 표시되는 코멘트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#ui">ui</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel 위양입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#UNDEFINED_CONDITION">UNDEFINED_CONDITION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;몇개의 API 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction()</code> 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_FOCUSED">WHEN_FOCUSED</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction</code> 로 사용되는 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#WHEN_IN_FOCUSED_WINDOW">WHEN_IN_FOCUSED_WINDOW</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>registerKeyboardAction()</code> 로 사용되는 정수입니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#BOTTOM_ALIGNMENT">BOTTOM_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#CENTER_ALIGNMENT">CENTER_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#LEFT_ALIGNMENT">LEFT_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#RIGHT_ALIGNMENT">RIGHT_ALIGNMENT</A>,
 <A HREF="../../java/awt/Component.html#TOP_ALIGNMENT">TOP_ALIGNMENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ImageObserver"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt.image. <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/image/ImageObserver.html#ABORT">ABORT</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#ALLBITS">ALLBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#ERROR">ERROR</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#FRAMEBITS">FRAMEBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#HEIGHT">HEIGHT</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#PROPERTIES">PROPERTIES</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#SOMEBITS">SOMEBITS</A>,
 <A HREF="../../java/awt/image/ImageObserver.html#WIDTH">WIDTH</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#JComponent()">JComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 <code>JComponent</code> 생성자
입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)">addAncestorListener</A> </B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>listener</code>를
 등록해, 컴퍼넌트 또는 게다가 위오브젝트가 이동하든가, 혹은 가시 또는 불가시가 될 때 그 리스너가 <code>AncestorEvent</code>를
 받아들이도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addNotify()">addNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 현재친컴퍼넌트가 있는 것을, 이 컴퍼넌트에 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)">addVetoableChangeListener</A> </B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VetoableChangeListener</code>를
 리스너 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#computeVisibleRect(java.awt.Rectangle)">computeVisibleRect</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Component</code>
 「가시 구형」을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#contains(int, int)">contains</A> </B>(int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마우스 처리를 위해서, 이 컴퍼넌트의 정확한 형상을 정의할 기회를 UI 위양에 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JToolTip.html" title="javax.swing 내의 클래스">JToolTip</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#createToolTip()">createToolTip</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;툴 힌트를 표시하기 위해서 사용되는 <code>JToolTip</code>
 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#disable()">disable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#enable()">enable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   boolean&nbsp;oldValue,
                   boolean&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 서포트합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   char&nbsp;oldValue,
                   char&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바운드 프로퍼티의 변경을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   int&nbsp;oldValue,
                   int&nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;정수형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 서포트합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)">fireVetoableChange</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;oldValue,
                   <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;newValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제약 프로퍼티의 변경의 보고를 서포트합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAccessibleContext()">getAccessibleContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code>을
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 내의 인터페이스">ActionListener</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getActionForKeyStroke(javax.swing.KeyStroke)">getActionForKeyStroke</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키스트로크(keystroke)에 대해서 등록되어 있는 액션을 실행하는 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 내의 클래스">ActionMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getActionMap()">getActionMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;특정의 <code>KeyStroke</code> 바인딩에 대해서 트리거 하는 <code>Action</code>
 지정에 사용되는 <code>ActionMap</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAlignmentX()">getAlignmentX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Container.getAlignmentX</code>를
 오버라이드(override) 해, 수직의 배치 방법을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAlignmentY()">getAlignmentY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Container.getAlignmentY</code>를
 오버라이드(override) 해, 수평의 배치 방법을 돌려주도록(듯이) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 내의 인터페이스">AncestorListener</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAncestorListeners()">getAncestorListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 등록되어 모든 상위 리스너의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getAutoscrolls()">getAutoscrolls</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoscrolls</code> 프로퍼티를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스">Border</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBorder()">getBorder</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 보더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getBounds(java.awt.Rectangle)">getBounds</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 경계를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)">getClientProperty</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 키를 가지는 프로퍼티의 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)">getComponentGraphics</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트를 페인트 하기 위해서 사용되는 그래픽스 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 내의 클래스">JPopupMenu</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()">getComponentPopupMenu</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getConditionForKeyStroke(javax.swing.KeyStroke)">getConditionForKeyStroke</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록되어 있는 액션이, 지정된 키스트로크(keystroke)에 반응해 발생할지 어떨지를 결정하는 조건을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getDebugGraphicsOptions()">getDebugGraphicsOptions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그래픽의 디버그 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()">getDefaultLocale</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 JComponent
 로케일 프로퍼티를 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Font</code>
 <code>FontMetrics</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getGraphics()">getGraphics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 그래픽스 컨텍스트
을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getHeight()">getHeight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 현재의 높이를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInheritsPopupMenu()">getInheritsPopupMenu</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JPopupMenu 가 부모로부터 상속되는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputMap()">getInputMap</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputMap(int)">getInputMap</A> </B>(int&nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>condition</code> 로 사용되고 있는 <code>InputMap</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스">InputVerifier</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInputVerifier()">getInputVerifier</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 입력 베리파이아를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInsets()">getInsets</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트로 보더가 설정되어 있는 경우는 보더의 인 세트를 돌려주고, 그렇지 않은 경우는 <code>super.getInsets</code>를
 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getInsets(java.awt.Insets)">getInsets</A> </B>(<A HREF="../../java/awt/Insets.html" title="java.awt 안의 클래스">Insets</A> &nbsp;insets)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 인 세트치를 포함하는 <code>Insets</code> 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 내의 인터페이스">EventListener</A> &gt; 
<BR>
T[]</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getListeners(java.lang.Class)">getListeners</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;T&gt;&nbsp;listenerType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 <code><em>Foo</em>Listener</code> 로서 현재 등록되어 모든 오브젝트의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getLocation(java.awt.Point)">getLocation</A> </B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 원점의 x, y 좌표를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getMaximumSize()">getMaximumSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최대 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getMinimumSize()">getMinimumSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최소 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()">getNextFocusableComponent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getPopupLocation(java.awt.event.MouseEvent)">getPopupLocation</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 좌표계에 pop-up menu를 표시하는데 적절한 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getPreferredSize()">getPreferredSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>preferredSize</code> 가 <code>null</code> 이외의 값으로 설정되어 있는 경우에 그 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스">KeyStroke</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getRegisteredKeyStrokes()">getRegisteredKeyStrokes</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록되어 있는 액션을 개시하는 <code>KeyStroke</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/JRootPane.html" title="javax.swing 내의 클래스">JRootPane</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getRootPane()">getRootPane</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 <code>JRootPane</code> 상위 컴퍼넌트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getSize(java.awt.Dimension)">getSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;rv)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 폭과 높이를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipLocation(java.awt.event.MouseEvent)">getToolTipLocation</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 좌표계에 있어서의 툴 힌트의 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipText()">getToolTipText</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>setToolTipText</code> 로 설정되어 있는 툴 힌트의 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getToolTipText(java.awt.event.MouseEvent)">getToolTipText</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>event</i>
 툴 힌트로서 사용되는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getTopLevelAncestor()">getTopLevelAncestor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 톱 레벨의 상위 오브젝트 (포함처의 <code>Window</code> 또는 <code>Applet</code>)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스">TransferHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getTransferHandler()">getTransferHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transferHandler</code> 프로퍼티를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getUIClassID()">getUIClassID</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel를
 정의하는 <code>swing.plaf.ComponentUI</code> 클래스의 이름을 참조하기 위해서 사용되는 <code>UIDefaults</code> 키를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()">getVerifyInputWhenFocusTarget</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 포커스를 요구하기 전에
 현재의 포커스를 가지는 컴퍼넌트에 입력 베리파이아를 호출할지 어떨지를 나타내는 값을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 내의 인터페이스">VetoableChangeListener</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()">getVetoableChangeListeners</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 등록되어 모든 거부 가능 변경 리스너의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getVisibleRect()">getVisibleRect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Component</code>
 「가시 구형」을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getWidth()">getWidth</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 현재의 폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getX()">getX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 원점의 현재의 x 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#getY()">getY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 원점의 현재의 y 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#grabFocus()">grabFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 입력초점을 취득해, 이 컴퍼넌트의 최상정도 클래스의 윈도우에 포커스를 설정하는 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isDoubleBuffered()">isDoubleBuffered</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isLightweightComponent(java.awt.Component)">isLightweightComponent</A> </B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 경량의 경우, 즉 네이티브의 윈도우 시스템 피어를 가지지 않는 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isManagingFocus()">isManagingFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isOpaque()">isOpaque</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 완전하게 불투명한 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isOptimizedDrawingEnabled()">isOptimizedDrawingEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 그 아이를 타일링 하는 경우, 즉 자식이 오버랩 하지 않는 것이 보증되는 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isPaintingTile()">isPaintingTile</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 현재 타일을 페인트 하고 있는 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isRequestFocusEnabled()">isRequestFocusEnabled</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 가 포커스를 얻는
 경우는 <code>true</code>를
 돌려주고, 그렇지 않은 경우는 <code>false</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#isValidateRoot()">isValidateRoot</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드가 true를
 돌려주는 경우, 이 컴퍼넌트의 하위 컴퍼넌트에
해 <code>revalidate</code> 가 불려 가면, 이 루트로 시작되는 트리 전체가 검증됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)">paint</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 Swing 에
해 불려 가 컴퍼넌트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)">paintBorder</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 보더를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)">paintChildren</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 아이를 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)">paintComponent</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI 위양이 <code>null</code> 가 아닌 경우에
 UI 위양의 페인트 메서드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintImmediately(int, int, int, int)">paintImmediately</A> </B>(int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;w,
                 int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 지정된 영역 및 그 영역과 오버랩 하는 모든 하위 컴퍼넌트를 곧바로 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paintImmediately(java.awt.Rectangle)">paintImmediately</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 영역을 곧바로 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#paramString()">paramString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code>
 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)">print</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 인쇄하려면,
 이 메서드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printAll(java.awt.Graphics)">printAll</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 인쇄하려면,
 이 메서드를 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)">printBorder</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 보더를 인쇄합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)">printChildren</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 아이를 인쇄합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)">printComponent</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 인쇄 조작중에 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processComponentKeyEvent(java.awt.event.KeyEvent)">processComponentKeyEvent</A> </B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트 자체가 인식하는 키 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)">processKeyBinding</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                  <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                  int&nbsp;condition,
                  boolean&nbsp;pressed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>KeyEvent</code> <code>e</code>
 결과로서 <code>ks</code>
 키 바인드를 처리하기 위해서 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A> </B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이벤트를 처리하는 <code>processKeyEvent</code>를
 오버라이드(override) 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트로 발생하는 마우스 이벤트를, 등록되어 모든 <code>MouseListener</code> 오브젝트에 디스패치 하는 것으로써, 마우스 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A> </B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MouseEvent.MOUSE_DRAGGED 등의 마우스 모션 이벤트를 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)">putClientProperty</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key,
                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;임의의 키와 값을 조합한 클라이언트 프로퍼티를 이 컴퍼넌트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)">registerKeyboardAction</A> </B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                       <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                       int&nbsp;aCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)">registerKeyboardAction</A> </B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;aCommand,
                       <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                       int&nbsp;aCondition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)">removeAncestorListener</A> </B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>listener</code>
 등록을 해제해, 그 리스너가 <code>AncestorEvent</code>를
 받지 않게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeNotify()">removeNotify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 친컴퍼넌트가 없어진 것을, 이 컴퍼넌트에 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)">removeVetoableChangeListener</A> </B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>VetoableChangeListener</code>를
 리스너 리스트로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)">repaint</A> </B>(long&nbsp;tm,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 표시되고 있는 경우에
 지정된 영역을 더티 리젼 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#repaint(java.awt.Rectangle)">repaint</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트가 표시되고 있는 경우에
 지정된 영역을 더티 리젼 리스트에 추가합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestDefaultFocus()">requestDefaultFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocus()">requestFocus</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocus(boolean)">requestFocus</A> </B>(boolean&nbsp;temporary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()">requestFocusInWindow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)">requestFocusInWindow</A> </B>(boolean&nbsp;temporary)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#resetKeyboardActions()">resetKeyboardActions</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 제 1 층의 <code>InputMap</code> 와 <code>ActionMap</code>
 바인딩을 모두 등록 해제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#reshape(int, int, int, int)">reshape</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;w,
        int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 5 이후는
<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.
 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#revalidate()">revalidate</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지연 자동 레이아웃을 서포트합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#scrollRectToVisible(java.awt.Rectangle)">scrollRectToVisible</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;aRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>scrollRectToVisible()</code> 메세지를 <code>JComponent</code>
 부모에게 전송 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setActionMap(javax.swing.ActionMap)">setActionMap</A> </B>(<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스">ActionMap</A> &nbsp;am)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ActionMap</code>를
 <code>am</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)">setAlignmentX</A> </B>(float&nbsp;alignmentX)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;수직의 배치 방법을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)">setAlignmentY</A> </B>(float&nbsp;alignmentY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;수평의 배치 방법을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)">setAutoscrolls</A> </B>(boolean&nbsp;autoscrolls)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>autoscrolls</code> 프로퍼티를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setBackground(java.awt.Color)">setBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 백그라운드 컬러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)">setBorder</A> </B>(<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 안의 인터페이스">Border</A> &nbsp;border)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 보더를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)">setComponentPopupMenu</A> </B>(<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A> &nbsp;popup)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 에 대해서 <code>JPopupMenu</code>를
 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)">setDebugGraphicsOptions</A> </B>(int&nbsp;debugOptions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트, 또는 그 아이의 어떤 것인가로 실행되는 모든 그래픽 조작에 대한 진단 정보를 유효화 또는 무효화합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)">setDefaultLocale</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 각 JComponent
 로케일 프로퍼티를 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setDoubleBuffered(boolean)">setDoubleBuffered</A> </B>(boolean&nbsp;aFlag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 버퍼를 사용해 렌더링 할지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setEnabled(boolean)">setEnabled</A> </B>(boolean&nbsp;enabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 유효한가 어떤가를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A> </B>(int&nbsp;id,
                      <A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 내의 클래스">AWTKeyStroke</A> &gt;&nbsp;keystrokes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 지정된 호랑이 용기 조작에 대한 포커스 호랑이 용기 키를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setFont(java.awt.Font)">setFont</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 폰트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setForeground(java.awt.Color)">setForeground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;fg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 foreground 컬러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInheritsPopupMenu(boolean)">setInheritsPopupMenu</A> </B>(boolean&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트에 <code>JPopupMenu</code>를
 할당할 수 있지 않은 경우에 <code>getComponentPopupMenu</code> 가 부모에게 위양 될지 어떨지를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInputMap(int, javax.swing.InputMap)">setInputMap</A> </B>(int&nbsp;condition,
            <A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;map)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;조건 <code>condition</code> 로 사용하는 <code>InputMap</code>를
 <code>map</code> 로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)">setInputVerifier</A> </B>(<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 안의 클래스">InputVerifier</A> &nbsp;inputVerifier)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 입력 베리파이아를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;maximumSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 최대 사이즈를 정수치로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;minimumSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 최소 사이즈를 정수치로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)">setNextFocusableComponent</A> </B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;aComponent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)">setOpaque</A> </B>(boolean&nbsp;isOpaque)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;true
 경우, 컴퍼넌트는 그 경계내의 모든 픽셀을 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A> </B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;preferredSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 적절한 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)">setRequestFocusEnabled</A> </B>(boolean&nbsp;requestFocusEnabled)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>JComponent</code> 가 포커스를 취득할지 어떨지에 대한 힌트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setToolTipText(java.lang.String)">setToolTipText</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;text)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;툴 힌트에 표시하는 텍스트를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)">setTransferHandler</A> </B>(<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스">TransferHandler</A> &nbsp;newHandler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>transferHandler</code> 프로퍼티를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)">setUI</A> </B>(<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스">ComponentUI</A> &nbsp;newUI)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트의 Look & Feel
 위양을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)">setVerifyInputWhenFocusTarget</A> </B>(boolean&nbsp;verifyInputWhenFocusTarget)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컴퍼넌트가 포커스를 요구하기 전에
 현재의 포커스를 가지는 컴퍼넌트에 입력 베리파이아를 호출할지 어떨지를 나타내는 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#setVisible(boolean)">setVisible</A> </B>(boolean&nbsp;aFlag)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트를 가시 또는 불가시로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#unregisterKeyboardAction(javax.swing.KeyStroke)">unregisterKeyboardAction</A> </B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 메서드는 현재 사용되고 있지 않습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#update(java.awt.Graphics)">update</A> </B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>paint</code>를
 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/swing/JComponent.html#updateUI()">updateUI</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UI 프로퍼티를 현재의 Look & Feel 로부터의 값에 리셋트 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Container"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Container.html" title="java.awt 안의 클래스">Container</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Container.html#add(java.awt.Component)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, int)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.awt.Component, java.lang.Object, int)">add</A>,
 <A HREF="../../java/awt/Container.html#add(java.lang.String, java.awt.Component)">add</A>,
 <A HREF="../../java/awt/Container.html#addContainerListener(java.awt.event.ContainerListener)">addContainerListener</A>,
 <A HREF="../../java/awt/Container.html#addImpl(java.awt.Component, java.lang.Object, int)">addImpl</A>,
 <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A>,
 <A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A>,
 <A HREF="../../java/awt/Container.html#applyComponentOrientation(java.awt.ComponentOrientation)">applyComponentOrientation</A>,
 <A HREF="../../java/awt/Container.html#areFocusTraversalKeysSet(int)">areFocusTraversalKeysSet</A>,
 <A HREF="../../java/awt/Container.html#countComponents()">countComponents</A>,
 <A HREF="../../java/awt/Container.html#deliverEvent(java.awt.Event)">deliverEvent</A>,
 <A HREF="../../java/awt/Container.html#doLayout()">doLayout</A>,
 <A HREF="../../java/awt/Container.html#findComponentAt(int, int)">findComponentAt</A>,
 <A HREF="../../java/awt/Container.html#findComponentAt(java.awt.Point)">findComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponent(int)">getComponent</A>,
 <A HREF="../../java/awt/Container.html#getComponentAt(int, int)">getComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponentAt(java.awt.Point)">getComponentAt</A>,
 <A HREF="../../java/awt/Container.html#getComponentCount()">getComponentCount</A>,
 <A HREF="../../java/awt/Container.html#getComponents()">getComponents</A>,
 <A HREF="../../java/awt/Container.html#getComponentZOrder(java.awt.Component)">getComponentZOrder</A>,
 <A HREF="../../java/awt/Container.html#getContainerListeners()">getContainerListeners</A>,
 <A HREF="../../java/awt/Container.html#getFocusTraversalKeys(int)">getFocusTraversalKeys</A>,
 <A HREF="../../java/awt/Container.html#getFocusTraversalPolicy()">getFocusTraversalPolicy</A>,
 <A HREF="../../java/awt/Container.html#getLayout()">getLayout</A>,
 <A HREF="../../java/awt/Container.html#getMousePosition(boolean)">getMousePosition</A>,
 <A HREF="../../java/awt/Container.html#insets()">insets</A>,
 <A HREF="../../java/awt/Container.html#invalidate()">invalidate</A>,
 <A HREF="../../java/awt/Container.html#isAncestorOf(java.awt.Component)">isAncestorOf</A>,
 <A HREF="../../java/awt/Container.html#isFocusCycleRoot()">isFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#isFocusCycleRoot(java.awt.Container)">isFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#isFocusTraversalPolicyProvider()">isFocusTraversalPolicyProvider</A>,
 <A HREF="../../java/awt/Container.html#isFocusTraversalPolicySet()">isFocusTraversalPolicySet</A>,
 <A HREF="../../java/awt/Container.html#layout()">layout</A>,
 <A HREF="../../java/awt/Container.html#list(java.io.PrintStream, int)">list</A>,
 <A HREF="../../java/awt/Container.html#list(java.io.PrintWriter, int)">list</A>,
 <A HREF="../../java/awt/Container.html#locate(int, int)">locate</A>,
 <A HREF="../../java/awt/Container.html#minimumSize()">minimumSize</A>,
 <A HREF="../../java/awt/Container.html#paintComponents(java.awt.Graphics)">paintComponents</A>,
 <A HREF="../../java/awt/Container.html#preferredSize()">preferredSize</A>,
 <A HREF="../../java/awt/Container.html#printComponents(java.awt.Graphics)">printComponents</A>,
 <A HREF="../../java/awt/Container.html#processContainerEvent(java.awt.event.ContainerEvent)">processContainerEvent</A>,
 <A HREF="../../java/awt/Container.html#processEvent(java.awt.AWTEvent)">processEvent</A>,
 <A HREF="../../java/awt/Container.html#remove(java.awt.Component)">remove</A>,
 <A HREF="../../java/awt/Container.html#remove(int)">remove</A>,
 <A HREF="../../java/awt/Container.html#removeAll()">removeAll</A>,
 <A HREF="../../java/awt/Container.html#removeContainerListener(java.awt.event.ContainerListener)">removeContainerListener</A>,
 <A HREF="../../java/awt/Container.html#setComponentZOrder(java.awt.Component, int)">setComponentZOrder</A>,
 <A HREF="../../java/awt/Container.html#setFocusCycleRoot(boolean)">setFocusCycleRoot</A>,
 <A HREF="../../java/awt/Container.html#setFocusTraversalPolicy(java.awt.FocusTraversalPolicy)">setFocusTraversalPolicy</A>,
 <A HREF="../../java/awt/Container.html#setFocusTraversalPolicyProvider(boolean)">setFocusTraversalPolicyProvider</A>,
 <A HREF="../../java/awt/Container.html#setLayout(java.awt.LayoutManager)">setLayout</A>,
 <A HREF="../../java/awt/Container.html#transferFocusBackward()">transferFocusBackward</A>,
 <A HREF="../../java/awt/Container.html#transferFocusDownCycle()">transferFocusDownCycle</A>,
 <A HREF="../../java/awt/Container.html#validate()">validate</A>,
 <A HREF="../../java/awt/Container.html#validateTree()">validateTree</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Component"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Component.html#action(java.awt.Event, java.lang.Object)">action</A>,
 <A HREF="../../java/awt/Component.html#add(java.awt.PopupMenu)">add</A>,
 <A HREF="../../java/awt/Component.html#addComponentListener(java.awt.event.ComponentListener)">addComponentListener</A>,
 <A HREF="../../java/awt/Component.html#addFocusListener(java.awt.event.FocusListener)">addFocusListener</A>,
 <A HREF="../../java/awt/Component.html#addHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">addHierarchyBoundsListener</A>,
 <A HREF="../../java/awt/Component.html#addHierarchyListener(java.awt.event.HierarchyListener)">addHierarchyListener</A>,
 <A HREF="../../java/awt/Component.html#addInputMethodListener(java.awt.event.InputMethodListener)">addInputMethodListener</A>,
 <A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)">addKeyListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseListener(java.awt.event.MouseListener)">addMouseListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseMotionListener(java.awt.event.MouseMotionListener)">addMouseMotionListener</A>,
 <A HREF="../../java/awt/Component.html#addMouseWheelListener(java.awt.event.MouseWheelListener)">addMouseWheelListener</A>,
 <A HREF="../../java/awt/Component.html#bounds()">bounds</A>,
 <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, java.awt.image.ImageObserver)">checkImage</A>,
 <A HREF="../../java/awt/Component.html#checkImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">checkImage</A>,
 <A HREF="../../java/awt/Component.html#coalesceEvents(java.awt.AWTEvent, java.awt.AWTEvent)">coalesceEvents</A>,
 <A HREF="../../java/awt/Component.html#contains(java.awt.Point)">contains</A>,
 <A HREF="../../java/awt/Component.html#createImage(java.awt.image.ImageProducer)">createImage</A>,
 <A HREF="../../java/awt/Component.html#createImage(int, int)">createImage</A>,
 <A HREF="../../java/awt/Component.html#createVolatileImage(int, int)">createVolatileImage</A>,
 <A HREF="../../java/awt/Component.html#createVolatileImage(int, int, java.awt.ImageCapabilities)">createVolatileImage</A>,
 <A HREF="../../java/awt/Component.html#disableEvents(long)">disableEvents</A>,
 <A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)">dispatchEvent</A>,
 <A HREF="../../java/awt/Component.html#enable(boolean)">enable</A>,
 <A HREF="../../java/awt/Component.html#enableEvents(long)">enableEvents</A>,
 <A HREF="../../java/awt/Component.html#enableInputMethods(boolean)">enableInputMethods</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, byte, byte)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, double, double)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, float, float)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, long, long)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, short, short)">firePropertyChange</A>,
 <A HREF="../../java/awt/Component.html#getBackground()">getBackground</A>,
 <A HREF="../../java/awt/Component.html#getBounds()">getBounds</A>,
 <A HREF="../../java/awt/Component.html#getColorModel()">getColorModel</A>,
 <A HREF="../../java/awt/Component.html#getComponentListeners()">getComponentListeners</A>,
 <A HREF="../../java/awt/Component.html#getComponentOrientation()">getComponentOrientation</A>,
 <A HREF="../../java/awt/Component.html#getCursor()">getCursor</A>,
 <A HREF="../../java/awt/Component.html#getDropTarget()">getDropTarget</A>,
 <A HREF="../../java/awt/Component.html#getFocusCycleRootAncestor()">getFocusCycleRootAncestor</A>,
 <A HREF="../../java/awt/Component.html#getFocusListeners()">getFocusListeners</A>,
 <A HREF="../../java/awt/Component.html#getFocusTraversalKeysEnabled()">getFocusTraversalKeysEnabled</A>,
 <A HREF="../../java/awt/Component.html#getFont()">getFont</A>,
 <A HREF="../../java/awt/Component.html#getForeground()">getForeground</A>,
 <A HREF="../../java/awt/Component.html#getGraphicsConfiguration()">getGraphicsConfiguration</A>,
 <A HREF="../../java/awt/Component.html#getHierarchyBoundsListeners()">getHierarchyBoundsListeners</A>,
 <A HREF="../../java/awt/Component.html#getHierarchyListeners()">getHierarchyListeners</A>,
 <A HREF="../../java/awt/Component.html#getIgnoreRepaint()">getIgnoreRepaint</A>,
 <A HREF="../../java/awt/Component.html#getInputContext()">getInputContext</A>,
 <A HREF="../../java/awt/Component.html#getInputMethodListeners()">getInputMethodListeners</A>,
 <A HREF="../../java/awt/Component.html#getInputMethodRequests()">getInputMethodRequests</A>,
 <A HREF="../../java/awt/Component.html#getKeyListeners()">getKeyListeners</A>,
 <A HREF="../../java/awt/Component.html#getLocale()">getLocale</A>,
 <A HREF="../../java/awt/Component.html#getLocation()">getLocation</A>,
 <A HREF="../../java/awt/Component.html#getLocationOnScreen()">getLocationOnScreen</A>,
 <A HREF="../../java/awt/Component.html#getMouseListeners()">getMouseListeners</A>,
 <A HREF="../../java/awt/Component.html#getMouseMotionListeners()">getMouseMotionListeners</A>,
 <A HREF="../../java/awt/Component.html#getMousePosition()">getMousePosition</A>,
 <A HREF="../../java/awt/Component.html#getMouseWheelListeners()">getMouseWheelListeners</A>,
 <A HREF="../../java/awt/Component.html#getName()">getName</A>,
 <A HREF="../../java/awt/Component.html#getParent()">getParent</A>,
 <A HREF="../../java/awt/Component.html#getPeer()">getPeer</A>,
 <A HREF="../../java/awt/Component.html#getPropertyChangeListeners()">getPropertyChangeListeners</A>,
 <A HREF="../../java/awt/Component.html#getPropertyChangeListeners(java.lang.String)">getPropertyChangeListeners</A>,
 <A HREF="../../java/awt/Component.html#getSize()">getSize</A>,
 <A HREF="../../java/awt/Component.html#getToolkit()">getToolkit</A>,
 <A HREF="../../java/awt/Component.html#getTreeLock()">getTreeLock</A>,
 <A HREF="../../java/awt/Component.html#gotFocus(java.awt.Event, java.lang.Object)">gotFocus</A>,
 <A HREF="../../java/awt/Component.html#handleEvent(java.awt.Event)">handleEvent</A>,
 <A HREF="../../java/awt/Component.html#hasFocus()">hasFocus</A>,
 <A HREF="../../java/awt/Component.html#hide()">hide</A>,
 <A HREF="../../java/awt/Component.html#imageUpdate(java.awt.Image, int, int, int, int, int)">imageUpdate</A>,
 <A HREF="../../java/awt/Component.html#inside(int, int)">inside</A>,
 <A HREF="../../java/awt/Component.html#isBackgroundSet()">isBackgroundSet</A>,
 <A HREF="../../java/awt/Component.html#isCursorSet()">isCursorSet</A>,
 <A HREF="../../java/awt/Component.html#isDisplayable()">isDisplayable</A>,
 <A HREF="../../java/awt/Component.html#isEnabled()">isEnabled</A>,
 <A HREF="../../java/awt/Component.html#isFocusable()">isFocusable</A>,
 <A HREF="../../java/awt/Component.html#isFocusOwner()">isFocusOwner</A>,
 <A HREF="../../java/awt/Component.html#isFocusTraversable()">isFocusTraversable</A>,
 <A HREF="../../java/awt/Component.html#isFontSet()">isFontSet</A>,
 <A HREF="../../java/awt/Component.html#isForegroundSet()">isForegroundSet</A>,
 <A HREF="../../java/awt/Component.html#isLightweight()">isLightweight</A>,
 <A HREF="../../java/awt/Component.html#isMaximumSizeSet()">isMaximumSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isMinimumSizeSet()">isMinimumSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isPreferredSizeSet()">isPreferredSizeSet</A>,
 <A HREF="../../java/awt/Component.html#isShowing()">isShowing</A>,
 <A HREF="../../java/awt/Component.html#isValid()">isValid</A>,
 <A HREF="../../java/awt/Component.html#isVisible()">isVisible</A>,
 <A HREF="../../java/awt/Component.html#keyDown(java.awt.Event, int)">keyDown</A>,
 <A HREF="../../java/awt/Component.html#keyUp(java.awt.Event, int)">keyUp</A>,
 <A HREF="../../java/awt/Component.html#list()">list</A>,
 <A HREF="../../java/awt/Component.html#list(java.io.PrintStream)">list</A>,
 <A HREF="../../java/awt/Component.html#list(java.io.PrintWriter)">list</A>,
 <A HREF="../../java/awt/Component.html#location()">location</A>,
 <A HREF="../../java/awt/Component.html#lostFocus(java.awt.Event, java.lang.Object)">lostFocus</A>,
 <A HREF="../../java/awt/Component.html#mouseDown(java.awt.Event, int, int)">mouseDown</A>,
 <A HREF="../../java/awt/Component.html#mouseDrag(java.awt.Event, int, int)">mouseDrag</A>,
 <A HREF="../../java/awt/Component.html#mouseEnter(java.awt.Event, int, int)">mouseEnter</A>,
 <A HREF="../../java/awt/Component.html#mouseExit(java.awt.Event, int, int)">mouseExit</A>,
 <A HREF="../../java/awt/Component.html#mouseMove(java.awt.Event, int, int)">mouseMove</A>,
 <A HREF="../../java/awt/Component.html#mouseUp(java.awt.Event, int, int)">mouseUp</A>,
 <A HREF="../../java/awt/Component.html#move(int, int)">move</A>,
 <A HREF="../../java/awt/Component.html#nextFocus()">nextFocus</A>,
 <A HREF="../../java/awt/Component.html#paintAll(java.awt.Graphics)">paintAll</A>,
 <A HREF="../../java/awt/Component.html#postEvent(java.awt.Event)">postEvent</A>,
 <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, java.awt.image.ImageObserver)">prepareImage</A>,
 <A HREF="../../java/awt/Component.html#prepareImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">prepareImage</A>,
 <A HREF="../../java/awt/Component.html#processComponentEvent(java.awt.event.ComponentEvent)">processComponentEvent</A>,
 <A HREF="../../java/awt/Component.html#processFocusEvent(java.awt.event.FocusEvent)">processFocusEvent</A>,
 <A HREF="../../java/awt/Component.html#processHierarchyBoundsEvent(java.awt.event.HierarchyEvent)">processHierarchyBoundsEvent</A>,
 <A HREF="../../java/awt/Component.html#processHierarchyEvent(java.awt.event.HierarchyEvent)">processHierarchyEvent</A>,
 <A HREF="../../java/awt/Component.html#processInputMethodEvent(java.awt.event.InputMethodEvent)">processInputMethodEvent</A>,
 <A HREF="../../java/awt/Component.html#processMouseWheelEvent(java.awt.event.MouseWheelEvent)">processMouseWheelEvent</A>,
 <A HREF="../../java/awt/Component.html#remove(java.awt.MenuComponent)">remove</A>,
 <A HREF="../../java/awt/Component.html#removeComponentListener(java.awt.event.ComponentListener)">removeComponentListener</A>,
 <A HREF="../../java/awt/Component.html#removeFocusListener(java.awt.event.FocusListener)">removeFocusListener</A>,
 <A HREF="../../java/awt/Component.html#removeHierarchyBoundsListener(java.awt.event.HierarchyBoundsListener)">removeHierarchyBoundsListener</A>,
 <A HREF="../../java/awt/Component.html#removeHierarchyListener(java.awt.event.HierarchyListener)">removeHierarchyListener</A>,
 <A HREF="../../java/awt/Component.html#removeInputMethodListener(java.awt.event.InputMethodListener)">removeInputMethodListener</A>,
 <A HREF="../../java/awt/Component.html#removeKeyListener(java.awt.event.KeyListener)">removeKeyListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseListener(java.awt.event.MouseListener)">removeMouseListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseMotionListener(java.awt.event.MouseMotionListener)">removeMouseMotionListener</A>,
 <A HREF="../../java/awt/Component.html#removeMouseWheelListener(java.awt.event.MouseWheelListener)">removeMouseWheelListener</A>,
 <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A>,
 <A HREF="../../java/awt/Component.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A>,
 <A HREF="../../java/awt/Component.html#repaint()">repaint</A>,
 <A HREF="../../java/awt/Component.html#repaint(int, int, int, int)">repaint</A>,
 <A HREF="../../java/awt/Component.html#repaint(long)">repaint</A>,
 <A HREF="../../java/awt/Component.html#resize(java.awt.Dimension)">resize</A>,
 <A HREF="../../java/awt/Component.html#resize(int, int)">resize</A>,
 <A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)">setBounds</A>,
 <A HREF="../../java/awt/Component.html#setBounds(java.awt.Rectangle)">setBounds</A>,
 <A HREF="../../java/awt/Component.html#setComponentOrientation(java.awt.ComponentOrientation)">setComponentOrientation</A>,
 <A HREF="../../java/awt/Component.html#setCursor(java.awt.Cursor)">setCursor</A>,
 <A HREF="../../java/awt/Component.html#setDropTarget(java.awt.dnd.DropTarget)">setDropTarget</A>,
 <A HREF="../../java/awt/Component.html#setFocusable(boolean)">setFocusable</A>,
 <A HREF="../../java/awt/Component.html#setFocusTraversalKeysEnabled(boolean)">setFocusTraversalKeysEnabled</A>,
 <A HREF="../../java/awt/Component.html#setIgnoreRepaint(boolean)">setIgnoreRepaint</A>,
 <A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)">setLocale</A>,
 <A HREF="../../java/awt/Component.html#setLocation(int, int)">setLocation</A>,
 <A HREF="../../java/awt/Component.html#setLocation(java.awt.Point)">setLocation</A>,
 <A HREF="../../java/awt/Component.html#setName(java.lang.String)">setName</A>,
 <A HREF="../../java/awt/Component.html#setSize(java.awt.Dimension)">setSize</A>,
 <A HREF="../../java/awt/Component.html#setSize(int, int)">setSize</A>,
 <A HREF="../../java/awt/Component.html#show()">show</A>,
 <A HREF="../../java/awt/Component.html#show(boolean)">show</A>,
 <A HREF="../../java/awt/Component.html#size()">size</A>,
 <A HREF="../../java/awt/Component.html#toString()">toString</A>,
 <A HREF="../../java/awt/Component.html#transferFocus()">transferFocus</A>,
 <A HREF="../../java/awt/Component.html#transferFocusUpCycle()">transferFocusUpCycle</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ui"><!-- --></A> <H3>
ui</H3>
<PRE>
protected transient <A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 내의 클래스">ComponentUI</A>  <B>ui</B></PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel 위양입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="listenerList"><!-- --></A> <H3>
listenerList</H3>
<PRE>
protected <A HREF="../../javax/swing/event/EventListenerList.html" title="javax.swing.event 내의 클래스">EventListenerList</A>  <B>listenerList</B></PRE>
<DL>
<DD>이 컴퍼넌트의 이벤트 리스너 리스트입니다.  </dl>
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="WHEN_FOCUSED"><!-- --></A> <H3>
WHEN_FOCUSED</H3>
<PRE>
public static final int <B>WHEN_FOCUSED</B></PRE>
<DL>
<DD><code>registerKeyboardAction</code> 로 사용되는 정수입니다. 컴퍼넌트에 포커스가 설정되었을 때에 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_FOCUSED">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="WHEN_ANCESTOR_OF_FOCUSED_COMPONENT"><!-- --></A> <H3>
WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</H3>
<PRE>
public static final int <B>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</B></PRE>
<DL>
<DD><code>registerKeyboardAction()</code> 로 사용되는 정수입니다. 수신측 컴퍼넌트가 포커스를 가지는 컴퍼넌트의 상위인지, 그 자체가 포커스를 가지는 컴퍼넌트인 경우에
 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="WHEN_IN_FOCUSED_WINDOW"><!-- --></A> <H3>
WHEN_IN_FOCUSED_WINDOW</H3>
<PRE>
public static final int <B>WHEN_IN_FOCUSED_WINDOW</B></PRE>
<DL>
<DD><code>registerKeyboardAction()</code> 로 사용되는 정수입니다. 수신측 컴퍼넌트가 포커스를 가지는 윈도우내에 있는지, 그 자체가 포커스를 가지는 컴퍼넌트인 경우에
 커멘드를 호출하는 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.WHEN_IN_FOCUSED_WINDOW">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="UNDEFINED_CONDITION"><!-- --></A> <H3>
UNDEFINED_CONDITION</H3>
<PRE>
public static final int <B>UNDEFINED_CONDITION</B></PRE>
<DL>
<DD>몇개의 API 로 사용되는 정수입니다. 조건이 정의되어 있지 않은 것을 나타냅니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.UNDEFINED_CONDITION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TOOL_TIP_TEXT_KEY"><!-- --></A> <H3>
TOOL_TIP_TEXT_KEY</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>TOOL_TIP_TEXT_KEY</B></PRE>
<DL>
<DD>커서가 컴퍼넌트상에 있을 때 표시되는 코멘트입니다. 「값힌트」, 「부유 헬프」, 또는 「부유 라벨」이라고도 불립니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#javax.swing.JComponent.TOOL_TIP_TEXT_KEY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="accessibleContext"><!-- --></A> <H3>
accessibleContext</H3>
<PRE>
protected <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>accessibleContext</B></PRE>
<DL>
<DD>이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code> 입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="JComponent()"><!-- --></A> <H3>
JComponent</H3>
<PRE>
public <B>JComponent</B>()</PRE>
<DL>
<DD>디폴트의 <code>JComponent</code> 생성자
입니다. 이 생성자에서는
<code>Container</code> 생성자
 호출전의 초기화는 거의 실행되지 않습니다. 예를 들어 초기 레이아웃 매니저는 <code>null</code> 입니다. 컴퍼넌트의 로케일 프로퍼티는 <code>JComponent.getDefaultLocale</code> 로 돌려주고진 값으로 설정합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()"><CODE>getDefaultLocale()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="setInheritsPopupMenu(boolean)"><!-- --></A> <H3>
setInheritsPopupMenu</H3>
<PRE>
public void <B>setInheritsPopupMenu</B>(boolean&nbsp;value)</PRE>
<DL>
<DD>이 컴퍼넌트에 <code>JPopupMenu</code>를
 할당할 수 있지 않은 경우에 <code>getComponentPopupMenu</code> 가 부모에게 위양 될지 어떨지를 설정합니다.
 <p>
이 메서드의 디폴트치는 false 입니다만, 다수의 <code>JComponent</code> 로서 구현되는 일부의 <code>JComponent</code> 서브 클래스에서는 이 메서드를 true 로 설정합니다.
 <p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>value</CODE> - JPopupMenu 가 상속될지 어떨지<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInheritsPopupMenu()"><!-- --></A> <H3>
getInheritsPopupMenu</H3>
<PRE>
public boolean <B>getInheritsPopupMenu</B>()</PRE>
<DL>
<DD>JPopupMenu 가 부모로부터 상속되는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setComponentPopupMenu(javax.swing.JPopupMenu)"><!-- --></A> <H3>
setComponentPopupMenu</H3>
<PRE>
public void <B>setComponentPopupMenu</B>(<A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 안의 클래스">JPopupMenu</A> &nbsp;popup)</PRE>
<DL>
<DD>이 <code>JComponent</code> 에 대해서 <code>JPopupMenu</code>를
 설정합니다. 이 UI는

<code>JPopupMenu</code> 가 적절한 타이밍에 표시되도록, 바인딩을 등록하거나 필요한 리스너를 추가하거나 합니다. <code>JPopupMenu</code> 가 언제 표시될까는
 Look & Feel 에 따라서 달라, 마우스 이벤트로 표시되는 일도 있으면, 키 바인딩이 유효하게 될 수도 있습니다.
 <p>
<code>popup</code> 가 null 로<code>getInheritsPopupMenu</code> 가 true를
 돌려주는 경우는
<code>getComponentPopupMenu</code> 이 부모에게 위양 됩니다. 이것에
해, 모든 아이 컴퍼넌트에 부모의 pop-up menu를 상속시킬 수가 있습니다.
 <p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>popup</CODE> - 이 컴퍼넌트에 할당할 수 있는 pop-up. null
 경우도 있는<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getComponentPopupMenu()"><CODE>getComponentPopupMenu()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponentPopupMenu()"><!-- --></A> <H3>
getComponentPopupMenu</H3>
<PRE>
public <A HREF="../../javax/swing/JPopupMenu.html" title="javax.swing 내의 클래스">JPopupMenu</A>  <B>getComponentPopupMenu</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code>를
 돌려줍니다. 이 컴퍼넌트에 <code>JPopupMenu</code>를
 할당할 수 있지 않고,<code>getInheritsPopupMenu</code> 가 true
 경우는
<code>getParent(). getComponentPopupMenu()</code> 이 돌려주고집니다 (부모가 유효하다 것으로 한다).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트에 할당할 수 있었던 <code>JPopupMenu</code>. pop-up를 할당할 수 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setComponentPopupMenu(javax.swing.JPopupMenu)"><CODE>setComponentPopupMenu(javax.swing.JPopupMenu)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="updateUI()"><!-- --></A> <H3>
updateUI</H3>
<PRE>
public void <B>updateUI</B>()</PRE>
<DL>
<DD>UI 프로퍼티를 현재의 Look & Feel 로부터의 값에 리셋트 합니다. <code>JComponent</code>
 서브 클래스는
 다음과 같이 이 메서드를 오버라이드(override) 할 필요가 있습니다.
 
 <pre>

   public void updateUI() {
      setUI((SliderUI) UIManager.getUI(this);
   }
  </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setUI(javax.swing.plaf.ComponentUI)"><CODE>setUI(javax.swing.plaf.ComponentUI)</CODE></A>,
 
<A HREF="../../javax/swing/UIManager.html#getLookAndFeel()"><CODE>UIManager.getLookAndFeel()</CODE></A>,
 
<A HREF="../../javax/swing/UIManager.html#getUI(javax.swing.JComponent)"><CODE>UIManager.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setUI(javax.swing.plaf.ComponentUI)"><!-- --></A> <H3>
setUI</H3>
<PRE>
protected void <B>setUI</B>(<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스">ComponentUI</A> &nbsp;newUI)</PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel
 위양을 설정합니다. 보통
,<code>JComponent</code>
 서브 클래스는 이 메서드를 오버라이드(override) 해 인수의 형태를 네로우 변환할 필요가 있습니다. 다음에 <code>JSlider</code>
 예를 나타냅니다.
  
 <pre>

 public void setUI(SliderUI newUI) {
     super.setUI(newUI);
 }
  </pre>


 <p>
또,<code>JComponent</code>
 서브 클래스는 올바른 형태를 돌려주는 <code>getUI</code> 메서드를 제공할 필요가 있습니다. 다음에 예를 나타냅니다.
 
 <pre>

 public SliderUI getUI() {
     return (SliderUI) ui;
 }
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newUI</CODE> - 새로운의 UI 위양<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#updateUI()"><CODE>updateUI()</CODE></A>,
 
<A HREF="../../javax/swing/UIManager.html#getLookAndFeel()"><CODE>UIManager.getLookAndFeel()</CODE></A>,
 
<A HREF="../../javax/swing/UIManager.html#getUI(javax.swing.JComponent)"><CODE>UIManager.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUIClassID()"><!-- --></A> <H3>
getUIClassID</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getUIClassID</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 Look & Feel를
 정의하는 <code>swing.plaf.ComponentUI</code> 클래스의 이름을 참조하기 위해서 사용되는 <code>UIDefaults</code> 키를 돌려줍니다. 대부분의 어플리케이션은, 이 메서드를 호출할 필요는 없습니다. 플러그 인 가능한 Look & Feel를
 지원하는
 <code>JComponent</code>
 서브 클래스는
 이 메서드를 오버라이드(override) 해, 그러한 Look & Feel를
 정의하는 <code>ComponentUI</code>
 서브 클래스에 대응하는 <code>UIDefaults</code> 키를 돌려줄 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>ComponentUI</code> 서브 클래스의 <code>UIDefaults</code> 키<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/UIDefaults.html#getUI(javax.swing.JComponent)"><CODE>UIDefaults.getUI(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponentGraphics(java.awt.Graphics)"><!-- --></A> <H3>
getComponentGraphics</H3>
<PRE>
protected <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>getComponentGraphics</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트를 페인트 하기 위해서 사용되는 그래픽스 오브젝트를 돌려줍니다. <code>DebugGraphics</code> 가 온의 경우, 필요한 때에 새로운 <code>DebugGraphics</code> 오브젝트를 생성합니다. 그렇지 않은 경우, 단순하게 지정된 그래픽스 오브젝트의 foreground와 폰트를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 오리지날의 <code>Graphics</code> 오브젝트
<DT><B>반환값:</B><DD>이 컴퍼넌트를 위해서 설정된 <code>Graphics</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="paintComponent(java.awt.Graphics)"><!-- --></A> <H3>
paintComponent</H3>
<PRE>
protected void <B>paintComponent</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>UI 위양이 <code>null</code> 가 아닌 경우에
 UI 위양의 페인트 메서드를 호출합니다. 위양에는 <code>Graphics</code> 오브젝트의 카피를 건네주어, 나머지의 페인트 코드에 대해서 취소할 수 없는 변경을 하지 않게 보호합니다 (예를 들어 <code>Graphics.translate</code> 등).
 <p>
이 메서드를 서브 클래스에서 오버라이드(override) 하는 경우는
 건네받은 <code>Graphics</code>
 오브젝트에는 영속적인 변경은 실시하지 않게 합니다. 예를 들어 <code>Rectangle</code> 클립이나 변환은 변경하지 않습니다. 이러한 변경이 필요한 경우는
 건네받은 <code>Graphics</code> 로부터 새로운 <code>Graphics</code>를
 생성해, 그것을 변경하는 편이 용이합니다. 한층 더 상위 오브젝트의 구현을 실시하지 않는 경우는
 불투명 프로퍼티에 주의할 필요가 있습니다. 즉 이 컴퍼넌트가 불투명한 경우는
 백그라운드에는 불투명하지 않은 색을 사용할 필요가 있습니다. 불투명 프로퍼티를 무시하면 화면이 보기 나뻐집니다.
 <p>
건네받은 <code>Graphics</code> 오브젝트에는
 인스톨 되고 있는 변환 이외의 변환이 포함되어 있는 일이 있습니다. 이 경우, 다른 변환을 누적적으로 적용하면, 예기치 않은 결과가 생길 가능성이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 보호 대상의 <code>Graphics</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintChildren(java.awt.Graphics)"><!-- --></A> <H3>
paintChildren</H3>
<PRE>
protected void <B>paintChildren</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트의 아이를 페인트 합니다. <code>shouldUseBuffer</code> 가 true
 경우, 컴퍼넌트의 상위 오브젝트는 버퍼를 가지지 않고, 컴퍼넌트의 아이는 각각 독자적인 버퍼를 가질 때 버퍼를 사용할 수 있습니다. 그렇지 않은 경우, 상위 오브젝트가 버퍼를 현재 사용중이며, 아이는 렌더링를 위한 버퍼를 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../java/awt/Container.html#paint(java.awt.Graphics)"><CODE>Container.paint(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintBorder(java.awt.Graphics)"><!-- --></A> <H3>
paintBorder</H3>
<PRE>
protected void <B>paintBorder</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트의 보더를 페인트 합니다.
 <p>
이 메서드를 서브 클래스에서 오버라이드(override) 하는 경우는
 건네받은 <code>Graphics</code>
 오브젝트에는 영속적인 변경은 실시하지 않게 합니다. 예를 들어 <code>Rectangle</code> 클립이나 변환은 변경하지 않습니다. 이러한 변경이 필요한 경우는
 건네받은 <code>Graphics</code> 로부터 새로운 <code>Graphics</code>를
 생성해, 그것을 변경하는 편이 용이합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="update(java.awt.Graphics)"><!-- --></A> <H3>
update</H3>
<PRE>
public void <B>update</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD><code>paint</code>를
 호출합니다. 백그라운드의 클리어는 실시하지 않고,<code>paintComponent</code> 에
해 불려 가는 <code>ComponentUI.update</code>를
 참조합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#update(java.awt.Graphics)">update</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paint(java.awt.Graphics)"><CODE>paint(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)"><CODE>paintComponent(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paint(java.awt.Graphics)"><!-- --></A> <H3>
paint</H3>
<PRE>
public void <B>paint</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 메서드는 Swing 에
해 불려 가 컴퍼넌트를 렌더링 합니다. 어플리케이션으로부터는 <code>paint</code>를
 직접 호출하지 않게 합니다. 대신에 <code>repaint</code> 메서드를 사용해 컴퍼넌트의 재렌더링를 스케줄 할 필요가 있습니다.
 <p>
이 메서드는
 실제로는 페인트 작업을 3 개의 protected 메서드에 위양 합니다. 그것들은,<code>paintComponent</code>,<code>paintBorder</code> 및 <code>paintChildren</code> 입니다. 이러한 메서드는
 여기에 늘어놓을 수 있었던 차례로 불려 가 자식이 컴퍼넌트상에 표시되도록 합니다. 보통
, 컴퍼넌트와 그 아이는
 보더에 할당할 수 있었던 인 세트 영역에는 페인트 하지 않습니다. 서브 클래스는
 보통
 대로에 이 메서드를 오버라이드(override) 할 수 있습니다. UI (Look & Feel) 위양의 <code>paint</code> 메서드를 특수화 하는 서브 클래스는
<code>paintComponent</code>를
 오버라이드(override) 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#paint(java.awt.Graphics)">paint</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#paintComponent(java.awt.Graphics)"><CODE>paintComponent(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#paintBorder(java.awt.Graphics)"><CODE>paintBorder(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#paintChildren(java.awt.Graphics)"><CODE>paintChildren(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getComponentGraphics(java.awt.Graphics)"><CODE>getComponentGraphics(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)"><CODE>repaint(long, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printAll(java.awt.Graphics)"><!-- --></A> <H3>
printAll</H3>
<PRE>
public void <B>printAll</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트를 인쇄하려면,
 이 메서드를 호출합니다. 이 메서드는 컴퍼넌트의 <code>print</code>를
 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#printAll(java.awt.Graphics)">printAll</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)"><CODE>printComponent(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)"><CODE>printBorder(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)"><CODE>printChildren(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="print(java.awt.Graphics)"><!-- --></A> <H3>
print</H3>
<PRE>
public void <B>print</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>컴퍼넌트를 인쇄하려면,
 이 메서드를 호출합니다. 이 메서드는 <code>printComponent</code>,<code>printBorder</code> 및 <code>printChildren</code>를
 호출합니다. 이 메서드를 오버라이드(override) 하는 것은 추천 되지 않기 때문에
 대신에 전술의 메서드의 어떤 것인지를 오버라이드(override) 합니다. 이 메서드에서는
 컴퍼넌트를 더블 버퍼링을 사용하지 않는 상태, 즉 페인트가 <code>Graphics</code>
 수신측에서 직접 행해지는 상태로 설정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#print(java.awt.Graphics)">print</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#printComponent(java.awt.Graphics)"><CODE>printComponent(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#printBorder(java.awt.Graphics)"><CODE>printBorder(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#printChildren(java.awt.Graphics)"><CODE>printChildren(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printComponent(java.awt.Graphics)"><!-- --></A> <H3>
printComponent</H3>
<PRE>
protected void <B>printComponent</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 메서드는 인쇄 조작중에 불려 갑니다. 컴퍼넌트의 <code>paintComponent</code>를
 호출하기 위해서 구현되고 있습니다. 인쇄시에 특정의 페인트 동작을 추가하는 경우는
 이 메서드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printChildren(java.awt.Graphics)"><!-- --></A> <H3>
printChildren</H3>
<PRE>
protected void <B>printChildren</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트의 아이를 인쇄합니다. 이 메서드는 컴퍼넌트의 <code>paintChildren</code>를
 호출하기 위해서 구현되고 있습니다. 페인트 하는 아이와는 다른 아이를 인쇄하는 경우는
 이 메서드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="printBorder(java.awt.Graphics)"><!-- --></A> <H3>
printBorder</H3>
<PRE>
protected void <B>printBorder</B>(<A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A> &nbsp;g)</PRE>
<DL>
<DD>이 컴퍼넌트의 보더를 인쇄합니다. 이 메서드는 컴퍼넌트의 <code>paintBorder</code>를
 호출하기 위해서 구현되고 있습니다. 페인트 하는 보더와는 다른 보더를 출력하고 싶을 때는
 이 메서드를 오버라이드(override) 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 페인트 대상의 <code>Graphics</code> 컨텍스트
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#print(java.awt.Graphics)"><CODE>print(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isPaintingTile()"><!-- --></A> <H3>
isPaintingTile</H3>
<PRE>
public boolean <B>isPaintingTile</B>()</PRE>
<DL>
<DD>컴퍼넌트가 현재 타일을 페인트 하고 있는 경우에 true를
 돌려줍니다. 이 메서드가 true를
 돌려주는 경우, 다른 타일을 위해서 paint 가 다시 불려 갑니다. 이 메서드는
 타일을 페인트 하고 있지 않는 경우, 또는 마지막 타일이 페인트 되고 있는 경우에 false를
 돌려줍니다. 이 메서드를 사용하면, 타일의 사이에 필요할 가능성이 있는 몇개의 상태를 유지할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트가 현재 타일을 인쇄하고 있는 경우는 true, 그렇지 않은 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="isManagingFocus()"><!-- --></A> <H3>
isManagingFocus</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public boolean <B>isManagingFocus</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>1.4 이후는 <code>Component.setFocusTraversalKeys(int, Set)</code> 와 <code>Container.setFocusCycleRoot(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는
 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오.
 <p>
이 <code>JComponent</code>
 포커스 호랑이 용기 키를 CTRL+TAB 와 CTRL+SHIFT+TAB 로 변경합니다. 또, 포커스 호랑이 용기 사이클 계산시에
<code>SortingFocusTraversalPolicy</code>를
 이 JComponent
 하위 클래스라고 보지 않게 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<?  extends java.awt.AWTKeyStroke>)</CODE></A>,
 
<A HREF="../../javax/swing/SortingFocusTraversalPolicy.html" title="javax.swing 안의 클래스"><CODE>SortingFocusTraversalPolicy</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setNextFocusableComponent(java.awt.Component)"><!-- --></A> <H3>
setNextFocusableComponent</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>setNextFocusableComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;aComponent)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는
 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오.
 <p>
이 <code>JComponent</code>
 포커스 호랑이 용기 사이클에 대한 디폴트의 <code>FocusTraversalPolicy</code>를
, 지정된 <code>Component</code>를
 사이클의 다음의 <code>Component</code> 로서 무조건 설정해, 오버라이드(override) 합니다. 이 <code>JComponent</code>는

 사이클내의 지정된 <code>Component</code>
 전의 <code>Component</code> 로서 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aComponent</CODE> - 포커스 호랑이 용기 사이클로 이 <code>JComponent</code>
 뒤에 계속되는 <code>Component</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getNextFocusableComponent()"><CODE>getNextFocusableComponent()</CODE></A>,
 
<A HREF="../../java/awt/FocusTraversalPolicy.html" title="java.awt 안의 클래스"><CODE>FocusTraversalPolicy</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNextFocusableComponent()"><!-- --></A> <H3>
getNextFocusableComponent</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A>  <B>getNextFocusableComponent</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는
<code>FocusTraversalPolicy</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는
 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오.
 <p>
전의 호출로 이 <code>JComponent</code>
 <code>setNextFocusableComponent(Component)</code> 로 설정된 <code>Component</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포커스 호랑이 용기 사이클로 이 <code>JComponent</code>
 뒤에 계속되는 <code>Component</code>. 명시적으로 지정되어 있지 않은 경우는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setNextFocusableComponent(java.awt.Component)"><CODE>setNextFocusableComponent(java.awt.Component)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRequestFocusEnabled(boolean)"><!-- --></A> <H3>
setRequestFocusEnabled</H3>
<PRE>
public void <B>setRequestFocusEnabled</B>(boolean&nbsp;requestFocusEnabled)</PRE>
<DL>
<DD>이 <code>JComponent</code> 가 포커스를 취득할지 어떨지에 대한 힌트를 제공합니다. 단순한 힌트이며, 이 프로퍼티를 고려해 포커스를 요구할지 어떨지는 컨슈머(consumer)측에서 결정합니다. 이것은 주로 마우스 조작으로 고려되어 키보드 조작에서는 그다지 고려되지 않습니다. 예를 들어 Look & Feel는

 마우스 조작의 포커스 요구전에
 이 프로퍼티가 true 화도인지를 확인할 수 있습니다. <code>JComponent</code> 상에서의 마우스 클릭으로 포커스를 취득시키지 않고,
 키보드로 <code>JComponent</code>
 암벽 횡단을 가능하게 하는 경우에 사용됩니다. 이 <code>JComponent</code> 에 대해서 전혀 포커스를 설정하지 않게 하기 위해서는
<code>setFocusable</code> 메서드를 사용합니다.
 <p>
상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>requestFocusEnabled</CODE> - 이 <code>JComponent</code> 에 포커스를 설정 가능하게 할지 어떨지를 나타내는<DT><B>관련 항목:</B><DD><a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>,
 
<A HREF="../../java/awt/Component.html#setFocusable(boolean)"><CODE>Component.setFocusable(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isRequestFocusEnabled()"><!-- --></A> <H3>
isRequestFocusEnabled</H3>
<PRE>
public boolean <B>isRequestFocusEnabled</B>()</PRE>
<DL>
<DD>이 <code>JComponent</code> 가 포커스를 얻는
 경우는 <code>true</code>를
 돌려주고, 그렇지 않은 경우는 <code>false</code>를
 돌려줍니다.
 <p>
상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 포커스를 얻는
 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setRequestFocusEnabled(boolean)"><CODE>setRequestFocusEnabled(boolean)</CODE></A>,
 
<a href="../../java/awt/doc-files/FocusSpec.html">Focus Specification</a>,
 
<A HREF="../../java/awt/Component.html#isFocusable()"><CODE>Component.isFocusable()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocus()"><!-- --></A> <H3>
requestFocus</H3>
<PRE>
public void <B>requestFocus</B>()</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#requestFocus()"><CODE>Component.requestFocus()</CODE></A> 를
 참조하십시오.
 <p>
이 메서드의 동작은 플랫폼에
존하고 있기 때문에
 이 메서드를 사용하는 것은 추천 되지 않습니다. 대신에 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()"><CODE>requestFocusInWindow()</CODE></A> 를
 사용하는 것을 추천합니다. 포커스의 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocus()">requestFocus</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocus(boolean)"><!-- --></A> <H3>
requestFocus</H3>
<PRE>
public boolean <B>requestFocus</B>(boolean&nbsp;temporary)</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#requestFocus(boolean)"><CODE>Component.requestFocus(boolean)</CODE></A> 를
 참조하십시오.
 <p>
이 메서드의 동작은 플랫폼에
존하고 있기 때문에
 이 메서드를 사용하는 것은 추천 되지 않습니다. 대신에 <A HREF="../../javax/swing/JComponent.html#requestFocusInWindow(boolean)"><CODE>requestFocusInWindow(boolean)</CODE></A> 를
 사용하는 것을 추천합니다. 포커스의 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocus(boolean)">requestFocus</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>temporary</CODE> - 포커스의 변경이 일시적인 것인가 어떤가를 나타내는 boolean 치
<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>, 정상적으로 실행되는 것 같으면 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocusInWindow()"><!-- --></A> <H3>
requestFocusInWindow</H3>
<PRE>
public boolean <B>requestFocusInWindow</B>()</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A> 를
 참조하십시오.
 <p>
포커스의 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocusInWindow()">requestFocusInWindow</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>, 정상적으로 실행되는 것 같으면 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestFocusInWindow(boolean)"><!-- --></A> <H3>
requestFocusInWindow</H3>
<PRE>
protected boolean <B>requestFocusInWindow</B>(boolean&nbsp;temporary)</PRE>
<DL>
<DD>이 <code>Component</code> 가 입력초점을 얻는
 것을 요구합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> 를
 참조하십시오.
 <p>
포커스의 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html"> 「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)">requestFocusInWindow</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>temporary</CODE> - 포커스의 변경이 일시적인 것인가 어떤가를 나타내는 boolean 치
<DT><B>반환값:</B><DD>포커스 변경 요구가 확실히 에러가 되는 경우는 <code>false</code>, 정상적으로 실행되는 것 같으면 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#requestFocusInWindow()"><CODE>Component.requestFocusInWindow()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#requestFocusInWindow(boolean)"><CODE>Component.requestFocusInWindow(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="grabFocus()"><!-- --></A> <H3>
grabFocus</H3>
<PRE>
public void <B>grabFocus</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 입력초점을 취득해, 이 컴퍼넌트의 최상정도 클래스의 윈도우에 포커스를 설정하는 것을 요구합니다. 이 요구를 허가하기 위해서는
 이 컴퍼넌트가 가시, 표시 가능해 포커스 가능하지 않으면 안됩니다.
 <p>
이 메서드는 포커스 구현에서의 사용을 상정하고 있습니다. 클라이언트 코드에서는 이 메서드는 아니고,<code>requestFocusInWindow()</code>를
 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#requestFocusInWindow()"><CODE>requestFocusInWindow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setVerifyInputWhenFocusTarget(boolean)"><!-- --></A> <H3>
setVerifyInputWhenFocusTarget</H3>
<PRE>
public void <B>setVerifyInputWhenFocusTarget</B>(boolean&nbsp;verifyInputWhenFocusTarget)</PRE>
<DL>
<DD>이 컴퍼넌트가 포커스를 요구하기 전에
 현재의 포커스를 가지는 컴퍼넌트에 입력 베리파이아를 호출할지 어떨지를 나타내는 값을 설정합니다. 이 설정의 디폴트는 true 입니다. 현재의 포커스를 가지는 컴퍼넌트에의 입력이, 그 컴퍼넌트의 입력 베리파이아로 건네받지 않은 경우에서도 액티브하게 할 필요가 있는 「Cancel」버튼 또는 스크롤 바등의 컴퍼넌트는
 false 로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>verifyInputWhenFocusTarget</CODE> - <code>verifyInputWhenFocusTarget</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)"><CODE>setInputVerifier(javax.swing.InputVerifier)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getInputVerifier()"><CODE>getInputVerifier()</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getVerifyInputWhenFocusTarget()"><CODE>getVerifyInputWhenFocusTarget()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVerifyInputWhenFocusTarget()"><!-- --></A> <H3>
getVerifyInputWhenFocusTarget</H3>
<PRE>
public boolean <B>getVerifyInputWhenFocusTarget</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 포커스를 요구하기 전에
 현재의 포커스를 가지는 컴퍼넌트에 입력 베리파이아를 호출할지 어떨지를 나타내는 값을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>verifyInputWhenFocusTarget</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setInputVerifier(javax.swing.InputVerifier)"><CODE>setInputVerifier(javax.swing.InputVerifier)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getInputVerifier()"><CODE>getInputVerifier()</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setVerifyInputWhenFocusTarget(boolean)"><CODE>setVerifyInputWhenFocusTarget(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics(java.awt.Font)"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>지정된 <code>Font</code>
 <code>FontMetrics</code>를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 폰트메트릭스를 얻는
 폰트
<DT><B>반환값:</B><DD><code>font</code>
 폰트메트릭스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>font</code> 가 null
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getFont()"><CODE>Component.getFont()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getPeer()"><CODE>Component.getPeer()</CODE></A>,
 
<CODE>ComponentPeer.getFontMetrics(Font)</CODE>, 
<A HREF="../../java/awt/Toolkit.html#getFontMetrics(java.awt.Font)"><CODE>Toolkit.getFontMetrics(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPreferredSize(java.awt.Dimension)"><!-- --></A> <H3>
setPreferredSize</H3>
<PRE>
public void <B>setPreferredSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;preferredSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 적절한 사이즈를 설정합니다. <code>preferredSize</code> 가 <code>null</code>
 경우, UI 로 적절한 사이즈를 요구합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setPreferredSize(java.awt.Dimension)">setPreferredSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>preferredSize</CODE> - 새로운 추천 사이즈, 또는 null<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getPreferredSize()"><CODE>Component.getPreferredSize()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#isPreferredSizeSet()"><CODE>Component.isPreferredSizeSet()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPreferredSize()"><!-- --></A> <H3>
getPreferredSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getPreferredSize</B>()</PRE>
<DL>
<DD><code>preferredSize</code> 가 <code>null</code> 이외의 값으로 설정되어 있는 경우에 그 값을 돌려줍니다. UI 위양의 <code>getPreferredSize()</code> 메서드가 <code>null</code> 이외의 값을 돌려주는 경우는
 그 값을 돌려줍니다. 그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getPreferredSize()">getPreferredSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>preferredSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setPreferredSize(java.awt.Dimension)"><CODE>setPreferredSize(java.awt.Dimension)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumSize(java.awt.Dimension)"><!-- --></A> <H3>
setMaximumSize</H3>
<PRE>
public void <B>setMaximumSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;maximumSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 최대 사이즈를 정수치로 설정합니다. <code>getMaximumSize</code>
 이후의 호출로 항상 이 값을 돌려줍니다. 그 계산을 위해서 컴퍼넌트의 UI 가 요구될 것은 없습니다. 최대 사이즈를 <code>null</code> 로 설정하면, 디폴트의 동작하러 돌아옵니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setMaximumSize(java.awt.Dimension)">setMaximumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>maximumSize</CODE> - 요구되는 최대 허가 사이즈를 보관 유지하는 <code>Dimension</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getMaximumSize()"><CODE>getMaximumSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumSize()"><!-- --></A> <H3>
getMaximumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMaximumSize</B>()</PRE>
<DL>
<DD>최대 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. UI 위양의 <code>getMaximumSize</code> 메서드가 <code>null</code> 이외의 값을 돌려주는 경우는
 그 값을 돌려줍니다. 그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getMaximumSize()">getMaximumSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>maximumSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setMaximumSize(java.awt.Dimension)"><CODE>setMaximumSize(java.awt.Dimension)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setMinimumSize(java.awt.Dimension)"><!-- --></A> <H3>
setMinimumSize</H3>
<PRE>
public void <B>setMinimumSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;minimumSize)</PRE>
<DL>
<DD>이 컴퍼넌트의 최소 사이즈를 정수치로 설정합니다. <code>getMinimumSize</code>
 이후의 호출로 항상 이 값을 돌려줍니다. 그 계산을 위해서 컴퍼넌트의 UI 가 요구될 것은 없습니다. 최소 사이즈를 <code>null</code> 로 설정하면, 디폴트의 동작하러 돌아옵니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setMinimumSize(java.awt.Dimension)">setMinimumSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>minimumSize</CODE> - 이 컴퍼넌트의 새로운 최소 사이즈<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getMinimumSize()"><CODE>getMinimumSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumSize()"><!-- --></A> <H3>
getMinimumSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getMinimumSize</B>()</PRE>
<DL>
<DD>최소 사이즈가 <code>null</code> 이외의 값으로 설정되어 있는 경우는 그 값을 돌려줍니다. UI 위양의 <code>getMinimumSize</code> 메서드가 <code>null</code> 이외의 값을 돌려주는 경우는
 그 값을 돌려줍니다. 그렇지 않은 경우는 컴퍼넌트 레이아웃 매니저에 따릅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getMinimumSize()">getMinimumSize</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>minimumSize</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setMinimumSize(java.awt.Dimension)"><CODE>setMinimumSize(java.awt.Dimension)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="contains(int, int)"><!-- --></A> <H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(int&nbsp;x,
                        int&nbsp;y)</PRE>
<DL>
<DD>마우스 처리를 위해서, 이 컴퍼넌트의 정확한 형상을 정의할 기회를 UI 위양에 제공합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#contains(int, int)">contains</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 점의 <i>x</i> 좌표<DD><CODE>y</CODE> - 점의 <i>y</i> 좌표
<DT><B>반환값:</B><DD>이 컴퍼넌트가 논리적으로 x 와 y를
 포함한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#contains(int, int)"><CODE>Component.contains(int, int)</CODE></A>,
 
<A HREF="../../javax/swing/plaf/ComponentUI.html" title="javax.swing.plaf 안의 클래스"><CODE>ComponentUI</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBorder(javax.swing.border.Border)"><!-- --></A> <H3>
setBorder</H3>
<PRE>
public void <B>setBorder</B>(<A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 안의 인터페이스">Border</A> &nbsp;border)</PRE>
<DL>
<DD>이 컴퍼넌트의 보더를 설정합니다. <code>Border</code> 오브젝트는
 컴퍼넌트의 인 세트를 정의해 (컴퍼넌트로 직접 설정되어 있는 인 세트를 오버라이드(override) 한다), 임의로 그러한 인 세트의 경계내의 보더 장식을 렌더링 합니다. Swing 컴퍼넌트로 장식 영역 및 비장식 영역 (마진 및 패딩등)의 양쪽 모두를 생성하려면,
 인 세트는 아니고 보더를 사용할 필요가 있습니다. 단일의 컴퍼넌트내에서 복수의 보더를 상자로 하려면,
 복합 보더를 사용할 수 있습니다.
 <p>
기술적으로는 <code>JComponent</code>를
 상속하는 어느 오브젝트에도 보더를 설정할 수 있습니다만, 표준의 Swing 컴퍼넌트의 Look & Feel
 구현의 상당수는
 유저 설정의 보더에서는 올바르게 동작하지 않습니다. 보통
,<code>JPanel</code> 또는 <code>JLabel</code> 이외의 표준의 Swing 컴퍼넌트로 보더를 설정할 때는
 컴퍼넌트를 <code>JPanel</code> 에 넣어,<code>JPanel</code> 로 보더를 설정하는 것을 추천합니다.
 <p>
이것은 바운드 프로퍼티입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>border</CODE> - 이 컴퍼넌트로 렌더링 되는 보더<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스"><CODE>Border</CODE></A>,
 
<A HREF="../../javax/swing/border/CompoundBorder.html" title="javax.swing.border 안의 클래스"><CODE>CompoundBorder</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBorder()"><!-- --></A> <H3>
getBorder</H3>
<PRE>
public <A HREF="../../javax/swing/border/Border.html" title="javax.swing.border 내의 인터페이스">Border</A>  <B>getBorder</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 보더를 돌려줍니다. 보더가 현재 설정되어 있지 않은 경우는 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 보더 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInsets()"><!-- --></A> <H3>
getInsets</H3>
<PRE>
public <A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A>  <B>getInsets</B>()</PRE>
<DL>
<DD>이 컴퍼넌트로 보더가 설정되어 있는 경우는 보더의 인 세트를 돌려주고, 그렇지 않은 경우는 <code>super.getInsets</code>를
 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getInsets()">getInsets</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>인 세트 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setBorder(javax.swing.border.Border)"><CODE>setBorder(javax.swing.border.Border)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInsets(java.awt.Insets)"><!-- --></A> <H3>
getInsets</H3>
<PRE>
public <A HREF="../../java/awt/Insets.html" title="java.awt 내의 클래스">Insets</A>  <B>getInsets</B>(<A HREF="../../java/awt/Insets.html" title="java.awt 안의 클래스">Insets</A> &nbsp;insets)</PRE>
<DL>
<DD>이 컴퍼넌트의 인 세트치를 포함하는 <code>Insets</code> 오브젝트를 돌려줍니다. 건네받은 <code>Insets</code> 오브젝트는
 가능한 경우는 재이용됩니다. 다만, 메서드를 호출할 때마다 같은 오브젝트가 돌려주고진다고는 할 수 없습니다. 이 오브젝트내의 모든 기존의 값은 덧쓰기됩니다. <code>insets</code> 가 null
 경우는 새로운 할당을 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>insets</CODE> - 재이용할 수 있는 <code>Insets</code> 오브젝트
<DT><B>반환값:</B><DD><code>Insets</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getInsets()"><CODE>getInsets()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentY()"><!-- --></A> <H3>
getAlignmentY</H3>
<PRE>
public float <B>getAlignmentY</B>()</PRE>
<DL>
<DD><code>Container.getAlignmentY</code>를
 오버라이드(override) 해, 수평의 배치 방법을 돌려주도록(듯이) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getAlignmentY()">getAlignmentY</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>alignmentY</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setAlignmentY(float)"><CODE>setAlignmentY(float)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getAlignmentY()"><CODE>Component.getAlignmentY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAlignmentY(float)"><!-- --></A> <H3>
setAlignmentY</H3>
<PRE>
public void <B>setAlignmentY</B>(float&nbsp;alignmentY)</PRE>
<DL>
<DD>수평의 배치 방법을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>alignmentY</CODE> - 새로운 수평의 배치 방법<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAlignmentY()"><CODE>getAlignmentY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlignmentX()"><!-- --></A> <H3>
getAlignmentX</H3>
<PRE>
public float <B>getAlignmentX</B>()</PRE>
<DL>
<DD><code>Container.getAlignmentX</code>를
 오버라이드(override) 해, 수직의 배치 방법을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getAlignmentX()">getAlignmentX</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>alignmentX</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setAlignmentX(float)"><CODE>setAlignmentX(float)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getAlignmentX()"><CODE>Component.getAlignmentX()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAlignmentX(float)"><!-- --></A> <H3>
setAlignmentX</H3>
<PRE>
public void <B>setAlignmentX</B>(float&nbsp;alignmentX)</PRE>
<DL>
<DD>수직의 배치 방법을 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>alignmentX</CODE> - 새로운 수직의 배치 방법<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAlignmentX()"><CODE>getAlignmentX()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setInputVerifier(javax.swing.InputVerifier)"><!-- --></A> <H3>
setInputVerifier</H3>
<PRE>
public void <B>setInputVerifier</B>(<A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 안의 클래스">InputVerifier</A> &nbsp;inputVerifier)</PRE>
<DL>
<DD>이 컴퍼넌트의 입력 베리파이아를 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputVerifier</CODE> - 새로운 입력 베리파이아<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInputVerifier()"><!-- --></A> <H3>
getInputVerifier</H3>
<PRE>
public <A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스">InputVerifier</A>  <B>getInputVerifier</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 입력 베리파이아를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>inputVerifier</code> 프로퍼티<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/InputVerifier.html" title="javax.swing 내의 클래스"><CODE>InputVerifier</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getGraphics()"><!-- --></A> <H3>
getGraphics</H3>
<PRE>
public <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>getGraphics</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 그래픽스 컨텍스트
을 돌려줍니다. 그래픽스 컨텍스트
을 사용하면, 컴퍼넌트를 렌더링 할 수 있습니다. 이 메서드를 사용하면,<code>Graphics</code> 오브젝트를 취득해, 그 오브젝트로 처리를 호출해 컴퍼넌트를 렌더링 할 수 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getGraphics()">getGraphics</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 그래픽스 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)"><CODE>Component.paint(java.awt.Graphics)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDebugGraphicsOptions(int)"><!-- --></A> <H3>
setDebugGraphicsOptions</H3>
<PRE>
public void <B>setDebugGraphicsOptions</B>(int&nbsp;debugOptions)</PRE>
<DL>
<DD>이 컴퍼넌트, 또는 그 아이의 어떤 것인가로 실행되는 모든 그래픽 조작에 대한 진단 정보를 유효화 또는 무효화합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>debugOptions</CODE> - 컴퍼넌트가 정보를 표시하는 방법을 지정하는 옵션. 다음의 어떤 것인가가 됩니다. <ul> <li>DebugGraphics.LOG_OPTION - 텍스트 메세지를 출력한다<li>DebugGraphics.FLASH_OPTION - 렌더링를 몇차례 점멸시킨다<li>DebugGraphics.BUFFERED_OPTION - View
 오프 스크린 버퍼로 실행된 처리를 표시하는 <code>ExternalWindow</code>를
 작성한다<li>DebugGraphics.NONE_OPTION -  디버그를 무효로 한다<li>값이 제로의 경우는 디버그 옵션을 변경하지 않는</ul> <code>debugOptions</code>는

 현재의 값에 대한 비트 단위의 논리합입니다. </DL>
</DD>
</DL>
<HR>

<A NAME="getDebugGraphicsOptions()"><!-- --></A> <H3>
getDebugGraphicsOptions</H3>
<PRE>
public int <B>getDebugGraphicsOptions</B>()</PRE>
<DL>
<DD>그래픽의 디버그 상태를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>다음에 드는 각 옵션의 비트 단위의 논리합. <ul> <li>DebugGraphics.LOG_OPTION - 텍스트 메세지를 출력한다<li>DebugGraphics.FLASH_OPTION - 렌더링를 몇차례 점멸시킨다<li>DebugGraphics.BUFFERED_OPTION - View
 오프 스크린 버퍼로 실행된 처리를 표시하는 <code>ExternalWindow</code>를
 작성한다<li>DebugGraphics.NONE_OPTION -  디버그를 무효로 한다<li>값이 제로의 경우는 디버그 옵션을 변경하지 않는 </ul><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setDebugGraphicsOptions(int)"><CODE>setDebugGraphicsOptions(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><!-- --></A> <H3>
registerKeyboardAction</H3>
<PRE>
public void <B>registerKeyboardAction</B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                                   <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;aCommand,
                                   <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                                   int&nbsp;aCondition)</PRE>
<DL>
<DD>이 메서드는 현재 사용되고 있지 않습니다. 유사한 동작에는
<code>getActionMap()</code> 와 <code>getInputMap()</code>
 메서드를 조합해 사용해 주세요. 예를 들어,<code>KeyStroke</code>
 <code>aKeyStroke</code>를
 <code>Action</code>
 <code>anAction</code> 에 바인드 하려면,
 다음의 메서드를 사용합니다.
 
 <pre>

   component.getInputMap(). put(aKeyStroke, aCommand);
   component.getActionMap(). put(aCommmand, anAction);
 </pre>
상기의 예는
<code>WHEN_FOCUSED</code> 에 적절한 바인딩을 실행하면 가정한 것입니다. 다른 포커스 상태의 바인딩을 등록하려면,
 정수값을 받는 <code>getInputMap</code> 메서드를 사용합니다.
 <p>
새로운 키보드 액션을 등록합니다. <code>anAction</code>는

<code>aKeyStroke</code> 와 일치하는 키 이벤트가 발생해,<code>aCondition</code> 가 확인되었을 경우에 불려 갑니다. <code>KeyStroke</code> 오브젝트는
 키보드의 키와 1 개 이상의 수식 키 (alt, shift, ctrl, meta)의 특정의 편성을 정의합니다.
 <p>
<code>aCommand</code>는

 지정되고 있으면, 보내지는 이벤트로 설정됩니다.
 <p>
<code>aCondition</code>는
 다음의 어떤 것인가입니다. <blockquote> <DL> <DT>WHEN_FOCUSED<DD>액션은, 컴퍼넌트가 포커스를 가지는 경우에 키스트로크(keystroke)가 발생했을 때에만 불려 가는<DT>WHEN_IN_FOCUSED_WINDOW<DD>액션은, 컴퍼넌트가 포커스를 가지는지, 또는 포커스를 가지는 윈도우내에 있는 경우에 키스트로크(keystroke)가 발생했을 때에만 불려 간다. 컴퍼넌트는 윈도우의 직접적인 하위일 필요는 없고, 윈도우의 포함 관계의 계층의 어디에 있어도 상관없다. 즉, 윈도우내의<em>어느</em>컴퍼넌트가 포커스를 가지고 있어도, 이 컴퍼넌트에 등록되어 있는 액션은 불려 가는<DT>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT<DD>액션은, 컴퍼넌트가 포커스를 가지는지, 또는 포커스를 가지는 컴퍼넌트의 상위 오브젝트인 경우에 키스트로크(keystroke)가 발생했을 때에만 불려 간다 </DL> </blockquote>
 <p>
키스트로크(keystroke)와 조건의 편성에
해, (KeyStroke 클래스를 사용해) 지정된 키스트로크(keystroke)와 수식 키의 편성에 대한 하이레벨의 (의미상의) 액션 이벤트를 정의할 수 있어 포커스를 가지는 컴퍼넌트의 부모 또는 아이, 혹은 컴퍼넌트 자체를 향할 수가 있습니다. 즉, 어떠한 컴퍼넌트의 계층 구조에 대해도, 임의의 키의 편성을 계층내의 적절한 컴퍼넌트에 직접 이끌 수가 있어 특정의 메서드를 호출할 수가 있습니다 (일반적으로 어댑터 오브젝트를 포함한
다).
 <p>
액션이 벌써 같은 charCode 및 같은 수식 키로 수신측 컨테이너에 등록되어 있는 경우,<code>anAction</code>는
 그 액션을 옮겨놓습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>anAction</CODE> - 등록하는 <code>Action</code><DD><CODE>aCommand</CODE> - 보내지는 이벤트로 설정되는 커멘드<DD><CODE>aKeyStroke</CODE> - 액션을 바인드 하는 <code>KeyStroke</code><DD><CODE>aCondition</CODE> - 채울 필요가 있는 조건. 상기 참조<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스"><CODE>KeyStroke</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="registerKeyboardAction(java.awt.event.ActionListener, javax.swing.KeyStroke, int)"><!-- --></A> <H3>
registerKeyboardAction</H3>
<PRE>
public void <B>registerKeyboardAction</B>(<A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 안의 인터페이스">ActionListener</A> &nbsp;anAction,
                                   <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke,
                                   int&nbsp;aCondition)</PRE>
<DL>
<DD>이 메서드는 현재 사용되고 있지 않습니다. 유사한 동작에는 <code>getActionMap()</code> 와 <code>getInputMap()</code>
 메서드를 조합해 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="unregisterKeyboardAction(javax.swing.KeyStroke)"><!-- --></A> <H3>
unregisterKeyboardAction</H3>
<PRE>
public void <B>unregisterKeyboardAction</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>이 메서드는 현재 사용되고 있지 않습니다. 기존의 바인딩의 등록을 해제하는데는
<code>ActionMap</code> 또는 <code>InputMap</code> 로부터 바인딩을 삭제하는지, 또는 <code>InputMap</code> 에 더미 바인딩을 설정합니다. <code>InputMap</code> 로부터 바인딩을 삭제하면, 부모의 <code>InputMap</code>
 바인딩을 액티브하게 할 수 있습니다. 그에 대해,<code>InputMap</code> 에 더미 바인딩을 배치하면, 지금까지 발생한 바인딩을 효과적으로 무효로 합니다.
 <p>
키보드 액션을 등록 해제합니다. 이 해제에
해,<code>InputMap</code> 와 같이 <code>ActionMap</code> (존재하는 경우)의 바인딩도 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getRegisteredKeyStrokes()"><!-- --></A> <H3>
getRegisteredKeyStrokes</H3>
<PRE>
public <A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 내의 클래스">KeyStroke</A> [] <B>getRegisteredKeyStrokes</B>()</PRE>
<DL>
<DD>등록되어 있는 액션을 개시하는 <code>KeyStroke</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>KeyStroke</code> 오브젝트의 배열<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getConditionForKeyStroke(javax.swing.KeyStroke)"><!-- --></A> <H3>
getConditionForKeyStroke</H3>
<PRE>
public int <B>getConditionForKeyStroke</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>등록되어 있는 액션이, 지정된 키스트로크(keystroke)에 반응해 발생할지 어떨지를 결정하는 조건을 돌려줍니다.
 <p>
Java 2 플랫폼 v1. 3
 경우,<code>KeyStroke</code>를
 복수의 조건과 관련지을 수가 있습니다. 예를 들어, 1 개의 키스트로크(keystroke)를 2 개의 조건 <code> WHEN_FOCUSED</code> 와 <code>WHEN_IN_FOCUSED_WINDOW</code> 에 바인드 할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>액션과 키스트로크(keystroke)의 조건</DL>
</DD>
</DL>
<HR>

<A NAME="getActionForKeyStroke(javax.swing.KeyStroke)"><!-- --></A> <H3>
getActionForKeyStroke</H3>
<PRE>
public <A HREF="../../java/awt/event/ActionListener.html" title="java.awt.event 내의 인터페이스">ActionListener</A>  <B>getActionForKeyStroke</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;aKeyStroke)</PRE>
<DL>
<DD>지정된 키스트로크(keystroke)에 대해서 등록되어 있는 액션을 실행하는 오브젝트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키스트로크(keystroke)가 발생했을 때에 불려 가는 <code>ActionListener</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="resetKeyboardActions()"><!-- --></A> <H3>
resetKeyboardActions</H3>
<PRE>
public void <B>resetKeyboardActions</B>()</PRE>
<DL>
<DD>제 1 층의 <code>InputMap</code> 와 <code>ActionMap</code>
 바인딩을 모두 등록 해제합니다. 이 방법은, 어느 로컬 바인딩을 삭제하는 경우에도 효과적이며, 부모의 <code>InputMap</code> 및 <code>ActionMap</code> (UI는
 보통
 제 2 층에서 정의)에 정의된 바인딩을 지속시킬 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setInputMap(int, javax.swing.InputMap)"><!-- --></A> <H3>
setInputMap</H3>
<PRE>
public final void <B>setInputMap</B>(int&nbsp;condition,
                              <A HREF="../../javax/swing/InputMap.html" title="javax.swing 안의 클래스">InputMap</A> &nbsp;map)</PRE>
<DL>
<DD>조건 <code>condition</code> 로 사용하는 <code>InputMap</code>를
 <code>map</code> 로 설정합니다. <code>null</code> 치는 UI 로부터의 것이어도 바인딩을 사용하지 않는 것을 나타냅니다. UI <code>InputMap</code> 가 존재하는 경우, 재인스톨은 하지 않습니다. <code>condition</code>
 값은 다음의 어떤 것인가가 됩니다. <ul> <li><code>WHEN_IN_FOCUSED_WINDOW</code> <li><code>WHEN_FOCUSED</code> <li><code>WHEN_ANCESTOR_OF_FOCUSED_COMPONENT</code> 
</ul>
 <code>condition</code> 가 <code>WHEN_IN_FOCUSED_WINDOW</code> 이며,<code>map</code> 가 <code>ComponentInputMap</code> 가 아닌 경우,<code>IllegalArgumentException</code> 가 Throw 됩니다. 같이<code>condition</code> 가 상기의 것이 아닌 경우,<code>IllegalArgumentException</code> 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 전술의 값의 어떤 것이나<DD><CODE>map</CODE> - 지정의 조건에 대해서 사용되는 <code>InputMap</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>condition</code> 가 <code>WHEN_IN_FOCUSED_WINDOW</code> 이며,<code>map</code> 가 <code>ComponentInputMap</code>
 인스턴스가 아닌 경우, 또는 <code>condition</code> 가 상기로 지정된 값이 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputMap(int)"><!-- --></A> <H3>
getInputMap</H3>
<PRE>
public final <A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A>  <B>getInputMap</B>(int&nbsp;condition)</PRE>
<DL>
<DD><code>condition</code> 로 사용되고 있는 <code>InputMap</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - WHEN_IN_FOCUSED_WINDOW, WHEN_FOCUSED, WHEN_ANCESTOR_OF_FOCUSED_COMPONENT  가운데 1 개
<DT><B>반환값:</B><DD>지정된 <code>condition</code> 에 대한 <code>InputMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputMap()"><!-- --></A> <H3>
getInputMap</H3>
<PRE>
public final <A HREF="../../javax/swing/InputMap.html" title="javax.swing 내의 클래스">InputMap</A>  <B>getInputMap</B>()</PRE>
<DL>
<DD>컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code>를
 돌려줍니다. 이것은 <code>getInputMap(WHEN_FOCUSED)</code>
 간이 메서드입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트가 포커스를 취득했을 때에 사용하는 <code>InputMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setActionMap(javax.swing.ActionMap)"><!-- --></A> <H3>
setActionMap</H3>
<PRE>
public final void <B>setActionMap</B>(<A HREF="../../javax/swing/ActionMap.html" title="javax.swing 안의 클래스">ActionMap</A> &nbsp;am)</PRE>
<DL>
<DD><code>ActionMap</code>를
 <code>am</code> 로 설정합니다. UI 가 존재하는 경우에서도,<code>am</code>
 부모를 UI 로부터의 <code>ActionMap</code> 로서는 설정하지 않습니다. 이 처리는 호출해 옆에서 실시합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>am</CODE> - 새로운 <code>ActionMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getActionMap()"><!-- --></A> <H3>
getActionMap</H3>
<PRE>
public final <A HREF="../../javax/swing/ActionMap.html" title="javax.swing 내의 클래스">ActionMap</A>  <B>getActionMap</B>()</PRE>
<DL>
<DD>특정의 <code>KeyStroke</code> 바인딩에 대해서 트리거 하는 <code>Action</code>
 지정에 사용되는 <code>ActionMap</code>를
 돌려줍니다. 외가 설정되어 있지 않으면, 돌려주고지는 <code>ActionMap</code>는

 그 부모와 같은 UI
 <code>ActionMap</code>를
 가집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>키 또는 액션의 바인딩을 포함한 <code>ActionMap</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="requestDefaultFocus()"><!-- --></A> <H3>
requestDefaultFocus</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public boolean <B>requestDefaultFocus</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.4 이후는 <code>FocusTraversalPolicy.getDefaultComponent(Container). requestFocus()</code> 로 옮겨졌습니다. </I>
<P>
<DD>릴리스 1.4 에서는
 포커스 하부조직이 재구축 되었습니다. 상세한 것에 대하여는
 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/focus.html">「How to Use the Focus Subsystem」</a>를 참조하십시오. <em></em>
 <p>
이 <code>JComponent</code>
 <code>FocusTraversalPolicy</code>
 디폴트 <code>Component</code> 에의 포커스를 요구합니다. 이 <code>JComponent</code> 가 포커스 사이클 루트의 경우, 그 <code>FocusTraversalPolicy</code> 가 사용됩니다. 그렇지 않은 경우는
 이 <code>JComponent</code>
 포커스 사이클 루트 클래스의 <code>FocusTraversalPolicy</code> 가 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/FocusTraversalPolicy.html#getDefaultComponent(java.awt.Container)"><CODE>FocusTraversalPolicy.getDefaultComponent(java.awt.Container)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setVisible(boolean)"><!-- --></A> <H3>
setVisible</H3>
<PRE>
public void <B>setVisible</B>(boolean&nbsp;aFlag)</PRE>
<DL>
<DD>컴퍼넌트를 가시 또는 불가시로 합니다. <code>Component.setVisible</code>를
 오버라이드(override) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setVisible(boolean)">setVisible</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aFlag</CODE> - 컴퍼넌트를 가시로 하는 경우는 true, 불가시로 하는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isVisible()"><CODE>Component.isVisible()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setEnabled(boolean)"><!-- --></A> <H3>
setEnabled</H3>
<PRE>
public void <B>setEnabled</B>(boolean&nbsp;enabled)</PRE>
<DL>
<DD>이 컴퍼넌트가 유효한가 어떤가를 설정합니다. 유효한 컴퍼넌트는 유저의 입력에 반응할 수 있습니다만, 무효인 컴퍼넌트는 유저의 입력에 반응할 수 없습니다. 컴퍼넌트에 따라서는 그것이 무효인 경우로 표시를 변경해, 입력을 납득할 수 없는 것을 나타내는 피드백을 유저에게 제공할 수 있습니다.
<p>컴퍼넌트를 무효화해도 아이는 무효화되지 않는 것에 주의해 주세요.


<p>경량화 컴퍼넌트를 사용 불가능하게 해도 MouseEvent는
 수신되는 것에 주의해 주세요.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setEnabled(boolean)">setEnabled</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enabled</CODE> - 이 컴퍼넌트를 유효화하는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isEnabled()"><CODE>Component.isEnabled()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#isLightweight()"><CODE>Component.isLightweight()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setForeground(java.awt.Color)"><!-- --></A> <H3>
setForeground</H3>
<PRE>
public void <B>setForeground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;fg)</PRE>
<DL>
<DD>이 컴퍼넌트의 foreground 컬러를 설정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setForeground(java.awt.Color)">setForeground</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fg</CODE> - 요구하는 foreground <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getForeground()"><CODE>Component.getForeground()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBackground(java.awt.Color)"><!-- --></A> <H3>
setBackground</H3>
<PRE>
public void <B>setBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bg)</PRE>
<DL>
<DD>이 컴퍼넌트의 백그라운드 컬러를 설정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#setBackground(java.awt.Color)">setBackground</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>bg</CODE> - 요구하는 백그라운드 <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getBackground()"><CODE>Component.getBackground()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A> <H3>
setFont</H3>
<PRE>
public void <B>setFont</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>이 컴퍼넌트의 폰트를 설정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#setFont(java.awt.Font)">setFont</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 이 컴퍼넌트로 지정하는 <code>Font</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getFont()"><CODE>Component.getFont()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultLocale()"><!-- --></A> <H3>
getDefaultLocale</H3>
<PRE>
public static <A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A>  <B>getDefaultLocale</B>()</PRE>
<DL>
<DD>각 JComponent
 로케일 프로퍼티를 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 돌려줍니다.
디폴트 로케일에는 「AppContext」스코프가 있어, 애플릿 (그리고 잠재적으로는 단독의 VM 로 실행되는 복수의 경량 어플리케이션)이 독자적인 설정을 가질 수가 있습니다. 어느 애플릿이 디폴트 로케일을 변경해도, 다른 애플릿 (또는 브라우저)에는 영향을 주지 않기 때문에
 안전하게 변경할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 <code>Locale</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setDefaultLocale(java.util.Locale)"><CODE>setDefaultLocale(java.util.Locale)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getLocale()"><CODE>Component.getLocale()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)"><CODE>Component.setLocale(java.util.Locale)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultLocale(java.util.Locale)"><!-- --></A> <H3>
setDefaultLocale</H3>
<PRE>
public static void <B>setDefaultLocale</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;l)</PRE>
<DL>
<DD>각 JComponent
 로케일 프로퍼티를 생성시에 초기화하기 위해서 사용하는 디폴트 로케일을 설정합니다. 초기치는 VM
 디폴트 로케일입니다.
디폴트 로케일에는 「AppContext」스코프가 있어, 애플릿 (그리고 잠재적으로는 단독의 VM 로 실행되는 복수의 경량 어플리케이션)이 독자적인 설정을 가질 수가 있습니다. 어느 애플릿이 디폴트 로케일을 변경해도, 다른 애플릿 (또는 브라우저)에는 영향을 주지 않기 때문에
 안전하게 변경할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>l</CODE> - 새로운 컴퍼넌트로 지정하는 디폴트 <code>Locale</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getDefaultLocale()"><CODE>getDefaultLocale()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getLocale()"><CODE>Component.getLocale()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#setLocale(java.util.Locale)"><CODE>Component.setLocale(java.util.Locale)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processComponentKeyEvent(java.awt.event.KeyEvent)"><!-- --></A> <H3>
processComponentKeyEvent</H3>
<PRE>
protected void <B>processComponentKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</PRE>
<DL>
<DD>컴퍼넌트 자체가 인식하는 키 이벤트를 처리합니다. 이 메서드는
 포커스 매니저 및 관련된 모든 리스너에게, 이벤트를 횡령할 기회가 주어진 뒤에 불려 갑니다. 이 메서드는
 이벤트가 아직 사용되어 있지 않은 경우에만 불려 갑니다. 이 메서드는
 키보드 UI 논리에 우선해 불려 갑니다.
 <p>
이 메서드의 구현은 아무것도 실시하지 않습니다. 보통
, 서브 클래스는 그것들 자체가 키 이벤트를 처리하는 경우에 이 메서드를 오버라이드(override) 합니다. 처리된 이벤트는 파기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="processKeyEvent(java.awt.event.KeyEvent)"><!-- --></A> <H3>
processKeyEvent</H3>
<PRE>
protected void <B>processKeyEvent</B>(<A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이벤트를 처리하는 <code>processKeyEvent</code>를
 오버라이드(override) 합니다.  </dl>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processKeyEvent(java.awt.event.KeyEvent)">processKeyEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 키 이벤트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 내의 클래스"><CODE>KeyEvent</CODE></A>,
 
<A HREF="../../java/awt/event/KeyListener.html" title="java.awt.event 안의 인터페이스"><CODE>KeyListener</CODE></A>,
 
<A HREF="../../java/awt/KeyboardFocusManager.html" title="java.awt 안의 클래스"><CODE>KeyboardFocusManager</CODE></A>,
 
<A HREF="../../java/awt/DefaultKeyboardFocusManager.html" title="java.awt 안의 클래스"><CODE>DefaultKeyboardFocusManager</CODE></A>,
 
<A HREF="../../java/awt/Component.html#processEvent(java.awt.AWTEvent)"><CODE>Component.processEvent(java.awt.AWTEvent)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#dispatchEvent(java.awt.AWTEvent)"><CODE>Component.dispatchEvent(java.awt.AWTEvent)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#addKeyListener(java.awt.event.KeyListener)"><CODE>Component.addKeyListener(java.awt.event.KeyListener)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#enableEvents(long)"><CODE>Component.enableEvents(long)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processKeyBinding(javax.swing.KeyStroke, java.awt.event.KeyEvent, int, boolean)"><!-- --></A> <H3>
processKeyBinding</H3>
<PRE>
protected boolean <B>processKeyBinding</B>(<A HREF="../../javax/swing/KeyStroke.html" title="javax.swing 안의 클래스">KeyStroke</A> &nbsp;ks,
                                    <A HREF="../../java/awt/event/KeyEvent.html" title="java.awt.event 안의 클래스">KeyEvent</A> &nbsp;e,
                                    int&nbsp;condition,
                                    boolean&nbsp;pressed)</PRE>
<DL>
<DD><code>KeyEvent</code> <code>e</code>
 결과로서 <code>ks</code>
 키 바인드를 처리하기 위해서 불려 갑니다. 이 메서드는 적절한 <code>InputMap</code>,
 그 바인딩,<code>ActionMap</code>
 액션을 취득해, (액션이 발견되어, 수신측이 유효한 경우) 액션을 통지하기 위해서 <code>notifyAction</code>를
 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ks</CODE> - 조회하는 <code>KeyStroke</code><DD><CODE>e</CODE> - <code>KeyEvent</code><DD><CODE>condition</CODE> - 다음의 값의 어떤 것인가<ul> <li>JComponent.WHEN_FOCUSED<li>JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT<li>JComponent.WHEN_IN_FOCUSED_WINDOW </ul><DD><CODE>pressed</CODE> - 키가 밀리고 있는 경우는 true
<DT><B>반환값:</B><DD>액션에 바인딩이 있어, 액션이 유효했던 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToolTipText(java.lang.String)"><!-- --></A> <H3>
setToolTipText</H3>
<PRE>
public void <B>setToolTipText</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;text)</PRE>
<DL>
<DD>툴 힌트에 표시하는 텍스트를 등록합니다. 이 텍스트는
 커서가 컴퍼넌트상에 있을 때 표시됩니다.
 <p>
자세한 것은, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/components/tooltip.html">「How to Use Tool Tips」</a>를 참조하십시오.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 표시하는 캐릭터 라인. 텍스트가 <code>null</code>
 경우는
 이 컴퍼넌트의 툴 힌트는 오프로 설정되는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY"><CODE>TOOL_TIP_TEXT_KEY</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText()"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>()</PRE>
<DL>
<DD><code>setToolTipText</code> 로 설정되어 있는 툴 힌트의 캐릭터 라인을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>툴 힌트의 텍스트<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#TOOL_TIP_TEXT_KEY"><CODE>TOOL_TIP_TEXT_KEY</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipText(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipText</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getToolTipText</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD><i>event</i>
 툴 힌트로서 사용되는 캐릭터 라인을 돌려줍니다. 디폴트에서는
 이 메서드는 <code> setToolTipText</code> 로 설정된 캐릭터 라인을 돌려줍니다. 컴퍼넌트가 보다 포괄적인 API를
 제공해 다른 위치에서 다른 툴 힌트를 지원하는
 경우, 이 메서드는 오버라이드(override) 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getToolTipLocation(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getToolTipLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getToolTipLocation</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD>이 컴퍼넌트의 좌표계에 있어서의 툴 힌트의 위치를 돌려줍니다. <code>null</code> 가 돌려주고지는 경우는
 Swing 가 위치를 선택합니다. 디폴트의 구현은 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - <code>ToolTipManager</code> 에 툴 힌트를 표시시키는 <code>MouseEvent</code>
<DT><B>반환값:</B><DD>항상 <code>null</code>를
 돌려준다</DL>
</DD>
</DL>
<HR>

<A NAME="getPopupLocation(java.awt.event.MouseEvent)"><!-- --></A> <H3>
getPopupLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getPopupLocation</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;event)</PRE>
<DL>
<DD>이 컴퍼넌트의 좌표계에 pop-up menu를 표시하는데 적절한 위치를 돌려줍니다. 이 프로퍼티를 받아들일 수 있을지 어떨지는 Look & Feel 나름이며, 무시되는 일도 있습니다. <code>null</code> 가 돌려주고졌을 경우는
 Look & Feel 에
해 적절한 위치가 선택됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - 표시되는 pop-up를 트리거 한 <code>MouseEvent</code>. 마우스 이벤트의 결과로서 pop-up가 표시되어 있지 않은 경우는 null.
<DT><B>반환값:</B><DD>JPopupMenu 가 표시되는 위치<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createToolTip()"><!-- --></A> <H3>
createToolTip</H3>
<PRE>
public <A HREF="../../javax/swing/JToolTip.html" title="javax.swing 내의 클래스">JToolTip</A>  <B>createToolTip</B>()</PRE>
<DL>
<DD>툴 힌트를 표시하기 위해서 사용되는 <code>JToolTip</code>
 인스턴스를 돌려줍니다. 보통
 컴퍼넌트는 이 메서드를 오버라이드(override) 하지 않습니다만, 이 메서드는 복수의 툴 힌트를 따로 따로 표시하기 위해서 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 툴 힌트 표시에 사용되는 <code>JToolTip</code></DL>
</DD>
</DL>
<HR>

<A NAME="scrollRectToVisible(java.awt.Rectangle)"><!-- --></A> <H3>
scrollRectToVisible</H3>
<PRE>
public void <B>scrollRectToVisible</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;aRect)</PRE>
<DL>
<DD><code>scrollRectToVisible()</code> 메세지를 <code>JComponent</code>
 부모에게 전송 합니다. 이 요구를 처리할 수 있는 <code>JViewport</code> 등의 컴퍼넌트는
 이 메서드를 오버라이드(override) 해 스크롤을 실행합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aRect</CODE> - 가시 <code>Rectangle</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JViewport.html" title="javax.swing 내의 클래스"><CODE>JViewport</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setAutoscrolls(boolean)"><!-- --></A> <H3>
setAutoscrolls</H3>
<PRE>
public void <B>setAutoscrolls</B>(boolean&nbsp;autoscrolls)</PRE>
<DL>
<DD><code>autoscrolls</code> 프로퍼티를 설정합니다. <code>true</code>
 경우, 마우스가 컴퍼넌트의 경계외에 드래그
 되어 마우스의 버튼을 누른 채로 정지되면, 마우스 드래그
 이벤트가 합성되어 생성됩니다. 합성 이벤트에서는
 컴퍼넌트의 경계를 넘어 드래그
가 실행되었을 경우, 그 방향에의 드래그
가 재개된 것처럼 가장합니다. 오토 스크롤을 지원하는
 컴퍼넌트는
 마우스 이벤트 위치를 포함한 구형을 지정해 <code>scrollRectToVisible</code>를
 호출해,<code>mouseDragged</code> 이벤트를 처리할 필요가 있습니다. 항목 선택을 서포트해,<code>JScrollPane</code> 에 표시되는 모든 Swing 컴퍼넌트 (<code>JTable</code>,<code>JList</code>,<code>JTree</code>,<code>JTextArea</code> 및 <code>JEditorPane</code>)는
 이 방법에서의 마우스 드래그
 이벤트 처리를 구현제입니다. 다른 컴퍼넌트로 오토 스크롤을 유효화하기 위해서는
<code>scrollRectToVisible</code>를
 호출하는 마우스 모션 리스너를 추가합니다. <code>JPanel</code>,<code>myPanel</code> 에서의 예를 듭니다.
 
 <pre>

 MouseMotionListener doScrollRectToVisible = new MouseMotionAdapter() {
     public void mouseDragged(MouseEvent e) {
        Rectangle r = new Rectangle(e.getX(), e.getY(), 1, 1);
        ((JPanel) e.getSource()). scrollRectToVisible(r);
    }
 };
 myPanel.addMouseMotionListener(doScrollRectToVisible);
 </pre>
<code>autoScrolls</code> 프로퍼티의 디폴트치는 <code>false</code> 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>autoscrolls</CODE> - true
 경우, mouse button가 밀린채로 컴퍼넌트의 경계외까지 마우스가 드래그
 되면 합성 마우스 드래그
 이벤트를 생성. false
 경우는 생성되지 않는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getAutoscrolls()"><CODE>getAutoscrolls()</CODE></A>,
 
<A HREF="../../javax/swing/JViewport.html" title="javax.swing 안의 클래스"><CODE>JViewport</CODE></A>,
 
<A HREF="../../javax/swing/JScrollPane.html" title="javax.swing 안의 클래스"><CODE>JScrollPane</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAutoscrolls()"><!-- --></A> <H3>
getAutoscrolls</H3>
<PRE>
public boolean <B>getAutoscrolls</B>()</PRE>
<DL>
<DD><code>autoscrolls</code> 프로퍼티를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>autoscrolls</code> 프로퍼티의 값<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JViewport.html" title="javax.swing 내의 클래스"><CODE>JViewport</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setAutoscrolls(boolean)"><CODE>setAutoscrolls(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTransferHandler(javax.swing.TransferHandler)"><!-- --></A> <H3>
setTransferHandler</H3>
<PRE>
public void <B>setTransferHandler</B>(<A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 안의 클래스">TransferHandler</A> &nbsp;newHandler)</PRE>
<DL>
<DD><code>transferHandler</code> 프로퍼티를 설정합니다. 컴퍼넌트가 데이터 전송 처리를 서포트하고 있지 않는 경우는 <code>null</code> 가 돌려주고집니다.
 <p>
<code>newHandler</code> 가 <code>null</code>는
 아니고, 시스템 프로퍼티 <code>suppressSwingDropSupport</code> 가 true 가 아닌 경우는
<code>JComponent</code>
 <code>DropTarget</code>를
 인스톨 합니다. 이 시스템 프로퍼티의 디폴트는 false 이며,<code>DropTarget</code> 가 추가됩니다.
 <p>
자세한 것은, 「The Java Tutorial」의<a href="http://java.sun.com/docs/books/tutorial/uiswing/misc/dnd.html">「How to Use Drag and Drop and Data Transfer」</a>를 참조하십시오.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newHandler</CODE> - 컴퍼넌트와의 사이에 데이터를 전송 하는 방법<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스"><CODE>TransferHandler</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getTransferHandler()"><CODE>getTransferHandler()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTransferHandler()"><!-- --></A> <H3>
getTransferHandler</H3>
<PRE>
public <A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스">TransferHandler</A>  <B>getTransferHandler</B>()</PRE>
<DL>
<DD><code>transferHandler</code> 프로퍼티를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><code>transferHandler</code> 프로퍼티의 값<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/TransferHandler.html" title="javax.swing 내의 클래스"><CODE>TransferHandler</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#setTransferHandler(javax.swing.TransferHandler)"><CODE>setTransferHandler(javax.swing.TransferHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processMouseEvent(java.awt.event.MouseEvent)"><!-- --></A> <H3>
processMouseEvent</H3>
<PRE>
protected void <B>processMouseEvent</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</PRE>
<DL>
<DD>이 컴퍼넌트로 발생하는 마우스 이벤트를, 등록되어 모든 <code>MouseListener</code> 오브젝트에 디스패치 하는 것으로써, 마우스 이벤트를 처리합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseEvent(MouseEvent)</CODE></A> 를
 참조하십시오.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)">processMouseEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - 마우스 이벤트<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#processMouseEvent(java.awt.event.MouseEvent)"><CODE>Component.processMouseEvent(java.awt.event.MouseEvent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="processMouseMotionEvent(java.awt.event.MouseEvent)"><!-- --></A> <H3>
processMouseMotionEvent</H3>
<PRE>
protected void <B>processMouseMotionEvent</B>(<A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 안의 클래스">MouseEvent</A> &nbsp;e)</PRE>
<DL>
<DD>MouseEvent.MOUSE_DRAGGED 등의 마우스 모션 이벤트를 처리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#processMouseMotionEvent(java.awt.event.MouseEvent)">processMouseMotionEvent</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>e</CODE> - <code>MouseEvent</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/event/MouseEvent.html" title="java.awt.event 내의 클래스"><CODE>MouseEvent</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="enable()"><!-- --></A> <H3>
enable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>enable</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#enable()">enable</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="disable()"><!-- --></A> <H3>
disable</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>disable</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>java.awt.Component.setEnabled(boolean)</code> 로 옮겨졌습니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#disable()">disable</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getAccessibleContext()"><!-- --></A> <H3>
getAccessibleContext</H3>
<PRE>
public <A HREF="../../javax/accessibility/AccessibleContext.html" title="javax.accessibility 내의 클래스">AccessibleContext</A>  <B>getAccessibleContext</B>()</PRE>
<DL>
<DD>이 <code>JComponent</code> 에 관련지을 수 있었던 <code>AccessibleContext</code>를
 돌려줍니다. 이 base class에
한 메서드 구현에서는 null 가 돌려주고집니다. <code>JComponent</code>를
 확장하는 클래스는
 이 메서드를 구현해, 서브 클래스에 관련지을 수 있었던 <code>AccessibleContext</code>를
 돌려주도록(듯이) 합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getAccessibleContext()">getAccessibleContext</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JComponent</code>
 <code>AccessibleContext</code></DL>
</DD>
</DL>
<HR>

<A NAME="getClientProperty(java.lang.Object)"><!-- --></A> <H3>
getClientProperty</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getClientProperty</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>지정된 키를 가지는 프로퍼티의 값을 돌려줍니다. <code>putClientProperty</code> 로 추가된 프로퍼티만이 <code>null</code> 이외의 값을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 조회용의 키
<DT><B>반환값:</B><DD>이 프로퍼티의 값 또는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#putClientProperty(java.lang.Object, java.lang.Object)"><CODE>putClientProperty(java.lang.Object, java.lang.Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="putClientProperty(java.lang.Object, java.lang.Object)"><!-- --></A> <H3>
putClientProperty</H3>
<PRE>
public final void <B>putClientProperty</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key,
                                    <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;value)</PRE>
<DL>
<DD>임의의 키와 값을 조합한 클라이언트 프로퍼티를 이 컴퍼넌트에 추가합니다.
 <p>
<code>get/putClientProperty</code> 메서드는
 인스턴스마다의 작은 해시 테이블에의 액세스를 제공합니다. 호출측은, getClientProperty 와 putClientProperty를
 사용해, 다른 모듈에
해 생성된 컴퍼넌트에 주석을 붙입니다. 예를 들어, 레이아웃 매니저는 이 방법으로 아이마다의 제약을 포함하는 경우가 있습니다. 다음에 예를 나타냅니다.
 
 <pre>

componentA.putClientProperty("to the left of", componentB);
 </pre>
값이 <code>null</code>
 경우, 이 메서드는 그 프로퍼티를 삭제합니다. 클라이언트 프로퍼티에의 변경은,<code>PropertyChange</code> 이벤트로 보고됩니다. (PropertyChange 이벤트용의) 프로퍼티의 이름은,<code>key.toString()</code> 입니다.
 <p>
<code>clientProperty</code>
 딕쇼내리는
 JComponent 에의 대규모 확장 기능을 지원하는
 것이 아닙니다. 또 새로운 컴퍼넌트를 설계할 때의 서브 클래스화의 대체라고 해도 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>key</CODE> - 새로운 클라이언트 프로퍼티 키<DD><CODE>value</CODE> - 새로운 클라이언트 프로퍼티치. <code>null</code>
 경우는 프로퍼티를 삭제<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getClientProperty(java.lang.Object)"><CODE>getClientProperty(java.lang.Object)</CODE></A>,
 
<A HREF="../../java/awt/Container.html#addPropertyChangeListener(java.beans.PropertyChangeListener)"><CODE>Container.addPropertyChangeListener(java.beans.PropertyChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFocusTraversalKeys(int, java.util.Set)"><!-- --></A> <H3>
setFocusTraversalKeys</H3>
<PRE>
public void <B>setFocusTraversalKeys</B>(int&nbsp;id,
                                  <A HREF="../../java/util/Set.html" title="java.util 안의 인터페이스">Set</A> &lt;?  extends <A HREF="../../java/awt/AWTKeyStroke.html" title="java.awt 내의 클래스">AWTKeyStroke</A> &gt;&nbsp;keystrokes)</PRE>
<DL>
<DD>이 컴퍼넌트의 지정된 호랑이 용기 조작에 대한 포커스 호랑이 용기 키를 설정합니다. 이 메서드의 상세한 것에 대하여는
<A HREF="../../java/awt/Component.html#setFocusTraversalKeys(int, java.util.Set)"><CODE>Component.setFocusTraversalKeys(int, java.util.Set<?  extends java.awt.AWTKeyStroke>)</CODE></A> 를
 참조하십시오.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#setFocusTraversalKeys(int, java.util.Set)">setFocusTraversalKeys</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>id</CODE> - KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, 또는 KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
 어떤 것이나<DD><CODE>keystrokes</CODE> - 지정된 조작에 대한 AWTKeyStroke 세트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - id 가 KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS, KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS, 또는 KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS
 어떤 것도 아닌 경우, 키스트로크(keystroke)가 null
 경우, 키스트로크(keystroke)의 오브젝트의 어떤 것인가가 AWTKeyStroke 가 아닌 경우, 키스트로크(keystroke)의 어떤 것인가가 KEY_TYPED 이벤트를 나타내지 않은 경우, 또는 키스트로크(keystroke)의 어떤 것인가가 이 컴퍼넌트의 다른 포커스 호랑이 용기 조작에 맵 되고 있는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/KeyboardFocusManager.html#FORWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS</CODE></A>,
 
<A HREF="../../java/awt/KeyboardFocusManager.html#BACKWARD_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS</CODE></A>,
 
<A HREF="../../java/awt/KeyboardFocusManager.html#UP_CYCLE_TRAVERSAL_KEYS"><CODE>KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isLightweightComponent(java.awt.Component)"><!-- --></A> <H3>
isLightweightComponent</H3>
<PRE>
public static boolean <B>isLightweightComponent</B>(<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스">Component</A> &nbsp;c)</PRE>
<DL>
<DD>이 컴퍼넌트가 경량의 경우, 즉 네이티브의 윈도우 시스템 피어를 가지지 않는 경우에 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 경량의 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="reshape(int, int, int, int)"><!-- --></A> <H3>
reshape</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>reshape</B>(int&nbsp;x,
                               int&nbsp;y,
                               int&nbsp;w,
                               int&nbsp;h)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 5 이후는
<code>Component.setBounds(int, int, int, int)</code> 로 옮겨졌습니다.
 <p>
이 컴퍼넌트를 이동해, 사이즈 변경합니다. </I>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#reshape(int, int, int, int)">reshape</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 새로운 수평 방향의 위치<DD><CODE>y</CODE> - 새로운 수직 방향의 위치<DD><CODE>w</CODE> - 새로운의 폭<DD><CODE>h</CODE> - 새로운의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#setBounds(int, int, int, int)"><CODE>Component.setBounds(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBounds(java.awt.Rectangle)"><!-- --></A> <H3>
getBounds</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getBounds</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 경계를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. <code>rv</code> 가 <code>null</code>
 경우, 새로운 <code>Rectangle</code>를
 할당할 수 있습니다. 이 버젼의 <code>getBounds</code>는

 호출측이 heap로 새로운 <code>Rectangle</code> 오브젝트를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getBounds(java.awt.Rectangle)">getBounds</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 경계가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code>. <code>rv</code> 가 <code>null</code>
 경우는 새롭게 등록된 <code>Rectangle</code> 와 컴퍼넌트의 경계를 돌려줍니다. </DL>
</DD>
</DL>
<HR>

<A NAME="getSize(java.awt.Dimension)"><!-- --></A> <H3>
getSize</H3>
<PRE>
public <A HREF="../../java/awt/Dimension.html" title="java.awt 내의 클래스">Dimension</A>  <B>getSize</B>(<A HREF="../../java/awt/Dimension.html" title="java.awt 안의 클래스">Dimension</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 폭과 높이를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. <code>rv</code> 가 <code>null</code>
 경우, 새로운 <code>Dimension</code> 오브젝트를 할당할 수 있습니다. 이 버젼의 <code>getSize</code>는

 호출측이 heap로 새로운 <code>Dimension</code> 오브젝트를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getSize(java.awt.Dimension)">getSize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 사이즈가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLocation(java.awt.Point)"><!-- --></A> <H3>
getLocation</H3>
<PRE>
public <A HREF="../../java/awt/Point.html" title="java.awt 내의 클래스">Point</A>  <B>getLocation</B>(<A HREF="../../java/awt/Point.html" title="java.awt 안의 클래스">Point</A> &nbsp;rv)</PRE>
<DL>
<DD>이 컴퍼넌트의 원점의 x, y 좌표를 「반환값」<code>rv</code> 에 포함해,<code>rv</code>를
 돌려줍니다. <code>rv</code> 가 <code>null</code>
 경우, 새로운 <code>Point</code>를
 할당할 수 있습니다. 이 버젼의 <code>getLocation</code>는

 호출측이 heap로 새로운 <code>Point</code> 오브젝트를 할당하고 싶지 않은 경우에 편리합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getLocation(java.awt.Point)">getLocation</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rv</CODE> - 컴퍼넌트의 위치가 포함된 반환값
<DT><B>반환값:</B><DD><code>rv</code></DL>
</DD>
</DL>
<HR>

<A NAME="getX()"><!-- --></A> <H3>
getX</H3>
<PRE>
public int <B>getX</B>()</PRE>
<DL>
<DD>컴퍼넌트의 원점의 현재의 x 좌표를 돌려줍니다. 이 메서드는
 heap 할당이 발생하지 않기 때문에
<code>component.getBounds(). x</code> 또는 <code>component.getLocation(). x</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getX()">getX</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 원점의 현재의 x 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getY()"><!-- --></A> <H3>
getY</H3>
<PRE>
public int <B>getY</B>()</PRE>
<DL>
<DD>컴퍼넌트의 원점의 현재의 y 좌표를 돌려줍니다. 이 메서드는
 heap 할당이 발생하지 않기 때문에
<code>component.getBounds(). y</code> 또는 <code>component.getLocation(). y</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getY()">getY</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>컴퍼넌트의 원점의 현재의 y 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getWidth()"><!-- --></A> <H3>
getWidth</H3>
<PRE>
public int <B>getWidth</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 현재의 폭을 돌려줍니다. 이 메서드는
 heap의 할당이 발생하지 않기 때문에
<code>component.getBounds(). width</code> 또는 <code>component.getSize(). width</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getWidth()">getWidth</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 현재의 폭</DL>
</DD>
</DL>
<HR>

<A NAME="getHeight()"><!-- --></A> <H3>
getHeight</H3>
<PRE>
public int <B>getHeight</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 현재의 높이를 돌려줍니다. 이 메서드는
 heap의 할당이 발생하지 않기 때문에
<code>component.getBounds(). height</code> 또는 <code>component.getSize(). height</code> 보다 적절합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#getHeight()">getHeight</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 현재의 높이</DL>
</DD>
</DL>
<HR>

<A NAME="isOpaque()"><!-- --></A> <H3>
isOpaque</H3>
<PRE>
public boolean <B>isOpaque</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 완전하게 불투명한 경우에 true를
 돌려줍니다.
 <p>
불투명한 컴퍼넌트는 그 구형 경계내의 모든 픽셀을 페인트 합니다. 불투명하지 않는 컴퍼넌트는 그 픽셀의 부분집합만을 페인트 하는지, 전혀 페인트 하지 않기 때문에
 그 아래의 픽셀을 틈이 날 수 있어 표시됩니다. 그 때문에
 모든 픽셀을 페인트 하지 않는 컴퍼넌트는 어느 정도의 투과성이 있습니다.
 <p>
항상 그 내용을 완전하게 페인트 하는 서브 클래스는
 이 메서드를 오버라이드(override) 해, true를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#isOpaque()">isOpaque</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 완전하게 불투명한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#setOpaque(boolean)"><CODE>setOpaque(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setOpaque(boolean)"><!-- --></A> <H3>
setOpaque</H3>
<PRE>
public void <B>setOpaque</B>(boolean&nbsp;isOpaque)</PRE>
<DL>
<DD>true
 경우, 컴퍼넌트는 그 경계내의 모든 픽셀을 페인트 합니다. false
 경우, 컴퍼넌트는 픽셀의 일부 또는 전부를 페인트 하지 않기 때문에
 그 아래의 픽셀을 틈이 날 수 있어 표시됩니다.
 <p>
<code>JComponent</code> 에 대한 이 프로퍼티의 디폴트치는
 false 입니다. 다만, 가장 표준적인 <code>JComponent</code>
 서브 클래스 (<code>JButton</code> 및 <code>JTree</code> 등)에 대한 이 프로퍼티의 디폴트치는
 Look & Feel 에
존합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>isOpaque</CODE> - 이 컴퍼넌트가 불투명한 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#isOpaque()"><CODE>isOpaque()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="computeVisibleRect(java.awt.Rectangle)"><!-- --></A> <H3>
computeVisibleRect</H3>
<PRE>
public void <B>computeVisibleRect</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;visibleRect)</PRE>
<DL>
<DD><code>Component</code>
 「가시 구형」을 돌려줍니다. 이것은, 이 컴퍼넌트와 그 모든 상위 오브젝트의 가시 구형의 공통 부분입니다. 반환값은,<code>visibleRect</code> 에 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>visibleRect</CODE> - 이 컴퍼넌트와 그 모든 상위 오브젝트의 가시 구형의 공통 부분으로서 요구되는 <code>Rectangle</code>. 이것은 이 메서드의 반환값입니다. <DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getVisibleRect()"><CODE>getVisibleRect()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleRect()"><!-- --></A> <H3>
getVisibleRect</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getVisibleRect</B>()</PRE>
<DL>
<DD><code>Component</code>
 「가시 구형」을 돌려줍니다. 이것은, 이 컴퍼넌트의 가시 구형,<code>new Rectangle(0, 0, getWidth(), getHeight())</code> 및 그 모든 상위 오브젝트의 가시 구형의 공통 부분입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>가시 구형</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, boolean, boolean)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               boolean&nbsp;oldValue,
                               boolean&nbsp;newValue)</PRE>
<DL>
<DD>boolean 형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 서포트합니다. 이 메서드는
 바운드 프로퍼티가 변경되었을 때에 불려 가 등록되어 모든 PropertyChangeListener 에
 대응하는 PropertyChangeEvent를
 보냅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, boolean, boolean)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 치가 변경된 프로퍼티<DD><CODE>oldValue</CODE> - 프로퍼티의 이전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 새로운 값</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, int, int)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               int&nbsp;oldValue,
                               int&nbsp;newValue)</PRE>
<DL>
<DD>정수형 프로퍼티에 대한 바운드 프로퍼티의 변경의 보고를 서포트합니다. 이 메서드는
 바운드 프로퍼티가 변경되었을 때에 불려 가 등록되어 모든 PropertyChangeListener 에
 대응하는 PropertyChangeEvent를
 보냅니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, int, int)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 치가 변경된 프로퍼티<DD><CODE>oldValue</CODE> - 프로퍼티의 이전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 새로운 값</DL>
</DD>
</DL>
<HR>

<A NAME="firePropertyChange(java.lang.String, char, char)"><!-- --></A> <H3>
firePropertyChange</H3>
<PRE>
public void <B>firePropertyChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                               char&nbsp;oldValue,
                               char&nbsp;newValue)</PRE>
<DL>
<DD><B>클래스 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, char, char)">Component</A> </CODE>
 기술: </B></DD>
<DD>바운드 프로퍼티의 변경을 통지합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, char, char)">firePropertyChange</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 변경된 프로퍼티의 프로그램명<DD><CODE>oldValue</CODE> - 프로퍼티의 변경전의 값 (char)<DD><CODE>newValue</CODE> - 프로퍼티의 변경 후의 값 (char)<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)"><CODE>Component.firePropertyChange(java.lang.String, java.lang.Object, java.lang.Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fireVetoableChange(java.lang.String, java.lang.Object, java.lang.Object)"><!-- --></A> <H3>
fireVetoableChange</H3>
<PRE>
protected void <B>fireVetoableChange</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;propertyName,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;oldValue,
                                  <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;newValue)
                           throws <A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 내의 클래스">PropertyVetoException</A> </PRE>
<DL>
<DD>제약 프로퍼티의 변경의 보고를 서포트합니다. 이 메서드는
 제약 프로퍼티가 변경되었을 때에 불려 가 등록되어 모든 <code>VetoableChangeListeners</code> 에 대응하는 <code>PropertyChangeEvent</code>를
 송신합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>propertyName</CODE> - 대기하고 있던 프로퍼티의 이름<DD><CODE>oldValue</CODE> - 프로퍼티의 변경전의 값<DD><CODE>newValue</CODE> - 프로퍼티의 변경 후의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/beans/PropertyVetoException.html" title="java.beans 안의 클래스">PropertyVetoException</A> </CODE> - 프로퍼티를 설정하려고 해 수신 측에야는 거부되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="addVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A> <H3>
addVetoableChangeListener</H3>
<PRE>
public void <B>addVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>VetoableChangeListener</code>를
 리스너 리스트에 추가합니다. 리스너는
 모든 프로퍼티에 등록됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 추가되는 <code>VetoableChangeListener</code></DL>
</DD>
</DL>
<HR>

<A NAME="removeVetoableChangeListener(java.beans.VetoableChangeListener)"><!-- --></A> <H3>
removeVetoableChangeListener</H3>
<PRE>
public void <B>removeVetoableChangeListener</B>(<A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 안의 인터페이스">VetoableChangeListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>VetoableChangeListener</code>를
 리스너 리스트로부터 삭제합니다. 모든 프로퍼티에 등록된 <code>VetoableChangeListener</code>를
 삭제합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 삭제되는 <code>VetoableChangeListener</code></DL>
</DD>
</DL>
<HR>

<A NAME="getVetoableChangeListeners()"><!-- --></A> <H3>
getVetoableChangeListeners</H3>
<PRE>
public <A HREF="../../java/beans/VetoableChangeListener.html" title="java.beans 내의 인터페이스">VetoableChangeListener</A> [] <B>getVetoableChangeListeners</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 등록되어 모든 거부 가능 변경 리스너의 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 모든 <code>VetoableChangeListener</code>. 거부 가능 변경 리스너가 현재 등록되지 않은 경우는 하늘의 배열을 돌려주는<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>addVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#removeVetoableChangeListener(java.beans.VetoableChangeListener)"><CODE>removeVetoableChangeListener(java.beans.VetoableChangeListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTopLevelAncestor()"><!-- --></A> <H3>
getTopLevelAncestor</H3>
<PRE>
public <A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A>  <B>getTopLevelAncestor</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 톱 레벨의 상위 오브젝트 (포함처의 <code>Window</code> 또는 <code>Applet</code>)를 돌려줍니다. 이 컴퍼넌트가 어느 컨테이너에도 추가되어 있지 않은 경우는 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 포함되는 톱 레벨의 <code>Container</code>. 어느 컨테이너에도 포함되지 않는 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="addAncestorListener(javax.swing.event.AncestorListener)"><!-- --></A> <H3>
addAncestorListener</H3>
<PRE>
public void <B>addAncestorListener</B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>listener</code>를
 등록해, 컴퍼넌트 또는 게다가 위오브젝트가 이동하든가, 혹은 가시 또는 불가시가 될 때 그 리스너가 <code>AncestorEvent</code>를
 받아들이도록(듯이) 합니다. 이벤트는
 컴퍼넌트 또는 게다가 위오브젝트가 포함 관계의 계층에 추가되는지, 또는 삭제될 때도 송신됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 등록하는 <code>AncestorListener</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/event/AncestorEvent.html" title="javax.swing.event 내의 클래스"><CODE>AncestorEvent</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeAncestorListener(javax.swing.event.AncestorListener)"><!-- --></A> <H3>
removeAncestorListener</H3>
<PRE>
public void <B>removeAncestorListener</B>(<A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 안의 인터페이스">AncestorListener</A> &nbsp;listener)</PRE>
<DL>
<DD><code>listener</code>
 등록을 해제해, 그 리스너가 <code>AncestorEvent</code>를
 받지 않게 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listener</CODE> - 삭제하는 <code>AncestorListener</code><DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)"><CODE>addAncestorListener(javax.swing.event.AncestorListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAncestorListeners()"><!-- --></A> <H3>
getAncestorListeners</H3>
<PRE>
public <A HREF="../../javax/swing/event/AncestorListener.html" title="javax.swing.event 내의 인터페이스">AncestorListener</A> [] <B>getAncestorListeners</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 등록되어 모든 상위 리스너의 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트의 모든 <code>AncestorListener</code>. 상위 리스너가 현재 등록되지 않은 경우는 하늘의 배열을 돌려주는<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#addAncestorListener(javax.swing.event.AncestorListener)"><CODE>addAncestorListener(javax.swing.event.AncestorListener)</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#removeAncestorListener(javax.swing.event.AncestorListener)"><CODE>removeAncestorListener(javax.swing.event.AncestorListener)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getListeners(java.lang.Class)"><!-- --></A> <H3>
getListeners</H3>
<PRE>
public &lt;T extends <A HREF="../../java/util/EventListener.html" title="java.util 내의 인터페이스">EventListener</A> &gt; T[] <B>getListeners</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;T&gt;&nbsp;listenerType)</PRE>
<DL>
<DD>이 <code>JComponent</code> 에 <code><em>Foo</em>Listener</code> 로서 현재 등록되어 모든 오브젝트의 배열을 돌려줍니다. 이 <code><em>Foo</em>Listener</code>는
 <code>add<em>Foo</em>Listener</code> 메서드로 등록된 것입니다.

 <p>
<code>listenerType</code> 인수는 <code><em>Foo</em>Listener.class</code> 와 같은 클래스 리터럴로 지정할 수 있습니다. 예를 들어, 이 마우스 리스너에 대한 <code>JComponent</code> <code>c</code>
 조회는 다음의 코드로 실시합니다.

 <pre>
MouseListener[] mls = (MouseListener[])(c.getListeners(MouseListener.class));</pre>
이러한 리스너가 없는 경우는 하늘의 배열을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#getListeners(java.lang.Class)">getListeners</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>listenerType</CODE> - 요구되는 리스너의 형태. <code>java.util.EventListener</code>
 하위 인터페이스를 지정
<DT><B>반환값:</B><DD>이 컴퍼넌트에 <code><em>Foo</em>Listener</code> 로서 등록되어 모든 오브젝트의 배열. 리스너가 등록되지 않은 경우는 하늘의 배열을 돌려준다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>listenerType</code> 가 <code>java.util.EventListener</code>를
 구현하는 클래스 또는 인터페이스를 지정하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#getVetoableChangeListeners()"><CODE>getVetoableChangeListeners()</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#getAncestorListeners()"><CODE>getAncestorListeners()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addNotify()"><!-- --></A> <H3>
addNotify</H3>
<PRE>
public void <B>addNotify</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 현재친컴퍼넌트가 있는 것을, 이 컴퍼넌트에 통지합니다. 이 메서드가 불려 가면, 친컴퍼넌트의 체인이 <code>KeyboardAction</code> 이벤트 리스너로 설정됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#addNotify()">addNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="removeNotify()"><!-- --></A> <H3>
removeNotify</H3>
<PRE>
public void <B>removeNotify</B>()</PRE>
<DL>
<DD>이 컴퍼넌트에 친컴퍼넌트가 없어진 것을, 이 컴퍼넌트에 통지합니다. 이 메서드가 불려 가면, 친컴퍼넌트의 체인으로 설정된 <code>KeyboardAction</code> 가 삭제됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#removeNotify()">removeNotify</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)"><CODE>registerKeyboardAction(java.awt.event.ActionListener, java.lang.String, javax.swing.KeyStroke, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="repaint(long, int, int, int, int)"><!-- --></A> <H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(long&nbsp;tm,
                    int&nbsp;x,
                    int&nbsp;y,
                    int&nbsp;width,
                    int&nbsp;height)</PRE>
<DL>
<DD>컴퍼넌트가 표시되고 있는 경우에
 지정된 영역을 더티 리젼 리스트에 추가합니다. 컴퍼넌트는
 현재 보류 떠날 수 있어 모든 이벤트가 디스패치 된 뒤에 재렌더링 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#repaint(long, int, int, int, int)">repaint</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tm</CODE> - 이 파라미터는 사용되지 않습니다<DD><CODE>x</CODE> - 더티 리젼의 x 좌표<DD><CODE>y</CODE> - 더티 리젼의 y 좌표<DD><CODE>width</CODE> - 더티 리젼의 폭<DD><CODE>height</CODE> - 더티 리젼의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A>,
 
<A HREF="../../javax/swing/RepaintManager.html#addDirtyRegion(javax.swing.JComponent, int, int, int, int)"><CODE>RepaintManager.addDirtyRegion(javax.swing.JComponent, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="repaint(java.awt.Rectangle)"><!-- --></A> <H3>
repaint</H3>
<PRE>
public void <B>repaint</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>컴퍼넌트가 표시되고 있는 경우에
 지정된 영역을 더티 리젼 리스트에 추가합니다. 컴퍼넌트는
 현재 보류 떠날 수 있어 모든 이벤트가 디스패치 된 뒤에 재렌더링 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 더티 리젼을 포함한 <code>Rectangle</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#isShowing()"><CODE>Component.isShowing()</CODE></A>,
 
<A HREF="../../javax/swing/RepaintManager.html#addDirtyRegion(javax.swing.JComponent, int, int, int, int)"><CODE>RepaintManager.addDirtyRegion(javax.swing.JComponent, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="revalidate()"><!-- --></A> <H3>
revalidate</H3>
<PRE>
public void <B>revalidate</B>()</PRE>
<DL>
<DD>지연 자동 레이아웃을 서포트합니다.
 <p> 
<code>invalidate</code>를
 호출해, 다음에 이 컴퍼넌트의 <code>validateRoot</code>를
, 검증될 필요가 있는 컴퍼넌트의 리스트에 추가합니다. 검증은, 현재 보류 떠날 수 있어 모든 이벤트가 디스패치 된 뒤에 행해집니다. 즉, 이 메서드가 불려 간 뒤, 이 컴퍼넌트의 포함 관계의 계층의 상위에서 최초로 발견된 validateRoot 가 검증됩니다. 디폴트에서는
<code>JRootPane</code>,<code>JScrollPane</code> 및 <code>JTextField</code> 이 <code>isValidateRoot</code> 로부터 true를
 돌려줍니다.
 <p>
이 메서드는
 이 컴퍼넌트의 사이즈, 위치, 또는 내부 레이아웃에 영향을 주는 프로퍼티치의 변경이 있었을 때에
 컴퍼넌트에 대해서 자동적으로 불려 갑니다. 이 자동적인 갱신은, 프로그램이, 보통
, GUI
 내용을 갱신하기 위해서 <code>validate</code>를
 호출할 필요가 없다고 하는 점으로써 AWT 와는 다릅니다.  
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#invalidate()"><CODE>Component.invalidate()</CODE></A>,
 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A>,
 
<A HREF="../../javax/swing/JComponent.html#isValidateRoot()"><CODE>isValidateRoot()</CODE></A>,
 
<A HREF="../../javax/swing/RepaintManager.html#addInvalidComponent(javax.swing.JComponent)"><CODE>RepaintManager.addInvalidComponent(javax.swing.JComponent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isValidateRoot()"><!-- --></A> <H3>
isValidateRoot</H3>
<PRE>
public boolean <B>isValidateRoot</B>()</PRE>
<DL>
<DD>이 메서드가 true를
 돌려주는 경우, 이 컴퍼넌트의 하위 컴퍼넌트에
해 <code>revalidate</code> 가 불려 가면, 이 루트로 시작되는 트리 전체가 검증됩니다. 디폴트에서는 false를
 돌려줍니다. <code>JScrollPane</code>는
 이 메서드를 오버라이드(override) 해, true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>항상 false를
 돌려주는<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#revalidate()"><CODE>revalidate()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#invalidate()"><CODE>Component.invalidate()</CODE></A>,
 
<A HREF="../../java/awt/Container.html#validate()"><CODE>Container.validate()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOptimizedDrawingEnabled()"><!-- --></A> <H3>
isOptimizedDrawingEnabled</H3>
<PRE>
public boolean <B>isOptimizedDrawingEnabled</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 그 아이를 타일링 하는 경우, 즉 자식이 오버랩 하지 않는 것이 보증되는 경우에 true를
 돌려줍니다. 일반적으로는
 재페인트 시스템 쪽이 꽤 효율적입니다. <code>JLayeredPane</code> 등, 이 보증을 할 수 없는 JComponent
 서브 클래스는
 이 메서드를 오버라이드(override) 해 false를
 돌려줄 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>항상 true를
 돌려준다</DL>
</DD>
</DL>
<HR>

<A NAME="paintImmediately(int, int, int, int)"><!-- --></A> <H3>
paintImmediately</H3>
<PRE>
public void <B>paintImmediately</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;w,
                             int&nbsp;h)</PRE>
<DL>
<DD>이 컴퍼넌트의 지정된 영역 및 그 영역과 오버랩 하는 모든 하위 컴퍼넌트를 곧바로 페인트 합니다.
 <p>
이 메서드를 호출할 필요는 거의 없습니다. 대부분의 경우, 실제의 페인트를 늦추어 장황한 요구를 단일의 paint 호출해에 집약할 수가 있는 repaint를
 호출하는 편이 보다 효율적입니다. 이 메서드는
 현재의 이벤트가 디스패치 되고 있을 때 표시를 갱신할 필요가 있는 경우에는 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 페인트 영역의 x 좌표<DD><CODE>y</CODE> - 페인트 영역의 y 좌표<DD><CODE>w</CODE> - 페인트 영역의 폭<DD><CODE>h</CODE> - 페인트 영역의 높이<DT><B>관련 항목:</B><DD><A HREF="../../javax/swing/JComponent.html#repaint(long, int, int, int, int)"><CODE>repaint(long, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="paintImmediately(java.awt.Rectangle)"><!-- --></A> <H3>
paintImmediately</H3>
<PRE>
public void <B>paintImmediately</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>지정된 영역을 곧바로 페인트 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 페인트 하는 영역을 포함한 <code>Rectangle</code></DL>
</DD>
</DL>
<HR>

<A NAME="setDoubleBuffered(boolean)"><!-- --></A> <H3>
setDoubleBuffered</H3>
<PRE>
public void <B>setDoubleBuffered</B>(boolean&nbsp;aFlag)</PRE>
<DL>
<DD>이 컴퍼넌트가 버퍼를 사용해 렌더링 할지 어떨지를 설정합니다. true 로 설정되어 있는 경우, 이 컴퍼넌트로부터의 모든 렌더링는 오프 스크린 렌더링 버퍼로 행해집니다. 그리고 오프 스크린 렌더링 버퍼가 화면에 카피됩니다. Swing
 렌더링 시스템은 항상  1 개의 더블 버퍼를 최대한 사용합니다. <code>Component</code> 가 버퍼링 되고 있어 게다가 위오브젝트도 버퍼링 되고 있는 경우, 상위 오브젝트의 버퍼가 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>aFlag</CODE> - true
 경우, 이 컴퍼넌트로 더블 버퍼를 사용하도록 설정</DL>
</DD>
</DL>
<HR>

<A NAME="isDoubleBuffered()"><!-- --></A> <H3>
isDoubleBuffered</H3>
<PRE>
public boolean <B>isDoubleBuffered</B>()</PRE>
<DL>
<DD>이 컴퍼넌트가 버퍼를 사용해 페인트 할지 어떨지를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스">Component</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Component.html#isDoubleBuffered()">isDoubleBuffered</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트가 더블 버퍼를 사용하는 경우는 true, 그렇지 않은 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="getRootPane()"><!-- --></A> <H3>
getRootPane</H3>
<PRE>
public <A HREF="../../javax/swing/JRootPane.html" title="javax.swing 내의 클래스">JRootPane</A>  <B>getRootPane</B>()</PRE>
<DL>
<DD>이 컴퍼넌트의 <code>JRootPane</code> 상위 컴퍼넌트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 컴퍼넌트를 포함하는 <code>JRootPane</code>. <code>JRootPane</code> 가 발견되지 않는 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="paramString()"><!-- --></A> <H3>
paramString</H3>
<PRE>
protected <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>paramString</B>()</PRE>
<DL>
<DD>이 <code>JComponent</code>
 캐릭터 라인 표현을 돌려줍니다. 이 메서드는 디버그 전용이며, 돌려주고지는 캐릭터 라인의 내용 및 형식은 구현에 따라서 다릅니다. 돌려주고지는 캐릭터 라인은 하늘의 경우가 있습니다만,<code>null</code> 로는 되지 않습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Container.html" title="java.awt 내의 클래스">Container</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Container.html#paramString()">paramString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>JComponent</code>
 캐릭터 라인 표현</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/JComponent.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/swing/JComboBox.KeySelectionManager.html" title="javax.swing 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/swing/JComponent.AccessibleJComponent.html" title="javax.swing 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/swing/JComponent.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="JComponent.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

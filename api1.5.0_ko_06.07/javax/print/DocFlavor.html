<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:00:45 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
DocFlavor (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.print.DocFlavor class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="DocFlavor (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/DocFlavor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/print/DocFlavor.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="DocFlavor.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.print</FONT>
<BR>
클래스 DocFlavor</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>javax.print.DocFlavor</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A>,
 <A HREF="../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스">DocFlavor.BYTE_ARRAY</A>,
 <A HREF="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.CHAR_ARRAY</A>,
 <A HREF="../../javax/print/DocFlavor.INPUT_STREAM.html" title="javax.print 안의 클래스">DocFlavor.INPUT_STREAM</A>,
 <A HREF="../../javax/print/DocFlavor.READER.html" title="javax.print 안의 클래스">DocFlavor.READER</A>,
 <A HREF="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="javax.print 안의 클래스">DocFlavor.SERVICE_FORMATTED</A>,
 <A HREF="../../javax/print/DocFlavor.STRING.html" title="javax.print 안의 클래스">DocFlavor.STRING</A>,
 <A HREF="../../javax/print/DocFlavor.URL.html" title="javax.print 안의 클래스">DocFlavor.URL</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>DocFlavor</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A>,
 <A HREF="../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>DocFlavor</code> 클래스는
 인쇄 데이터 <A HREF="../../javax/print/DocPrintJob.html" title="javax.print 중의 인터페이스"><CODE>DocPrintJob</CODE></A>  에의 제공 형식을 지정하는 오브젝트를 캡슐화합니다. 「Doc」는
 인쇄 데이터의 일부를
미하는
 짧게 발음하기 쉬운 용어입니다. 인쇄 데이터 형식인 「doc 플레이버
」는
 이하의 2 개로 구성됩니다.
<UL> 
 <LI> <B>MIME 타입</B>. 이것은, 인쇄 데이터를 해석하는 방법을 지정하는 Multipurpose Internet Mail Extensions (MIME) 미디어 타입 (<A HREF="http://www.ietf.org/rfc/rfc2045.txt">RFC 2045</A>  및 <A HREF="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</A>  으로 정의)입니다. 텍스트 데이터의 캐릭터 세트는
 IANA MIME 우선명 또는 표준명 (우선명이 지정되어 있지 않은 경우)으로 할 필요가 있습니다. 게다가 이전의 버젼의 Java 플랫폼에서 서포트되어 아픈 구두인가의 이름도 인식 가능합니다. Java 플랫폼이 지원하는
 캐릭터 세트의 자세한 것은,<a href="../../java/lang/package-summary.html#charenc">「캐릭터 세트」</a>를 참조하십시오.
<P>
 
 <LI> <B>표현 클래스명</B>. 인감 도장쇄데이터의 출력원오브젝트의 클래스의 완전 지정된 이름을 지정합니다. 이것은,<A HREF="../../java/lang/Class.html#getName()"><CODE><CODE>Class.getName()</CODE></CODE></A>  메서드에
해 돌려주고집니다. 이 때문에
<CODE>byte[]</CODE>
 클래스명은 <CODE>「[B」</CODE>,<CODE>char[]</CODE>
 클래스명은 <CODE>「[C」</CODE> 가 됩니다.
</UL> 
<P>
 <code>DocPrintJob</code>는

<A HREF="../../javax/print/Doc.html" title="javax.print 안의 인터페이스"><CODE>Doc</CODE></A>  인터페이스를 사용해 인쇄 데이터를 취득합니다. <code>DocPrintJob</code>는

<code>Doc</code> 오브젝트를 사용해, 클라이언트가 제공 가능한 doc 플레이버
를 판별할 수 있습니다. 또,<code>DocPrintJob</code>는

<code>Doc</code> 오브젝트를 사용해, doc 플레이버
의 표현 클래스의 인스턴스를 취득할 수도 있습니다. <code>DocPrintJob</code>는

 이 인스턴스로부터 인감 도장쇄데이터를 취득합니다.
<P>
 <HR> <H3>클라이언트 형식의 인쇄 데이터</H3> 인쇄 데이터는
 클라이언트 형식의 인쇄 데이터와 서비스 형식의 인쇄 데이터의 2 개의 카테고리에 크게 나눌 수가 있습니다.
<P>
 <B>클라이언트 형식의 인쇄 데이터</B>의 경우, 클라이언트는 인쇄 데이터 형식을 인식 또는 판별합니다. 예를 들어, 클라이언트는
 JPEG 로 encode 된 이미지, HTML 코드의 URL, 또는 어떤 것인가의 인코딩의 plaintext 파일을 포함한 디스크 파일을 (외부 소스로부터 얻는
 등 해) 보관 유지할 수가 있어 인쇄 서비스에 데이터 형식을 기술하는 수단을 필요로 합니다.
 <p>
doc 플레이버
의 표현 클래스는
 JPS <code>DocPrintJob</code>
 안녕 제트입니다. 이 표현 클래스를 사용해, 클라이언트로부터 문자 또는 바이트 순서를 취득할 수 있습니다. doc 플레이버
의 MIME 타입은, 문자 또는 바이트 순서의 해석 방법을 지정하는
 어떤 것인가의 표준 미디어 타입입니다. 표준 미디어 타입의 리스트에 대해서는
 Internet Assigned Numbers Authority (IANA)의 <A  HREF="http://www.isi.edu/in-notes/iana/assignments/media-types/">「Media Types Directory」</A> 를
 참조하십시오. 인터페이스 <A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><CODE>Doc</CODE></A> 는

<code>Doc</code> 오브젝트의 클라이언트가 클라이언트 형식의 인쇄 데이터를 추출할 때에 이용 가능한 2 개의 유틸리티 조작,<A HREF="../../javax/print/Doc.html#getReaderForText()"><CODE>getReaderForText</CODE></A>  및 <A HREF="../../javax/print/Doc.html#getStreamForBytes()"><CODE>getStreamForBytes()</CODE></A> 를
 제공합니다.
<P>
 보통
, 클라이언트 형식의 인쇄 데이터는
 다음의 어떤 것인가의 인쇄 데이터 표현 클래스가 됩니다 (다른 표현 클래스도 사용 가능).
<UL> 
 <LI> 문자 배열 (<CODE>char[]</CODE>) -- 인쇄 데이터는
 배열내의 Unicde 문자로 구성된다
<P>
 
 <LI> <code>String</code>  -- 인쇄 데이터는
 캐릭터 라인내의 Unicode 문자로 구성된다
<P>
 
 <LI> 문자 스트림 (<A HREF="../../java/io/Reader.html" title="java.io 안의 클래스"><CODE>java.io.Reader</CODE></A> ) -- 인쇄 데이터는
 스트림을 최초부터 끝까지 읽어들인 Unicode 문자로 구성된다
<P>
 
 <LI> 바이트 배열 (<CODE>byte[]</CODE>) -- 인쇄 데이터는
 배열내의 바이트로 구성된다. 바이트는
 doc 플레이버
의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용된다
<P>
 
 <LI> 바이트 스트림 (<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스"><CODE>java.io.InputStream</CODE></A> ) -- 인쇄 데이터는
 스트림을 최초부터 끝까지 읽어들인 바이트로 구성된다. 바이트는
 doc 플레이버
의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용된다

 <LI> Uniform Resource Locator (<A HREF="../../java/net/URL.html" title="java.net 안의 클래스"><CODE>URL</CODE></A> ) -- 인쇄 데이터는
 URL 위치로부터 읽힌 바이트로 구성된다. 바이트는
 doc 플레이버
의 MIME 타입으로 지정된 캐릭터 세트에 encode 된다. MIME 타입으로 캐릭터 세트가 지정되지 않는 경우, 디폴트의 캐릭터 세트인 US-ASCII 가 사용된다
<P>
 표현 클래스가 URL
 경우, 클라이언트를 개좌도에
 인쇄 서비스 자체가, URL 주소의 문서에의 액세스 및 다운로드를 직접 실행합니다. 서비스의 형태는
 다른 환경에서 실행되는 네트워크 인쇄 서비스의 경우도 있습니다. 이 때문에
 클라이언트로부터는 가시이지만 프린터로부터는 가시가 아닌 제한된 URL
 문서는
 URL 인쇄 데이타플레이버
를 사용해 인쇄하지 말아 주세요. 또, 클라이언트와는 별개에 액세스 가능한 URL 에서는 사용 불가능한 로컬 파일에 포함된 문서도, URL 인쇄 데이타플레이버
를 사용해 인쇄하지 말아 주세요. HTTP 서버 또는 FTP 서버가 제공하고 있지 않는 파일이 그 예입니다. 이러한 파일을 인쇄하려면,
 클라이언트를 사용해, URL 또는 파일의 입력 스트림을 열어, 입력 스트림을 데이타플레이버
로서 사용합니다.  
</UL>
 <p>
<HR> <h3>디폴트 및 플랫폼의 인코딩</h3>
 
<P>
 doc 플레이버
의 MIME 타입에 <CODE>charset</CODE> 파라미터가 포함되지 않는 바이트 인쇄 데이터의 경우, Java Print Service 인스턴스는
 US-ASCII 캐릭터 세트가 디폴트로 설정되어 있는 것이라고 판단 합니다. 이것은, 디폴트 캐릭터 세트를 US-ASCII 로 한다고 하는
<A HREF="http://www.ietf.org/rfc/rfc2046.txt">RFC 2046</A>  에 근거하는 동작입니다. US-ASCII는
 UTF-8
 부분집합이기 때문에
 장래 RFC 에
해 UTF-8 가 디폴트로서 승인되었을 경우, US-ASCII 가 호환성을 유지하면서 확장될 가능성이 있습니다.
 <p>
또, 이것은, 바이트 스트림을 텍스트 데이터로서 해석하는 경우의 Java 실행시의 동작과는 다른 경우가 있습니다. 이 경우에는
 유저의 로케일의 디폴트 인코딩이라고 판단되기 때문에입니다. 이 때문에
 로컬 인코딩의 파일을 Java Print Service 에 spool 하는 경우에는
 인코딩을 정확하게 지정하는 것이 중요합니다. 특히, 영어 로케일로 작업을 실시하는 개발자는
 스스로의 플랫폼 인코딩이 디폴트 MIME 캐릭터 세트에 대응하고 있으므로 이 점을
식할 필요가 있습니다. 경우에 따라서는
 플랫폼 데이터의 인코딩을 지정하지 않아도 동작하는 것이 있기 때문에입니다.
 <p>
Java 가상 머신의 각 인스턴스는
 가상 머신의 시작시로 결정되는 디폴트 캐릭터 세트를 보관 유지합니다. 또, 보통
, 기본  operating system가 사용하는 로케일 및 캐릭터 세트에
존합니다. 분산환경에서는
 2 개의 VM 가 같은 디폴트 인코딩을 공유하는 것은 보증되지 않습니다. 이 때문에
 플랫폼에서 encode 된 텍스트 데이터를, 호스트 플랫폼으로부터 Java Print Service 인스턴스에 스트림 처리하는 클라이언트는
 캐릭터 세트를 명시적으로 선언해, 디폴트에
존하지 않게 할 필요가 있습니다.
 <p>
우선되는 형식은, 인코딩의 정식적 IANA 프라이머리명입니다. 텍스트 데이터를 스트림 처리하는 어플리케이션은, 캐릭터 세트를 항상 MIME 타입으로 지정할 필요가 있습니다. 이 때문에
 호스트 플랫폼의 인코딩으로 보존된 데이터 (파일 등)에 관한, 플랫폼의 인코딩을 취득할 필요가 있습니다. 이것에 대응해, DocFlavor
 MIME 타입에서의 사용에 적절한 CharSet는

<A HREF="../../javax/print/DocFlavor.html#hostEncoding"><CODE><CODE>DocFlavor.hostEncoding</CODE></CODE></A>  로부터 취득할 수 있습니다. 이것은, 항상 프라이머리 IANA 명이라고 하는 것은 아닙니다만, 확실히 이 가상 머신에
해 이해됩니다. 일반적인 플레이버
의 경우, 정의 끝난 *HOST DocFlavors를
 사용할 수 있습니다.
 <p>

 <p>
Java 플랫폼에서 서포트되는 캐릭터 세트의 자세한 것은,<a href="../../java/lang/package-summary.html#charenc">「캐릭터 세트」</a> 를
 참조하십시오.
 <p>
<HR> <h3>추천 되는 DocFlavor</h3>
 
<P>
 Java Print Service API는

 강제적으로 서포트되는 DocFlavor를
 정의하지 않습니다. 다만, Java Print Service 인스턴스가, 클라이언트 형식의 인쇄 데이터로 서포트 가능한 MIME 타입의 예를 몇개인가 가리킵니다. DocFlavor 클래스 내부에서 상자가 되어 있는 클래스는
 이러한 샘플 doc 플레이버
에 대해서, 사전 정의된 static 정수 DocFlavor 오브젝트를 선언합니다. DocFlavor 클래스의 생성자는
 임의의 doc 플레이버
의 작성에 사용할 수 있습니다.
<UL> 
 <LI>서식 설정 끝난 텍스트
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions"> <TR> <TH>MIME 타입</TH><TH>설명</TH> </TR> <TR> <TD><CODE>「text/plain」</CODE></TD> <TD>디폴트 캐릭터 세트 (US-ASCII)의 plaintext</TD> </TR> <TR> <TD><CODE>「text/plain; charset=<I>xxx</I>」</CODE></TD> <TD>캐릭터 세트 <I>xxx</I>
 plaintext</TD> </TR> <TR> <TD><CODE>「text/html」</CODE></TD> <TD>디폴트 캐릭터 세트 (US-ASCII)의 하이퍼 텍스트(hyper text) 마크업 언어</TD> </TR> <TR> <TD><CODE>「text/html; charset=<I>xxx</I>」</CODE></TD> <TD>캐릭터 세트 <I>xxx</I>
 하이퍼 텍스트(hyper text) 마크업 언어</TD> </TR> </TABLE> 
<P>
 일반적으로 서식 설정 끝난 텍스트 인쇄 데이터는
 문자 지향의 표현 클래스 (문자 배열, String, Reader), 또는 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.
<P>
 
 <LI>서식 설정 끝난 페이지 기술 언어 (PDL) 문서
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions"> <TR> <TH>MIME 타입</TH><TH>설명</TH> </TR><TR> <TD><CODE>「application/pdf」</CODE></TD> <TD>Portable Document Format 문서</TD> </TR> <TR> <TD><CODE>「application/postscript」</CODE></TD> <TD>PostScript 문서</TD> </TR> <TR> <TD><CODE>「application/vnd.hp-PCL」</CODE></TD> <TD>Printer Control Language 문서</TD> </TR> </TABLE> 
<P>
 일반적으로 서식 설정 끝난 PDL 인쇄 데이터는
 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.
<P>
 
 <LI>서식 설정 끝난 이미지
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions"> <TR> <TH>MIME 타입</TH><TH>설명</TH> </TR>  <TR> <TD><CODE>「image/gif」</CODE></TD> <TD>Graphics Interchange Format 이미지</TD> </TR> <TR> <TD><CODE>「image/jpeg」</CODE></TD> <TD>Joint Photographic Experts Group 이미지</TD> </TR> <TR> <TD><CODE>「image/png」</CODE></TD> <TD>Portable Network Graphics 이미지</TD> </TR> </TABLE> 
<P>
 일반적으로 서식 설정 끝난 이미지 인쇄 데이터는
 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.
<P>
 
 <LI>서식 설정의 autosense 인쇄 데이터
<P>
 <TABLE BORDER=1 CELLPADDING=0 CELLSPACING=0 SUMMARY="MIME-Types and their descriptions"> <TR> <TH>MIME 타입</TH><TH>설명</TH> </TR>  <TR> <TD><CODE>「application/octet-stream」</CODE></TD> <TD>인쇄 데이터 형식은 지정되지 않는다 (octet 스트림만)</TD> </TABLE> 
<P>
 프린터가, 인쇄 데이터의 해석 방법을 판별합니다. 이 「자동 인식」의 동작은, 구현에 따라서 다릅니다. 일반적으로 서식 설정 끝난 autosense 인쇄 데이터는
 바이트 지향의 표현 클래스 (바이트 배열, InputStream, URL)에서 제공됩니다.
<P>
 <HR> <H3>서비스 형식의 인쇄 데이터</H3> 
<P>
 <B>서비스 형식의 인쇄 데이터</B>의 경우, Java Print Service 인스턴스가 인쇄 데이터 형식을 판별합니다. doc 플레이버
의 표현 클래스가 가리키는 인터페이스 (렌더링 가능한 이미지 인터페이스나 Java 2 로 인쇄 가능한 인터페이스등)의 메서드가,<code>DocPrintJob</code> 에
해 불려 가 인쇄하는 내용이 결정됩니다. doc 플레이버
의 MIME 타입은, 특수한 값 <CODE>「application/x-java-jvm-local-objectref」</CODE> 가 됩니다. 이 값은, 표현 클래스로서 명명된 인터페이스를 구현하는 클라이언트가 Java 오브젝트에의 참조를 제공하는 것을 나타냅니다. 이 MIME 타입은 단순한 플레이스홀더이며, 중요한 것은 인쇄 데이터 표현 클래스입니다.
<P>
 서비스 형식의 인쇄 데이터의 경우, 인쇄 데이터 표현 클래스는 (다른 표현 클래스를 이용 가능한 경우에서도) 보통
다음의 어떤 것인가가 됩니다. DocFlavor 클래스 내부에서 상자가 된 클래스는
 이러한 샘플 doc 플레이버
의 경우, 정의 끝난 static 정수 DocFlavor 오브젝트를 선언합니다. DocFlavor 클래스의 생성자를 사용해, 임의의 doc 플레이버
를 작성할 수 있습니다.
<UL> 
 <LI> 렌더링 가능한 이미지 오브젝트 -- 클라이언트는
<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A>  인터페이스를 구현하는 오브젝트를 제공합니다. 프린터는 이 인터페이스내의 메서드를 호출해, 인쇄하는 이미지를 취득합니다.
<P>
 
 <LI> 인쇄 가능한 오브젝트 -- 클라이언트는
<A HREF="../../java/awt/print/Printable.html" title="java.awt.print 안의 인터페이스"><CODE>Printable</CODE></A>  인터페이스를 구현하는 오브젝트를 제공합니다. 프린터는 이 인터페이스내의 메서드를 호출해, 인쇄하는 페이지를 페이지 마다 취득합니다. 프린터는 페이지 마다 그래픽스 컨텍스트
을 제공해, 클라이언트에
해 그래픽스 컨텍스트
에 렌더링 된 내용이 모두 인쇄됩니다.
<P>
 
 <LI> 페이징 가능한 오브젝트 -- 클라이언트는
<A HREF="../../java/awt/print/Pageable.html" title="java.awt.print 안의 인터페이스"><CODE>Pageable</CODE></A>  인터페이스를 구현하는 오브젝트를 제공합니다. 프린터는 이 인터페이스내의 메서드를 호출해, 인쇄하는 페이지를 페이지 마다 취득합니다. 프린터는 페이지 마다 그래픽스 컨텍스트
을 제공해, 클라이언트에
해 그래픽스 컨텍스트
에 렌더링 된 내용이 모두 인쇄됩니다.
</UL> 
<P>
 <HR> 
<P>
 <HR> <H3>정의 끝난 doc 플레이버
</H3> Java Print Service 인스턴스에는
 다음의 인쇄 데이터 형식 및 인쇄 데이터 표현 클래스를 지원하는
 것은<B>요구되고 있지 않습니다</B>. 실제, 이 클래스를 사용하는 개발자는
 이러한 정의가 끝난 doc 플레이버
에 대응하는 문서형을 특정의 인쇄 서비스가 서포트하고 있다고는<b>절대로 상정하지 말아 주세요</b>. 항상 인쇄 서비스에 조회를 행해, 지원하는
 doc 플레이버
를 판별해 주세요. 다만, 이러한 doc 플레이버
를 지원하는
 인쇄 서비스를 보관 유지하는 개발자는
 여기서 작성된 정의 끝난 단독 인스턴스를 참조하는 것을 추천합니다. <I></I>
<UL> 
 <LI> 바이트 스트림을 개입시켜 제공되는 plaintext 인쇄 데이터. 특히, 다음의 doc 플레이버
의 서포트가 추천 되고 있다<BR>&#183;&nbsp;&nbsp; <CODE>("text/plain", "java.io.InputStream")</CODE> <BR>&#183;&nbsp;&nbsp; <CODE>("text/plain; charset=us-ascii", "java.io.InputStream")</CODE> <BR>&#183;&nbsp;&nbsp; <CODE>("text/plain; charset=utf-8", "java.io.InputStream")</CODE>
<P>
 
 <LI> 렌더링 가능한 이미지 오브젝트. 특히, 다음의 doc 플레이버
의 서포트가 추천 되고 있다<BR>&#183;&nbsp;&nbsp; <CODE>("application/x-java-jvm-local-objectref", "java.awt.image.renderable.RenderableImage")</CODE>
</UL> 
<P>
 Java Print Service 인스턴스는
 상기의 필수 doc 플레이버
에 가세해 임의의 doc 플레이버
를 서포트 가능합니다 (필수의 doc 플레이버
인 만큼 한정하는 일도 가능).
<P>
 상기의 doc 플레이버
의 서포트가 추천 되고 있기 때문에
 인쇄를 실시하는 클라이언트는
 프린터가 지원하는
 doc 플레이버
에 관계없이, 임의의 JPS 프린터에 인쇄 가능하다라고 판단해 서로 지장있습니다. 프린터가 클라이언트의 우선 doc 플레이버
를 서포트하지 않는 경우, 클라이언트는 적어도 plaintext는 인쇄할 수 있습니다. 또, 데이터를 렌더링 가능한 이미지로 변환하고 나서 이미지를 인쇄하는 일도 가능합니다.
<P>
 각 Java Print Service 인스턴스는
 다음에 나타내는 plaintext 인쇄 데이터의 처리 요건도 채울 필요가 있습니다.
<UL> 
 <LI> 복귀 문자와 개행 문자의 페어 (CR-LF)는
 「다음의 행의 제 1 열로 이동한다」일을
미한다
 <LI> 복귀 (CR) 문자는
 그 자체로 「다음의 행의 제 1 열로 이동한다」일을
미한다
 <LI> 개행 (LF) 문자는
 그 자체로 「다음의 행의 제 1 열로 이동한다」일을
미한다
</UL> 
<P>
 클라이언트는
 상기의 요건에 포함되지 않는
 모든 plaintext 인쇄 데이터의 서식 설정을 실행할 필요가 있습니다.
<P>
 <H3>설계의 근거</H3> 
<P>
 javax.print.data 패키지내의 DocFlavor 클래스는
<A HREF="../../java/awt/datatransfer/DataFlavor.html" title="java.awt.datatransfer 안의 클래스"><CODE>DataFlavor</CODE></A>  클래스에 유사하고 있습니다. Java Print Service (JPS) API 에서는
<code>DataFlavor</code> 클래스는 다음의 3 개의 이유로써 사용되지 않습니다. 이러한 이유는 모두, JSP API를
 공유 가능한 다른 인쇄 서비스 API 가, Java 2 Standard Edition
 모든 것을 포함하지 않는 Java 프로파일상에서 실행되는 경우가 있는 것에 유래하고 있습니다. <OL TYPE=1> 
 <LI> JPS API는

 AWT를
 서포트하지 않는 Java 프로파일로 사용하도록 설계되고 있다
<P>
 
 <LI> <code>java.awt.datatransfer.DataFlavor</code> 클래스의 구현은, 등가인 데이타플레이버
가 같은 직렬화 표현을 보관 유지하는 것을 보증하지 않는다. DocFlavor를
 서비스로 사용하는 것으로 등가인 데이타플레이버
가 같은 직렬화 표현을 보관 유지하는 것이 보증된다
<P>
 
 <LI> <code>java.awt.datatransfer.DataFlavor</code> 클래스의 구현에는
 판독 가능한 이름이 직렬화 표현의 일부에 포함된다. 이것은, 서비스 일치 제약의 일부로서는 부적절하다</OL> 
<P>
 DocFlavor 클래스의 직렬화 표현은, 다음에 나타내는 정규의 형식의 MIME 타입 캐릭터 라인을 사용합니다. 이 때문에
 동일하지 않게 등가 (정규 형식이 같다)의 MIME 타입을 보관 유지하는 2 개의 doc 플레이버
는
 동일하다고 볼 수가 있습니다.
<UL> 
 <LI> 미디어 타입, 미디어 아류형 및 파라미터는 보관 유지되지만, 코멘트 및 공백 문자는 모두 파기된다
 <LI> 미디어 타입, 미디어 아류형 및 파라미터명은, 소문자에 변환된다
 <LI> 파라미터치는 원의 대문자/소문자를 보관 유지한다. 다만, 텍스트 미디어 타입의 캐릭터 세트 파라미터치는
 소문자에 변환된다
 <LI> 파라미터치를 둘러싸는 인용부호 문자는
 삭제된다
 <LI> 파라미터치 내부의 인용 backslash 문자는
 삭제된다
 <LI> 파라미터는
 파라미터명을 키로 해 승순에 배치된다
</UL> 
<P>
 DocFlavor 클래스의 직렬화 표현에는
 표현 클래스 그 자체 (Class 오브젝트)는 아니고, 표현 클래스의 완전 지정된 클래스명 (String 오브젝트)도 포함됩니다. 클라이언트는
 이 클래스명을 이용하는 것으로 표현 클래스를 로드하지 않아도, Java Print Service 인스턴스가 지원하는
 doc 플레이버
를 검증할 수 있습니다. 클라이언트의 사용 가능한 자원이 한정되어 있는 경우, 표현 클래스의 로드에서 문제가 발생하는 것이 많기 때문에
 이것은 유용한 방법입니다.   
<P>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../serialized-form.html#javax.print.DocFlavor">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.BYTE_ARRAY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.BYTE_ARRAY 클래스는
 사전 정의된 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.CHAR_ARRAY.html" title="javax.print 안의 클래스">DocFlavor.CHAR_ARRAY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.CHAR_ARRAY 클래스는
 사전 정의된 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.INPUT_STREAM.html" title="javax.print 안의 클래스">DocFlavor.INPUT_STREAM</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.INPUT_STREAM 클래스는
 사전 정의된 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.READER.html" title="javax.print 안의 클래스">DocFlavor.READER</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.READER 클래스는
 사전 정의된 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.SERVICE_FORMATTED.html" title="javax.print 안의 클래스">DocFlavor.SERVICE_FORMATTED</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.SERVICE_FORMATTED 클래스는
 정의 끝난 static 정수 DocFlavor 오브젝트 (예, 서비스 형식의 인쇄 데이터용 doc 플레이버
)를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.STRING.html" title="javax.print 안의 클래스">DocFlavor.STRING</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.STRING 클래스는
 정의 끝난 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.URL.html" title="javax.print 안의 클래스">DocFlavor.URL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DocFlavor.URL 클래스는
 사전 정의된 static 정수 DocFlavor 오브젝트를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#hostEncoding">hostEncoding</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호스트  operating system의 인코딩을 나타내는 캐릭터 라인입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#DocFlavor(java.lang.String, java.lang.String)">DocFlavor</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mimeType,
          <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 MIME 타입 및 표현 클래스명으로부터 새로운 doc 플레이버
오브제크트를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트가 지정된 오브젝트에 동일한지 어떤지를 판별합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMediaSubtype()">getMediaSubtype</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트의 미디어 아류형을 (MIME 타입으로부터) 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMediaType()">getMediaType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트의 미디어 타입을 (MIME 타입으로부터) 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getMimeType()">getMimeType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트의 MIME 타입 캐릭터 라인을, 정규의 형식에서 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getParameter(java.lang.String)">getParameter</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;paramName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MIME 파라미터를 나타내는 <code>String</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#getRepresentationClassName()">getRepresentationClassName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트의 표현 클래스의 이름이 돌려주고집니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 doc 플레이버
오브제크트의 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/print/DocFlavor.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>DocFlavor</code>를
 캐릭터 라인으로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="hostEncoding"><!-- --></A> <H3>
hostEncoding</H3>
<PRE>
public static final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>hostEncoding</B></PRE>
<DL>
<DD>호스트  operating system의 인코딩을 나타내는 캐릭터 라인입니다. 이것은<a href="http://ietf.org/rfc/rfc2278.txt">「RFC&nbsp;2278:&nbsp;IANA Charset Registration Procedures」</a>에 기재된 규칙에 따릅니다. 다만, Java 플랫폼의 이전의 버젼과의 호환성을 유지하기 위해, 이력명이 돌려주고지는 점이 다릅니다. 메서드로부터 돌려주고지는 값은, 값을 돌려주는 가상 머신 및 DocFlavor 로 사용하는 경우에만 유효합니다. 이것은, 실행하는 VM 내의, 「HOST」가 정의 끝난 모든 DocFlavor 에 대응하는 캐릭터 세트입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DocFlavor(java.lang.String, java.lang.String)"><!-- --></A> <H3>
DocFlavor</H3>
<PRE>
public <B>DocFlavor</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;mimeType,
                 <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;className)</PRE>
<DL>
<DD>지정된 MIME 타입 및 표현 클래스명으로부터 새로운 doc 플레이버
오브제크트를 구축합니다. 지정된 MIME 타입은, 정규의 형식에 변환되어 내부에 포함됩니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>mimeType</CODE> - MIME 미디어 타입 캐릭터 라인<DD><CODE>className</CODE> - 완전 지정의 표현 클래스명
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - (체크되지 않는 예외) <CODE>mimeType</CODE> 또는 <CODE>className</CODE> 가 null
 경우에 Throw 된다
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - (체크되지 않는 예외) <CODE>mimeType</CODE> 가 MIME 미디어 타입 캐릭터 라인의 구문에 따르지 않는 경우에 Throw 된다</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getMimeType()"><!-- --></A> <H3>
getMimeType</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMimeType</B>()</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트의 MIME 타입 캐릭터 라인을, 정규의 형식에서 돌려줍니다. 각 파라미터치는 인용부호로 둘러싸입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>MIME 타입</DL>
</DD>
</DL>
<HR>

<A NAME="getMediaType()"><!-- --></A> <H3>
getMediaType</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMediaType</B>()</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트의 미디어 타입을 (MIME 타입으로부터) 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>미디어 타입</DL>
</DD>
</DL>
<HR>

<A NAME="getMediaSubtype()"><!-- --></A> <H3>
getMediaSubtype</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getMediaSubtype</B>()</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트의 미디어 아류형을 (MIME 타입으로부터) 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>미디어 아류형</DL>
</DD>
</DL>
<HR>

<A NAME="getParameter(java.lang.String)"><!-- --></A> <H3>
getParameter</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getParameter</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;paramName)</PRE>
<DL>
<DD>MIME 파라미터를 나타내는 <code>String</code>를
 돌려줍니다. MIME 타입에는
 보통
 옵션의 파라미터를 포함할 수가 있습니다. 텍스트 타입의 캐릭터 세트는
 샘플로서 자주 사용됩니다. 이 메서드는
 지정된 파라미터의 값이 이 플레이버
의 MIME 타입내로 지정되고 있는 경우에
 그 값을 돌려줍니다.
 <p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>paramName</CODE> - 파라미터명. 매칭의 실행전에
 이 이름은 내부에서 정규의 소문자 형식에 변환된다
<DT><B>반환값:</B><DD>MIME 파라미터를 나타내는 캐릭터 라인, 또는
 파라미터가 MIME 타입 캐릭터 라인에 존재하지 않는 경우는 null
<DT><B>예외:</B>
<DD><CODE>throws</CODE> - paramName 가 null
 경우에 NullPointerException 가 Throw 된다</DL>
</DD>
</DL>
<HR>

<A NAME="getRepresentationClassName()"><!-- --></A> <H3>
getRepresentationClassName</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getRepresentationClassName</B>()</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트의 표현 클래스의 이름이 돌려주고집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>표현 클래스의 이름</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>DocFlavor</code>를
 캐릭터 라인으로 변환합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>정규의 형식에 근거하는 MIME 타입 캐릭터 라인. 각 파라미터치는
 인용부호로 둘러싸인다. 표현 클래스명인 것을 나타내기 때문에
 「class=」파라미터가 MIME 타입 캐릭터 라인에 추가된다</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트의 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 오브젝트의 해시 코드치<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>,
 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 doc 플레이버
오브제크트가 지정된 오브젝트에 동일한지 어떤지를 판별합니다. 지정된 오브젝트가 null는
 아니고,<code>DocFlavor</code>
 인스턴스이며, 이 doc 플레이버
오브제크트의 MIME 타입과 등가인 MIME 타입을 보관 유지하는 (즉, MIME 타입이 같은 미디어 타입, 미디어 아류형 및 파라미터를 보관 유지한다) 경우 및 이 doc 플레이버
오브제크트와 같은 표현 클래스명을 보관 유지하는 경우, 2 개의 오브젝트는 동일해집니다. 이 때문에
 2 개의 doc 플레이버
오브제크트의 MIME 타입이 코멘트를 제외해 동일한 경우, 이것들은 동일하다고 보여집니다. 다만, MIME 타입 「text/plain」 및 「text/plain; charset=US-ASCII」를 보관 유지하는 2 개의 doc 플레이버
오브제크트는
 같은 미디어 타입을 나타내는 경우에서도, 동일하다고는 보여지지 않습니다 (plaintext의 디폴트 캐릭터 세트가 US-ASCII 이기 때문에).
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 판정되는 오브젝트
<DT><B>반환값:</B><DD>이 doc 플레이버
오브제크트가 <CODE>obj</CODE> 에 동일한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>,
 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/DocFlavor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/print/Doc.html" title="javax.print 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../javax/print/DocFlavor.BYTE_ARRAY.html" title="javax.print 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/print/DocFlavor.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="DocFlavor.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

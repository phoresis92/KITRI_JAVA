<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:23:08 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
javax.sql.rowset.spi (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.sql.rowset.spi package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="javax.sql.rowset.spi (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../javax/sql/rowset/serial/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 javax.sql.rowset.spi
</H2>
써드파티의 벤더가 동기 프로바이더의 구현으로 사용해야 하는 표준 클래스 및 인터페이스입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스">SyncResolver</A> </B></TD>
<TD>어플리케이션이, 수동의
지결정 트리를 사용해 동기 경합이 발생했을 때의 대처 방법을 결정할 수 있도록 하는 체제를 정의합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/TransactionalWriter.html" title="javax.sql.rowset.spi 안의 인터페이스">TransactionalWriter</A> </B></TD>
<TD>보다 정밀한 트랜잭션(transaction) 제어를 할 수 있도록, 표준 <code>SyncProvider</code>추상 클래스의 확장을 촉진하는 특별한 인터
페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/XmlReader.html" title="javax.sql.rowset.spi 안의 인터페이스">XmlReader</A> </B></TD>
<TD><code>SyncProvider</code> 추상 클래스의 확장을 촉진하는
 XML 지향의 동기 제공자용의 특별한 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/XmlWriter.html" title="javax.sql.rowset.spi 안의 인터페이스">XmlWriter</A> </B></TD>
<TD><code>SyncProvider</code> 추상 클래스의 확장을 촉진하는
 XML 지향의 동기 제공자용의 특별한 인터페이스입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스">SyncFactory</A> </B></TD>
<TD>미접속의 <code>RowSet</code>오브젝트에
해 사용되는 <code>SyncProvider</code>인스탄
스를 생성하는 서비스 프로바이더 인터페이스 (Service Provider Interface, SPI) 도구
입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스">SyncProvider</A> </B></TD>
<TD>미접속의 <code>RowSet</code> 오브젝트의 읽어내/기입 기능을 제공하는  동기도구
입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>예외 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncFactoryException.html" title="javax.sql.rowset.spi 안의 클래스">SyncFactoryException</A> </B></TD>
<TD><code>SyncFactory</code> 도구
의 에러를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </B></TD>
<TD><code>SyncProvider</code> 도구
로 발생한 에러를 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 javax.sql.rowset.spi
 설명
</H2>

<P>
써드파티의 벤더가 동기 프로바이더의 구현으로 사용해야 하는 표준 클래스 및 인터페이스입니다. 이러한 클래스 및 인터페이스를 정리해, 「서비스 프로바이더 인터페이스 (Service Provider Interface, SPI)」라고 부릅니다. 사용 가능한 <code>SyncProvider</code> 구현의 일람이 기재된 JDBC Web 페이지에 벤더 고유의 구현을 추가해, 개발자에게 구현을 공개하고 싶은 경우는
<code>jdbc@sun.com</code> 까지 전자 메일에서 연락해 주십시오. <code>RowSet</code> 오브젝트로 구현을 사용할 수 있도록 하려면,
 그 구현을 <code>SyncFactory</code> 싱글 톤에 등록할 필요가 있습니다. 등록 순서와 명명 규칙의 자세한 설명에 대해서는
<code>SyncProvider</code>
 클래스 코멘트를 참조하십시오.
<P>
<h2>목차</h2>
<ul><li><a href="#pkgspec">1.0 패키지의 사양</a> <li><a href="#arch">2.0 서비스 프로바이더 아키텍쳐</a> <li><a href="#impl">3.0 구현 가이드</a> <li><a href="#resolving">4.0 동기 경합의 해결</a> <li><a href="#relspec">5.0 관련 사양</a> <li><a href="#reldocs">6.0 관련 항목</a> 
</ul>

<h3><a name="pkgspec">1.0 패키지의 사양</h3>

<P>
<code>javax.sql.rowset.spi</code> 패키지는
 다음의 클래스 및 인터페이스로 구성되어 있습니다.
<UL> 
 <LI><code>SyncFactory</code> 
 <LI><code>SyncProvider</code> 
 <LI><code>SyncFactoryException</code> 
 <LI><code>SyncProviderException</code> 
 <LI><code>SyncResolver</code> 
 <LI><code>XmlReader</code> 
 <LI><code>XmlWriter</code> 
 <LI><code>TransactionalWriter</code>
</UL>이 SPI 에는
<code>javax.sql</code> 패키지내의 다음의 인터페이스도 포함되어 있습니다.
<UL> 
 <LI><code>RowSetReader</code> 
 <LI><code>RowSetWriter</code>
</UL>
<P>
<code>SyncProvider</code> 구현은, 미접속의 <code>RowSet</code> 오브젝트가 데이터를 읽어들여, 변경을 더한 뒤 부하의 데이터 소스에 재차 기입할 수 있도록 하는 수단을 제공합니다. 리더 오브젝트 (<code>RowSetReader</code> 또는 <code>XMLReader</code>)는
<code>CachedRowSet</code>
 <code>execute</code> 또는 <code>populate</code> 메서드가 불려 가면,<code>RowSet</code> 오브젝트에 데이터를 읽어들입니다. 라이터 오브젝트 (<code>RowSetWriter</code> 또는 <code>XMLWriter</code>)는
<code>CachedRowSet</code>
 <code>acceptChanges</code> 메서드가 불려 가면, 부하의 데이터 소스로 변경된 데이터를 기입합니다.
<P>
<code>RowSet</code> 오브젝트의 변경 내용을 데이터 소스에 기입하는 처리를 「동기」라고 부릅니다. <code>RowSet</code> 오브젝트의 라이터가 사용하는 동기의 레벨은,<code>RowSet</code> 오브젝트의 <code>SyncProvider</code> 구현에
결정됩니다. 동기의 다양한 레벨을 「그레이드」라고 부릅니다.
<P>
저그레이드의 동기는
 경합이 전혀 존재하지 않는지, 존재했다고 해도 적는다고 하는 오프티미스틱 (낙관적)인 상정한 기초로 행해집니다. 이 동기 모델을 「오프티미스틱 병행 모델」이라고 부릅니다. <code>RowSet</code> 오브젝트내에서 변경된 데이터가 데이터 소스내에서도 변경되고 있는 경우는
 경합이 존재합니다. 오프티미스틱 병행 모델을 사용한다고 하는 것은, 경합이 존재하는 경우, 데이터 소스 또는 <code>RowSet</code> 오브젝트에의 변경이 없어진다고 하는 것을
미합니다.
<P>
이것에 대해서, 고그레이드의 동기 모델을 「염세적인 (비관적) 병행 모델」이라고 부릅니다. 이 모델에서는
 다른 유저가 데이터 소스에 접속해 변경을 더할 가능성이 있다고 하는 상정한 기초로 동기 처리를 합니다. 염세적인 병행 모델에서는
 경합의 발생을 억제하기 때문에
 다양한 락 레벨이 설정됩니다.
<P>
최저 레벨의 동기로는
<code>RowSet</code> 오브젝트에의 전변경 내용이, 단순하게 부하의 데이터 소스에 기입해집니다. 라이터는 경합의 체크를 실시하지 않습니다. 경합이 존재해, 데이터 소스의 값이 덧쓰기되었을 경우, 그 외의 유저에
한 데이터 소스의 변경은 없어집니다.
<P>
<code>RIXMLProvider</code> 구현은, 최저 레벨의 동기를 사용해,<code>RowSet</code>
 변경을 단순하게 데이터 소스에 기입합니다. 이것은, 보통
, XML 데이터 소스가, 데이터의 정합성을 확보하기 위한 트랜잭션(transaction) 기술을 서포트하고 있지 않기 때문입니다. 그러나, XML 베이스의 동기를 가능하게 하는 수단을 제공하려고 하고 있는 표준화 그룹도 존재합니다. 상세한 것에 대하여는
 이하를 참조하십시오. <PRE> <a href="http://www.syncml.org">http://www.syncml.org</a> </PRE>
<P>
1 개상의 레벨에서는
 라이터는 경합이 존재할지 어떨지를 체크해, 존재하는 경우는 데이터 소스에 아무것도 기입하지 않습니다. 이 동기 레벨에는
<code>RowSet</code> 오브젝트가 데이터를 취득한 뒤 다른 유저가 데이터 소스내의 대응하는 데이터로 변경을 더했을 경우,<code>RowSet</code> 오브젝트의 변경이 없어진다고 하는 문제가 있습니다. <code>RIOptimisticProvider</code> 구현은, 이 동기 레벨을 사용합니다.
<P>
최고 레벨의 동기 (염세적인 병행 모델의 동기)로는
 라이터는
 경합을 피하기 위해서 락을 설정합니다. 락의 설정이라고 해도, 단일의 행의 락으로부터, 테이블 또는 데이터 소스 전체의 락까지, 다양한 레벨이 있습니다. 따라서, 동기 레벨은, 복수의 유저에
한 데이터 소스에의 동시 액세스에 중점을 둘까하고, 라이터가 <code>RowSet</code> 오브젝트내의 데이터와 데이터 소스를 동기 하게 하는 것에 중점을 둘까하고의 트레이드 오프가 됩니다. 반대로 라이터의 기능을 유효하게 하면, 동시 액세스 기능은 무효가 됩니다.
<P>
미접속의 모든 <code>RowSet</code> 오브젝트 (<code>CachedRowSet</code>,<code>FilteredRowSet</code>,<code>JoinRowSet</code> 및 <code>WebRowSet</code> 오브젝트)는
<code>SyncFactory</code> 도구
로부터 <code>SyncProvider</code> 오브젝트를 취득할 필요가 있습니다.
<P>
레퍼런스 구현 (RI)은, 다음의 2 살의 동기 프로바이더를 제공합니다.    
<UL> 
 <LI><b><tt>RIOptimisticProvider</tt></b> <br> 프로바이더 구현이 지정되어 있지 않을 때,<code>SyncFactory</code> 인스턴스로부터 미접속의 <code>RowSet</code> 오브젝트에 제공되는 디폴트의 프로바이더. <BR> 데이타베이스내의 같은 데이터에 액세스 하는 유저 사이에 경합이 거의 존재하지 않으면 상정한, 오프티미스틱 병행 모델을 사용합니다. 락은 사용합니다만, 그 대신에
<code>RowSet</code> 오브젝트와 데이터 소스의 동기를 잡기 전에
 경합이 존재할지 어떨지의 체크를 실시합니다. 경합이 존재하는 경우는
 아무것도 실시하지 않습니다. 즉,<code>RowSet</code> 오브젝트의 변경은, 데이터 소스에서는 보관 유지되지 않습니다.
 <LI><B><tt>RIXMLProvider</tt></B> <BR> <code>WebRowSet</code> 오브젝트, 즉 XML 형식에서 읽어내 또는 기입해 가능한 행 세트로 사용할 수 있는 동기 프로바이더. <code>RIXMLProvider</code> 구현은 경합의 체크를 일절 실시하지 않고,<code>WebRowSet</code> 오브젝트의 갱신 데이터를 부하의 데이터 소스에 단순하게 기입합니다. <code>WebRowSet</code> 오브젝트는
 XML 데이터의 처리시에
 이 프로바이더를 사용합니다.
</UL>
이러한 <code>SyncProvider</code> 구현은, 레퍼런스 구현에 번들 되고 있기 때문에
<code>RowSet</code> 구현은 이러한 구현을 언제라도 이용할 수 있습니다. <code>SyncProvider</code> 구현은,<code>SyncFactory</code> 싱글 톤에 등록되면, 이용 가능한 상태가 됩니다. <code>RowSet</code> 오브젝트로부터 프로바이더 (생성자내로 지정, 또는 <code>CachedRowSet</code>
 <code>setSyncProvider</code> 메서드의 인수로서 지정)의 요구를 받아들이면,<code>SyncFactory</code> 싱글 톤은, 요구된 프로바이더가 등록되어 있는지 어떤지를 확인합니다. 등록되어 있는 경우는
<code></code>그 인스턴스를 작성해, 요구원의 <code>RowSet</code> 오브젝트에 건네줍니다. 지정된 <code>SyncProvider</code> 구현이 등록되지 않은 경우는
<code>SyncFactory</code> 싱글 톤은 <code>SyncFactoryException</code> 오브젝트를 Throw 합니다. 프로바이더가 지정되어 있지 않은 경우는
 디폴트 프로바이더 구현 <code>RIOptimisticProvider</code>를
 작성해, 요구원의 <code>RowSet</code> 오브젝트에 건네줍니다. <code></code>

<P>
<code>WebRowSet</code> 오브젝트의 생성자내에 프로바이더가 지정되어 있지 않은 경우,<code>SyncFactory</code>는

<code>RIOptimisticProvider</code>
 인스턴스를 건네줍니다. 다만, 구현에
해,<code>WebRowSet</code>
 생성자가 프로바이더로서 <code>RIXMLProvider</code>를
 설정하는 경우,<code>RowSet</code> 오브젝트의 독해 및 기입은 XML 형식에서 행해집니다.
<P>
상세한 것에 대하여는
<a href="SyncProvider.html">SyncProvider</a>  클래스 사양을 참조하십시오. <p>벤더는
<tt>SyncProvider</tt> 구현과 임의의 동기 레벨을 개발해,<code>RowSet</code> 오브젝트에  동기도구
를 선택시킬 수가 있습니다. 또,<code>jdbc@sun.com</code> 로 Sun Microsystems 에 구현의 완전 수식 클래스명을 등록하는 것으로써, 그 구현을 공개할 수도 있습니다. 이 처리의 상세한 것에 대하여는
 이하로 설명합니다.  
<P>

<a name="arch"><h3>2.0 서비스 프로바이더 인터페이스 아키텍쳐</h3>
<ul><b>2.1 개요</b><p>서비스 프로바이더 인터페이스는
<code>SyncProvider</code> 구현을 등록한 뒤, 필요한 때에 생성할 수가 있는
 플러그 인 가능한 도구
를 제공합니다. <code>SyncFactory</code>
 지연 참조 도구
는
 미접속의 <code>RowSet</code> 오브젝트로부터 요구가 있을 때까지 인스턴스의 생성을 늦추는 것으로 자원의 쓸데없는 소비를 제한합니다. <code>SyncFactory</code> 클래스는
 특정의 <code>SyncProvider</code> 구현에
해 제공되는 로그 옵션과 스트림을 구성하기 위한 표준 API 도 제공합니다. <p><b>2.2 <code>SyncFactory</code> 에의 등록</b><p>미접속의 <code>RowSet</code> 오브젝트가 써드파티의 <code>SyncProvider</code> 구현을 취득해, 그 <code>javax.sql.RowSetReader</code> 구현과 <code>javax.sql.RowSetWriter</code> 구현을 사용할 수 있도록 하려면,
 이 구현을 <code>SyncFactory</code> 에 등록할 필요가 있습니다. 모든 <code>SyncProvider</code> 구현은, 다음의 등록 도구
를 이용할 수 있습니다. <ul><li><b>시스템 프로퍼티</b> - 커멘드행으로 설정하는 프로퍼티. 이러한 프로퍼티는 실행시로 설정되어 Java 어플리케이션의 호출에
해 시스템 전체에 적용된다. 상세한 것에 대하여는
<a href="#reldocs">「관련 항목」</a>을 참조<p><li><b>프로퍼티 파일</b> - 표준 프로퍼티 파일로 지정하는 프로퍼티. 시스템 프로퍼티를 이용하는지, 플랫폼의 실행시에 검출된 표준 프로퍼티 파일을 변경하는 것에
해 지정한다. 이 테크놀러지의 레퍼런스 구현에는 표준 프로퍼티 파일이 1 개 포함된다. 이 표준 프로퍼티 파일을 편집하는 것으로<code>SyncProvider</code> 오브젝트를 추가할 수 있다<p> <li><b>JNDI 컨텍스트
</b> - 사용 가능한 프로바이더는 JNDI 컨텍스트
에 등록할 수 있다. <tt>SyncFactory</tt> 은, 컨텍스트
에 바인드 된 <tt>SyncProvider</tt> 오브젝트를 로드해, 팩토리에 등록하려고 한다. 이 도구
를 정상적으로 기능시키기 위해서는
 컨텍스트
을 <code>SyncFactory</code> 에 건네줄 필요가 있다
</ul>
<p>프로퍼티 파일내에 시스템 프로퍼티나 프로퍼티를 지정하는 방법, JNDI 컨텍스트
을 구성하는 방법의 상세한 것에 대하여는
<a href="SyncFactory.html"><code>SyncFactory</code></a>  클래스의 설명을 참조하십시오. <p><b>2.3 SyncFactory 프로바이더 인스턴스 생성 폴리시</b><p>프로바이더가 정상적으로 등록되어 있으면,<code>SyncFactory</code> 은 요구된 <code>SyncProvider</code> 오브젝트를 생성합니다. 미접속의 <code>RowSet</code> 오브젝트가 특정의 <code>SyncProvider</code> 구현으로 초기화되었을 때, 또는 그 외의 <code>SyncProvider</code> 오브젝트로 실행시에 복구 이루어졌을 때는
 다음의 폴리시가 시행됩니다. <ul><li> <code>SyncProvider</code> 오브젝트가 지정되어<code>SyncFactory</code> 에 프로바이더의 참조가 포함되지 않는 경우,<code>SyncFactoryException</code> 가 Throw 된다<p><li> <code>SyncProvider</code> 오브젝트가 지정되어<code>SyncFactory</code> 에 프로바이더의 참조가 포함되는 경우, 요구된 프로바이더가 제공된다<p><li> <code>SyncProvider</code> 오브젝트가 지정되어 있지 않은 경우, 레퍼런스 구현 프로바이더 <code>RIOptimisticProvider</code> 가 제공된다
</ul>
<p>이러한 폴리시의 상세한 것에 대하여는
<a href="SyncFactory.html"><code><code>SyncFactory</code></code></a>  클래스의 설명을 참조하십시오.
</ul>

<li><a name="impl"><h3>3.0 SyncProvider 구현 가이드</h3>
<ul><b>3.1 요건</b><p><code>SyncFactory</code> 에 완전하게 플러그 인 가능한 <code>SyncProvider</code> 준거 구현은, 모든 추상 메서드를 확장해,<a href="SyncProvider.html"><code>SyncProvider</code></a>  클래스에 구현할<b>필요가 있습니다</b>. 개개의 구현은,<code>SyncProvider</code> 클래스 정의내의 그레이드, 락, 갱신 가능 뷰의 기능을 확정할<b>필요가 있습니다</b>. 1 개 이상의 <code>SyncProvider</code> 기술 기준이 서포트되고 있을<b>필요가 있습니다</b>. 벤더 구현은, 그레이드, 락, 갱신 가능 뷰의 기능의 범위를 나타내는 것이 요구됩니다. <p>게다가<code>SyncProvider</code> 명명 규칙에 준거할<b>필요가 있습니다</b>. 이 명명 규칙의 상세한 것에 대하여는
<a href="SyncProvider.html"><code>SyncProvider</code></a>  클래스의 설명을 참조하십시오. <p><b>3.2 그레이드</b><p>JSR 114 에는
<code>SyncProvider</code> 오브젝트로부터 미접속의 <code>RowSet</code> 오브젝트에 제공되는 동기의 품질을 나타내는
 일련의 그레이드가 정의되고 있습니다. 이러한 그레이드는
 서비스 품질의 낮은 순서에 일람 됩니다. <ul><li><b>GRADE_NONE</b> - 원래의 데이터 소스와의 동기는 행해지지 않는다. 이 그레이드를 돌려주는 <code>SyncProvider</code>  구현은,<code>RowSet</code> 오브젝트내의 변경이 끝난 데이터를 부하의 데이터 소스에 덧쓰기할 뿐. 원의 값과 현재의 값을 비교해 경합이 있을지 어떨지를 확인하는 처리는 행해지지 않는다. <code>RIXMLProvider</code>는

 이 그레이드로 구현되고 있다<p><li><b>GRADE_CHECK_MODIFIED_AT_COMMIT</b> - 저그레이드의 오프티미스틱 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은, 전회의 동기부터 이번 동기까지 변경된 은행내에 경합이 없는가 체크를 실시한다. 원래의 데이터 소스로 변경이 더해진 뒤, 그 내용이 미접속의 <code>RowSet</code> 오브젝트에 반영될 것은 없다. 경합이 존재하지 않는 경우,<code>RowSet</code> 오브젝트내의 변경은 데이터 소스에 기입해진다. 경합이 존재하는 경우, 변경 내용은 기입해지지 않다. <code>RIOptimisticProvider</code> 구현은, 이 그레이드를 사용한다<p><li><b>GRADE_CHECK_ALL_AT_COMMIT</b> - 고그레이드의 오프티미스틱 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은, 미접속의 <code>RowSet</code> 오브젝트내의 모든 행을, 미변경의 것도 포함해 체크한다. 이것에
해, 동기가 정상적으로 완료했을 때, 부하의 데이터 소스내의 모든 행의 변경이 미접속의 <code>RowSet</code> 오브젝트에 반영된다<p><li><b>GRADE_LOCK_WHEN_MODIFIED</b> - 염세적인 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은,<code>RowSet</code> 오브젝트내의 행이 변경되었을 때, 데이터 소스내의 같은 데이터가 다른 프로세스에
해 변경되는 것이 없게, 원래의 데이터 소스내의 행을 잠근다<p><li><b>GRADE_LOCK_WHEN_LOADED</b> - 고그레이드의 염세적인 병행 동기. 이 그레이드를 돌려주는 <code>SyncProvider</code> 구현은,<code>RowSet</code> 오브젝트의 이식에 사용된 원의 쿼리의 영향을 받는 뷰와 테이블 전체, 또는 그 어느쪽이든을 잠근다
</ul>
<p><b>3.3 락</b><p>JSR 114 에는
<code>RowSet</code> 오브젝트의 부하의 데이터 소스에 락이 적용되고 있는지 어떤지, 적용되고 있는 경우는 어느 구조체에 적용되고 있는지를 나타내는 정수세트가 정의되고 있습니다. 이러한 락은, 데이터 소스로부터 <code>RowSet</code> 오브젝트가 절단 될 때까지, 데이터 소스상에 보관 유지됩니다.
<P>
이러한 정수는
 그레이드 정수를 보완하는 정수입니다. 대부분의 그레이드의 디폴트 설정은,<code>RowSet</code> 오브젝트를 데이터 소스로부터 절단 할 때 데이터 소스의 락도 파기하는 것을 요구합니다. 그레이드 <code>GRADE_LOCK_WHEN_MODIFIED</code> 및 <code>GRADE_LOCK_WHEN_LOADED</code> 에서는
 미접속의 <code>RowSet</code> 오브젝트로 락의 단계를 세세하게 제어할 수 있습니다. <ul><li><b>DATASOURCE_NO_LOCK</b> - 락은 원래의 데이터 소스상에 보관 유지되지 않는다. <code>RowSet</code> 오브젝트의 관리하에 있는 것을 제외하는 모든 <code>SyncProvider</code> 구현의 디폴트의 락 설정<p><li><b>DATASOURCE_ROW_LOCK</b> - 락은,<code>RowSet</code> 오브젝트의 이식에 사용된 원의 SQL 쿼리의 영향을 받는 행에게만 보관 유지된다<p> <li><b>DATASOURCE_TABLE_LOCK</b> - 락은,<code>RowSet</code> 오브젝트의 이식에 사용된 쿼리의 영향을 받는 모든 테이블상에서 보관 유지된다<p><li><b>DATASOURCE_DB_LOCK</b> - 락은,<code>RowSet</code> 오브젝트에
해 사용되는 데이터 소스 전체로 보관 유지된다
</ul>
<p><b>3.4 갱신 가능 뷰</b><p><code>RowSet</code> 오브젝트에는
 SQL <code>VIEW</code>
 데이터를 이식할 수 있습니다. 이하는
<code>SyncProvider</code> 오브젝트가,<code>VIEW</code>
 파생원의 테이블 (복수가) 내의 데이터를 갱신할 수 있을지 어떨지를 나타내는 정수입니다. <ul><li><b>UPDATABLE_VIEW_SYNC</b> - <code>SyncProvider</code> 구현이,<code>RowSet</code> 오브젝트를 이식하기 위해서 사용된 SQL <code>VIEW</code>
 파생원의 테이블 (복수가능)에의 동기를 지원하는
 것을 나타낸다<p><li><b>NONUPDATABLE_VIEW_SYNC</b> - <code>SyncProvider</code> 구현이,<code>RowSet</code> 오브젝트를 이식하기 위해서 사용된 SQL <code>VIEW</code>
 파생원의 테이블 (복수가능)에의 동기를 서포트<b>하지 않는</b>것을 나타낸다
</ul>
<p><b>3.5 <code>SyncProvider</code>
 그레이드 기능과 락 기능의 사용 방법</b><p>이하에
 레퍼런스 구현 <tt>CachedRowSetImpl</tt> 가 <tt>setSyncProvider</tt> 메서드를 호출하는 것에
해 현재의 <tt>SyncProvider</tt> 오브젝트를 구성하는 예를 나타냅니다. <br><PRE> CachedRowSetImpl crs = new CachedRowSetImpl(); crs.setSyncProvider("com.foo.bar.HASyncProvider");</PRE> 어플리케이션은, 미접속의 <code>RowSet</code> 오브젝트에
해 현재 사용되고 있는 <tt>SyncProvider</tt> 오브젝트를 취득할 수 있습니다. 또, 프로바이더의 구현에 사용된 동기의 그레이드와 현재 사용되고 있는 락의 단계도 취득할 수 있습니다. 어플리케이션의 유연성을 이용해, 사용하는 락의 단계를 설정하는 것으로써, 동기의 성공의 확률을 높일 수가 있습니다. 이러한 오퍼레이션에 대해서는
 이하의 코드의 발췌를 참조하십시오. <PRE> SyncProvider sync = crs.getSyncProvider();
switch (sync.getProviderGrade()) { case: SyncProvider.GRADE_CHECK_ALL_AT_COMMIT //A high grade of optimistic synchronization break; case: SyncProvider.GRADE_CHECK_MODIFIED_AT_COMMIT  //A low grade of optimistic synchronization  break; case: SyncProvider.GRADE_LOCK_WHEN_LOADED  // A pessimistic synchronization grade  break; case: SyncProvider.GRADE_LOCK_WHEN_MODIFIED  // A pessimistic synchronization grade  break; case: SyncProvider.GRADE_NONE  // No synchronization with the originating data source provided break; }           switch (sync.getDataSourcLock() { case: SyncProvider.DATASOURCE_DB_LOCK // A lock is placed on the entire datasource that is used by the // <code>RowSet</code> object  break;
case: SyncProvider.DATASOURCE_NO_LOCK // No locks remain on the  originating data source.  break;
case: SyncProvider.DATASOURCE_ROW_LOCK // A lock is placed on the rows that are  touched by the original  // SQL statement used to populate // the RowSet object that is using the SyncProvider break;
case: DATASOURCE_TABLE_LOCK // A lock is placed on  all tables that are touched by the original  // SQL statement used to populated // the RowSet object that is using the SyncProvider break;
</PRE> <code>SyncFactory</code> 클래스의 static 유틸리티 메서드를 사용해, 현재 <code>SyncFactory</code> 에 등록되어 있는 <code>SyncProvider</code> 구현의 일람을 확인할 수도 있습니다.
 <pre>
        Enumeration e = SyncFactory.getRegisteredProviders();</pre>    

</ul>

<h3><a name="resolving">4.0 동기 경합의 해결</h3>

어플리케이션은,<code>SyncResolver</code> 인터페이스를 이용해, 경합이 발생했을 때의 수동에서의 대처법을 결정할 수 있습니다. <code>CachedRowSet</code>
 <code>acceptChanges</code> 메서드가 종료해, 경합의 존재가 확인되었을 경우, 이 메서드는 <code>SyncProviderException</code> 오브젝트를 Throw 합니다. 어플리케이션은 예외를 캐치 해,<code>SyncProviderException.getSyncResolver()</code> 메서드 호출에
해 <code>SyncResolver</code> 오브젝트를 취득시킬 수가 있습니다.
<P>
<code>SyncResolver</code> 오브젝트는
<code>SyncResolver</code> 인터페이스를 구현하고 있는 특수한 <code>CachedRowSet</code> 또는 <code>JdbcRowSet</code> 오브젝트이며, 1 행씩 경합의 체크를 실시합니다. 동기 되는 <code>RowSet</code> 오브젝트의 복제가 되어 있어, 경합의 원인이 되고 있는 데이터 소스의 데이터만을 포함하고 있습니다. 이것이, 경합의 원인입니다. 그 외의 모든 렬치는 <code>null</code> 로 설정됩니다. <code>SyncResolver</code> 오브젝트는
 경합 하고 있는 값으로부터 다른 경합 하고 있는 값에 이동할 수 있는 메서드,<code>nextConflict</code> 및 <code>previousConflict</code>를
 제공하고 있습니다.
<P>
<code>SyncResolver</code> 인터페이스는
 이하의 처리를 실시하는 메서드도 제공합니다.
<UL> 
 <LI>갱신, 삭제, 또는 삽입을 필요로 하는 경합일지 어떨지를 검출
 <LI>경합의 원인이 된 데이터 소스내의 값을 취득
 <LI>만약 데이터 소스내의 데이터를 변경할 필요가 있는 경우 그 적절한 값의 설정. 혹은,<code>RowSet</code> 오브젝트의 데이터를 변경할 필요가 있는 경우 그 적절한 값의 설정
</UL>
<P>
<code>CachedRowSet</code>
 <code>acceptChanges</code> 메서드는
 불려 가면,<code>RowSet</code> 오브젝트의 <code>SyncProvider</code> 오브젝트를 위양 합니다. 이 <code>SyncProvider</code> 오브젝트로부터 제공되는 라이터의 구현 방법은, 경합의 체크 레벨 (그레이드)에
결정됩니다. 경합의 체크가 모두 완료해, 실제로 경합이 검출되었을 경우,<code>acceptChanges</code> 메서드는 <code>SyncProviderException</code> 오브젝트를 Throw 합니다. 어플리케이션은 예외를 캐치 해, 이 예외를 사용해 <code>SyncResolver</code> 오브젝트를 취득할 수가 있습니다.
<P>
그 후,<code>SyncResolver</code> 메서드를 사용해, 각 경합의 정보를 취득해, 대처 방법을 결정합니다. 어플리케이션 논리 또는 유저에
해,<code>RowSet</code> 오브젝트내의 값을 지속시킬 필요가 있다고 하는 판단이 내려졌을 경우, 어플리케이션 또는 유저는
 이 값으로 데이터 소스치를 덧쓰기할 수 있습니다.
<P>
상세한 것에 대하여는
<code>SyncResolver</code> 인터페이스의 코멘트를 참조하십시오.
<a name="relspec"><h3>5.0 관련 사양</h3>
<ul><li><a href="http://java.sun.com/products/jndi">JNDI 1.3</a> <li><a href="../../../../../guide/logging/index.html">Java Logging API</a> 
</ul>
<a name="reldocs"><h3>6.0 관련 항목</h3>
<ul><li><a href="../../../../../tooldocs/index.html#basic">시스템 프로퍼티</a> <li>resource file<li><a href="http://java.sun.com/tutorial/jdbc">JDBC 접속의 데이터 소스</a> 
</ul>
<P>

<P>
<DL>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../javax/sql/rowset/serial/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../javax/swing/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?javax/sql/rowset/spi/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:01:23 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
CachedRowSet (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.sql.rowset.CachedRowSet interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="CachedRowSet (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CachedRowSet.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/sql/rowset/BaseRowSet.html" title="javax.sql.rowset 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/sql/rowset/CachedRowSet.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="CachedRowSet.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.sql.rowset</FONT>
<BR>
인터페이스 CachedRowSet</H2>
<DL>
<DT><B>모든 슈퍼 인터페이스:</B> <DD><A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 내의 인터페이스">Joinable</A>,
 <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>,
 <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A> </DD>
</DL>
<DL>
<DT><B>기존의 서브 인터페이스의 일람: </B> <DD><A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스">FilteredRowSet</A>,
 <A HREF="../../../javax/sql/rowset/JoinRowSet.html" title="javax.sql.rowset 안의 인터페이스">JoinRowSet</A>,
 <A HREF="../../../javax/sql/rowset/WebRowSet.html" title="javax.sql.rowset 안의 인터페이스">WebRowSet</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>CachedRowSet</B><DT>extends <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 내의 인터페이스">RowSet</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 안의 인터페이스">Joinable</A> </DL>
</PRE>

<P>
<code>CachedRowSet</code>의 모든 표준 구현이 구현해야 하는 인터페이스입니다.
  <p> Sun Microsystems 로부터 제공된 <code>CachedRowSet</code> 인터페이스의 레퍼런스 구현은, 표준 구현입니다. 개발자는 이것을 그대로 사용하는 일도, 확장하는 일도, 또는 이 인터페이스의 구현을 독자적으로 작성할 수도 있습니다. </p>
  <p> <code>CachedRowSet</code> 오브젝트는
 메모리내에 행을 캐쉬하는
 데이터행의 컨테이너이며, 항상 그 데이터 소스에 접속하고 있지 않아도 처리를 실행할 수 있습니다. 또, 스크롤, 갱신, 직렬화가 가능한 JavaBeans<sup><font size="-2">TM</font></sup> 컴퍼넌트입니다. <code>CachedRowSet</code> 오브젝트에는
 보통
, 결과 세트의 행이 포함됩니다만, 스프레드쉬트 등, 겉(표) 형식의 모든 파일의 행을 포함할 수도 있습니다. 레퍼런스 구현은,<code>ResultSet</code> 오브젝트로부터의 데이터의 취득 밖에 서포트합니다만, 개발자는
 그 외의 겉(표) 형식의 데이터 소스에 액세스 할 수 있도록,<code>SyncProvider</code> 구현을 확장할 수가 있습니다. </p>
  <p> 어플리케이션은,<code>CachedRowSet</code> 오브젝트내의 데이터를 변경할 수 있습니다. 이러한 변경은, 데이터 소스에도 반영됩니다. </p>
 <p> <code>CachedRowSet</code> 오브젝트는 「미접속의」행 세트입니다. 즉, 데이터 소스와의 접속을 조금 밖에 이용하지 않습니다. <code>CachedRowSet</code> 오브젝트가 데이터 소스에 접속하는 것은, 데이터를 읽어내 자신에게 행을 읽어들일 때와 부하의 데이터 소스로 변경 내용을 반영할 때 뿐입니다. 그 이외 때는
 데이터의 변경중도 포함해, 데이터 소스로부터 절단 되고 있습니다. <code>RowSet</code> 오브젝트는
 이와 같이, 데이터 소스로부터 절단 되고 있기 때문에 헛일이 적고, 그 외의 컴퍼넌트에 건네주기 쉬워지고 있습니다. 예를 들어, 미접속의 <code>RowSet</code> 오브젝트를 직렬화해, 회선 경유로 PDA 등의 thin 클라이언트에 건네줄 수가 있습니다.  
  
<h3>1.0 <code>CachedRowSet</code> 오브젝트의 작성</h3>

다음의 코드는
 레퍼런스 구현 (RI)의 <code>CachedRowSet</code>의 디폴트 생성자를 사용해, 디폴트의 <code>CachedRowSet</code>오브젝트를 작성합니다.
  
 <pre>
 CachedRowSetImpl crs = new CachedRowSetImpl() ;k
 </pre>
이 새로운 <code>CachedRowSet</code>오브젝트는
 그 프로퍼티를 <code>BaseRowSet</code>오브젝트의 디폴트의 프로퍼티로 설정합니다. 게다가 동기 프로바이더로서 <code>RIOptimisticProvider</code>오브젝트를 가집니다. RI 에 포함되는 2 개의 <code>SyncProvider</code>구현 가운데 1 개,<code>RIOptimisticProvider</code>는
 동기 프로바이더가 지정되어 있지 않은 경우에 <code>SyncFactory</code>싱글 톤으로부터 제공되는 디폴트의 프로바이더입니다.
  <p> <code>SyncProvider</code> 오브젝트는
<code>CachedRowSet</code> 오브젝트와 데이터 소스로부터 데이터를 읽어내 자신에게 데이터를 읽어들이는 리더 (<code>RowSetReader</code> 오브젝트)를 제공합니다. 리더를 구현하는 것으로써,<code>ResultSet</code> 오브젝트나 겉(표) 형식의 파일로부터 데이터를 읽어낼 수가 있습니다. <code>SyncProvider</code> 오브젝트는
 라이터(<code>RowSetWriter</code> 오브젝트)도 제공합니다. 라이터는
 부하의 데이터 소스내의 데이터로부터 절단 되고 있는 동안에 <code>CachedRowSet</code> 오브젝트에 더해진 변경 내용을 동기 합니다. </p>
  <p>
라이터를 구현하는 것으로써, 다양한 레벨로 행 세트에 값을 읽어들인 후에 데이터 소스내의 값이 변경되었을 경우에 발생하는 경합의 체크나 예방을 실시할 수가 있습니다. <code>RIOptimisticProvider</code> 구현은, 경합이 거의 없는지, 전혀 없는 것으로서 락을 일절 설정하지 않습니다. 이 구현은, 경합이 없는 경우에게만,<code>CachedRowSet</code> 오브젝트의 값으로 데이터 소스를 갱신합니다. 변경된 데이터를 데이터 소스에 기입하는 목적에서만 구현되는 라이터도 있습니다. 이 구현은, 경합의 체크를 실시하지 않는가, 그 완전히 역으로 데이터 소스내의 데이터의 변경을 충분히 막을 수 있을 뿐의 락을 설정하는 것에
해 행해집니다. 또, 그 거의 중간의 라이터 구현도 있습니다. </p>
  <p> <code>CachedRowSet</code> 오브젝트는
<code>SyncFactory</code> 싱글 톤에 등록된 임의의 <code>SyncProvider</code> 구현을 사용할 수 있습니다. 어플리케이션은, 다음의 코드를 호출하는 것으로 등록되어 있는 <code>SyncProvider</code> 구현을 검출할 수 있습니다. </p>
 <pre>
 java.util.Enumeration providers = SyncFactory.getRegisteredProviders();</pre>

  <p> <code>CachedRowSet</code> 오브젝트로 사용하는 <code>SyncProvider</code>
오브젝트를 지정하는 방법은, 다음의 2 대로입니다. </p>
  <ul )="">
    <li>생성자에 구현명을 제공한다<br>
다음의 코드는
 디폴트치 (다만 <code>SyncProvider</code>를
 지정)로 초기화되는 <code>CachedRowSet</code> 오브젝트 <i>crs2</i>를
 작성합니다.
      
 <pre>
 CachedRowSetImpl crs2 = new CachedRowSetImpl( 
                        "com.fred.providers.HighAvailabilityProvider");</pre>
    </li>

    <li><code>CachedRowSet</code> 메서드 <code>setSyncProvider</code>
를 사용해 <code>SyncProvider</code>를
 설정한다<br>
다음의 코드는
<i>crs</i>
 <code>SyncProvider</code> 오브젝트 (디폴트의 생성자
으로 작성된 <code>CachedRowSet</code> 오브젝트)를 리셋트 합니다.
      
 <pre>
 crs.setSyncProvider("com.fred.providers.HighAvailabilityProvider");</pre>
    </li>

  
</ul>

상세한 것에 대하여는 <code>SyncFactory</code>및 <code>SyncProvider</code>를 참조해 관이야
있고.
  <h3>2.0 <code>CachedRowSet</code> 오브젝트로부터의 데이터의 취득</h3>

데이터는
<code>ResultSet</code>인터페이스로부터 상속된 취득 메서드를 사용해,<code>CachedRowSet</code>오브젝트로부터 취득됩니다. 다음의 예는
<code>crs</code>를 <code>CachedRowSet</code>오브젝트로서 행의 반복 처리를 실시해, 각 행으로부터 열의 값을 얻는
 방법을 나타냅니다. 최초의 예에서는
 열번호를 취하는 취득 메서드를 사용합니다. 2 번째의 예에서는
 렬명을 취하는 취득 메서드를 사용합니다. 열번호는
 보통
,<code>RowSet</code>오브젝트의 커멘드가 <code>SELECT * FROM TABLENAME</code>의 형식이 되는 경우에 사용됩니다. 렬명은, 렬명을 지정하는 커멘드로 자주 사용됩니다.
  
 <pre>
 while (crs.next()) { 
     String name = crs.getString(1);
     int id = crs.getInt(2);
     Clob comment = crs.getClob(3);
     short dept = crs.getShort(4);
     System.out.println(name + "  " + id + "  " + comment + "  " + dept);
 } </pre>

  
 <pre>
 while (crs.next()) { 
     String name = crs.getString("NAME");
     int id = crs.getInt("ID");
     Clob comment = crs.getClob("COM");
     short dept = crs.getShort("DEPT");
     System.out.println(name + "  " + id + "  " + comment + "  " + dept);
 }</pre>

  <h4>2.1 <code>RowSetMetaData</code>
 취득</h4>
어플리케이션은,<code>RowSetMetaData</code>오브젝트상에 <code>ResultSetMetaData</code>메서드와 <code>RowSetMetaData</code>메서드를 호출하는 것으로<code>CachedRowSet</code>오브젝트내의 열에 관한 정보를 취득할 수 있습니다. 다음의 코드의 발췌에서는
<i>crs</i>를 <code>CachedRowSet</code>오브젝트로서 이 처리에 대해 설명합니다. 1 행 째로는
<i>crs</i>내의 열에 관한 정보를 가지는 <code>RowSetMetaData</code>오브젝트를 작성합니다. <code>ResultSet</code>인터페이스로부터 상속된 <code>getMetaData</code>메서드는
<code>ResultSetMetaData</code>오브젝트를 돌려줍니다. 돌려주고진 오브젝트는
 변수 <i>rsmd</i>에 할당할 수 있기 전에 <code>RowSetMetaData</code>오브젝트에 캐스트 됩니다. 2 행 째로는
<i>jrs</i>의 렬수를 확인합니다. 3 행 째로는
<code>jrs</code>의 2 번째의 열에 포함된 값의 JDBC 형을 취득합니다.
  
 <pre>
 RowSetMetaData rsmd = (RowSetMetaData) crs.getMetaData();
 int count = rsmd.getColumnCount();
 int type = rsmd.getColumnType(2);</pre>

  <code>RowSetMetaData</code>인터페이스는
 다음의 2 개의 점으로써,<code>ResultSetMetaData</code>인터페이스와는 다릅니다.
  <ul>
    <li><code>설정</code>메서드를 포함한: <code>RowSet</code> 오브젝트는
 다른 <code>ResultSet</code>
오브젝트의 데이터를 읽어들일 때, 이러한 메서드를 내부에서 사용합니다.
    </li>

    <li>포함되는<code>취득</code>메서드의 수가 적은: 일부의 <code>ResultSetMetaData</code> 메서드는 <code>RowSet</code> 오브젝트에는 적용되지 않습니다. 예를 들어, 열의 값이 기입해 가능한가 독해 전용인지를 확인하는 메서드는 적용되지 않습니다. 이것은,<code>RowSet</code> 오브젝트의 모든 열은, 행 세트의 갱신이 가능한 경우는 기입해 가능, 행 세트의 갱신을 할 수 없는 경우는 읽어내 전용이기 때문입니다. </li>
  
</ul>

주: <code>RowSetMetaData</code>오브젝트를 돌려주기 위해서는
 구현으로 <code>java.sql.ResultSet</code>에 정의된 <code>getMetaData()</code>메서드를 오버라이드(override) 해,<code>RowSetMetaData</code>오브젝트를 돌려줄 필요가 있습니다.
  
<h3>3.0 <code>CachedRowSet</code> 오브젝트의 갱신</h3>

  <code>CachedRowSet</code>오브젝트의 갱신 방법은 <code>ResultSet</code>오브젝트의 갱신 방법과 같습니다만, 갱신중, 행 세트는 데이터 소스에 접속하고 있지 않았기 때문에
 부하의 데이터 소스로 변경을 더하는 추가 순서가 필요하게 됩니다. <code>CachedRowSet</code>오브젝트는
<code>updateRow</code>메서드나 <code>insertRow</code>메서드를 호출한 뒤,<code>acceptChanges</code>메서드를 호출해, 갱신 내용을 데이터 소스에 기입할 필요가 있습니다. 다음의 예에서는
<code>CachedRowSet</code>오브젝트 <i>crs</i>내의 행에 커서가 놓여져 있습니다. 이 코드는
 현재의 행의 2 개의 열의 값을 갱신해,<code>RowSet</code>오브젝트의 부하의 데이터 소스를 갱신합니다.
  
 <pre>
 crs.updateShort(3, 58);
 crs.updateInt(4, 150000);
 crs.updateRow();
 crs.acceptChanges();</pre>

  <p> 다음의 예에서는
 삽입행으로 이동해, 삽입행 위에 새로운 행을 작성해, 이것을 행 세트에 삽입합니다. 게다가<code>acceptChanges</code> 메서드를 호출해, 부하의 데이터 소스에 새로운 행을 추가합니다. 취득 메서드의 경우와 같게, 갱신 메서드에서도, 열인덱스나 렬명을 사용해 처리 대상의 열을 지정할 수 있습니다. </p>
  
 <pre>
 crs.moveToInsertRow();
 crs.updateString("Name", "Shakespeare");
 crs.updateInt("ID", 10098347);
 crs.updateShort("Age", 58);
 crs.updateInt("Sal", 150000);
 crs.insertRow();
 crs.moveToCurrentRow();
 crs.acceptChanges();</pre>

  <p> 주: <code>insertRow()</code> 메서드로<code>CachedRowSet</code> 오브젝트의 삽입행의 내용을 삽입하는 장소는
 구현으로 정의합니다. <code>CachedRowSet</code> 인터페이스의 레퍼런스 구현은, 현재의 행의 직후에 새로운 행을 삽입합니다만, 다른 임의의 개소에도 삽입하도록 구현할 수 있습니다. </p>
  <p> 이러한 예에 있어서의 <code>acceptChanges</code> 메서드의 사용 방법에 주목해 주세요. 이 메서드는
<code>RowSet</code> 오브젝트의 라이터를 내부에서 호출해, 데이터 소스로 변경을 기입하는 것으로<code>CachedRowSet</code> 오브젝트내의 변경 내용을 부하의 데이터 소스에 전달합니다. 이 때문에
 라이터는
 데이터 소스와의 접속을 확립하지 않으면 안됩니다. 최초의 2 개의 코드의 발췌는
<code>updateRow</code> 또는 <code>insertRow</code>
 호출 후 즉시 <code>acceptChanges</code> 메서드를 호출합니다. 그러나, 복수의 행을 변경하는 경우는
 <code>updateRow</code> 와 <code>insertRow</code>
 호출이 모두 완료하고 나서 <code>acceptChanges</code>를
 호출하는 방법 쪽이 효율이 좋아집니다. <code>acceptChanges</code>를
 1 회 밖에 호출하지 않는 경우는
 접속을 1 개 확립하는 것만으로 끝납니다. </p>

  <h3>4.0 부하의 데이터 소스의 갱신</h3>

  <code>acceptChanges</code>메서드의 실행시에는
 행 세트에의 변경점을 부하의 데이터 소스에 기입하기 때문에
 배후에서 <code>CachedRowSet</code>오브젝트의 라이터,<code>RowSetWriterImpl</code>오브젝트가 불려 갑니다. 이 라이터가 구현되는 것으로 데이터 소스에의 접속이 확립되어 갱신 정보가 기입해집니다. <p> 라이터는
 섹션 1
 「<code>CachedRowSet</code> 오브젝트의 작성」으로 설명했던 대로<code>SyncProvider</code> 인터페이스의 구현을 개입시켜 이용할 수 있습니다. 디폴트의 레퍼런스 구현 프로바이더 <code>RIOptimisticProvider</code>는

 오프티미스틱 concurrent processing 제어 도구
를 이용하기 위해, 라이터를 구현하고 있습니다. 즉, 행 세트가 데이타베이스로부터 절단 되고 있는 동안, 부하의 데이타베이스는 락 되지 않고, 데이터 소스에 데이터를 기입하기 전에 경합이 있는지 없는지의 확인을 하게만 됩니다. 경합이 있는 경우, 데이터 소스에는 아무것도 기입해지지 않습니다. </p>
  <p> <code>SyncProvider</code> 클래스에
해 제공되는 리더/라이터의 기능은, 플러그 인 가능하고, 데이터의 취득과 갱신의 커스터마이즈에 이용할 수 있습니다. 다른 concurrent processing 제어 도구
가 필요한 경우는
<code>setSyncProvider</code> 메서드를 사용해, 다른 <code>SyncProvider</code> 구현을 플러그 인 할 수 있습니다. </p>
  <p> 오프티미스틱 concurrent processing 제어 루틴을 사용하기 위해,<code>RIOptismisticProvider</code>는

 현재의 값과 원의 값 (현재의 값의 직전의 값)의 양쪽 모두를 보관 유지합니다. <code>RowSet</code> 오브젝트내의 데이터가 변경되지 않았던 경우, 현재의 값과 원의 값은 동일 (<code>RowSet</code> 오브젝트가 최초로 생성되었을 때의 값)이 됩니다. 그러나,<code>RowSet</code> 오브젝트내의 값이 변경되었을 경우, 현재의 값과 원의 값은 일치하지 않습니다. 이 단계에서는
 원의 값은 초기치인 채입니다. 그 후의 <code>RowSet</code> 오브젝트내의 데이터의 변경에
해, 원의 값과 현재의 값은 일치하지 않게 됩니다만, 이전 현재의 값이었던 값이 원의 값이 됩니다. </p>
 <p> 원의 값을 추적하는 것으로 라이터는
<code>RowSet</code> 오브젝트의 원의 값과 데이타베이스내의 값을 비교할 수 있습니다. 데이타베이스내의 값이 <code>RowSet</code> 오브젝트의 원의 값과 일치하지 않는 경우, 데이타베이스내의 값이 변경되고 있어 경합이 발생하고 있는 것을
미합니다. 라이터를 사용해 경합의 체크를 실시하는지, 어느 정도까지 체크를 실시하는지, 경합을 어떻게 처리할까는
 모두 구현에 따라서 다릅니다. </p>
  
<h3>5.0 리스너의 등록과 통지</h3>

JavaBeans 컴퍼넌트이므로 모든 행 세트는
<code>BaseRowSet</code>클래스로부터 리스너의 등록이라고 변경 내용을 통지하기 위한 메서드를 상속해, JavaBeans 이벤트 모델에 참여 합니다. <code>CachedRowSet</code>오브젝트의 리스너는
 행 세트내로 변경이 있었는지 어떠했는지를 통지되는 컴퍼넌트입니다. 예를 들어,<code>CachedRowSet</code>오브젝트에 쿼리의 결과가 포함되어 이러한 결과가 겉(표)나 막대 그래프로서 표시된다고 합니다. 겉(표)나 막대 그래프는
 행 세트의 리스너로서 등록되는 것으로 변경 내용을 반영하도록 자신의 갱신을 실시할 수가 있습니다. 겉(표)나 막대 그래프의 클래스가 리스너가 되려면,
<code>RowSetListener</code>인터페이스를 구현할 필요가 있습니다. 그 후, 이것들을 <code>CachedRowSet</code>오브젝트의 리스너의 리스트에 추가합니다. 다음의 코드를 참조하십시오.
 <pre>
  crs.addRowSetListener(table);
  crs.addRowSetListener(barGraph);</pre>

커서를 이동하거나 데이터를 변경하거나 하는 <code>CachedRowSet</code>메서드도, 등록을 마친 리스너로 변경을 통지합니다. 따라서,<code>crs</code>내로 변경이 있으면,<code>table</code>와 <code>barGraph</code>는 그 통지를 받습니다.
  
<h3>6.0 thin 클라이언트에의 데이터의 송신</h3>

  <code>CachedRowSet</code>오브젝트는
 주로 어플리케이션 컴퍼넌트간에서의 데이터의 수수에 이용됩니다. <code>CachedRowSet</code>오브젝트는 직렬화 가능해서, 예를 들어, 서버 환경에서 가동중의 엔터프라이즈 JavaBeans 컴퍼넌트에
해 실행된 쿼리의 결과를, Web 브라우저로 가동중의 클라이언트에
 네트워크 경유로 송신하기 위해서 이용할 수가 있습니다.
  <p> 미접속의 <code>CachedRowSet</code> 오브젝트는
 같은 데이터를 가지는 <code>ResultSet</code> 오브젝트보다 컴팩트해서, 자원의 제한이나 보안상의 이유에
해 JDBC 드라이버를 사용하는 것이 어려운 PDA 등의 thin 클라이언트에의 데이터 송신에 최적입니다. 이와 같이,<code>CachedRowSet</code> 오브젝트에서는
 JDBC API를
 완전하게 구현하지 않아도 행을 취득할 수 있습니다. </p>

  <h3>7.0 스크롤과 갱신</h3>

  <code>CachedRowSet</code>오브젝트에는
 스크롤 기능이나 갱신 기능을 가지지 않는 <code>ResultSet</code>오브젝트에 이러한 기능을 제공하는 기능도 있습니다. DBMS 가 스크롤과 갱신의 기능을 완전하게 서포트하지 않는 경우는
<code>CachedRowSet</code>오브젝트를 사용해, JDBC 테크놀러지를 사용 가능한 드라이버의 기능을 향상시킬 수가 있습니다. 스크롤 기능을 가지지 않는 독해 전용의 <code>ResultSet</code>오브젝트에 스크롤 기능과 갱신 기능을 갖게하려면,
<code>CachedRowSet</code>오브젝트를 작성해, 그 <code>ResultSet</code>오브젝트의 데이터를 읽어들이는 것만으로 끝납니다. 구체적인 예에 대해서는
 다음의 코드의 발췌를 참조하십시오. 이 예에서는
<code>stmt</code>는 <code>Statement</code>오브젝트를 나타냅니다.
 <pre>
 ResultSet rs = stmt.executeQuery("SELECT * FROM EMPLOYEES");
 CachedRowSetImpl crs = new CachedRowSetImpl();
 crs.populate(rs);</pre>

  <p> <code>rs</code> 오브젝트의 경우와 같게,<code>crs</code> 오브젝트에
 겉(표) <code>EMPLOYEES</code>
 데이터가 추가됩니다. 다만,<code>crs</code>
 커서는 전방, 후방, 또는 특정의 행으로 이동할 수 있는데 대해,<code>rs</code>
 커서는 전방 밖에 이동할 수 없습니다. 또,<code>crs</code> 에 갱신 기능이 있는데 대해,<code>rs</code> 에는 갱신 기능은 없습니다. 이것은,<code>CachedRowSet</code> 오브젝트에
 스크롤 기능과 갱신 기능이 디폴트로 준비되어 있기 때문입니다. </p>
  <p> 즉,<code>CachedRowSet</code> 오브젝트는
 데이터 소스의 외부에서 캐쉬되는 미접속의 행이 됩니다. 사이즈가 작고, 직렬화 가능해서, 회선 경유로 간단하게 송신 가능할 뿐만 아니라, thin 클라이언트에의 데이터 송신에도 적합합니다. 다만, 메모리내에 동시에 포함할 수 있는 데이터량이 정해져 있기 때문에
<code>CachedRowSet</code> 오브젝트의 사이즈는 제한되고 있습니다. </p>
  
<h3>8.0 범용 데이터 액세스의 취득</h3>

  <code>CachedRowSet</code>클래스에는
 RDB 이외의 소스로부터 데이터를 취득해, 포함할 수 있다고 하는 이점이 있습니다. 행 세트의 리더를 구현하는 것으로써, 임의의 겉(표) 형식의 데이터 소스 (스프레드쉬트, 플랫 파일을 포함한다) 행 세트의 데이터를 읽어내, read 할 수 있습니다. <code>CachedRowSet</code>오브젝트와 그 메타데이타는
 모두 제로로부터 작성 가능해서, 행 세트의 팩토리로서 기능하는 컴퍼넌트는
 이 기능을 이용해, 비 SQL 데이터 소스로부터 데이터를 포함한 행 세트를 작성할 수 있습니다. 그러나, 대부분의 경우,<code>CachedRowSet</code>오브젝트는
 JDBC API를
 사용해 SQL 데이타베이스로부터 취득한 데이터를 포함합니다.
  
<h3>9.0 프로퍼티의 설정</h3>

모든 행 세트는
 프로퍼티세트를 가지고 있습니다. 이 세트는 보통
, 툴을 사용해 설정합니다. 행 세트의 프로퍼티의 수와 종류는
 행 세트의 기능과 데이터의 취득 방법에 따라서 다릅니다. 예를 들어,<code>ResultSet</code>오브젝트로부터 데이터를 얻는
 행 세트는
 데이타베이스 접속을 작성하기 위해서 필요한 프로퍼티를 설정할 필요가 있습니다. 행 세트가 <code>DriverManager</code>기능을 사용해 접속을 작성하는 경우는
 적절한 드라이버를 식별하는 JDBC URL
 프로퍼티와 유저명과 패스워드를 지정하는 프로퍼티를 설정할 필요가 있습니다. 한편, 행 세트가 <code>DataSource</code>오브젝트를 사용해 접속을 작성하는 경우 (이 방법이 추천 된다)는
 JDBC URL
 프로퍼티를 설정할 필요는 없습니다. 대신에
 데이터 소스의 논리명의 프로퍼티와 유저명 및 패스워드의 프로퍼티를 설정할 필요가 있습니다.
  <p> 주: <code>DataSource</code> 오브젝트를 사용해 접속을 작성하는 경우는
 Java Naming and Directory Interface<sup><font size="-2">TM</font></sup> (JNDI) API를
 사용하는 네임 서비스에
<code>DataSource</code> 오브젝트를 등록할 필요가 있습니다. 등록은 보통
, 시스템 관리 책임자가 실시합니다. </p>
  <p> 행 세트에 데이타베이스의 데이터를 읽어들이려면,
 커멘드 프로퍼티를 설정할 필요가 있습니다. 이 프로퍼티는
<code>PreparedStatement</code> 오브젝트를 나타내는 쿼리입니다. 이것에
해, 쿼리는
 설계시는 아니고 실행시로 설정되는 파라미터 플레이스홀더를 가질 수가 있습니다. 이러한 플레이스홀더 파라미터에 값을 설정하기 위해, 행 세트는
 각 데이터형의 값을 설정하는 설정 메서드를 제공합니다. 이러한 설정 메서드는
<code>PreparedStatement</code> 인터페이스에
해 제공되는 설정 메서드와 자주 닮았습니다. </p>
  <p> 다음의 코드의 발췌는
<code>CachedRowSet</code> 오브젝트 <code>crs</code> 에 커멘드 프로퍼티를 설정하는 방법을 나타내고 있습니다. 툴이 프로퍼티를 설정하는 경우, 이 코드를 사용합니다. </p>
 <pre>
 crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS" + 
                "WHERE CREDIT_LIMIT &gt; ?  AND REGION = ? ");</pre>

  <p> 커멘드의 플레이스홀더 파라미터의 설정에 사용되는 값은,<code>RowSet</code> 오브젝트의 <code>params</code> 필드에
<code>Vector</code> 오브젝트로서 포함됩니다. <code>CachedRowSet</code> 클래스는
<code>params</code> 필드내의 요소를 설정하는 설정 메서드세트를 제공합니다. 이하의 코드의 발췌에서는
 전의 예의 쿼리에 포함되는 2 개의 파라미터를 설정합니다. </p>
  
 <pre>
 crs.setInt(1, 5000);
 crs.setString(2, "West");</pre>

  <p> <code>params</code> 필드에 2 개의 요소가 추가되었습니다. 이것들은 각각, 요소 2 개 분의 길이의 배열이 됩니다. 최초의 요소는 파라미터 번호, 2 번째의 요소는 설정하는 값을 나타냅니다. 이 경우,<code>params</code>
 최초의 요소는 <code>1</code>,<code>5000</code>, 2 번째의 요소는 <code>2</code>,<code>"West"</code> 가 됩니다. 어플리케이션은,<code>execute</code> 메서드를 호출하는 것으로 이 <code>RowSet</code> 오브젝트의 리더를 호출합니다. 이것에
해, 그 <code>readData</code> 메서드가 불려 갑니다. 이 구현에 포함되는 <code>readData</code>는

<code>params</code> 내의 값을 취득해, 이것들을 사용해 커멘드의 플레이스홀더 파라미터를 설정합니다. 이하의 코드의 발췌에서는
<code>Connection</code> 오브젝트 <code>con</code>
 취득 후에
 리더가 플레이스홀더 파라미터를 설정하는 순서를 나타냅니다. </p>
  
 <pre>
 PreparedStatement pstmt = con.prepareStatement(crs.getCommand());
 reader.decodeParams();
 // decodeParams figures out which setter methods to use and does something 
 // like the following:
 //    for (i = 0; i &lt; params.length; i++) { 
 //        pstmt.setObject(i + 1, params[i]);
 //    }</pre>

  <p> 이 시점에서,<code>crs</code>
 커멘드는
 쿼리 <code>"SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS WHERE CREDIT_LIMIT &gt; 5000 AND REGION = "West"</code> 가 됩니다. <code>readData</code> 메서드는
 다음의 코드로 이 커멘드를 실행하는 것으로써,<code>crs</code> 에 읽히는 <code>rs</code>
 데이터를 취득합니다. </p>
  
 <pre>
 ResultSet rs = pstmt.executeQuery();</pre>

  <p> 전의 코드의 발췌에서는
 배후에서 행해지는 처리에 대해 설명했습니다. 이러한 코드는
 어플리케이션내에서는 비표시이며,<code>readData</code> 나 <code>decodeParams</code> 등의 메서드를 호출하지 않습니다. 이것에 대해서, 이하의 코드의 발췌는
 어플리케이션의 실행 내용을 나타내고 있습니다. 이 코드에서는
 행 세트의 커멘드를 설정해, 커멘드의 파라미터를 설정해, 커멘드를 실행합니다. <code>execute</code> 메서드를 호출하는 것만으로<code>crs</code> 에
 요구된 겉(표) <code>CUSTOMERS</code>
 데이터가 읽힙니다. </p>
  
 <pre>
 crs.setCommand("SELECT FIRST_NAME, LAST_NAME, ADDRESS FROM CUSTOMERS" + 
                "WHERE CREDIT_LIMIT &gt; ?  AND REGION = ? ");
 crs.setInt(1, 5000);
 crs.setString(2, "West");
 crs.execute();
 </pre>

  <h3>10.0 페이징 데이터</h3>

  <code>CachedRowSet</code>오브젝트는 데이터를 메모리에 포함하기 위해, 한 번에 포함할 수 있는 데이터의 양은 사용 가능한 메모리의 양에
해 정해집니다. 이 제한을 회피하기 위해,<code>CachedRowSet</code>오브젝트에서는
<code>ResultSet</code>오브젝트로부터 「페이지」라고 불리는 체크로 데이터를 취득할 수 있습니다. 이 도구
를 이용하려면,
 어플리케이션으로<code>setPageSize</code>메서드를 사용해, 페이지에 포함하는 행수를 설정합니다. 즉, 페이지 사이즈를 5 로 설정해 있는 경우, 데이터 소스로부터 한 번에 5 행의 데이터의 체크가 페치 됩니다. 또, 어플리케이션에서는
 옵션으로 한 번에 페치 할 수 있는 최대행수도 설정할 수 있습니다. 최대행수를 0 으로 설정했을 경우, 또는 최대행수를 설정하지 않는 경우, 한 번에 페치 가능한 행수의 제한은 없습니다. <p> 프로퍼티의 설정 후,<code>CachedRowSet</code> 오브젝트에
<code>populate</code> 또는 <code>execute</code> 메서드를 사용해, 데이터를 포함할 필요가 있습니다. 이하의 코드행에
<code>populate</code> 메서드를 사용한 예를 나타냅니다. 이 메서드에서는
<code>ResultSet</code> 핸들과 행의 취득을 개시하는 <code>ResultSet</code> 오브젝트내의 행의 2 개의 파라미터를 취합니다. </p>
  
 <pre>
 CachedRowSet crs = new CachedRowSetImpl();
 crs.setMaxRows(20);
 crs.setPageSize(4);
 crs.populate(rsHandle, 10);
 </pre>

이 코드를 실행하면,<i>crs</i>에 <i>rsHandle</i>의 10 행 째부터 시작되는 4 행 분이 포함됩니다.
<p> 다음의 코드의 발췌에 <code>execute</code> 메서드를 사용해,<code>CachedRowSet</code> 오브젝트에 포함하는 예를 나타냅니다. 이 메서드는 파라미터로서 <code>Connection</code> 오브젝트를 취하는 경우라고 취하지 않는 경우가 있습니다. 이 코드에서는 <code>execute</code> 에 <code>Connection</code> 오브젝트 <i>conHandle</i>를
 건네주고 있습니다. </p>
  <p> 다음의 코드의 발췌와 상기의 코드에는 2 개의 차이가 있습니다. 우선,<code>setMaxRows</code> 메서드를 호출하지 않기 때문에
<i>crs</i> 에 포함할 수 있는 최대행수에 제한이 없습니다 (<i>crs</i> 에는 항상, 메모리내에 포함할 수 있는 데이터량의 제한이 최우선으로 존재하는 것에 주의해 주세요). 2 점목의 차이는 <code>execute</code> 메서드에
 행의 취득을 개시하는 <code>ResultSet</code> 오브젝트내로부터의 행 번호를 건네줄 수 없는 것입니다. 이 메서드는 항상 선두행으로부터 개시합니다. </p>
  
 <pre>
 CachedRowSet crs = new CachedRowSetImpl();
 crs.setPageSize(5);
 crs.execute(conHandle);
 </pre>

이 코드를 실행하면,<i>crs</i>에 대한 커멘드에
해 생성된 <code>ResultSet</code>오브젝트로부터 5 행 분의 데이터가 <i>crs</i>에 포함됩니다.  <i>crs</i>의 라이터는 <i>conHandle</i>를 사용해 데이터 소스에 접속해,<i>crs</i>에 대해서 커멘드를 실행합니다. 이것에
해, 어플리케이션은, 다른 <code>CachedRowSet</code>오브젝트의 데이터의 조작과 같이 <i>crs</i>의 데이터를 조작할 수 있습니다.
  <p> 어플리케이션으로 다음의 페이지 (데이터의 체크)에 액세스 하려면,
<code>nextPage</code> 메서드를 호출합니다. 이 메서드는 새로운 <code>CachedRowSet</code> 오브젝트를 작성해, 거기에 다음의 페이지의 데이터를 포함합니다. 예를 들어,<code>CachedRowSet</code> 오브젝트의 커멘드가 1000 행 분의 데이터를 포함하는 <code>ResultSet</code> 오브젝트 <i>rs</i>를
 돌려주었다고 합니다. 페이지 사이즈가 100 으로 설정되어 있는 경우,<code>nextPage</code> 메서드의 최초의 호출로<i>rs</i>
 선두의 100 행을 포함하는 <code>CachedRowSet</code> 오브젝트가 작성됩니다. 이 선두의 100 행의 데이터의 처리가 끝나면, 어플리케이션은 다시 <code>nextPage</code> 메서드를 호출해,<i>rs</i> 로부터 다음의 100 행을 포함하는 다른 <code>CachedRowSet</code> 오브젝트를 작성할 수 있습니다. 최초의 <code>CachedRowSet</code> 오브젝트의 데이터는
 2번째의 <code>CachedRowSet</code> 오브젝트의 데이터로 옮겨지고 있기 때문에
 메모리내에 남아 있지 않습니다. <code>nextPage</code> 메서드의 10 번째의 호출에서는
 10 번째의 <code>CachedRowSet</code> 오브젝트에 <i>rs</i> 로부터의 마지막 100 행의 데이터가 포함되어 이것들이 메모리에 포함됩니다. 항상 메모리에는
 1 개의 <code>CachedRowSet</code> 오브젝트의 데이터만이 포함되게 됩니다. </p>
 <p> <code>nextPage</code> 메서드는
 현재의 페이지가 행의 마지막 페이지가 아닌 동안은 <code>true</code>를
 돌려주고, 그 이후의 페이지가 없어지면 <code>false</code>를
 돌려줍니다. 따라서, 다음의 코드행에 나타내도록(듯이),<code>while</code> 루프로 사용하면, 모든 페이지를 취득할 수 있습니다. </p>
  
 <pre>
 CachedRowSet crs = CachedRowSetImpl();
 crs.setPageSize(100);
 crs.execute(conHandle);<br><p>

 while(crs.next() { 
 .  .  .  // operate on first chunk of 100 rows in crs, row by row 
 }

 while(crs.nextPage()) { 
     while(crs.next()) { 
         .  .  .  // operate on the subsequent chunks (of 100 rows each) in crs,  
               // row by row 
     } 
 } </p></pre>

이 코드의 발췌를 실행하면, 어플리케이션은 1000 행을 모두 암벽 횡단 합니다만, 메모리에는 한 번에 100 행까지 밖에 포함되지 않습니다. <p> <code>CachedRowSet</code> 인터페이스는 <code>previousPage</code> 메서드도 정의하고 있습니다. <code>nextPage</code> 메서드가 <code>ResultSet</code>
 <code>next</code> 메서드에 유사하고 있는 것과 같이,<code>previousPage</code> 메서드는 <code>ResultSet</code>
 <code>previous</code> 메서드를 닮아 있습니다. <code>nextPage</code> 메서드와 같게,<code>previousPage</code>는
 페이지 사이즈로서 설정되었을 뿐의 행수를 포함하는 <code>CachedRowSet</code> 오브젝트를 작성합니다. 그 때문에
 예를 들어, 상기의 코드의 발췌의 마지막 <code>while</code> 루프내에서 <code>previousPage</code> 메서드를 사용해, 마지막 페이지로부터 선두의 페이지까지, 반대로 페이지를 이동할 수가 있습니다. <code>previousPage</code> 메서드는
<code>while</code> 루프로 사용할 수 있는 점으로써 <code>nextPage</code> 와도 닮았습니다. 다만, 전에 다른 페이지가 존재하는 동안 <code>true</code>를
 돌려주고, 그 이전의 페이지가 없어지면,<code>false</code>를
 돌려주는 점이 다릅니다. </p>
  <p> 다음의 코드의 발췌에 나타내도록(듯이),<code>previous</code> 메서드는 각 페이지의 마지막 행의 말미에 커서를 두는 것으로 각 페이지의 맨 마지막 줄로부터 선두행까지 이동합니다. 혹은, 각 페이지의 선두행의 전에 커서를 두어,<code>while</code> 루프로 <code>next</code> 메서드를 사용해, 각 페이지의 선두행으로부터 맨 마지막 줄까지 이동할 수도 있습니다. </p>
  <p> 다음의 코드의 발췌에서는
 상기의 코드의 발췌의 계속으로 10 개째의 <code>CachedRowSet</code> 오브젝트의 커서가 마지막 행에 있으면 가정하고 있습니다. 이 코드에서는 커서를 맨 마지막 줄의 뒤로 이동하고 있기 때문에
<code>previous</code> 메서드의 최초의 호출로 커서를 맨 마지막 줄에 되돌립니다. 마지막 페이지 (<code>CachedRowSet</code> 오브젝트 <i>crs</i>)의 모든 행을 이동하면, 코드는 <code>while</code> 루프에 들어가, 9 페이지눈으로 이동해, 역방향으로 행을 이동해, 8 페이지눈으로 이동해, 역방향으로 행을 이동해, 똑같이 해 선두 페이지의 선두행까지 나갑니다. </p>
<PRE>
     crs.afterLast();
     while(crs.previous())  {
         .  .  .  // navigate through the rows, last to first
     {
     while(crs.previousPage())  {
         crs.afterLast();
         while(crs.previous())  {
             .  .  .  // go from the last row to the first row of each page
         }
     }
 </PRE>
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#COMMIT_ON_ACCEPT_CHANGES">COMMIT_ON_ACCEPT_CHANGES</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>acceptChanges()</code>의 호출시에
<code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에
변경을 위탁시킵니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.sql.ResultSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.sql. <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/sql/ResultSet.html#CLOSE_CURSORS_AT_COMMIT">CLOSE_CURSORS_AT_COMMIT</A>,
 <A HREF="../../../java/sql/ResultSet.html#CONCUR_READ_ONLY">CONCUR_READ_ONLY</A>,
 <A HREF="../../../java/sql/ResultSet.html#CONCUR_UPDATABLE">CONCUR_UPDATABLE</A>,
 <A HREF="../../../java/sql/ResultSet.html#FETCH_FORWARD">FETCH_FORWARD</A>,
 <A HREF="../../../java/sql/ResultSet.html#FETCH_REVERSE">FETCH_REVERSE</A>,
 <A HREF="../../../java/sql/ResultSet.html#FETCH_UNKNOWN">FETCH_UNKNOWN</A>,
 <A HREF="../../../java/sql/ResultSet.html#HOLD_CURSORS_OVER_COMMIT">HOLD_CURSORS_OVER_COMMIT</A>,
 <A HREF="../../../java/sql/ResultSet.html#TYPE_FORWARD_ONLY">TYPE_FORWARD_ONLY</A>,
 <A HREF="../../../java/sql/ResultSet.html#TYPE_SCROLL_INSENSITIVE">TYPE_SCROLL_INSENSITIVE</A>,
 <A HREF="../../../java/sql/ResultSet.html#TYPE_SCROLL_SENSITIVE">TYPE_SCROLL_SENSITIVE</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges()">acceptChanges</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;행의 갱신을 송신해, 이 <code>CachedRowSet</code>오브젝트에의 변경을 부하의 데이터 소스에 삽입하거나 부하의 데이터
소스로부터 삭제하거나 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges(java.sql.Connection)">acceptChanges</A> </B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;con)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Connection</code>오브젝트를 사용해 데이터 소스에의 접속을 확립해, 모든 행의 갱신을 송신해, 이
  <code>CachedRowSet</code>오브젝트에 데이터 소스에의 변경을 삽입하거나 삭제하거나 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#columnUpdated(int)">columnUpdated</A> </B>(int&nbsp;idx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 현재의 은행내의 지정된 열이 갱신되었는지 어떠했는지를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#columnUpdated(java.lang.String)">columnUpdated</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;columnName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 현재의 은행내의 지정된 열이 갱신되었는지 어떠했는지를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#commit()">commit</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
<code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 생성자에게 건네지는 JDBC 프로퍼티가 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopy()">createCopy</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 데이터의 딥 카피인 <code>RowSet</code>오
브제크트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()">createCopyNoConstraints</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 딥 카피이지만, 독립하고 있는 <code>CachedRowSet</code>오
브제크트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 내의 인터페이스">CachedRowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()">createCopySchema</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 하늘의 카피인 <code>CachedRowSet</code>오
브제크트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/RowSet.html" title="javax.sql 내의 인터페이스">RowSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()">createShared</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트와 같은 데이터에
해, 백업 된 새로운 <code>RowSet</code>오
브제크트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)">execute</A> </B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;conn)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터 소스가 되는 결과 세트를 생성하기 위한 지정의 접속을 사용해, 이 <code>CachedRowSet</code>오브젝트에 데이터
를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getKeyColumns()">getKeyColumns</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 행을 일의에 식별하는 키를 구성하는 열을 나타내는 1
개이상의 열번호를 포함하는 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/sql/ResultSet.html" title="java.sql 내의 인터페이스">ResultSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginal()">getOriginal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 원의 값을 포함하는 <code>ResultSet</code>오브제
쿠트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/sql/ResultSet.html" title="java.sql 내의 인터페이스">ResultSet</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginalRow()">getOriginalRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 현재의 행만의 원의 값을 포함하는 <code>ResultSet</code>오
브제크트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getPageSize()">getPageSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>오브젝트의 페이지 사이즈를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 내의 클래스">RowSetWarning</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getRowSetWarnings()">getRowSetWarnings</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>RowSet</code>오브젝트에 관한 호출에
해 보고되는 최초의 경고를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getShowDeleted()">getShowDeleted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 행 세트내의 삭제행을 표시할지 어떨지를 나타내는 <code>boolean</code>를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 내의 클래스">SyncProvider</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getSyncProvider()">getSyncProvider</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>구현을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getTableName()">getTableName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 작성에 사용된 오브젝트 (테이블)
의 식별자를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#nextPage()">nextPage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>의 현재의 페이지를 증분 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)">populate</A> </B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트에
 지정된 <code>ResultSet</code>오브젝트
의 데이터를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet, int)">populate</A> </B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;rs,
         int&nbsp;startRow)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 오브젝트로 지정된 <code>ResultSet</code>
오브젝트의 데이터를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#previousPage()">previousPage</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>의 현재의 페이지를 감 분 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#release()">release</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 현재의 컨텐츠를 해방해, 등록을 마친 모든 리스너에게 <code>rowSetChanged</code>이
겨이삭띠를 송신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#restoreOriginal()">restoreOriginal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트를 원의 값 (전회의 변경 세트의 전의 값)
에 되돌립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback()">rollback</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
 원의 <code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 거기에 건네받는 JDBC 프로퍼티가 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback(java.sql.Savepoint)">rollback</A> </B>(<A HREF="../../../java/sql/Savepoint.html" title="java.sql 안의 인터페이스">Savepoint</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
 원의 <code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 거기에 건네받는 JDBC 프로퍼티가 포함됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#rowSetPopulated(javax.sql.RowSetEvent, int)">rowSetPopulated</A> </B>(<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스">RowSetEvent</A> &nbsp;event,
                int&nbsp;numRows)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;등록이 끝난 리스너에게, 지정된 RowSetEvent 오브젝트내의 RowSet 오브젝트가 다수의 추가행을 읽어들인 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setKeyColumns(int[])">setKeyColumns</A> </B>(int[]&nbsp;keys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 <code>keyCols</code>필드에
 지정된 렬번
호의 배열 (이 <code>CachedRowSet</code>오브젝트내의 행을 일의에 식별하는 키를 구성한다)을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setMetaData(javax.sql.RowSetMetaData)">setMetaData</A> </B>(<A HREF="../../../javax/sql/RowSetMetaData.html" title="javax.sql 안의 인터페이스">RowSetMetaData</A> &nbsp;md)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>RowSetMetaData</code>오브젝트를 사용해,<code>CachedRowSet</code>오브
젝트의 메타데이타를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setOriginalRow()">setOriginalRow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 현재의 행을 원의 행으로서 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setPageSize(int)">setPageSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>CachedRowSet</code>오브젝트의 페이지 사이즈를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setShowDeleted(boolean)">setShowDeleted</A> </B>(boolean&nbsp;b)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>showDeleted</code>프로퍼티에
 지정된 <code>boolean</code>치를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setSyncProvider(java.lang.String)">setSyncProvider</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>오브젝트로 지정
한 오브젝트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setTableName(java.lang.String)">setTableName</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;tabName)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트의 파생원의 테이블의 식별자를, 지정의 테이블명으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#size()">size</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트내의 행수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()">toCollection</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트를, 이 <code>CachedRowSet</code>오브젝트
의 모든 데이터를 포함하는 <code>Collection</code>오브젝트로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)">toCollection</A> </B>(int&nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code>오브젝트내의 지정된 열을 <code>Collection</code>오브
젝트로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)">toCollection</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;column)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CachedRowSet</code> 오브젝트내의 지정된 열을 <code>Collection</code>
오브젝트로 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()">undoDelete</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 행의 삭제를 취소해, 리스너로 행이 변경된 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()">undoInsert</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 행이 삽입된 상태이면, 현재의 행을 삭제해, 리스너로 행이 변경된 것을 통지합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoUpdate()">undoUpdate</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;만약 행이 변경되고 있으면, 전회의 갱신 조작을 바탕으로 되돌립니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.sql.RowSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.sql. <A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/sql/RowSet.html#addRowSetListener(javax.sql.RowSetListener)">addRowSetListener</A>,
 <A HREF="../../../javax/sql/RowSet.html#clearParameters()">clearParameters</A>,
 <A HREF="../../../javax/sql/RowSet.html#execute()">execute</A>,
 <A HREF="../../../javax/sql/RowSet.html#getCommand()">getCommand</A>,
 <A HREF="../../../javax/sql/RowSet.html#getDataSourceName()">getDataSourceName</A>,
 <A HREF="../../../javax/sql/RowSet.html#getEscapeProcessing()">getEscapeProcessing</A>,
 <A HREF="../../../javax/sql/RowSet.html#getMaxFieldSize()">getMaxFieldSize</A>,
 <A HREF="../../../javax/sql/RowSet.html#getMaxRows()">getMaxRows</A>,
 <A HREF="../../../javax/sql/RowSet.html#getPassword()">getPassword</A>,
 <A HREF="../../../javax/sql/RowSet.html#getQueryTimeout()">getQueryTimeout</A>,
 <A HREF="../../../javax/sql/RowSet.html#getTransactionIsolation()">getTransactionIsolation</A>,
 <A HREF="../../../javax/sql/RowSet.html#getTypeMap()">getTypeMap</A>,
 <A HREF="../../../javax/sql/RowSet.html#getUrl()">getUrl</A>,
 <A HREF="../../../javax/sql/RowSet.html#getUsername()">getUsername</A>,
 <A HREF="../../../javax/sql/RowSet.html#isReadOnly()">isReadOnly</A>,
 <A HREF="../../../javax/sql/RowSet.html#removeRowSetListener(javax.sql.RowSetListener)">removeRowSetListener</A>,
 <A HREF="../../../javax/sql/RowSet.html#setArray(int, java.sql.Array)">setArray</A>,
 <A HREF="../../../javax/sql/RowSet.html#setAsciiStream(int, java.io.InputStream, int)">setAsciiStream</A>,
 <A HREF="../../../javax/sql/RowSet.html#setBigDecimal(int, java.math.BigDecimal)">setBigDecimal</A>,
 <A HREF="../../../javax/sql/RowSet.html#setBinaryStream(int, java.io.InputStream, int)">setBinaryStream</A>,
 <A HREF="../../../javax/sql/RowSet.html#setBlob(int, java.sql.Blob)">setBlob</A>,
 <A HREF="../../../javax/sql/RowSet.html#setBoolean(int, boolean)">setBoolean</A>,
 <A HREF="../../../javax/sql/RowSet.html#setByte(int, byte)">setByte</A>,
 <A HREF="../../../javax/sql/RowSet.html#setBytes(int, byte[])">setBytes</A>,
 <A HREF="../../../javax/sql/RowSet.html#setCharacterStream(int, java.io.Reader, int)">setCharacterStream</A>,
 <A HREF="../../../javax/sql/RowSet.html#setClob(int, java.sql.Clob)">setClob</A>,
 <A HREF="../../../javax/sql/RowSet.html#setCommand(java.lang.String)">setCommand</A>,
 <A HREF="../../../javax/sql/RowSet.html#setConcurrency(int)">setConcurrency</A>,
 <A HREF="../../../javax/sql/RowSet.html#setDataSourceName(java.lang.String)">setDataSourceName</A>,
 <A HREF="../../../javax/sql/RowSet.html#setDate(int, java.sql.Date)">setDate</A>,
 <A HREF="../../../javax/sql/RowSet.html#setDate(int, java.sql.Date, java.util.Calendar)">setDate</A>,
 <A HREF="../../../javax/sql/RowSet.html#setDouble(int, double)">setDouble</A>,
 <A HREF="../../../javax/sql/RowSet.html#setEscapeProcessing(boolean)">setEscapeProcessing</A>,
 <A HREF="../../../javax/sql/RowSet.html#setFloat(int, float)">setFloat</A>,
 <A HREF="../../../javax/sql/RowSet.html#setInt(int, int)">setInt</A>,
 <A HREF="../../../javax/sql/RowSet.html#setLong(int, long)">setLong</A>,
 <A HREF="../../../javax/sql/RowSet.html#setMaxFieldSize(int)">setMaxFieldSize</A>,
 <A HREF="../../../javax/sql/RowSet.html#setMaxRows(int)">setMaxRows</A>,
 <A HREF="../../../javax/sql/RowSet.html#setNull(int, int)">setNull</A>,
 <A HREF="../../../javax/sql/RowSet.html#setNull(int, int, java.lang.String)">setNull</A>,
 <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object)">setObject</A>,
 <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object, int)">setObject</A>,
 <A HREF="../../../javax/sql/RowSet.html#setObject(int, java.lang.Object, int, int)">setObject</A>,
 <A HREF="../../../javax/sql/RowSet.html#setPassword(java.lang.String)">setPassword</A>,
 <A HREF="../../../javax/sql/RowSet.html#setQueryTimeout(int)">setQueryTimeout</A>,
 <A HREF="../../../javax/sql/RowSet.html#setReadOnly(boolean)">setReadOnly</A>,
 <A HREF="../../../javax/sql/RowSet.html#setRef(int, java.sql.Ref)">setRef</A>,
 <A HREF="../../../javax/sql/RowSet.html#setShort(int, short)">setShort</A>,
 <A HREF="../../../javax/sql/RowSet.html#setString(int, java.lang.String)">setString</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTime(int, java.sql.Time)">setTime</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTime(int, java.sql.Time, java.util.Calendar)">setTime</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTimestamp(int, java.sql.Timestamp)">setTimestamp</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTimestamp(int, java.sql.Timestamp, java.util.Calendar)">setTimestamp</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTransactionIsolation(int)">setTransactionIsolation</A>,
 <A HREF="../../../javax/sql/RowSet.html#setType(int)">setType</A>,
 <A HREF="../../../javax/sql/RowSet.html#setTypeMap(java.util.Map)">setTypeMap</A>,
 <A HREF="../../../javax/sql/RowSet.html#setUrl(java.lang.String)">setUrl</A>,
 <A HREF="../../../javax/sql/RowSet.html#setUsername(java.lang.String)">setUsername</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.sql.ResultSet"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.sql. <A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/sql/ResultSet.html#absolute(int)">absolute</A>,
 <A HREF="../../../java/sql/ResultSet.html#afterLast()">afterLast</A>,
 <A HREF="../../../java/sql/ResultSet.html#beforeFirst()">beforeFirst</A>,
 <A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()">cancelRowUpdates</A>,
 <A HREF="../../../java/sql/ResultSet.html#clearWarnings()">clearWarnings</A>,
 <A HREF="../../../java/sql/ResultSet.html#close()">close</A>,
 <A HREF="../../../java/sql/ResultSet.html#deleteRow()">deleteRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#findColumn(java.lang.String)">findColumn</A>,
 <A HREF="../../../java/sql/ResultSet.html#first()">first</A>,
 <A HREF="../../../java/sql/ResultSet.html#getArray(int)">getArray</A>,
 <A HREF="../../../java/sql/ResultSet.html#getArray(java.lang.String)">getArray</A>,
 <A HREF="../../../java/sql/ResultSet.html#getAsciiStream(int)">getAsciiStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getAsciiStream(java.lang.String)">getAsciiStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(int)">getBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(int, int)">getBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(java.lang.String)">getBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBigDecimal(java.lang.String, int)">getBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBinaryStream(int)">getBinaryStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBinaryStream(java.lang.String)">getBinaryStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBlob(int)">getBlob</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBlob(java.lang.String)">getBlob</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBoolean(int)">getBoolean</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBoolean(java.lang.String)">getBoolean</A>,
 <A HREF="../../../java/sql/ResultSet.html#getByte(int)">getByte</A>,
 <A HREF="../../../java/sql/ResultSet.html#getByte(java.lang.String)">getByte</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBytes(int)">getBytes</A>,
 <A HREF="../../../java/sql/ResultSet.html#getBytes(java.lang.String)">getBytes</A>,
 <A HREF="../../../java/sql/ResultSet.html#getCharacterStream(int)">getCharacterStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getCharacterStream(java.lang.String)">getCharacterStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getClob(int)">getClob</A>,
 <A HREF="../../../java/sql/ResultSet.html#getClob(java.lang.String)">getClob</A>,
 <A HREF="../../../java/sql/ResultSet.html#getConcurrency()">getConcurrency</A>,
 <A HREF="../../../java/sql/ResultSet.html#getCursorName()">getCursorName</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDate(int)">getDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDate(int, java.util.Calendar)">getDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDate(java.lang.String)">getDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDate(java.lang.String, java.util.Calendar)">getDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDouble(int)">getDouble</A>,
 <A HREF="../../../java/sql/ResultSet.html#getDouble(java.lang.String)">getDouble</A>,
 <A HREF="../../../java/sql/ResultSet.html#getFetchDirection()">getFetchDirection</A>,
 <A HREF="../../../java/sql/ResultSet.html#getFetchSize()">getFetchSize</A>,
 <A HREF="../../../java/sql/ResultSet.html#getFloat(int)">getFloat</A>,
 <A HREF="../../../java/sql/ResultSet.html#getFloat(java.lang.String)">getFloat</A>,
 <A HREF="../../../java/sql/ResultSet.html#getInt(int)">getInt</A>,
 <A HREF="../../../java/sql/ResultSet.html#getInt(java.lang.String)">getInt</A>,
 <A HREF="../../../java/sql/ResultSet.html#getLong(int)">getLong</A>,
 <A HREF="../../../java/sql/ResultSet.html#getLong(java.lang.String)">getLong</A>,
 <A HREF="../../../java/sql/ResultSet.html#getMetaData()">getMetaData</A>,
 <A HREF="../../../java/sql/ResultSet.html#getObject(int)">getObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#getObject(int, java.util.Map)">getObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#getObject(java.lang.String)">getObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#getObject(java.lang.String, java.util.Map)">getObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#getRef(int)">getRef</A>,
 <A HREF="../../../java/sql/ResultSet.html#getRef(java.lang.String)">getRef</A>,
 <A HREF="../../../java/sql/ResultSet.html#getRow()">getRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#getShort(int)">getShort</A>,
 <A HREF="../../../java/sql/ResultSet.html#getShort(java.lang.String)">getShort</A>,
 <A HREF="../../../java/sql/ResultSet.html#getStatement()">getStatement</A>,
 <A HREF="../../../java/sql/ResultSet.html#getString(int)">getString</A>,
 <A HREF="../../../java/sql/ResultSet.html#getString(java.lang.String)">getString</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTime(int)">getTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTime(int, java.util.Calendar)">getTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTime(java.lang.String)">getTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTime(java.lang.String, java.util.Calendar)">getTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTimestamp(int)">getTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTimestamp(int, java.util.Calendar)">getTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTimestamp(java.lang.String)">getTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#getTimestamp(java.lang.String, java.util.Calendar)">getTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#getType()">getType</A>,
 <A HREF="../../../java/sql/ResultSet.html#getUnicodeStream(int)">getUnicodeStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getUnicodeStream(java.lang.String)">getUnicodeStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#getURL(int)">getURL</A>,
 <A HREF="../../../java/sql/ResultSet.html#getURL(java.lang.String)">getURL</A>,
 <A HREF="../../../java/sql/ResultSet.html#getWarnings()">getWarnings</A>,
 <A HREF="../../../java/sql/ResultSet.html#insertRow()">insertRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#isAfterLast()">isAfterLast</A>,
 <A HREF="../../../java/sql/ResultSet.html#isBeforeFirst()">isBeforeFirst</A>,
 <A HREF="../../../java/sql/ResultSet.html#isFirst()">isFirst</A>,
 <A HREF="../../../java/sql/ResultSet.html#isLast()">isLast</A>,
 <A HREF="../../../java/sql/ResultSet.html#last()">last</A>,
 <A HREF="../../../java/sql/ResultSet.html#moveToCurrentRow()">moveToCurrentRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#moveToInsertRow()">moveToInsertRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#next()">next</A>,
 <A HREF="../../../java/sql/ResultSet.html#previous()">previous</A>,
 <A HREF="../../../java/sql/ResultSet.html#refreshRow()">refreshRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#relative(int)">relative</A>,
 <A HREF="../../../java/sql/ResultSet.html#rowDeleted()">rowDeleted</A>,
 <A HREF="../../../java/sql/ResultSet.html#rowInserted()">rowInserted</A>,
 <A HREF="../../../java/sql/ResultSet.html#rowUpdated()">rowUpdated</A>,
 <A HREF="../../../java/sql/ResultSet.html#setFetchDirection(int)">setFetchDirection</A>,
 <A HREF="../../../java/sql/ResultSet.html#setFetchSize(int)">setFetchSize</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateArray(int, java.sql.Array)">updateArray</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateArray(java.lang.String, java.sql.Array)">updateArray</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(int, java.io.InputStream, int)">updateAsciiStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateAsciiStream(java.lang.String, java.io.InputStream, int)">updateAsciiStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBigDecimal(int, java.math.BigDecimal)">updateBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBigDecimal(java.lang.String, java.math.BigDecimal)">updateBigDecimal</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(int, java.io.InputStream, int)">updateBinaryStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBinaryStream(java.lang.String, java.io.InputStream, int)">updateBinaryStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBlob(int, java.sql.Blob)">updateBlob</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBlob(java.lang.String, java.sql.Blob)">updateBlob</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBoolean(int, boolean)">updateBoolean</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBoolean(java.lang.String, boolean)">updateBoolean</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateByte(int, byte)">updateByte</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateByte(java.lang.String, byte)">updateByte</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBytes(int, byte[])">updateBytes</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateBytes(java.lang.String, byte[])">updateBytes</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(int, java.io.Reader, int)">updateCharacterStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateCharacterStream(java.lang.String, java.io.Reader, int)">updateCharacterStream</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateClob(int, java.sql.Clob)">updateClob</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateClob(java.lang.String, java.sql.Clob)">updateClob</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateDate(int, java.sql.Date)">updateDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateDate(java.lang.String, java.sql.Date)">updateDate</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateDouble(int, double)">updateDouble</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateDouble(java.lang.String, double)">updateDouble</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateFloat(int, float)">updateFloat</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateFloat(java.lang.String, float)">updateFloat</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateInt(int, int)">updateInt</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateInt(java.lang.String, int)">updateInt</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateLong(int, long)">updateLong</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateLong(java.lang.String, long)">updateLong</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateNull(int)">updateNull</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateNull(java.lang.String)">updateNull</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateObject(int, java.lang.Object)">updateObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateObject(int, java.lang.Object, int)">updateObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateObject(java.lang.String, java.lang.Object)">updateObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateObject(java.lang.String, java.lang.Object, int)">updateObject</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateRef(int, java.sql.Ref)">updateRef</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateRef(java.lang.String, java.sql.Ref)">updateRef</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateRow()">updateRow</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateShort(int, short)">updateShort</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateShort(java.lang.String, short)">updateShort</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateString(int, java.lang.String)">updateString</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateString(java.lang.String, java.lang.String)">updateString</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateTime(int, java.sql.Time)">updateTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateTime(java.lang.String, java.sql.Time)">updateTime</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateTimestamp(int, java.sql.Timestamp)">updateTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#updateTimestamp(java.lang.String, java.sql.Timestamp)">updateTimestamp</A>,
 <A HREF="../../../java/sql/ResultSet.html#wasNull()">wasNull</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.sql.rowset.Joinable"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 javax.sql.rowset. <A HREF="../../../javax/sql/rowset/Joinable.html" title="javax.sql.rowset 안의 인터페이스">Joinable</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnIndexes()">getMatchColumnIndexes</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnNames()">getMatchColumnNames</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int)">setMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int[])">setMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String)">setMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String[])">setMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(int)">unsetMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(int[])">unsetMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(java.lang.String)">unsetMatchColumn</A>,
 <A HREF="../../../javax/sql/rowset/Joinable.html#unsetMatchColumn(java.lang.String[])">unsetMatchColumn</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="COMMIT_ON_ACCEPT_CHANGES"><!-- --></A> <H3>
COMMIT_ON_ACCEPT_CHANGES</H3>
<PRE>
static final boolean <B>COMMIT_ON_ACCEPT_CHANGES</B></PRE>
<DL>
<DD><code>acceptChanges()</code>의 호출시에
<code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에
변경을 위탁시킵니다. false 로 설정되어 있는 경우, 변경 내용은,<code>CachedRowSet</code>인타페스트란자크
숀 메서드가 불려 갈 때까지<b>위탁되지 않습니다</b>.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#commit()"><CODE>commit()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#rollback()"><CODE>rollback()</CODE></A>,
 
<A HREF="../../../constant-values.html#javax.sql.rowset.CachedRowSet.COMMIT_ON_ACCEPT_CHANGES">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="populate(java.sql.ResultSet)"><!-- --></A> <H3>
populate</H3>
<PRE>
void <B>populate</B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;data)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트에
 지정된 <code>ResultSet</code>오브젝트
의 데이터를 읽어들입니다.
  <p> 이 메서드는
 어플리케이션이 오픈 <code>ResultSet</code> 오브젝트에 접속하고 있을 때 <code>execute</code>
메서드의 대체로서 사용할 수 있습니다. 새로운 접속을 열어 이 <code>CachedRowSet</code>
오브젝트의 커멘드를 재실행할 필요가 없는 점으로써,<code>populate</code> 메서드는
 파라미터를 취하지 않는 <code>execute</code>
메서드보다 효율적입니다. 또,<code>populate</code> 메서드를 사용하는 것은,<code>ResultSet</code>
오브젝트를 취하는 <code>execute</code> 메서드보다 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 이 <code>CachedRowSet</code>
오브젝트에 읽히는 데이터를 포함한 <code>ResultSet</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - null
의 <code>ResultSet</code> 오브젝트가 제공되었을 경우, 또는 이 <code>CachedRowSet</code>
오브젝트가 관련된 <code>ResultSetMetaData</code> 오브젝트를 취득할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)"><CODE>execute(java.sql.Connection)</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스"><CODE>ResultSet</CODE></A>,
 
<A HREF="../../../java/sql/ResultSetMetaData.html" title="java.sql 안의 인터페이스"><CODE>ResultSetMetaData</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.sql.Connection)"><!-- --></A> <H3>
execute</H3>
<PRE>
void <B>execute</B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;conn)
             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>데이터 소스가 되는 결과 세트를 생성하기 위한 지정의 접속을 사용해, 이 <code>CachedRowSet</code>오브젝트에 데이터
를 읽어들입니다. 이 메서드는
 작성하는 모든 데이타베이스 접속을 클로우즈 하는 것으로 데이터 소스로부터 데이터를 읽어내고 있을 때와 데이터 소스에
데이터를 기입하고 있을 때 이외, 이 <code>CachedRowSet</code>오브젝트가 미접속 상태인 것을 보증합니다.
  <p> 이 <code>CachedRowSet</code>
오브젝트의 리더는
 행 세트의 커멘드를 실행해, 결과적으로 생성되는 <code>ResultSet</code> 오브젝트로부터 이
  <code>CachedRowSet</code> 오브젝트에 데이터를 읽어들이기 위해서,<i>conn</i>
를 사용해 데이터 소스에의 접속을 확립합니다. 또, 이 메서드는
 이 <code>CachedRowSet</code>
오브젝트의 생성 후에
 <i>conn</i>를
 닫습니다. </p>
  <p> 구현의 생성 후에 이 메서드를 호출하면, 컨텐츠와 메타데이타가 리셋트 됩니다. 또,<code>acceptChanges</code>
메서드를 호출해, 아직 적용하고 있지 않는 갱신을 확정한 뒤, 이 메서드를 호출하면, 갱신 내용은 없어집니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>conn</CODE> - 유효한 프로
파티를 가지는 표준 JDBC <code>Connection</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 무
효과인 <code>Connection</code> 오브젝트가 제공되었을 경우, 또는 데이터 소스와의 접속의 확립시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)"><CODE>populate(java.sql.ResultSet)</CODE></A>,
 
<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스"><CODE>Connection</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptChanges()"><!-- --></A> <H3>
acceptChanges</H3>
<PRE>
void <B>acceptChanges</B>()
                   throws <A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 내의 클래스">SyncProviderException</A> </PRE>
<DL>
<DD>행의 갱신을 송신해, 이 <code>CachedRowSet</code>오브젝트에의 변경을 부하의 데이터 소스에 삽입하거나 부하의 데이터
소스로부터 삭제하거나 합니다.
  <p> 이 메서드는
 이 <code>CachedRowSet</code>
오브젝트의 라이터상에서 불려 가 배후에서 처리를 실시합니다. 표준 <code>CachedRowSet</code> 구현은,<code>SyncFactory</code>
싱글 톤을 사용해 <code>SyncProvider</code> 인스턴스를 얻는
 것으로써,<code>RowSetWriter</code>
오브젝트 (라이터)를 제공합니다. 라이터는
 이 <code>CachedRowSet</code>
오브젝트에의 변경을 데이터 소스에 반송하려고 합니다. </p>
  <p> <code>acceptChanges</code>
메서드가 정상적으로 실행되었을 경우, 데이터 소스에 변경이 기입해져 현재의 행의 값이 원의 행의 값으로 변경됩니다. </p>
  <p> 사용하는 <code>SyncProvider</code>
구현의 동기 레벨에
해, 라이터는 원의 값과 데이터 소스내의 값을 비교해, 경합의 체크를 실시합니다. 경합이 검출되었을 경우, 예를 들어 <code>RIOptimisticProvider</code>
구현은,<code>SyncProviderException</code>를
 Throw 해, 데이터 소스에는 아무것도 기입하지 않습니다. </p>
  <p> 어플리케이션은,<code>SyncProviderException</code>
오브젝트를 캐치 해, 이 오브젝트에 포함되는 <code>SyncResolver</code>
오브젝트를 취득할 수가 있습니다. <code>SyncResolver</code>
오브젝트는
 행 마다 경합을 일람 해, 현재 존재하는 경합을 해결할 때까지 새로운 경합이 발생하지 않게, 데이터 소스를 잠급니다. 게다가 개개의 경합
에 대해서, 경합을 검사해, 데이터 소스에 남기는 값을 설정하는 메서드를 제공합니다. 모든 경합이 해결되면, 어플리케이션은 재차 <code>acceptChanges</code>
메서드를 호출해, 해결된 값을 데이터 소스에 기입할 필요가 있습니다. 데이터 소스내의 모든 값이 벌써 지속치인 경우,<code>acceptChanges</code>
메서드는 아무것도 실시하지 않습니다. </p>
  <p> 일부의 프로바이더 구현은, 경합을 막기 위해서 락을 사용합니다. 이 경우,<code>acceptChanges</code>
메서드를 호출했을 때, 라이터에
한 데이터 소스에의 변경의 기입은 반드시 성공합니다. 이 메서드는
<code>updateRow</code>
메서드,<code>insertRow</code> 메서드, 또는 <code>deleteRow</code>
메서드의 호출 후 즉시 호출할 수 있습니다만, 모든 변경이 완료해, 1 개만 접속을 확립하면 좋은 상태로 호출하는 편이 효율적입니다. </p>
  <p> 주: <code>acceptChanges()</code> 메서드는
<code>COMMIT_ON_ACCEPT_CHANGES</code>
하지만 true 로 설정되어 있는지 어떤지를 확인합니다. true
(으)로 설정되어 있는 경우, 동기내의 모든 갱신이 데이터 소스에 위탁됩니다. 그 외의 경우, 어플리케이션은,<code>commit()</code>
메서드나 <code>rollback()</code> 메서드를 명시적으로 호출할<b>필요가 있습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 카
솔이 삽입행에 있는 경우
<DD><CODE><A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </CODE> - 배
아래의 동기 프로바이더의 라이터가, 데이터 소스에의 갱신의 기입해에 실패했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges(java.sql.Connection)"><CODE>acceptChanges(java.sql.Connection)</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncFactory</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProviderException</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스"><CODE>SyncResolver</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="acceptChanges(java.sql.Connection)"><!-- --></A> <H3>
acceptChanges</H3>
<PRE>
void <B>acceptChanges</B>(<A HREF="../../../java/sql/Connection.html" title="java.sql 안의 인터페이스">Connection</A> &nbsp;con)
                   throws <A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 내의 클래스">SyncProviderException</A> </PRE>
<DL>
<DD>지정된 <code>Connection</code>오브젝트를 사용해 데이터 소스에의 접속을 확립해, 모든 행의 갱신을 송신해, 이
  <code>CachedRowSet</code>오브젝트에 데이터 소스에의 변경을 삽입하거나 삭제하거나 합니다.
  <p> 이제(벌써) 한편의 <code>acceptChanges</code> 메서드는 <code>RowSet</code>
오브젝트내에 벌써 정의되고 있는 <code>Connection</code> 오브젝트 (초기 생성시에 사용되는 접속)
를 사용하므로 접속을 건네받지 않습니다. </p>
  <p> 이 형식의 <code>acceptChanges</code>
메서드는
 인수를 취하지 않는 형식과 자주 닮습니다만, 부하의 데이터 소스가 JDBC
데이터 소스인 경우 밖에 사용할 수 없는 점으로써, 그 외의 형식과는 다릅니다. <code>SyncProvider</code>는

<code>CachedRowSet</code>
오브젝트가 정상적으로 동기 되도록, 갱신된 <code>Connection</code> 프로퍼티를 사용해 <code>RowSetWriter</code>
구성을 리셋트 할 필요가 있습니다. </p>
  <p> <code>acceptChanges</code>
메서드가 정상적으로 실행되었을 경우, 데이터 소스에 변경이 기입해져 현재의 행의 값이 원의 행의 값으로 변경됩니다. </p>
  <p> 사용하는 <code>SyncProvider</code>
구현의 동기 레벨에
해, 라이터는 원의 값과 데이터 소스내의 값을 비교해, 경합의 체크를 실시합니다. 경합이 검출되었을 경우, 예를 들어 <code>RIOptimisticProvider</code>
구현은,<code>SyncProviderException</code>를
 Throw 해, 데이터 소스에는 아무것도 기입하지 않습니다. </p>
  <p> 어플리케이션은,<code>SyncProviderException</code>
오브젝트를 캐치 해, 이 오브젝트에 포함되는 <code>SyncResolver</code>
오브젝트를 취득할 수가 있습니다. <code>SyncResolver</code>
오브젝트는
 행 마다 경합을 일람 해, 현재 존재하는 경합을 해결할 때까지 새로운 경합이 발생하지 않게, 데이터 소스를 잠급니다. 게다가 개개의 경합
에 대해서, 경합을 검사해, 데이터 소스에 남기는 값을 설정하는 메서드를 제공합니다. 모든 경합이 해결되면, 어플리케이션은 재차 <code>acceptChanges</code>
메서드를 호출해, 해결된 값을 데이터 소스에 기입할 필요가 있습니다. 데이터 소스내의 모든 값이 벌써 지속치인 경우,<code>acceptChanges</code>
메서드는 아무것도 실시하지 않습니다. </p>
  <p> 일부의 프로바이더 구현은, 경합을 막기 위해서 락을 사용합니다. 이 경우,<code>acceptChanges</code>
메서드를 호출했을 때, 라이터에
한 데이터 소스에의 변경의 기입은 반드시 성공합니다. 이 메서드는
<code>updateRow</code>
메서드,<code>insertRow</code> 메서드, 또는 <code>deleteRow</code>
메서드의 호출 후 즉시 호출할 수 있습니다만, 모든 변경이 완료해, 1 개만 접속을 확립하면 좋은 상태로 호출하는 편이 효율적입니다. </p>
  <p> 주: <code>acceptChanges()</code> 메서드는
<code>COMMIT_ON_ACCEPT_CHANGES</code>
하지만 true 로 설정되어 있는지 어떤지를 판단합니다. true
(으)로 설정되어 있는 경우, 동기내의 모든 갱신이 데이터 소스에 위탁됩니다. false
 경우, 어플리케이션은,<code>commit</code>
메서드나 <code>rollback</code> 메서드를 명시적으로 호출할<b>필요가 있습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>con</CODE> - 표준
JDBC <code>Connection</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 카
솔이 삽입행에 있는 경우
<DD><CODE><A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스">SyncProviderException</A> </CODE> - 배
아래의 동기 프로바이더의 라이터가, 데이터 소스에의 갱신의 기입해에 실패했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#acceptChanges()"><CODE>acceptChanges()</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncFactory.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncFactory</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncProviderException.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProviderException</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncResolver.html" title="javax.sql.rowset.spi 안의 인터페이스"><CODE>SyncResolver</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="restoreOriginal()"><!-- --></A> <H3>
restoreOriginal</H3>
<PRE>
void <B>restoreOriginal</B>()
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트를 원의 값 (전회의 변경 세트의 전의 값)
에 되돌립니다. 행 세트가 변경되어 있지 않은 경우나, 변경 세트가 1 개 밖에 없는 경우는
 이 <code>CachedRowSet</code>오브
젝트에 읽힌 값이 원의 값이 됩니다. 그 외의 경우는
 현재의 값의 직전으로 설정되어 있던 값이 원의 값이 됩니다.
  <p> 이 메서드가 불려 갔을 경우,<code>CachedRowSet</code>
구현은, 현재의 행 세트 인스턴스에의 모든 갱신, 삽입 및 삭제를 이전의 값으로 옮겨놓을 필요가 있습니다. 게다가 커서를 최초의 행에 되돌려,<code>rowSetChanged</code>
이벤트를 트리거해, 등록을 마친 모든 리스너에게 통지를 보낼 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 와
의 <code>CachedRowSet</code> 오브젝트의 현재의 값을 이전의 값에 되돌리고 있는 동안에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)"><CODE>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="release()"><!-- --></A> <H3>
release</H3>
<PRE>
void <B>release</B>()
             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 현재의 컨텐츠를 해방해, 등록을 마친 모든 리스너에게 <code>rowSetChanged</code>이
겨이삭띠를 송신합니다. 이 메서드를 호출하면, 아직 적용되지 않은 갱신은 모두 파기되어 행 세트의 행이 모두 삭제됩니다. 부하의 데이터 소스와의
대화는 행해지지 않기 때문에
 행 세트의 컨텐츠, 메타데이타, 컨텐츠의 갱신을 복원할 수 없습니다.
  <p> 이 <code>CachedRowSet</code>
오브젝트는
 컨텐츠와 그 갱신이 완전하게 소거될 때까지 락 됩니다. 따라서, 이 <code>RowSet</code>
오브젝트에의 참조를 포함하는 그 외의 컴퍼넌트에
한 더티 독해는 발생하지 않습니다. 또, 이 <code>CachedRowSet</code>
오브젝트를 읽어내는 모든 컴퍼넌트가 독해를 완료할 때까지, 컨텐츠를 해방할 수 없습니다. 이 <code>CachedRowSet</code>
오브젝트의 동작은,<code>rowSetChanged</code> 이벤트가 트리거된 뒤, 정상적인 상태에 돌아옵니다. </p>
  <p> JDBC 프로퍼티와 Synchronization SPI 프로퍼티를 포함한 메타데이타는
 장래 사용하기 위해서 보관 유지됩니다. <code>command</code>
프로퍼티등의 프로퍼티는
 이 <code>CachedRowSet</code>
오브젝트의 생성원의 데이터 소스에 관련지을 필요가 있습니다. </p>
  <p> <code>close</code> 메서드는
 모든 행 세트를 복원 가능으로 해, 가비지 컬렉터에 행 세트의 Java VM
자원을 허가합니다만, 이 메서드는
 행 세트를 비웁니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 와
의 <code>CachedRowSet</code> 오브젝트의 컨텐츠의 플래시시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetListener.html#rowSetChanged(javax.sql.RowSetEvent)"><CODE>RowSetListener.rowSetChanged(javax.sql.RowSetEvent)</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html#close()"><CODE>ResultSet.close()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoDelete()"><!-- --></A> <H3>
undoDelete</H3>
<PRE>
void <B>undoDelete</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>현재의 행의 삭제를 취소해, 리스너로 행이 변경된 것을 통지합니다. 이 메서드를 호출한 뒤, 현재의 행은 삭제의 대상으로부터 제외됩니다. 이 메
솟드는
 행 세트의 수명의 사이 언제라도 호출할 수가 있습니다.
  <p> 게다가 복수의 행의 삭제를 취소할 수도 있습니다. 이 경우는
 다음과 같은 커서 위치 제어 메서드를 사용해, 커서의 위치를 조정합니다. </p>
  <ul>
    <li><code>CachedRowSet.absolute</code> </li>

    <li><code>CachedRowSet.first</code> </li>

    <li><code>CachedRowSet.last</code> </li>

  
</ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - (1)
현재의 행이 삭제되어 있지 않은 경우, (2) 커서가 삽입행, 최초의 행의 전, 또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()"><CODE>undoInsert()</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoInsert()"><!-- --></A> <H3>
undoInsert</H3>
<PRE>
void <B>undoInsert</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>만약 행이 삽입된 상태이면, 현재의 행을 삭제해, 리스너로 행이 변경된 것을 통지합니다. 이 메서드는
 행 세트의 수명의 사이 언제라도 불러 출
. 현재의 행이 예외 제한 (아래와 같이 참조) 내에 있는 경우, 현재의 행의 삽입을 취소합니다.
  <p> 게다가 복수의 행의 삽입을 취소할 수도 있습니다. 이 경우는
 다음과 같은 커서 위치 제어 메서드를 사용해, 커서의 위치를 조정합니다. </p>
  <ul>
    <li><code>CachedRowSet.absolute</code> </li>

    <li><code>CachedRowSet.first</code> </li>

    <li><code>CachedRowSet.last</code> </li>

  
</ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - (1)
현재의 행이 삽입되어 있지 않은 경우, (2) 커서가 최초의 행의 전, 맨 마지막 줄의 뒤, 또는 삽입행에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()"><CODE>undoDelete()</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="undoUpdate()"><!-- --></A> <H3>
undoUpdate</H3>
<PRE>
void <B>undoUpdate</B>()
                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>만약 행이 변경되고 있으면, 전회의 갱신 조작을 바탕으로 되돌립니다. 이 메서드는
 최종적으로 은행내의 모든 갱신이 전회의 동기화 (<code>acceptChanges</code>)
또는 생성의 직전 상태에 돌아오도록(듯이), 모든 열의 갱신을 바탕으로 되돌립니다. 이 메서드는
 삽입행의 갱신중에도 호출할 수가 있습니다.
  <p> <code>undoUpdate</code></p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 커서가, 이 <code>CachedRowSet</code> 오브젝트의 최초의 행의 전 또는 마지막 행의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoDelete()"><CODE>undoDelete()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#undoInsert()"><CODE>undoInsert()</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html#cancelRowUpdates()"><CODE>ResultSet.cancelRowUpdates()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnUpdated(int)"><!-- --></A> <H3>
columnUpdated</H3>
<PRE>
boolean <B>columnUpdated</B>(int&nbsp;idx)
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 현재의 은행내의 지정된 열이 갱신되었는지 어떠했는지를 나타냅니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>idx</CODE> - 갱신의 체
쿠를 실시하는 열을 나타내는 <code>int</code>
<DT><B>반환값:</B><DD>지정된 열이 아키라등
게갱신되고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 카
솔이 삽입행, 최초의 행의 전, 또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/DatabaseMetaData.html#updatesAreDetected(int)"><CODE>DatabaseMetaData.updatesAreDetected(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="columnUpdated(java.lang.String)"><!-- --></A> <H3>
columnUpdated</H3>
<PRE>
boolean <B>columnUpdated</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;columnName)
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 현재의 은행내의 지정된 열이 갱신되었는지 어떠했는지를 나타냅니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>columnName</CODE> - 갱
신의 체크를 실시하는 열의 이름을 지정하는 <code>String</code> 오브젝트
<DT><B>반환값:</B><DD>열이 분명하게 갱신함
라고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 카
솔이 삽입행, 최초의 행의 전, 또는 맨 마지막 줄의 뒤에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/DatabaseMetaData.html#updatesAreDetected(int)"><CODE>DatabaseMetaData.updatesAreDetected(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection()"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>()
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트를, 이 <code>CachedRowSet</code>오브젝트
의 모든 데이터를 포함하는 <code>Collection</code>오브젝트로 변환합니다. <code>Collection</code>후
레임워크의 추상성에
해, 구현은, 이 <code>Collection</code>오브젝트를 어느 정도 자유롭게 표현할 수가 있습니다. 각
행은 범용적인 <code>Collection</code>구현인가, 또는 <code>TreeMap</code>오브젝트나 <code>Vector</code>오
브제크트등이 특수한 <code>Collection</code>구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>열
값은 Java 프로그램 언어로 <code>null</code>로서 표현할 필요가 있습니다.
  <p> <code>CachedRowSet</code> 인터페이스의 표준적인 레퍼런스 구현에서는
 행 세트에 <code>TreeMap</code>
오브젝트를 사용해, 각 행의 값을 <code>Vector</code>
오브젝트에 포함합니다. 대부분의 구현으로와 같이  처리하는 것이 상정됩니다. </p>
  <p> <code>TreeMap</code>
형태의 컬렉션에
해, 키의 클래스의 본래의 순서에 따라, 맵이 승순으로 소트 됩니다. 각 키는
<code>RowSet</code>
오브젝트의 1 행에 대응하는 <code>Vector</code> 오브젝트를 참조합니다. 따라서, 각 <code>Vector</code>
오브젝트의 사이즈는
<code>RowSet</code> 오브젝트내의 렬수에 정확하게 일치할 필요가 있습니다. <code>TreeMap</code>
컬렉션으로 사용하는 키는
 구현 마다 결정합니다. 구현에서는
<code>RowSet</code> 오브젝트 자체, 또는 부하의 SQL
데이터에 벌써 설정되어 있는 키에
해, 내부의 <code>RowSet</code>
겉(표) 구조내의 사용 가능한 세트 키를 이용할 수가 있습니다. </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 각 행의 값을 포함하는 <code>Collection</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 코
레크션의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)"><CODE>toCollection(int)</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)"><CODE>toCollection(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection(int)"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>(int&nbsp;column)
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트내의 지정된 열을 <code>Collection</code>오브
젝트로 변환합니다. <code>Collection</code>체제의 추상성에
해, 구현은, 이 <code>Collection</code>오
브제크트를 어느 정도 자유롭게 표현할 수가 있습니다. 각 렬치는 범용적인 <code>Collection</code>구현인가, 또는 <code>Vector</code>오
브제크트등이 특수한 <code>Collection</code>구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>열
값은 Java 프로그램 언어로 <code>null</code>로서 표현할 필요가 있습니다.
  <p> 표준적인 레퍼런스 구현에서는
<code>Vector</code>
오브젝트를 사용해, 렬치를 포함합니다만, 대부분의 구현으로와 같이  처리하는 것이 상정됩니다. <code>Vector</code>
오브젝트를 사용하는 경우는
 사이즈를 이 <code>CachedRowSet</code>
오브젝트의 행수와 정확하게 일치시킬 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 치를
  <code>Collection</code> 오브젝트로 표현하는 열을 나타내는 <code>int</code>
<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 지정된 열에 포함된 값을 포함한 <code>Collection</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 코
레크션의 생성시에 에러가 발생했을 경우, 또는 무효인 열 ID 가 제공되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()"><CODE>toCollection()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(java.lang.String)"><CODE>toCollection(String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toCollection(java.lang.String)"><!-- --></A> <H3>
toCollection</H3>
<PRE>
<A HREF="../../../java/util/Collection.html" title="java.util 안의 인터페이스">Collection</A> &lt;? &gt; <B>toCollection</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;column)
                           throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><p>이 <code>CachedRowSet</code> 오브젝트내의 지정된 열을 <code>Collection</code>
오브젝트로 변환합니다. <code>Collection</code> 체제의 추상성에
해, 구현은, 이 <code>Collection</code>
오브젝트를 어느 정도 자유롭게 표현할 수가 있습니다. 각 렬치는 범용적인 <code>Collection</code> 구현인가, 또는 <code>Vector</code>
오브젝트등이 특수한 <code>Collection</code> 구현의 어느 쪽인지로 완전하게 표현할 필요가 있습니다. SQL <code>NULL</code>
렬치는 Java 프로그램 언어로 <code>null</code> 로서 표현할 필요가 있습니다. </p>
  <p> 표준적인 레퍼런스 구현에서는
<code>Vector</code>
오브젝트를 사용해, 렬치를 포함합니다만, 대부분의 구현으로와 같이  처리하는 것이 상정됩니다. <code>Vector</code>
오브젝트를 사용하는 경우는
 사이즈를 이 <code>CachedRowSet</code>
오브젝트의 행수와 정확하게 일치시킬 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>column</CODE> - 코레크
숀으로 표현되는 값을 가지는 열의 이름을 지정하는 <code>String</code> 오브젝트
<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 지정된 열에 포함된 값을 포함한 <code>Collection</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 코
레크션의 생성시에 에러가 발생했을 경우, 또는 무효인 열 ID 가 제공되었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection()"><CODE>toCollection()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#toCollection(int)"><CODE>toCollection(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSyncProvider()"><!-- --></A> <H3>
getSyncProvider</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스">SyncProvider</A>  <B>getSyncProvider</B>()
                             throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>구현을 취득합니다.
행 세트는
 이 메서드를 내부에서 사용해, 행 세트와 데이터 소스간의 읽어내 또는 기입해 조작을 트리거합니다. 예를 들어, 행 세트는
 데이터를 격
납 하기 위한,<code>SyncProvider</code>로부터 행 세트 리더 (<code>RowSetReader</code>오브제크
트)의 핸들을 취득해야 하는 경우가 있습니다.
  
 <pre>
     RowSetReader rowsetReader = null;<br>     SyncProvider provider = <br>         SyncFactory.getInstance("javax.sql.rowset.provider.RIOptimisticProvider");<br>         if (provider instanceof RIOptimisticProvider) {<br>             rowsetReader = provider.getRowSetReader();<br>         }<br> </pre>

  <i>rowsetReader</i>가 행 세트 구현내의 private 인 액세스 가능 필드이다고 하면, 어플리케이션이 <code>execute</code>메
솟드를 호출하면, 이 메서드는 리더의 <code>readData</code>메서드를 호출해,<code>RowSet</code>오
브제크트에 데이터를 포함합니다.
  
 <pre>
     rowsetReader.readData((RowSetInternal) this);</pre>
  <p> 게다가 어플리케이션은 이 메서드로부터 돌려주고지는 <code>SyncProvider</code>
오브젝트를 사용해, 벤더, 버젼, 프로바이더 ID, 동기의 그레이드, 현재 설정되어 있는 락등의 <code>SyncProvider</code>
오브젝트에 관한 정보를 돌려주는 메서드를 호출할 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 세트가 인스타
스화 되었을 때에 설정된 <code>SyncProvider</code>
오브젝트, 또는 설정되어 있지 않은 경우는 디폴트의 프로바이더
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>SyncProvider</code>
오브젝트를 돌려줄 때 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setSyncProvider(java.lang.String)"><CODE>setSyncProvider(java.lang.String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSyncProvider(java.lang.String)"><!-- --></A> <H3>
setSyncProvider</H3>
<PRE>
void <B>setSyncProvider</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;provider)
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>오브젝트로 지정
한 오브젝트를 설정합니다. 이 메서드로<code>SyncProvider</code>오브젝트를 리셋트 할 수 있습니다.
  <p> <code>CachedRowSet</code> 구현은 항상 이용 가능한 <code>SyncProvider</code>
도구
로 인스턴스화할 필요가 있습니다만,<code>SyncProvider</code>
오브젝트의 리셋트가 바람직한, 또는 필요하게 되는 경우도 있습니다. 예를 들어, 어플리케이션으로 당분간은 디폴트의 <code>SyncProvider</code>
오브젝트를 사용해 두어, 나중에 최근 이용할 수 있게 된, 보다 필요하게 이루어지는 프로바이더를 선택해 사용할 수가 있습니다. </p>
  <p> <code>SyncProvider</code> 오브젝트를 리셋트 하면,<code>RowSet</code>
오브젝트는 <code>SyncFactory</code> 로부터 새로운 <code>SyncProvider</code>
구현을 요구합니다. 이것에
해, 이전의 모든 접속과 원의 데이터 소스와의 관계를 리셋트 해, 미접속의 행 세트의 동기 동작을 큰폭으로 변경일??
.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>provider</CODE> - <code>SyncProvider</code>
구현의 완전 수식 클래스명을 지정하는 <code>String</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>SyncProvider</code>
구현의 리셋트중에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getSyncProvider()"><CODE>getSyncProvider()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="size()"><!-- --></A> <H3>
size</H3>
<PRE>
int <B>size</B>()</PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트내의 행수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 세트내의 행수</DL>
</DD>
</DL>
<HR>

<A NAME="setMetaData(javax.sql.RowSetMetaData)"><!-- --></A> <H3>
setMetaData</H3>
<PRE>
void <B>setMetaData</B>(<A HREF="../../../javax/sql/RowSetMetaData.html" title="javax.sql 안의 인터페이스">RowSetMetaData</A> &nbsp;md)
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>지정된 <code>RowSetMetaData</code>오브젝트를 사용해,<code>CachedRowSet</code>오브
젝트의 메타데이타를 설정합니다. <code>RowSetReader</code>오브젝트는
 행 세트의 컨텐츠를 읽어낼 때에
<code>RowSetMetaData</code>오
브제크트를 생성해,<code>RowSetMetaData</code>구현내의 메서드를 사용해 이것을 초기화합니다. 레퍼런스 구현에서는 <code>RowSetMetaDataImpl</code>쿠
라스를 사용합니다. 리더가 행 세트의 컨텐츠의 독해를 완료하면, 이 메서드가 내부에서 불려 가<code>RowSetMetaData</code>오
브제크트가 행 세트에게 건네집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>md</CODE> - 이 <code>CachedRowSet</code>
오브젝트의 열에 관한 메타데이타를 포함하는 <code>RowSetMetaData</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행
세트에 무효인 메타데이타가 제공되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginal()"><!-- --></A> <H3>
getOriginal</H3>
<PRE>
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  <B>getOriginal</B>()
                      throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 원의 값을 포함하는 <code>ResultSet</code>오브제
쿠트를 돌려줍니다.
  <p> <code>ResultSet</code> 오브젝트의 커서는
 선두행의 전에 둘 필요가 있습니다. 게다가 돌려주고지는 <code>ResultSet</code>
오브젝트는 다음의 프로퍼티를 가질 필요가 있습니다. </p>
  <ul>
    <li>ResultSet.TYPE_SCROLL_INSENSITIVE</li>

    <li>ResultSet.CONCUR_UPDATABLE</li>

  
</ul>

  <p> <code>RowSet</code>
오브젝트의 원의 값은, 부하의 데이터 소스와 마지막 동기의 앞에 포함되고 있던 값입니다. 동기가 없었던 경우, 원의 값은,<code>RowSet</code>
오브젝트에 포함된 값이 됩니다. 이 메서드는
 어플리케이션이 <code>acceptChanges</code>
메서드를 호출해,<code>SyncProvider</code>
오브젝트가 경합을 확인하도록 구현되고 있는 경우에
 내부에서 불려 갑니다. 이 경우, 라이터는 원의 값과 데이터 소스내의 현재의 값을 비교해, 경합
를 확인합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 원의 값을 포함하는 <code>ResultSet</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>ResultSet</code>
오브젝트의 생성시에 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOriginalRow()"><!-- --></A> <H3>
getOriginalRow</H3>
<PRE>
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A>  <B>getOriginalRow</B>()
                         throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 현재의 행만의 원의 값을 포함하는 <code>ResultSet</code>오
브제크트를 돌려줍니다.
  <p> <code>ResultSet</code> 오브젝트의 커서는
 선두행의 전에 둘 필요가 있습니다. 게다가 돌려주고지는 <code>ResultSet</code>
오브젝트는 다음의 프로퍼티를 가질 필요가 있습니다. </p>
  <ul>
    <li>ResultSet.TYPE_SCROLL_INSENSITIVE</li>

    <li>ResultSet.CONCUR_UPDATABLE </li>

  
</ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 원의 결과 세트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 현재행이 존재하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setOriginalRow()"><CODE>setOriginalRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setOriginalRow()"><!-- --></A> <H3>
setOriginalRow</H3>
<PRE>
void <B>setOriginalRow</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 현재의 행을 원의 행으로서 설정합니다.
  <p>
이 메서드는
 현재의 행의 변경된 값이 데이터 소스와 동기 된 뒤에
 내부에서 불려 갑니다. 현재의 행은, 삽입, 삭제, 또는 갱신으로서 태그 붙이고 해
(이)라고 있어서는 안됩니다. </p>
  <p> <code>setOriginalRow</code>
 호출은 취소할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 현재행이 존재하지 않는 경우, 또는 원의 행의 컨텐츠의 리셋트시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getOriginalRow()"><CODE>getOriginalRow()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTableName()"><!-- --></A> <H3>
getTableName</H3>
<PRE>
<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A>  <B>getTableName</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 작성에 사용된 오브젝트 (테이블)
의 식별자를 돌려줍니다. 이 이름은, 반복 설정할 수 있습니다. 이름의 설정 회수나, 표준 구현이 이전의 테이블명을 추적할 필요가 있을지 어떨지에 대해서는
 사양에
밤제한은 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 데이터의 소스인 테이블명을 지정하는 <code>String</code>
오브젝트, 또는 테이블의 이름을 설정하고 있지 않는 경우는 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 테이블명을 돌려줄 때 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/ResultSetMetaData.html#getTableName(int)"><CODE>ResultSetMetaData.getTableName(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTableName(java.lang.String)"><!-- --></A> <H3>
setTableName</H3>
<PRE>
void <B>setTableName</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;tabName)
                  throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 파생원의 테이블의 식별자를, 지정의 테이블명으로 설정합니다. 라이터는
 동
기시에
 이 이름을 사용해, 데이터 소스의 값과 <code>CachedRowSet</code>오브젝트의 값을 비교할 때에 사용하는 테이
불을 판단합니다. 테이블의 식별자는
 이 <code>CachedRowSet</code>오브젝트로부터 변경된 값을 기입하는 장소도 가리켜
.
  <p> 이 <code>CachedRowSet</code> 오브젝트의 구현에서는
 내부적으로 <code>RowSetMetaDataImpl</code>
오브젝트에 이름을 취득시킬 수가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tabName</CODE> - 이
  <code>CachedRowSet</code> 오브젝트가 파생한 테이블을 식별하는 <code>String</code>
오브젝트. <code>null</code>는
 불가, 하늘의 캐릭터 라인은 가능
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 테이
불의 이름부로 에러가 발생했을 경우, 또는 <i>tabName</i> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetMetaData.html#setTableName(int, java.lang.String)"><CODE>RowSetMetaData.setTableName(int, java.lang.String)</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스"><CODE>RowSetWriter</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/spi/SyncProvider.html" title="javax.sql.rowset.spi 안의 클래스"><CODE>SyncProvider</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeyColumns()"><!-- --></A> <H3>
getKeyColumns</H3>
<PRE>
int[] <B>getKeyColumns</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 행을 일의에 식별하는 키를 구성하는 열을 나타내는 1
개이상의 열번호를 포함하는 배열을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트의 행의 주키를 구성하는 열을 나타내는 열번호를 포함하는 배열. 주키를 표현하는 열이 없는 경우, 이 배열은 비운다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 와
의 <code>CachedRowSet</code> 오브젝트가 하늘의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setKeyColumns(int[])"><CODE>setKeyColumns(int[])</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnIndexes()"><CODE>Joinable.getMatchColumnIndexes()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/Joinable.html#getMatchColumnNames()"><CODE>Joinable.getMatchColumnNames()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeyColumns(int[])"><!-- --></A> <H3>
setKeyColumns</H3>
<PRE>
void <B>setKeyColumns</B>(int[]&nbsp;keys)
                   throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 <code>keyCols</code>필드에
 지정된 렬번
호의 배열 (이 <code>CachedRowSet</code>오브젝트내의 행을 일의에 식별하는 키를 구성한다)을 설정합니다.
  <p><code>CachedRowSet</code> 오브젝트가 <code>JoinRowSet</code>
오브젝트에 포함되는 경우, 키열로서 지정된 열이 일치열이 되면, 이 메서드로 정의된 키와 생성된 제약은 보관 유지됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>keys</CODE> - 이 <code>CachedRowSet</code>
오브젝트의 주키를 구성하는 열을 나타내는 <code>int</code> 배열. 배열내의 각 요소는
<code>0</code>
보다 크고, 한편 이 행 세트내의 렬수이하일 필요가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 지정된 배열내의 번호가 이 행 세트로 유효하지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getKeyColumns()"><CODE>getKeyColumns()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(java.lang.String)"><CODE>Joinable.setMatchColumn(String)</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/Joinable.html#setMatchColumn(int)"><CODE>Joinable.setMatchColumn(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createShared()"><!-- --></A> <H3>
createShared</H3>
<PRE>
<A HREF="../../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A>  <B>createShared</B>()
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트와 같은 데이터에
해, 백업 된 새로운 <code>RowSet</code>오
브제크트를 돌려줍니다. 실제로 양쪽 모두의 <code>CachedRowSet</code>오브젝트는 같은 데이터상에 커서를 가집니다. 그 결
과, 원의 오브젝트에
한 변경이, 그 모든 중복에 가시인 것과 같게, 중복에
한 모든 변경이, 원의 오브젝트와 그 외의 모든 중복에 가능
시가 됩니다. 중복으로 부하의 데이터를 변경하는 메서드를 호출하면, 그 메서드는
 원의 <code>CachedRowSet</code>오브
젝트에
해 불려 가는 경우와 완전히 똑같이, 등록된 모든 리스너에게 통지합니다.
  <p> 게다가 이 메서드에
해 작성되는 <code>RowSet</code> 오브젝트는 이 <code>CachedRowSet</code>
오브젝트와 같은 프로퍼티를 가집니다. 예를 들어, 이 <code>CachedRowSet</code>
오브젝트가 읽어내 전용의 경우, 그 모든 중복도 읽어내 전용이 됩니다. 이것을 갱신 가능하게 변경하면, 중복도 갱신 가능하게 됩니다. </p>
  <p> 주: 복수의 thread가 <code>createShared()</code> 메서드에
해 작성된 <code>RowSet</code>
오브젝트에 액세스 하는 경우, 공유 데이터의 정합성을 확보하기 위해, 다음의 동작이 지정됩니다. 모든 공유된 <code>RowSet</code>
오브젝트의 독해와 기입은, 각 오브젝트와 부하의 단일의 겉(표) 구조간에 순서대로 행해질 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>CachedRowSet</code>
오브젝트와 같은 프로퍼티를 가져, 같은 데이터상의 커서를 가지는 새로운 공유 <code>RowSet</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 에러가 발생했을 경우, 또는 부하의 플랫폼에서 복제가 서포트되어 있지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 내의 클래스"><CODE>RowSetEvent</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopy()"><!-- --></A> <H3>
createCopy</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopy</B>()
                        throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 데이터의 딥 카피인 <code>RowSet</code>오
브제크트를 작성합니다. <code>createShared</code>호출에
해 생성된 <code>RowSet</code>오
브제크트의 경우와는 달라, 원의 <code>RowSet</code>오브젝트의 카피의 갱신이, 원의 <code>RowSet</code>오
브제크트에 가시여 되지 않습니다. 또, 원의 <code>RowSet</code>에 등록된 이벤트 리스너의 스코프에
 새로운 <code>RowSet</code>코
피가 포함되어 있어 되지 않습니다. 또, 확립 끝난 제약 제한은 보관 유지되지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 <code>RowSet</code>
오브젝트. <code>CachedRowSet</code> 오브젝트의 딥 카피이며, 이 <code>CachedRowSet</code>
(으)로부터는 완전하게 독립하고 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 오브젝트의 카피의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()"><CODE>createCopyNoConstraints()</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopySchema()"><!-- --></A> <H3>
createCopySchema</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopySchema</B>()
                              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 하늘의 카피인 <code>CachedRowSet</code>오
브제크트를 작성합니다. 카피에는
 아무것도 포함하지 않고, 원의 <code>CachedRowSet</code>오브젝트의 겉(표) 구조만을 표현할 필요
(이)가 있습니다. 게다가 원의 <code>CachedRowSet</code>오브젝트로 설정된 주키 또는 외부 키의 제약을, 새로운 하늘의
  <code>CachedRowSet</code>오브젝트에도 동일하게 적용할 필요가 있습니다. <code>createShared</code>메
솟드 호출에
해 생성된 <code>RowSet</code>오브젝트와는 달라,<code>createCopySchema</code>메
솟드에
한 이 <code>CachedRowSet</code>오브젝트의 카피에의 갱신은 가시으로서는 되지 않습니다.
  <p> 어플리케이션은, 이 메서드에
해 돌려주고진 <code>CachedRowSet</code> 오브젝트로부터 <code>WebRowSet</code>
오브젝트를 형성해, 나중에 사용하기 위해서,<code>RowSet</code> schema 정의를 XML 에 export 할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 <code>CachedRowSet</code> 오브젝트의 구조의 복제시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopyNoConstraints()"><CODE>createCopyNoConstraints()</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCopyNoConstraints()"><!-- --></A> <H3>
createCopyNoConstraints</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/CachedRowSet.html" title="javax.sql.rowset 안의 인터페이스">CachedRowSet</A>  <B>createCopyNoConstraints</B>()
                                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>CachedRowSet</code>오브젝트의 딥 카피이지만, 독립하고 있는 <code>CachedRowSet</code>오
브제크트를 작성합니다. <code>createShared</code>메서드 호출에
해 생성된 <code>RowSet</code>오
브제크트의 경우와는 달라, 이 <code>CachedRowSet</code>오브젝트의 카피에 대해서 행해진 변경은 가시여
선. 게다가 이 <code>CachedRowSet</code>오브젝트에
해 등록된 모든 이벤트 리스너의 스코프에 신
해 있고 <code>RowSet</code>오브젝트가 포함되어 있어 되지 않습니다. 또, 이 <code>CachedRowSet</code>오
브제크트에 대해서 확립된 제약 제한은 카피에 유지<b>되고 있어 되지 않습니다</b>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>새로운 <code>CachedRowSet</code>
오브젝트. <code>CachedRowSet</code> 오브젝트의 딥 카피이며, 이 <code>CachedRowSet</code>
오브젝트로부터는 완전하게 독립하고 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>CachedRowSet</code>
오브젝트의 카피의 생성시에 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopy()"><CODE>createCopy()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createShared()"><CODE>createShared()</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#createCopySchema()"><CODE>createCopySchema()</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스"><CODE>RowSetEvent</CODE></A>,
 
<A HREF="../../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스"><CODE>RowSetListener</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRowSetWarnings()"><!-- --></A> <H3>
getRowSetWarnings</H3>
<PRE>
<A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 안의 클래스">RowSetWarning</A>  <B>getRowSetWarnings</B>()
                                throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>이 <code>RowSet</code>오브젝트에 관한 호출에
해 보고되는 최초의 경고를 돌려줍니다. 후속의 <code>RowSet</code>오
브제크트의 경고는
 이 메서드가 돌려주는 <code>RowSetWarning</code>오브젝트에 체인 됩니다.
  <p>경고 체인은, 새로운 행이 읽힐 때마다 자동적으로 클리어 됩니다. 이 메서드는 클로우즈 된 RowSet
오브젝트의 호출에는 사용하지 않습니다. 사용하면 <code>SQLException</code> 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>RowSetWarning.
보고된 최초의 <code>RowSetWarning</code> 오브젝트. 없는 경우는 null
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이 메서드가, 닫혀진 RowSet 상에서 불려 갔을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/RowSetWarning.html" title="javax.sql.rowset 내의 클래스"><CODE>RowSetWarning</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShowDeleted()"><!-- --></A> <H3>
getShowDeleted</H3>
<PRE>
boolean <B>getShowDeleted</B>()
                       throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>현재의 행 세트내의 삭제행을 표시할지 어떨지를 나타내는 <code>boolean</code>를 취득합니다. <code>true</code>가 반
되었을 경우, 삭제행은 현재의 행과 함께 표시됩니다. <code>false</code>가 돌려주고졌을 경우, 삭제행은 현재의 행세트내에 표시키
응. 디폴트치는 <code>false</code>입니다.
  <p>
표준행 세트 구현은, 보안상의 배려 또는 특정의 배치 시나리오에 적합시키기 때문에
 이 동작을 제한할 수가 있습니다. 이것은, 정의 끝난 구현으로서
남겨져 표준의 동작을 나타내지 않습니다. </p>
  <p> 주: 삭제된 행을 표시하면, 일부의 표준 JDBC <code>RowSet</code>
구현 메서드의 동작이 복잡하게 됩니다. 그러나, 삭제된 행을 표시하는 기능은, 매우 전문적인 어플리케이션으로 밖에 사용되지 않습니다. 따라서, 와
어느 행 세트 유저는
 이 설정을 무시해 괜찮습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>삭제된 행을 표시
하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행 세트 구현이, 삭제행이 표시될지 어떨지를 판단할 수  없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#setShowDeleted(boolean)"><CODE>setShowDeleted(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setShowDeleted(boolean)"><!-- --></A> <H3>
setShowDeleted</H3>
<PRE>
void <B>setShowDeleted</B>(boolean&nbsp;b)
                    throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>showDeleted</code>프로퍼티에
 지정된 <code>boolean</code>치를 설정합니다. 이것에
, 삭제행을 현재의 행 세트내에 표시할지 어떨지가 결정됩니다. 값이 <code>true</code>의 경우, 삭제된 행이 현재의 행 세트와라고도
에 표시됩니다. 값이 <code>false</code>의 경우, 삭제된 행은 현재의 행 세트내에 표시되지 않습니다.
  <p>
표준행 세트 구현은, 보안상의 배려 또는 특정의 배치 시나리오에 적합시키기 때문에
 이 동작을 제한할 수가 있습니다. 이것은, 정의 끝난 구현으로서
남겨져 표준의 동작을 나타내지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>b</CODE> - 삭제된 행을 겉(표)
시 하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 행 세트 구현이, 삭제행의 표시 또는 비표시의 설정을 리셋트 할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#getShowDeleted()"><CODE>getShowDeleted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="commit()"><!-- --></A> <H3>
commit</H3>
<PRE>
void <B>commit</B>()
            throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
<code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 생성자에게 건네지는 JDBC 프로퍼티가 포함됩니다. 이 메서드는
<code>Connection</code>코
미트 메서드를 랩 해, 유연한 자동 위탁 또는 비자동 위탁의 트랜잭션(transaction) 제어 서포트를 제공합니다.
  <p>전회의 위탁/롤백(rollback)의 뒤,<code>acceptChanges()</code>
메서드에
해 행해진 모든 변경을 영속적인 것으로 합니다. 이 메서드는
 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이타베이스 액세스 에러가 발생했을 경우, 또는 이 <code>CachedRowSet</code> 내의 Connection 오브젝트가 자동 위탁 모드인 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/sql/Connection.html#setAutoCommit(boolean)"><CODE>Connection.setAutoCommit(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="rollback()"><!-- --></A> <H3>
rollback</H3>
<PRE>
void <B>rollback</B>()
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
 원의 <code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 거기에 건네받는 JDBC 프로퍼티가 포함됩니다.
  <p>현재의 트랜잭션(transaction)에서의 모든 변경을 취소합니다. 이 메서드는 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이
타베이스아크세스에라가 발생했을 경우, 또는 이 <code>CachedRowSet</code> 내의 Connection
오브젝트가 자동 위탁 모드인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="rollback(java.sql.Savepoint)"><!-- --></A> <H3>
rollback</H3>
<PRE>
void <B>rollback</B>(<A HREF="../../../java/sql/Savepoint.html" title="java.sql 안의 인터페이스">Savepoint</A> &nbsp;s)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>오브젝트의 <code>SyncProvider</code>에는
 원의 <code>ResultSet</code>의
  <code>Connection</code>오브젝트인가, 거기에 건네받는 JDBC 프로퍼티가 포함됩니다.
  <p>현재의 트랜잭션(transaction)에서의 모든 변경을 취소해, 마지막 <code>Savepoint</code>
트랜잭션(transaction) 마커에 되돌립니다. 이 메서드는 자동 위탁 모드가 무효가 되어 있을 때 밖에 사용할 수 없습니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - <code>Savepoint</code>
트랜잭션(transaction) 마커
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 데이
타베이스아크세스에라가 발생했을 경우, 또는 이 <code>CachedRowSet</code> 내의 Connection
오브젝트가 자동 위탁 모드인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="rowSetPopulated(javax.sql.RowSetEvent, int)"><!-- --></A> <H3>
rowSetPopulated</H3>
<PRE>
void <B>rowSetPopulated</B>(<A HREF="../../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스">RowSetEvent</A> &nbsp;event,
                     int&nbsp;numRows)
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD>등록이 끝난 리스너에게, 지정된 RowSetEvent 오브젝트내의 RowSet 오브젝트가 다수의 추가행을 읽어들인 것을 통지합니다. <code>numRows</code>파
라메이타에
해, 이 이벤트는
<code>numRow</code>마다 트리거됩니다.
  <p>이벤트의 소스는 event.getSource 메서드로 취득할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>event</CODE> - 이벤트
의 소스인 <code>RowSet</code> 오브젝트를 포함하는 <code>RowSetEvent</code>
오브젝트<DD><CODE>numRows</CODE> - 읽기
포함시의 행의 간격수. 여기서, 읽힌 <code>CachedRowSet</code> 가 트리거된다. 디폴트치는 제로. <code>fetchSize</code>
보다 작은 값과 제로보다 작은 값은 지정할 수 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE></DL>
</DD>
</DL>
<HR>

<A NAME="populate(java.sql.ResultSet, int)"><!-- --></A> <H3>
populate</H3>
<PRE>
void <B>populate</B>(<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스">ResultSet</A> &nbsp;rs,
              int&nbsp;startRow)
              throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><p>이 <code>CachedRowSet</code> 오브젝트로 지정된 <code>ResultSet</code>
오브젝트의 데이터를 읽어들입니다. <code>populate(ResultSet)</code>
메서드에 관련지을 수 있고 있는 경우, 추가 파라미터에
해, CashedRowSet 인스턴스의 read를 개시하는 <code>ResultSet</code>
안의 개시 위치를 지정할 수가 있습니다. </p>
  <p> 이 메서드는
 어플리케이션이 오픈하고 있는 <code>ResultSet</code> 오브젝트에 접속하고 있을 때
  <code>execute</code> 메서드의 대체로서 사용할 수 있습니다. 새로운 접속을 열어 이 <code>CachedRowSet</code>
오브젝트의 커멘드를 재실행할 필요가 없는 점으로써,<code>populate</code> 메서드는
 파라미터를 취하지 않는 <code>execute</code>
메서드보다 효율적입니다. 또,<code>populate</code> 메서드를 사용하는 것은,<code>ResultSet</code>
오브젝트를 취하는 <code>execute</code> 메서드보다 편리합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>startRow</CODE> - <DD><CODE>rs</CODE> - 이 <code>CachedRowSet</code>
오브젝트에 읽히는 데이터를 포함한 <code>ResultSet</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - null
 <code>ResultSet</code> 오브젝트가 제공되었을 경우, 또는 이 <code>CachedRowSet</code>
오브젝트가 관련된 <code>ResultSetMetaData</code> 오브젝트를 취득할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../javax/sql/rowset/CachedRowSet.html#execute(java.sql.Connection)"><CODE>execute(java.sql.Connection)</CODE></A>,
 
<A HREF="../../../javax/sql/rowset/CachedRowSet.html#populate(java.sql.ResultSet)"><CODE>populate(ResultSet)</CODE></A>,
 
<A HREF="../../../java/sql/ResultSet.html" title="java.sql 안의 인터페이스"><CODE>ResultSet</CODE></A>,
 
<A HREF="../../../java/sql/ResultSetMetaData.html" title="java.sql 안의 인터페이스"><CODE>ResultSetMetaData</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPageSize(int)"><!-- --></A> <H3>
setPageSize</H3>
<PRE>
void <B>setPageSize</B>(int&nbsp;size)
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>오브젝트의 페이지 사이즈를 설정합니다. <code>CachedRowSet</code>는

자신을 페이지 사이즈로 설정된 행수의 행에 읽어들이는 설정으로 할 수 있습니다. <code>populate()</code>또는 <code>execute()</code>가
불려 가면,<code>CachedRowSet</code>는
 RowSet
 read 사용한 원의 SQL
쿼리에 따라, 추가 페이지를 페치 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - <code>CachedRowSet</code>
의 페이지 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - <code>CachedRowSet</code>
페이지 사이즈의 설정시에 에러가 발생했을 경우, 또는 페이지 사이즈가 제로보다 작은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getPageSize()"><!-- --></A> <H3>
getPageSize</H3>
<PRE>
int <B>getPageSize</B>()</PRE>
<DL>
<DD><code>CachedRowSet</code>오브젝트의 페이지 사이즈를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>페이지 사이즈를 나타낸다
  <code>int</code></DL>
</DD>
</DL>
<HR>

<A NAME="nextPage()"><!-- --></A> <H3>
nextPage</H3>
<PRE>
boolean <B>nextPage</B>()
                 throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>의 현재의 페이지를 증분 합니다. 이것에
해,<code>CachedRowSet</code>열매
장은, 다음의 페이지 사이즈 분의행을 페치 해, RowSet 에 읽어들입니다. 다만, 이 때문에는
 그 외의 행이 RowSet
의 read에 사용된 원의 SQL 쿼리의 스코프내에 남아 있지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아직 페이지가 있는 장소
합은 true, 이것이 마지막 페이지인 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 다음
의 페이지의 페치시에 에러가 발생했을 경우, 또는 이 메서드가 populate 나 execute
 실행전에 너무 빨리 불려 갔을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="previousPage()"><!-- --></A> <H3>
previousPage</H3>
<PRE>
boolean <B>previousPage</B>()
                     throws <A HREF="../../../java/sql/SQLException.html" title="java.sql 내의 클래스">SQLException</A> </PRE>
<DL>
<DD><code>CachedRowSet</code>의 현재의 페이지를 감 분 합니다. 이것에
해,<code>CachedRowSet</code>열매
장은, 이전의 페이지 사이즈 분의행을 페치 해, RowSet 에 읽어들입니다. 이전의 페이지내가 돌려주고진 행의 양은, RowSet
의 read에 사용된 원의 SQL 쿼리의 스코프내에 남아 있을 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>전의 페이지가 정상적으로
취득되었을 경우는 true, 이것이 최초의 페이지인 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/sql/SQLException.html" title="java.sql 안의 클래스">SQLException</A> </CODE> - 이
전의 페이지의 페치시에 에러가 발생했을 경우, 또는 이 메서드가 populate 나 execute
 실행전에 너무 빨리 불려 갔을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/CachedRowSet.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../javax/sql/rowset/BaseRowSet.html" title="javax.sql.rowset 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../javax/sql/rowset/FilteredRowSet.html" title="javax.sql.rowset 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?javax/sql/rowset/CachedRowSet.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="CachedRowSet.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

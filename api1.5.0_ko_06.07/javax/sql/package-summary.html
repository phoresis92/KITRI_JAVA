<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:23:08 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
javax.sql (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="javax.sql package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="javax.sql (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/sound/sampled/spi/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../javax/sql/rowset/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/sql/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 javax.sql
</H2>
Java<sup><font size=-2>TM</font></sup> 프로그램 언어를 사용해 서버측의 데이터 소스에 접속해 처리하기 위한 API를
 제공합니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/ConnectionEventListener.html" title="javax.sql 안의 인터페이스">ConnectionEventListener</A> </B></TD>
<TD>
 <code>PooledConnection</code> 오브젝트에
해 생성된 이벤트가 통지되도록 등록하는 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/ConnectionPoolDataSource.html" title="javax.sql 안의 인터페이스">ConnectionPoolDataSource</A> </B></TD>
<TD><code>PooledConnection</code> 오브젝트의 팩토리입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/DataSource.html" title="javax.sql 안의 인터페이스">DataSource</A> </B></TD>
<TD>이 <code>DataSource</code> 오브젝트가 나타내는 물리 데이터 소스에의 접속에 대한 팩토리입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/PooledConnection.html" title="javax.sql 안의 인터페이스">PooledConnection</A> </B></TD>
<TD>접속 풀 관리의 훅을 제공하는 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSet.html" title="javax.sql 안의 인터페이스">RowSet</A> </B></TD>
<TD>JavaBeans<sup><font size=-2>TM</font></sup> 컴퍼넌트 모델의 JDBC API 로 서포트되게 된 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetInternal.html" title="javax.sql 안의 인터페이스">RowSetInternal</A> </B></TD>
<TD><code>RowSet</code> 오브젝트가 자신을 <code>RowSetReader</code> 오브젝트나 <code>RowSetWriter</code> 오브젝트에 건네주기 위해서 구현하는 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetListener.html" title="javax.sql 안의 인터페이스">RowSetListener</A> </B></TD>
<TD><code>RowSet</code> 오브젝트의 유효기간중에 중요한 이벤트가 발생했을 때에 통지를 희망하는 컴퍼넌트에
해 구현되고 있는 인터페이스입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetMetaData.html" title="javax.sql 안의 인터페이스">RowSetMetaData</A> </B></TD>
<TD><code>RowSet</code> 오브젝트의 열에 관한 정보를 포함하는 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetReader.html" title="javax.sql 안의 인터페이스">RowSetReader</A> </B></TD>
<TD>절단 된 <code>RowSet</code> 오브젝트가, 열데이터 첨부로 자기 자신을 생성하기 위해서 호출하는 기능입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetWriter.html" title="javax.sql 안의 인터페이스">RowSetWriter</A> </B></TD>
<TD><code>RowSetWriter</code> 인터페이스를 구현하는 오브젝트로 「라이터」라고 불립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/XAConnection.html" title="javax.sql 안의 인터페이스">XAConnection</A> </B></TD>
<TD>분산 트랜잭션(transaction)를 지원하는
 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/XADataSource.html" title="javax.sql 안의 인터페이스">XADataSource</A> </B></TD>
<TD>내부에서 사용되는 <code>XAConnection</code> 오브젝트의 팩토리입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/ConnectionEvent.html" title="javax.sql 안의 클래스">ConnectionEvent</A> </B></TD>
<TD>
접속 관련의 이벤트의 소스에 관한 정보를 제공하는 <code>Event</code> 오브젝트입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../javax/sql/RowSetEvent.html" title="javax.sql 안의 클래스">RowSetEvent</A> </B></TD>
<TD><code>RowSet</code> 오브젝트에 이벤트가 발생했을 때에 생성되는 <code>Event</code> 오브젝트입니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 javax.sql
 설명
</H2>

<P>
Java<sup><font size=-2>TM</font></sup> 프로그램 언어를 사용해 서버측의 데이터 소스에 접속해 처리하기 위한 API를
 제공합니다. 이 패키지는 <code>java.sql</code> 패키지를 보충하는 것이어, 버젼 1.4 이후의 JDK 에 포함되어 있습니다. 또, 여전히 Java 2 SDK, Enterprise Edition (J2EE<sup><font size=-2>TM</sup></font>)의 주요 부분입니다.
<P>
<code>java.sql</code> 패키지는
 다음의 API를
 제공합니다. <OL> 
 <LI>데이터 소스와의 접속을 확립하기 위한,
<code>DriverManager</code>
 대체가 되는 <code>DataSource</code> 인터페이스
 <LI>접속 풀
 <LI>분산 트랜잭션(transaction)
 <LI>행 세트</OL>
<P>
어플리케이션에서는 <code>DataSource</code> API 와 <code>RowSet</code> API를
 직접 사용합니다만, 접속 풀 API 와 분산 트랜잭션(transaction) API는
 중간층 인프라스트럭쳐에
해 내부적으로 사용됩니다.
<H2><code>DataSource</code> 오브젝트를 사용한 접속의 확립</H2>
<code>javax.sql</code> 패키지에서는
 데이터 소스와의 접속을 확립하기 위한 최적인 방법을 제공하고 있습니다. 원의 도구
인 <code>DriverManager</code> 클래스도 여전히 유효하고, 이 클래스를 사용한 코드도 계속해 실행할 수 있습니다. 다만,<code>DriverManager</code> 도구
보다 많은 이점이 있기 때문에
 새로운 <code>DataSource</code> 도구
를 사용하는 것을 추천 합니다.
<P>
접속을 확립할 때에 <code>DataSource</code> 오브젝트를 사용하는 주된 이점을 듭니다.
<UL> 
 <LI>어플리케이션으로 드라이버 클래스를 하드 코딩 할 필요가 없다
 <LI>변경은 데이터 소스의 프로퍼티에 가세하면 좋다. 즉, 데이터 소스나 드라이버에 관한 변경이 있었을 때에
 어플리케이션 코드를 변경할 필요가 없다
 <LI>중간층 인프라스트럭쳐로 동작하도록 구현된 접속 풀과 분산 트랜잭션(transaction)는
<code>DataSource</code> 오브젝트를 개입시켜 이용할 수 있다. <code>DriverManager</code>을
 개입시켜 확립된 접속에는
 접속 풀이나 분산 트랜잭션(transaction)라고 하는 기능이 없다
</UL>
<P>
드라이버의 벤더는 <code>DataSource</code>
 구현을 제공합니다. <code>DataSource</code> 오브젝트는 특정의 물리 데이터 소스를 나타내, 동오브젝트가 작성하는 접속은, 그 물리 데이터 소스에의 접속이 됩니다.
<P>
데이터 소스의 논리명은, 일반적으로 시스템 관리 책임자나 시스템 관리 책임자의 작업을 실시하는 유저에
해, Java Naming and Directory Interface<sup><font size=-2>TM</font></sup> (JNDI) API를
 사용하는 네임 서비스에 등록됩니다. 어플리케이션에서는
 등록되어 있는 논리명을 룩 올라가, 필요한 <code>DataSource</code> 오브젝트를 취득합니다. 그리고, 취득한 <code>DataSource</code> 오브젝트를 사용해, 이 오브젝트가 나타내는 물리 데이터 소스에의 접속을 작성합니다.
<P>
<code>DataSource</code> 오브젝트는
 중간층 인프라스트럭쳐와 제휴해 동작하도록 구현할 수 있습니다. 이 구현에서는
<code>DataSource</code> 오브젝트에
해 작성된 접속을 풀 해 재이용할 수가 있습니다. 이 구현을 사용하는 어플리케이션에서는
 접속 풀에 있는 접속을 자동적으로 취득할 수 있습니다. 또,<code>DataSource</code> 오브젝트에
해 작성된 접속을, 특별한 코딩없이, 분산 트랜잭션(transaction)로 사용할 수도 있습니다.
<H2>접속 풀</H2>
중간층 접속 풀 관리 프로그램으로 동작하도록 구현된 <code>DataSource</code> 오브젝트에
해 작성된 접속은, 접속 풀에 추가됩니다. 새로운 접속의 작성은 매우 부하가 큰 작업이기 때문에
 이것에
해 퍼포먼스가 비약적으로 향상합니다. 접속 풀에서는
 접속의 이용 및 재이용이 가능합니다. 그 때문에
 작성할 필요가 있는 새로운 접속의 수는 큰폭으로 삭감됩니다.
<P>
접속 풀은 완전하게 투과적입니다. J2EE
 구성의 중간층으로 자동적으로 행해져 어플리케이션의 관점으로부터는
 코드를 변경할 필요는 없습니다. 어플리케이션에서는 단지 <code>DataSource.getConnection</code> 메서드를 사용해 풀 된 접속을 취득해,<code>Connection</code> 오브젝트를 사용하는 것과 같은 방법으로 사용합니다.
<P>
접속 풀에 사용되는 클래스와 인터페이스는 다음과 같습니다.
<UL> 
 <LI><code>ConnectionPoolDataSource</code> 
 <LI><code>PooledConnection</code> 
 <LI><code>ConnectionEvent</code> 
 <LI><code>ConnectionEventListener</code>
</UL>접속 풀 관리 프로그램은 3 층 아키텍쳐의 중간층으로 기능해, 이러한 클래스나 인터페이스를 배후에서 사용합니다. <code>PooledConnection</code> 오브젝트를 작성하기 위해서 <code>ConnectionPoolDataSource</code> 오브젝트가 불려 가면, 접속 풀 관리 프로그램에
해 새로운 <code>PooledConnection</code> 오브젝트가 <code>ConnectionEventListener</code> 오브젝트로서 등록됩니다. 접속이 닫혀질까 에러가 발생하면, 접속 풀 관리 프로그램 (리스너)이 <code>ConnectionEvent</code> 오브젝트를 포함한 통지를 받습니다.

<H2>분산 트랜잭션(transaction)</H2>
풀 된 접속과 같게, 중간층 인프라스트럭쳐로 동작하도록 구현된 <code>DataSource</code> 오브젝트로 작성된 접속은, 분산 트랜잭션(transaction)에도 참가합니다. 이것에
해, 어플리케이션에서는 단일 트랜잭션(transaction)로 복수 서버상의 데이터 소스에 액세스 할 수 있게 됩니다.
<P>
분산 트랜잭션(transaction)에 사용되는 클래스와 인터페이스는 다음과 같습니다.
<UL> 
 <LI><code>XADataSource</code> 
 <LI><code>XAConnection</code>
</UL>이러한 인터페이스는 트랜잭션(transaction) 매니저에
해 사용되어 어플리케이션이 직접 사용할 것은 없습니다.
<P>
<code>XAConnection</code> 인터페이스는 <code>PooledConnection</code> 인터페이스로부터 파생하고 있기 때문에
 풀 된 접속에 적용되는 것은, 분산 트랜잭션(transaction)를 구성하는 접속에도 적용됩니다. 트랜잭션(transaction) 매니저는 중간층에 있어, 모든 것을 투과적으로 처리합니다. 어플리케이션 코드중의 변경점은, 어플리케이션에 트랜잭션(transaction) 매니저의 처리와 간섭하는 처리를 시키지 않는
 이라고 하는 점이 됩니다. 특히, 어플리케이션에서는 <code>Connection.commit</code> 메서드나 <code>Connection.rollback</code> 메서드를 호출할 수가 없습니다. 또, 접속을 자동 위탁 모드로 설정할 수도 있습니다. 즉,<code>Connection.setAutoCommit(true)</code>를
 호출할 수 없습니다.
<P>
분산 트랜잭션(transaction)에 참가하기 위해서, 어플리케이션이 특별히 실행할 필요가 있는 것은 아무것도 없습니다. 보통
 대로 사용하는 데이터 소스에의 접속을 <code>DataSource.getConnection</code> 메서드로 작성하는 것만으로 끝납니다. 트랜잭션(transaction) 매니저는
 트랜잭션(transaction)를 배후에서 관리합니다. <code>XADataSource</code> 인터페이스는 <code>XAConnection</code> 오브젝트를 작성해, 각 <code>XAConnection</code> 오브젝트는 트랜잭션(transaction) 매니저가 접속을 관리하기 위해서 사용하는 <code>XAResource</code> 오브젝트를 작성합니다.

<H2>행 세트</H2><code>RowSet</code> 인터페이스는
 다른 다양한 클래스나 인터페이스와 함께 배후에서 동작합니다. 이러한 클래스나 인터페이스는 3 개의 카테고리로 나눌 수 있습니다. <OL>
 <LI>이벤트 통지
<UL> 
 <LI><code>RowSetListener</code><br><code>RowSet</code> 오브젝트는
 JavaBeans<sup><font size=-2>TM</font></sup> 프로퍼티를 가져, JavaBeans
 이벤트 통지 도구
에 참가하고 있기 때문에
 JavaBeans
 컴퍼넌트이다고 말할 수 있습니다. <code>RowSetListener</code> 인터페이스는
 특정의 <code>RowSet</code> 오브젝트에 발생하는 이벤트를 통지받고 싶은 컴퍼넌트에
해 구현됩니다. 그러한 컴퍼넌트는
<code>RowSet.addRowSetListener</code> 메서드를 사용해, 자신을 리스너로서 행 세트에 등록합니다.
<P>
<code>RowSet</code> 오브젝트가 1 행을 변경, 전행을 변경, 또는 커서 위치를 이동하면, 이 오브젝트에 등록된 각 리스너에게도 통지됩니다. 리스너는
 통지 메서드의 구현을 호출하는 것에
해 실행합니다.
<P>
 
 <LI><code>RowSetEvent</code><br>내부 통지 프로세스의 일부로서<code>RowSet</code> 오브젝트는 <code>RowSetEvent</code>
 인스턴스를 작성해 리스너에게 건네줍니다. 리스너는 건네받은 <code>RowSetEvent</code> 오브젝트를 사용해, 어느 행 세트에 이벤트가 있는지를 검출할 수 있습니다.
</UL>
<P>

 <LI>메타데이타
<UL> 
 <LI><code>RowSetMetaData</code><br>이 인터페이스는 <code>ResultSetMetaData</code> 인터페이스로부터 파생하고 있어,<code>RowSet</code> 오브젝트의 열에 관한 정보를 제공합니다. 어플리케이션에서는 <code>RowSetMetaData</code> 메서드를 사용해, 행 세트에 포함되는 렬수나 각 열에 포함할 수 있는 데이터의 종류를 검출할 수 있습니다.
<P>
<code>RowSetMetaData</code> 인터페이스에서는 열에 관한 정보를 설정하는 메서드를 제공합니다만, 어플리케이션이 사용하는 것은 보통
 없습니다. 어플리케이션이 <code>RowSet</code>
 <code>execute</code> 메서드를 호출하면,<code>RowSet</code> 오브젝트는 행의 새로운 세트를 포함해,<code>RowSetMetaData</code> 오브젝트는 내부적으로 갱신되어, 새로운 열에 관한 정보를 포함하게 됩니다.
<P>

</UL>
 <LI>리더/라이터 기능<br><code>RowSetInternal</code> 인터페이스를 구현하는 <code>RowSet</code> 오브젝트에서는
 관련된 <code>RowSetReader</code> 오브젝트를 호출하는 것으로 데이터를 자신에게 읽어들일 수가 있습니다. 또, 관련된 <code>RowSetWriter</code> 오브젝트를 호출하는 것으로 행에 가세한 변경을, 그 행을 원래 취득한 데이터 소스로 써 되돌릴 수가 있습니다. 데이터 소스에 접속한 채로의 행 세트에서는
 데이터 소스를 직접 조작할 수가 있기 때문에
 리더나 라이터를 사용할 필요는 없습니다.

<UL> 
 <LI><code>RowSetInternal</code><br><code>RowSetInternal</code> 인터페이스를 구현하는 것으로<code>RowSet</code> 오브젝트에서는 내부 상태에 액세스 할 수가 있어 리더나 라이터를 호출할 수가 있게 됩니다. 행 세트는 현재의 행의 값과 원의 값으로 해서 참조되는
 현재의 행의 직전에 있는 행의 값을 보관 유지합니다. 또 (1) 커멘드용으로 설정된 파라미터와(2) 행 세트에게 건네진 접속 (존재하는 경우)도 보관 유지합니다. 행 세트는 <code>RowSetInternal</code> 메서드를 배후에서 사용하는 것으로 이러한 정보에 액세스 합니다. 어플리케이션이 이러한 메서드를 직접 호출하는 것은 보통
 없습니다.
<P>
 
 <LI><code>RowSetReader</code><br><code>RowSetInternal</code> 인터페이스를 구현하는
 절단 된 <code>RowSet</code> 오브젝트는 리더 (RowSet 오브젝트에 관련지을 수 있었던 <code>RowSetReader</code> 오브젝트)를 호출해, 데이터를 자신에게 읽어들일 수가 있습니다. 어플리케이션이 <code>RowSet.execute</code> 메서드를 호출하면, 이 메서드가 행 세트의 리더를 호출해, 대부분의 작업을 실시합니다. 리더의 구현은 다양합니다만, 일반적으로는
 데이터 소스에의 접속을 확립해, 데이터 소스로부터 데이터를 읽어들여, 그 데이터를 행 세트에 추가해, 접속을 닫습니다. 또, 리더는 그 행 세트용으로 <code>RowSetMetaData</code> 오브젝트를 갱신하는 일도 있습니다. 행 세트의 내부 상태도, 리더에
해, 또는 직접 <code>RowSet.execute</code> 메서드에
해 갱신됩니다.


 <LI><code>RowSetWriter</code><br><code>RowSetInternal</code> 인터페이스를 구현하는
 절단 된 <code>RowSet</code> 오브젝트는 라이터 (RowSet 오브젝트에 관련지을 수 있었던 <code>RowSetWriter</code> 오브젝트)를 호출해, 변경을 부하의 데이터 소스에 써 되돌립니다. 라이터의 구현은 다양합니다만, 일반적으로는 다음과 같이 동작합니다.

<P>

<UL> 
 <LI>데이터 소스에의 접속을 확립한다
 <LI>모순이 있을지 어떨지, 즉, 행 세트내의 변경된 값이 데이터 소스라도 변경되고 있는지 어떤지를 확인한다
 <LI>모순이 없는 경우는
 새로운 값을 데이터 소스에 기입한다
 <LI>접속을 닫는다
</UL> 

</UL></OL>
<P>
<code>RowSet</code> 인터페이스는 많은 방법으로 구현할 수 있어 누구나가 구현을 작성할 수 있습니다. 개발자는 자유롭게 상상력을 일하게 해 행 세트의 새로운 사용 방법을 찾아내는 것이 추천 되고 있습니다.
<P>
<B>중요:</B> 「도입된 버젼: 1.4」(이)라고 표시된 API를
 사용하는 코드는
 JDBC 3.0 API를
 구현하는 JDBC 테크놀러지 드라이버를 사용해 실행할 필요가 있습니다. 사용하려고 하는 특정의 기능이 드라이버에 구현되고 있는지 어떤지를, 드라이버의 문서로 확인해 주세요.
<P>

<h2>패키지의 사양</h2>

<ul> <li><a href="http://java.sun.com/products/jdbc/download.html">「JDBC 3.0 API
 사양」</a> 
</ul>

<h2>관련 문서</h2>

Addison-Wesley Longman 로부터 출판되고 있는 Java Series 북에서는
<code>javax.sql</code> 패키지의 클래스나 인터페이스에 관한 상세한 정보를 참조할 수 있습니다.  
<ul> <li><a href="http://java.sun.com/docs/books/jdbc">「JDBC<sup><font size=-2>TM</font></sup> API Tutorial and Reference, Second Edition: Universal Data Access for the Java 2 Platform」</a> 
</ul>

<P>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../javax/sound/sampled/spi/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../javax/sql/rowset/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?javax/sql/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

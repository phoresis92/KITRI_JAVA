<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:55:59 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ComponentColorModel (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.image.ComponentColorModel class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ComponentColorModel (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ComponentColorModel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/image/ComponentColorModel.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ComponentColorModel.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.image.ColorModel">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.image</FONT>
<BR>
클래스 ComponentColorModel</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">java.awt.image.ColorModel</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.image.ComponentColorModel</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/awt/Transparency.html" title="java.awt 내의 인터페이스">Transparency</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ComponentColorModel</B><DT>extends <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </DL>
</PRE>

<P>
이것은 <CODE>ColorModel</CODE> 클래스의 1 개로 픽셀치를 취급합니다. 이 픽셀치는
 색정보 및 알파 정보를 개별의 샘플로서 표현해, 각 샘플을 개별의 데이터 요소에 포함합니다. 이 클래스는
 임의의 <CODE>ColorSpace</CODE> 와 함께 사용할 수 있습니다. 픽셀치에 포함한 컬러 샘플의 수는
<CODE>ColorSpace</CODE> 에 있는 색성분의 수로 동일하지 않으면 안됩니다. 알파 샘플은, 단일에서도 괜찮습니다.
 <p>
<CODE>transferType</CODE> 형의 원시적 배열 픽셀 표현을 사용하는 메서드의 경우, 배열의 길이는 컬러 샘플 및 알파 샘플의 수로 동일해집니다. 배열에는 컬러 샘플이 최초로 포함되어 알파 샘플이 있으면, 그 후에 포함됩니다. 컬러 샘플의 순서는
<CODE>ColorSpace</CODE> 로 지정합니다. 보통
, 이 순서는 컬러 영역의 형태의 이름을 반영합니다. 예를 들어,<CODE>TYPE_RGB</CODE>
 인덱스 0 은 빨강, 인덱스 1 은 초록, 그리고 인덱스 2는
 파랑이 됩니다.
 <p>
표시, 혹은 이미지 처리를 위해서 픽셀치를 색성분 또는 알파 성분으로 변환하는 처리는
 샘플과 성분의 1 대 1 대응이 됩니다. <code>ComponentColorModel</code>
 인스턴스의 작성에 사용하는 전송형에 응해, 인스턴스가 부호 첨부나 부호 없음인가 및 정수형, float, double
 어떤 것인가 (자세한 것은 이후를 참조)에
해, 픽셀 샘플치는 표현됩니다. 샘플치를 색성분 또는 알파 성분으로 변환하는 처리는
 특정의 규칙에 따를 필요가 있습니다. float 및 double
 샘플의 경우는 항등변환으로 표준화 성분치가 대응하는 샘플치와 동일해집니다. 정수 샘플의 경우는
 단순한 스케일 및 오프셋(offset)만의 변환입니다. 스케일 정수와 오프셋(offset) 정수는 성분 마다 다른 일이 있습니다. 스케일 정수와 오프셋(offset) 정수를 적용한 결과는
 특정의 범위에 확실히 들어가는 색성분 및 알파 성분의 값세트입니다. 보통
, 색성분의 범위는 <code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메서드와 <code>getMaxValue</code> 메서드에
해 정의됩니다. 알파 성분의 범위는 0.0 ~ 1.0 입니다.
 <p>
전송형 <CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE> 및 <CODE>DataBuffer.TYPE_INT</CODE> 으로 작성된 <code>ComponentColorModel</code>
 인스턴스는
 부호 없음 정수치로서 다루어지는 픽셀 샘플치를 가집니다. 픽셀치의 색샘플과 알파 샘플의 비트수는
<code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code> 생성자에게 건네진, 대응하는 컬러 샘플 및 알파 샘플의 비트수와 다른 경우가 있습니다. 이 경우, 이 클래스는
 샘플치의 최하정도 n 비트가 성분의 값을 보관 유지하고 있다고 봅니다. 이 때 n는

 생성자에게 건네진 성분의 유효 비트의 수입니다. 또, 보다 상위에 있는 샘플치의 임의의 비트에 대해서는
 모두 0 이다고 보여집니다. 따라서, 샘플치의 범위는 0 ~ 2<sup>n</sup> - 1 이 됩니다. 이 클래스는
 이러한 샘플치를 표준화 된 색성분치에 맵 하므로 0 은 <code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메서드로부터 취득한 값에 맵 되어 2<sup>n</sup> - 1 은 <code>getMaxValue</code> 메서드로부터 취득한 값에 맵 됩니다. 다른 컬러 샘플의 매핑의 <code>ComponentColorModel</code>을
 작성하려면,
 이 클래스의 서브 클래스화해,<code>getNormalizedComponents(Object, float[], int)</code> 메서드를 오버라이드(override) 할 필요가 있습니다. 알파 샘플의 경우, 항상 0 이 0.0 에
 2<sup>n</sup> - 1 이 1.0 에 맵 됩니다.
 <p>
부호 없음 샘플치를 가지는 인스턴스에서는
 다음의 2 개의 조건이 채워지는 경우에게만, 표준화되어 있지 않은 색성분 및 알파 성분 표현이 지원됩니다. 1 개는
 샘플치 0 이 표준화 성분치 0.0 에 맵 되어 샘플치 2<sup>n</sup> - 1 이 1.0 에 맵 되는 것입니다. 이제(벌써) 1 개는
<code>ColorSpace</code>
 모든 색성분의 최소/최대 범위가 0.0 ~ 1.0 인 것입니다. 이 경우, 성분 표현은 대응하는 샘플의 최하정도 n 비트가 됩니다. 따라서, 각 성분은 0 으로 2<sup>n</sup> - 1
 사이의 부호 없음 정수치입니다. 이 때 n는

 특정의 성분의 유효 비트수입니다. 이러한 조건이 채워지지 않은 경우는
 비표준화 성분의 인수를 취하는 임의의 메서드가 <code>IllegalArgumentException</code>를
 Throw 합니다.
 <p>
전송형 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE> 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 로 작성된 <code>ComponentColorModel</code>
 인스턴스는
 부호 첨부 short, float, 또는 double 치로서 다루어지는 픽셀 샘플치를 보관 유지합니다. 이러한 인스턴스는 표준화되어 있지 않은 색성분 및 알파 성분 표현을 지원하지 않기 때문에
 인스턴스를 호출하면, 인수에 이러한 표현을 취하는 메서드는 <code>IllegalArgumentException</code>를
 Throw 합니다. 이 클래스의 인스턴스의 표준화 성분치는
 다음의 전송형에 대응한 범위를 가집니다. float 샘플은 float 데이터형의 전범위, double 샘플은 float 데이터형의 전범위 (double를
 float 에 캐스트 한 결과), short 샘플은 거의 -maxVal ~ +maxVal 입니다. maxVal는
 <code>ColorSpace</code>
 성분 근처의 최대치입니다 (-32767 가 -maxVal 에
 0 이 0.0 에
 32767 이 +maxVal 에 맵 됩니다). 서브 클래스는
<code>getNormalizedComponents(Object, float[], int)</code> 메서드를 오버라이드(override) 하는 것으로써, short 샘플치의 표준화 성분치에의 슬캘링을 오버라이드(override) 하는 일이 있습니다. float 샘플과 double 샘플에 대해서는
 표준화 성분치가 대응하는 샘플치와 동일해져, 서브 클래스는 이러한 전송형의 어느 비항등변환슬캘링도 추가하지 않습니다.
 <p>
전송형 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE> 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 로 작성된 <code>ComponentColorModel</code>
 인스턴스는
 모든 샘플치의 모든 비트를 사용합니다. 따라서, 모든 색성분 및 알파 성분은,<CODE>DataBuffer.TYPE_SHORT</CODE>
 경우는 16 비트,<CODE>DataBuffer.TYPE_FLOAT</CODE>
 경우는 32 비트,<CODE>DataBuffer.TYPE_DOUBLE</CODE>
 경우는 64 비트를 보관 유지합니다. <code>ComponentColorModel(ColorSpace, int[], boolean, boolean, int, int)</code> 형식의 생성자가 이러한 전송형으로 사용되는 경우, 비트 배열 인수는 무시됩니다.
 <p>
컬러 샘플치와 알파 샘플치가 렌더링 하는 성분치로서 적절히 해석되지 않는 것도 있습니다. 이것은,<code>ComponentColorModel</code> 이, 부호 없음 샘플치의 표준화 된 색성분치에의 매핑을 오버라이드(override) 하기 위한(해) 서브 클래스화 되고 있는지, 특정의 범위외의 부호 첨부 샘플치가 사용되고 있는 경우에 일어납니다. 예를 들어, 알파 성분을 0 ~ 32767
 범위에 없는 부호 첨부 short 치, 표준화 범위 0.0 ~ 1.0 으로서 지정하면, 예기치 않은 결과가 됩니다. 색성분이 <code>ColorSpace</code>
 표준화 범위 (<code>ColorSpace</code> 클래스의 <code>getMinValue</code> 메서드와 <code>getMaxValue</code> 메서드를 사용해 취득) 내에 있어, 알파 성분이 0.0 ~ 1.0 이도록(듯이), 렌더링의 전에 어플리케이션측에서 픽셀 데이터를 적절히 슬캘링 할 필요가 있습니다. 색성분치 또는 알파 성분치가 범위외에 있는 경우에는
 렌더링 결과를 확정할 수 없습니다.
 <p>
<CODE>ComponentColorModel</CODE>
 성분수가 1 으로 컴퍼넌트치가 부호 없음 (즉, 전송형 <CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 또는 <CODE>DataBuffer.TYPE_INT</CODE>를
 사용하는 단일의 색성분만으로 알파 성분이 없다) 이외의 경우, 단일의 int 픽셀 표현을 사용하는 메서드는 <CODE>IllegalArgumentException</CODE>를
 Throw 합니다.
 <p>
<CODE>ComponentColorModel</CODE> 은,<CODE>ComponentSampleModel</CODE>,<CODE>BandedSampleModel</CODE>, 또는 <CODE>PixelInterleavedSampleModel</CODE> 와 조합해,<CODE>BufferedImage</CODE>
 작성에 사용할 수 있습니다.
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><CODE>ColorModel</CODE></A>,
 
<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스"><CODE>ColorSpace</CODE></A>,
 
<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 안의 클래스"><CODE>ComponentSampleModel</CODE></A>,
 
<A HREF="../../../java/awt/image/BandedSampleModel.html" title="java.awt.image 안의 클래스"><CODE>BandedSampleModel</CODE></A>,
 
<A HREF="../../../java/awt/image/PixelInterleavedSampleModel.html" title="java.awt.image 안의 클래스"><CODE>PixelInterleavedSampleModel</CODE></A>,
 
<A HREF="../../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스"><CODE>BufferedImage</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.image.ColorModel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt.image. <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 안의 클래스">ColorModel</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/image/ColorModel.html#pixel_bits">pixel_bits</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#transferType">transferType</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.awt.Transparency"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.awt. <A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스">Transparency</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/Transparency.html#BITMASK">BITMASK</A>,
 <A HREF="../../../java/awt/Transparency.html#OPAQUE">OPAQUE</A>,
 <A HREF="../../../java/awt/Transparency.html#TRANSLUCENT">TRANSLUCENT</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#ComponentColorModel(java.awt.color.ColorSpace, boolean, boolean, int, int)">ComponentColorModel</A> </B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                    boolean&nbsp;hasAlpha,
                    boolean&nbsp;isAlphaPremultiplied,
                    int&nbsp;transparency,
                    int&nbsp;transferType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 파라미터로부터,<CODE>ComponentColorModel</CODE>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#ComponentColorModel(java.awt.color.ColorSpace, int[], boolean, boolean, int, int)">ComponentColorModel</A> </B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                    int[]&nbsp;bits,
                    boolean&nbsp;hasAlpha,
                    boolean&nbsp;isAlphaPremultiplied,
                    int&nbsp;transparency,
                    int&nbsp;transferType)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 파라미터로부터,<CODE>ComponentColorModel</CODE>를
 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#coerceData(java.awt.image.WritableRaster, boolean)">coerceData</A> </B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster,
           boolean&nbsp;isAlphaPremultiplied)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;라스터 데이터가 <CODE>isAlphaPremultiplied</CODE> 변수로 지정된 상태와 일치하도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스">SampleModel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#createCompatibleSampleModel(int, int)">createCompatibleSampleModel</A> </B>(int&nbsp;w,
                            int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭 및 높이로 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃을 가지는 <CODE>SampleModel</CODE>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#createCompatibleWritableRaster(int, int)">createCompatibleWritableRaster</A> </B>(int&nbsp;w,
                               int&nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭 및 높이로 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃 (<CODE>SampleModel</CODE>)을 가지는 <CODE>WritableRaster</CODE>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컬러 모델과 다른 컬러 모델이 동일한지 어떤지를 비교합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlpha(int)">getAlpha</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 알파 성분을, 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlpha(java.lang.Object)">getAlpha</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 알파 성분을 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getAlphaRaster(java.awt.image.WritableRaster)">getAlphaRaster</A> </B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지의 알파 채널을 표현하는 <CODE>Raster</CODE>를
, 입력된 <CODE>Raster</CODE> 로부터 추출해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getBlue(int)">getBlue</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 파랑 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getBlue(java.lang.Object)">getBlue</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 청색 성분을, 디폴트의 RGB <CODE>ColorSpace</CODE> (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getComponents(int, int[], int)">getComponents</A> </B>(int&nbsp;pixel,
              int[]&nbsp;components,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <CODE>ColorModel</CODE>
 픽셀을 지정해, 표준화되어 있지 않은 색성분 또는 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getComponents(java.lang.Object, int[], int)">getComponents</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
              int[]&nbsp;components,
              int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <CODE>ColorModel</CODE>
 픽셀을 지정해, 표준화되어 있지 않은 색성분 또는 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElement(float[], int)">getDataElement</A> </B>(float[]&nbsp;normComponents,
               int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 에 <code>int</code> 로서 나타내지는 픽셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElement(int[], int)">getDataElement</A> </B>(int[]&nbsp;components,
               int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비정규화된 색성분 혹은 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE>
 int 로서 표현되는 픽셀치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(float[], int, java.lang.Object)">getDataElements</A> </B>(float[]&nbsp;normComponents,
                int&nbsp;normOffset,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code>
 픽셀의 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(int[], int, java.lang.Object)">getDataElements</A> </B>(int[]&nbsp;components,
                int&nbsp;offset,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;비정규화된 색성분 또는 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE>
 픽셀의 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getDataElements(int, java.lang.Object)">getDataElements</A> </B>(int&nbsp;rgb,
                <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 RGB 컬러 모델의 int 픽셀 표현을 지정해, 이 <CODE>ColorModel</CODE>
 픽셀 데이터 요소 배열 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getGreen(int)">getGreen</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 초록 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getGreen(java.lang.Object)">getGreen</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 녹색 성분을, 디폴트의 RGB <CODE>ColorSpace</CODE> (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getNormalizedComponents(int[], int, float[], int)">getNormalizedComponents</A> </B>(int[]&nbsp;components,
                        int&nbsp;offset,
                        float[]&nbsp;normComponents,
                        int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getNormalizedComponents(java.lang.Object, float[], int)">getNormalizedComponents</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                        float[]&nbsp;normComponents,
                        int&nbsp;normOffset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>ColorModel</code>
 지정된 픽셀에 대해, 표준화 형식에서 색성분과 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRed(int)">getRed</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 빨강 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRed(java.lang.Object)">getRed</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 픽셀의 적색 성분을, 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRGB(int)">getRGB</A> </B>(int&nbsp;pixel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 RGB 컬러 모델 형식에서, 픽셀의 색성분 또는 알파 성분을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getRGB(java.lang.Object)">getRGB</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 RGB 컬러 모델 형식에서, 픽셀의 색성분 또는 알파 성분을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#getUnnormalizedComponents(float[], int, int[], int)">getUnnormalizedComponents</A> </B>(float[]&nbsp;normComponents,
                          int&nbsp;normOffset,
                          int[]&nbsp;components,
                          int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#isCompatibleRaster(java.awt.image.Raster)">isCompatibleRaster</A> </B>(<A HREF="../../../java/awt/image/Raster.html" title="java.awt.image 안의 클래스">Raster</A> &nbsp;raster)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우에 true를
 돌려주고, 그렇지 않은 경우는 false를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/image/ComponentColorModel.html#isCompatibleSampleModel(java.awt.image.SampleModel)">isCompatibleSampleModel</A> </B>(<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스">SampleModel</A> &nbsp;sm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있을지 어떨지를 판정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.image.ColorModel"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt.image. <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 안의 클래스">ColorModel</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/awt/image/ColorModel.html#finalize()">finalize</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getColorSpace()">getColorSpace</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getComponentSize()">getComponentSize</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getComponentSize(int)">getComponentSize</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getNumColorComponents()">getNumColorComponents</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getNumComponents()">getNumComponents</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getPixelSize()">getPixelSize</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()">getRGBdefault</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getTransferType()">getTransferType</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#getTransparency()">getTransparency</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#hasAlpha()">hasAlpha</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#isAlphaPremultiplied()">isAlphaPremultiplied</A>,
 <A HREF="../../../java/awt/image/ColorModel.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ComponentColorModel(java.awt.color.ColorSpace, int[], boolean, boolean, int, int)"><!-- --></A> <H3>
ComponentColorModel</H3>
<PRE>
public <B>ComponentColorModel</B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                           int[]&nbsp;bits,
                           boolean&nbsp;hasAlpha,
                           boolean&nbsp;isAlphaPremultiplied,
                           int&nbsp;transparency,
                           int&nbsp;transferType)</PRE>
<DL>
<DD>지정된 파라미터로부터,<CODE>ComponentColorModel</CODE>를
 구축합니다. 색성분은, 지정된 <CODE>ColorSpace</CODE> 내가 됩니다. 지원되는 전송형은,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE> 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 입니다. null 가 아닌 경우,<CODE>bits</CODE> 배열은, 색성분 및 알파 성분마다의 유효 비트수를 지정합니다. 픽셀치에 알파 정보가 없는 경우, 배열의 길이는 적어도 <CODE>ColorSpace</CODE> 에 있는 성분수가 되어, 알파 정보가 있는 경우는
 성분수보다 1 커집니다. <CODE>transferType</CODE> 가 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 또는 <CODE>DataBuffer.TYPE_DOUBLE</CODE>
 경우,<CODE>bits</CODE> 배열 인수는 무시됩니다. <CODE>hasAlpha</CODE>는

 알파 정보의 유무를 나타냅니다. <CODE>hasAlpha</CODE> 가 true
 경우, boolean 형의 <CODE>isAlphaPremultiplied</CODE>는

 픽셀치에 있는 컬러 샘플 및 알파 샘플을 평가하는 방법을 지정합니다. boolean 가 true
 경우는
 컬러 샘플은 알파 샘플과 곱셈되었다고 보여집니다. <CODE>transparency</CODE>는

 이 컬러 모델로 표현할 수 있는 알파치를 지정합니다. 허용 되는 <code>transparency</code> 치는
<CODE>OPAQUE</CODE>,<CODE>BITMASK</CODE>, 또는 <CODE>TRANSLUCENT</CODE> 입니다. <CODE>transferType</CODE>는

 픽셀치를 표현하기 위해서 사용하는 원시적 배열의 형태입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>colorSpace</CODE> - 이 컬러 모델에 관련한 <CODE>ColorSpace</CODE><DD><CODE>bits</CODE> - 성분마다의 유효 비트수. null
 경우, 모든 성분 샘플의 모든 비트가 유효하게 된다. transferType 가 <CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>, 또는 <CODE>DataBuffer.TYPE_DOUBLE</CODE>
 경우는 무시되어 모든 성분 샘플의 모든 비트가 유효하게 되는<DD><CODE>hasAlpha</CODE> - true
 경우, 이 컬러 모델은 알파를 지원하는<DD><CODE>isAlphaPremultiplied</CODE> - true
 경우, 알파는 미리 곱셈되고 있는<DD><CODE>transparency</CODE> - 이 컬러 모델로 표현 가능한 알파치를 지정하는<DD><CODE>transferType</CODE> - 픽셀치의 표현에 사용하는 원시적 배열의 형태를 지정한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <CODE>bits</CODE> 배열 인수가 null 가 아닌 경우, 그 길이는 색성분 및 알파 성분보다 작고, 전송형은 <CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>, 또는 <CODE>DataBuffer.TYPE_INT</CODE>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - transferType 가,<code>DataBuffer.TYPE_BYTE</code>,<code>DataBuffer.TYPE_USHORT</code>,<code>DataBuffer.TYPE_INT</code>,<code>DataBuffer.TYPE_SHORT</code>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>
 어떤 것도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 내의 클래스"><CODE>ColorSpace</CODE></A>,
 
<A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스"><CODE>Transparency</CODE></A> </DL>
</DL>
<HR>

<A NAME="ComponentColorModel(java.awt.color.ColorSpace, boolean, boolean, int, int)"><!-- --></A> <H3>
ComponentColorModel</H3>
<PRE>
public <B>ComponentColorModel</B>(<A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 안의 클래스">ColorSpace</A> &nbsp;colorSpace,
                           boolean&nbsp;hasAlpha,
                           boolean&nbsp;isAlphaPremultiplied,
                           int&nbsp;transparency,
                           int&nbsp;transferType)</PRE>
<DL>
<DD>지정된 파라미터로부터,<CODE>ComponentColorModel</CODE>를
 구축합니다. 색성분은, 지정된 <CODE>ColorSpace</CODE> 내가 됩니다. 지원되는 전송형은,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE> 및 <CODE>DataBuffer.TYPE_DOUBLE</CODE> 입니다. 색성분 및 알파 성분마다의 유효 비트수는
 각각 8, 16, 32, 16, 32, 64 입니다. 색성분수는 <CODE>ColorSpace</CODE> 에 있는 성분수가 됩니다. <CODE>hasAlpha</CODE> 가 true
 경우, 알파 성분이 있습니다. <CODE>hasAlpha</CODE> 가 true
 경우, boolean 형의 <CODE>isAlphaPremultiplied</CODE>는

 픽셀치에 있는 컬러 샘플 및 알파 샘플을 평가하는 방법을 지정합니다. boolean 가 true
 경우는
 컬러 샘플은 알파 샘플과 곱셈되었다고 보여집니다. <CODE>transparency</CODE>는

 이 컬러 모델로 표현할 수 있는 알파치를 지정합니다. 허용 되는 <code>transparency</code> 치는
<CODE>OPAQUE</CODE>,<CODE>BITMASK</CODE>, 또는 <CODE>TRANSLUCENT</CODE> 입니다. <CODE>transferType</CODE>는

 픽셀치의 표현에 사용하는 원시적 배열의 형태입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>colorSpace</CODE> - 이 컬러 모델에 관련한 <CODE>ColorSpace</CODE><DD><CODE>hasAlpha</CODE> - true
 경우, 이 컬러 모델은 알파를 지원하는<DD><CODE>isAlphaPremultiplied</CODE> - true
 경우, 알파는 미리 곱셈되고 있는<DD><CODE>transparency</CODE> - 이 컬러 모델로 표현 가능한 알파치를 지정하는<DD><CODE>transferType</CODE> - 픽셀치의 표현에 사용하는 원시적 배열의 형태를 지정한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - transferType 가,<code>DataBuffer.TYPE_BYTE</code>,<code>DataBuffer.TYPE_USHORT</code>,<code>DataBuffer.TYPE_INT</code>,<code>DataBuffer.TYPE_SHORT</code>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>
 어떤 것도 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/color/ColorSpace.html" title="java.awt.color 내의 클래스"><CODE>ColorSpace</CODE></A>,
 
<A HREF="../../../java/awt/Transparency.html" title="java.awt 안의 인터페이스"><CODE>Transparency</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getRed(int)"><!-- --></A> <H3>
getRed</H3>
<PRE>
public int <B>getRed</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 빨강 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. 픽셀의 값은 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 빨강의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRed(int)">getRed</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 적색 성분을 얻는
 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 적색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE>
 성분치가 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getGreen(int)"><!-- --></A> <H3>
getGreen</H3>
<PRE>
public int <B>getGreen</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 초록 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. 픽셀의 값은 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 초록의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getGreen(int)">getGreen</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 녹색 성분을 얻는
 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 녹색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE>
 성분치가 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getBlue(int)"><!-- --></A> <H3>
getBlue</H3>
<PRE>
public int <B>getBlue</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 파랑 성분을 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. 픽셀의 값은 int 로서 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 파랑의 값은 0 이 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getBlue(int)">getBlue</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 청색 성분을 얻는
 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 청색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE>
 성분치가 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getAlpha(int)"><!-- --></A> <H3>
getAlpha</H3>
<PRE>
public int <B>getAlpha</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>지정된 픽셀의 알파 성분을, 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 픽셀치는 int 로서 지정됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlpha(int)">getAlpha</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 알파 성분을 얻는
 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE>
 성분치가 부호 첨부의 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB(int)"><!-- --></A> <H3>
getRGB</H3>
<PRE>
public int <B>getRGB</B>(int&nbsp;pixel)</PRE>
<DL>
<DD>디폴트의 RGB 컬러 모델 형식에서, 픽셀의 색성분 또는 알파 성분을 돌려줍니다. 필요한 경우는
 색변환을 합니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 색성분으로 제산합니다. 알파치가 0
 경우, 컬러치도 0 이 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRGB(int)">getRGB</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 색성분 또는 알파 성분을 얻는
 픽셀
<DT><B>반환값:</B><DD>지정된 픽셀의 색성분 또는 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE>
 성분치가 부호 첨부의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()"><CODE>ColorModel.getRGBdefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRed(java.lang.Object)"><!-- --></A> <H3>
getRed</H3>
<PRE>
public int <B>getRed</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 적색 성분을, 디폴트의 RGB ColorSpace (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. <CODE>pixel</CODE> 치는
 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에
해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 빨강의 값은 0 이 됩니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스가 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRed(java.lang.Object)">getRed</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 적색 성분을 얻는
 픽셀. <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 적색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getGreen(java.lang.Object)"><!-- --></A> <H3>
getGreen</H3>
<PRE>
public int <B>getGreen</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 녹색 성분을, 디폴트의 RGB <CODE>ColorSpace</CODE> (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. <CODE>pixel</CODE> 치는
 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에
해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 초록의 값은 0 이 됩니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getGreen(java.lang.Object)">getGreen</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 녹색 성분을 얻는
 픽셀. <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 녹색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getBlue(java.lang.Object)"><!-- --></A> <H3>
getBlue</H3>
<PRE>
public int <B>getBlue</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 청색 성분을, 디폴트의 RGB <CODE>ColorSpace</CODE> (sRGB)로 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 필요한 경우는
 색변환을 합니다. <CODE>pixel</CODE> 치는
 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에
해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있는 경우, 이 메서드는 값을 돌려주기 전에 알파를 제산합니다. 알파치가 0
 경우, 파랑의 값은 0 이 됩니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getBlue(java.lang.Object)">getBlue</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 청색 성분을 얻는
 픽셀. <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 청색 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getAlpha(java.lang.Object)"><!-- --></A> <H3>
getAlpha</H3>
<PRE>
public int <B>getAlpha</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>지정된 픽셀의 알파 성분을 0 ~ 255
 범위에서 슬캘링 해 돌려줍니다. 픽셀의 값은, 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에
해 지정됩니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlpha(java.lang.Object)">getAlpha</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 알파 성분을 얻는
 픽셀. <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getRGB(java.lang.Object)"><!-- --></A> <H3>
getRGB</H3>
<PRE>
public int <B>getRGB</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;inData)</PRE>
<DL>
<DD>디폴트의 RGB 컬러 모델 형식에서, 픽셀의 색성분 또는 알파 성분을 돌려줍니다. 필요한 경우는
 색변환을 합니다. 픽셀의 값은, 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소로부터 되는 배열에
해 지정됩니다. 반환값은, 미리 곱셈되어 있지 않은 값입니다. 알파가 미리 곱셈되고 있었을 경우, 이 메서드는 색성분으로 알파를 제산합니다. 알파치가 0
 경우, 컬러치는 0 이 됩니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getRGB(java.lang.Object)">getRGB</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inData</CODE> - 색성분 또는 알파 성분을 얻는
 픽셀. <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정한다
<DT><B>반환값:</B><DD>지정된 픽셀의 색성분 또는 알파 성분 (int)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>inData</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>inData</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/ColorModel.html#getRGBdefault()"><CODE>ColorModel.getRGBdefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(int&nbsp;rgb,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel)</PRE>
<DL>
<DD>디폴트의 RGB 컬러 모델의 int 픽셀 표현을 지정해, 이 <CODE>ColorModel</CODE>
 픽셀 데이터 요소 배열 표현을 돌려줍니다. 그 후 이 배열은,<CODE>WritableRaster</CODE> 오브젝트의 <CODE>setDataElements</CODE> 메서드에 건네줄 수가 있습니다. <CODE>pixel</CODE> 파라미터가 null 인 경우는
 새로운 배열을 할당할 수 있습니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rgb</CODE> - RGB 컬러 모델의 정수형 픽셀 표현<DD><CODE>pixel</CODE> - 지정된 픽셀
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE>
 픽셀의 데이터 요소 배열 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>pixel</CODE> 가 null 가 아니고,<CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>pixel</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A>,
 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComponents(int, int[], int)"><!-- --></A> <H3>
getComponents</H3>
<PRE>
public int[] <B>getComponents</B>(int&nbsp;pixel,
                           int[]&nbsp;components,
                           int&nbsp;offset)</PRE>
<DL>
<DD>이 <CODE>ColorModel</CODE>
 픽셀을 지정해, 표준화되어 있지 않은 색성분 또는 알파 성분의 배열을 돌려줍니다. 이 <CODE>ColorModel</CODE>
 성분치가 비표준화 형식에서 표현할 수 없는 경우는
 IllegalArgumentException 가 Throw 됩니다. 색성분이나 알파 성분은,<CODE>components</CODE> 배열의 <CODE>offset</CODE> 위치로부터 포함됩니다. 이것은, 배열이 이 메서드로 할당할 수 있고 있는 경우도 같습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getComponents(int, int[], int)">getComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 정수로 지정되는 픽셀치<DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분을 포함하는 정수형의 배열. <CODE>components</CODE> 배열이 null
 경우는
 새로운 배열을 할당할 수 있는<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD>components 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>components</CODE> 배열이 null 가 아닌 경우에
 offset 로부터의 모든 색성분 및 알파 성분을 보관 유지하는데 충분한 크기가 아닐 때</DL>
</DD>
</DL>
<HR>

<A NAME="getComponents(java.lang.Object, int[], int)"><!-- --></A> <H3>
getComponents</H3>
<PRE>
public int[] <B>getComponents</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                           int[]&nbsp;components,
                           int&nbsp;offset)</PRE>
<DL>
<DD>이 <CODE>ColorModel</CODE>
 픽셀을 지정해, 표준화되어 있지 않은 색성분 또는 알파 성분의 배열을 돌려줍니다. 픽셀의 값은, 오브젝트 참조로서 건네받은 <CODE>transferType</CODE> 형의 데이터 요소에
한 배열로 지정됩니다. 이 <CODE>ColorModel</CODE>
 성분치가 비표준화 형식에서 표현할 수 없는 경우는
 IllegalArgumentException 가 Throw 됩니다. 색성분이나 알파 성분은,<CODE>components</CODE> 배열의 <CODE>offset</CODE>
 위치로부터 포함됩니다. 이것은, 배열이 이 메서드로 할당할 수 있고 있는 경우도 같습니다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 이 메서드는 예외를 Throw 하는 일이 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getComponents(java.lang.Object, int[], int)">getComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - <CODE>transferType</CODE> 형의 데이터 요소의 배열로 지정되는 픽셀치<DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분을 포함하는 정수형의 배열. <CODE>components</CODE> 배열이 null
 경우는
 새로운 배열을 할당할 수 있는<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD><CODE>components</CODE> 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>
 머지않아도 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>pixel</CODE> 가 <CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <CODE>components</CODE> 배열이 null 가 아닌 경우에
 offset 로부터의 모든 색성분 및 알파 성분을 보관 유지하는데 충분한 크기가 아닐 때. 혹은,<CODE>pixel</CODE> 가 이 ColorModel
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getUnnormalizedComponents(float[], int, int[], int)"><!-- --></A> <H3>
getUnnormalizedComponents</H3>
<PRE>
public int[] <B>getUnnormalizedComponents</B>(float[]&nbsp;normComponents,
                                       int&nbsp;normOffset,
                                       int[]&nbsp;components,
                                       int&nbsp;offset)</PRE>
<DL>
<DD>표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. 비표준화 성분은, 0 으로 2<sup>n</sup> - 1
 사이의 부호 없음 정수치입니다. n는

 특정의 성분의 비트수입니다. 표준화 성분은, 이 <code>ColorModel</code>
 <code>ColorSpace</code> 에
해 지정된 1 성분 근처의 최소와 최대의 사이의 float 치입니다. 이 <code>ColorModel</code>
 색성분치가 비표준화 형식에서 표현할 수 없는 경우는
<code>IllegalArgumentException</code> 가 Throw 됩니다. <code>components</code> 배열이 <code>null</code>
 경우는
 새로운 배열을 할당할 수 있습니다. <code>components</code> 배열이 돌려주고집니다. 색성분 및 알파 성분은,<code>offset</code>를
 기점으로 <code>components</code> 배열에 포함됩니다. 배열이 이 메서드로 할당할 수 있고 있는 경우도 같습니다. <code>components</code> 배열이 <code>null</code> 가 아닌 경우에
 (<code>offset</code>를
 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닐 때는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다. <code>normComponents</code> 배열이 <code>normOffset</code>를
 기점으로 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는
<code>IllegalArgumentException</code> 가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getUnnormalizedComponents(float[], int, int[], int)">getUnnormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 성분을 포함하고 있는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 취득을 개시하는
<code>normComponents</code> 배열내의 오프셋(offset)<DD><CODE>components</CODE> - <code>normComponents</code> 로부터 성분을 받는 배열<DD><CODE>offset</CODE> - <code>normComponents</code> 로부터 표준화 성분의 포함을 개시하는
<code>components</code> 내의 인덱스
<DT><B>반환값:</B><DD>표준화되어 있지 않은 색성분 및 알파 성분이 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>normComponents</code> 로부터 <code>normOffset</code>을
 뺀 길이가 <code>numComponents</code> 보다 작은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedComponents(int[], int, float[], int)"><!-- --></A> <H3>
getNormalizedComponents</H3>
<PRE>
public float[] <B>getNormalizedComponents</B>(int[]&nbsp;components,
                                       int&nbsp;offset,
                                       float[]&nbsp;normComponents,
                                       int&nbsp;normOffset)</PRE>
<DL>
<DD>표준화 성분 배열을 지정해, 비표준화 형식에서 모든 색성분 및 알파 성분의 배열을 돌려줍니다. 비표준화 성분은, 0 으로 2<sup>n</sup> - 1
 사이의 부호 없음 정수치입니다. n는

 특정의 성분의 비트수입니다. 표준화 성분은, 이 <code>ColorModel</code>
 <code>ColorSpace</code> 에
해 지정된 1 성분 근처의 최소와 최대의 사이의 float 치입니다. 이 <code>ColorModel</code>
 색성분치가 비표준화 형식에서 표현할 수 없는 경우는
<code>IllegalArgumentException</code> 가 Throw 됩니다. <code>components</code> 배열이 <code>null</code>
 경우는
 새로운 배열을 할당할 수 있습니다. <code>components</code> 배열이 돌려주고집니다. 색성분 및 알파 성분은,<code>offset</code>를
 기점으로 <code>components</code> 배열에 포함됩니다. 배열이 이 메서드로 할당할 수 있고 있는 경우도 같습니다. <code>components</code> 배열이 <code>null</code> 가 아닌 경우에
 (<code>offset</code>를
 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닐 때는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다. <code>normComponents</code> 배열이 <code>normOffset</code>를
 기점으로 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는
<code>IllegalArgumentException</code> 가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getNormalizedComponents(int[], int, float[], int)">getNormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 성분을 포함하고 있는 배열<DD><CODE>offset</CODE> - 표준화되어 있지 않은 성분의 취득을 개시하는
<code>components</code> 배열내의 오프셋(offset)<DD><CODE>normComponents</CODE> - 표준화 성분을 받는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 포함을 개시하는
<code>normComponents</code> 내의 인덱스
<DT><B>반환값:</B><DD>표준화 되고 있는 색성분 및 알파 성분이 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElement(int[], int)"><!-- --></A> <H3>
getDataElement</H3>
<PRE>
public int <B>getDataElement</B>(int[]&nbsp;components,
                          int&nbsp;offset)</PRE>
<DL>
<DD>비정규화된 색성분 혹은 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE>
 int 로서 표현되는 픽셀치를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElement(int[], int)">getDataElement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분의 배열<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD>int 로 표현된 픽셀치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ColorModel</CODE> 에 2 개 이상의 성분이 있는 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(int[], int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(int[]&nbsp;components,
                              int&nbsp;offset,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>비정규화된 색성분 또는 알파 성분의 배열을 지정해, 이 <CODE>ColorModel</CODE>
 픽셀의 데이터 요소 배열 표현을 돌려줍니다. 이 배열은,<CODE>WritableRaster</CODE> 오브젝트의 <CODE>setDataElements</CODE> 메서드에 건네줄 수가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(int[], int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>components</CODE> - 표준화되어 있지 않은 색성분 또는 알파 성분의 배열<DD><CODE>offset</CODE> - <CODE>components</CODE> 배열내의 int 오프셋(offset)<DD><CODE>obj</CODE> - 픽셀의 데이터 요소 배열 표현을 포함하는 오브젝트. <CODE>obj</CODE> 변수가 null
 경우는
 새로운 배열을 할당할 수 있다. <CODE>obj</CODE> 가 null 가 아닌 경우는
<CODE>transferType</CODE> 형의 원시적 배열이 아니면 안된다. <CODE>obj</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우는
<CODE>ArrayIndexOutOfBoundsException</CODE> 가 Throw 된다. <code>ComponentColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속하지만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 된다
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE>
 픽셀의 데이터 요소 배열 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - components 배열이, offset 로부터의 모든 색성분 및 알파 성분을 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <CODE>obj</CODE> 가 null 가 아니고,<CODE>transferType</CODE> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <CODE>obj</CODE> 가 이 <CODE>ColorModel</CODE>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE> 가 비표준화 형식을 지원하지 않는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이,<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>
 머지않아도 아닌 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A>,
 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDataElement(float[], int)"><!-- --></A> <H3>
getDataElement</H3>
<PRE>
public int <B>getDataElement</B>(float[]&nbsp;normComponents,
                          int&nbsp;normOffset)</PRE>
<DL>
<DD>표준화되어 있지 않은 색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code> 에 <code>int</code> 로서 나타내지는 픽셀치를 돌려줍니다. 이 <code>ColorModel</code>
 픽셀치가 단일의 <code>int</code> 로서 표현할 수 없는 경우, 이 메서드는 <code>IllegalArgumentException</code>를
 Throw 합니다. <code>normComponents</code> 배열이 (<code>normOffset</code>를
 기점으로) 모든 색성분 및 알파 성분을 보관 유지하는데 충분한 크기가 아닌 경우는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElement(float[], int)">getDataElement</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 되고 있는 색성분 및 알파 성분의 배열<DD><CODE>normOffset</CODE> - 색성분 및 알파 성분의 취득을 개시하는
<code>normComponents</code> 내의 인덱스
<DT><B>반환값:</B><DD>지정된 성분에 대응하는
 이 <code>ColorModel</code> 내의 <code>int</code> 픽셀치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 이 <code>ColorModel</code>
 픽셀치가 단일의 <code>int</code> 로서 표현할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>normComponents</code> 배열의 크기가 <code>normOffset</code>를
 기점으로 모든 색성분 및 알파 성분을 보관 유지하는데 충분하지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDataElements(float[], int, java.lang.Object)"><!-- --></A> <H3>
getDataElements</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getDataElements</B>(float[]&nbsp;normComponents,
                              int&nbsp;normOffset,
                              <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>표준화색성분 및 알파 성분의 배열을 지정해, 이 <code>ColorModel</code>
 픽셀의 데이터 요소 배열 표현을 돌려줍니다. 이 배열은,<code>WritableRaster</code> 오브젝트의 <code>setDataElements</code> 메서드에 건네줄 수가 있습니다. <code>normComponents</code> 배열이 (<code>normOffset</code>를
 기점으로) 모든 색성분 및 알파 성분을 포함하는데 충분한 크기가 아닌 경우는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다. <code>obj</code> 변수가 <code>null</code>
 경우는
 새로운 배열을 할당할 수 있습니다. <code>obj</code> 가 <code>null</code> 가 아닌 경우는
 transferType 형의 원시적 배열일 필요가 있습니다. 그렇지 않은 경우는
<code>ClassCastException</code> 가 Throw 됩니다. <code>obj</code> 가 이 <code>ColorModel</code>
 픽셀치를 포함하는데 충분한 크기가 아닌 경우는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getDataElements(float[], int, java.lang.Object)">getDataElements</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>normComponents</CODE> - 표준화 되고 있는 색성분 및 알파 성분의 배열<DD><CODE>normOffset</CODE> - 색성분 및 알파 성분의 취득을 개시하는
<code>normComponents</code> 내의 인덱스<DD><CODE>obj</CODE> - 돌려주고진 픽셀을 보관 유지하는 원시적 데이터 배열
<DT><B>반환값:</B><DD>픽셀의 원시적 데이터 배열 표현의 <code>Object</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>obj</code> 가 <code>transferType</code> 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>obj</code> 가 이 <code>ColorModel</code>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우, 혹은 <code>normOffset</code>를
 기점으로 한 <code>normComponents</code> 배열이 모든 색성분 및 알파 성분을 보관 유지하는데 충분한 크기가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html#setDataElements(int, int, java.lang.Object)"><CODE>WritableRaster.setDataElements(int, int, java.lang.Object)</CODE></A>,
 
<A HREF="../../../java/awt/image/SampleModel.html#setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)"><CODE>SampleModel.setDataElements(int, int, java.lang.Object, java.awt.image.DataBuffer)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getNormalizedComponents(java.lang.Object, float[], int)"><!-- --></A> <H3>
getNormalizedComponents</H3>
<PRE>
public float[] <B>getNormalizedComponents</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;pixel,
                                       float[]&nbsp;normComponents,
                                       int&nbsp;normOffset)</PRE>
<DL>
<DD>이 <code>ColorModel</code>
 지정된 픽셀에 대해, 표준화 형식에서 색성분과 알파 성분의 배열을 돌려줍니다. 픽셀치는
 오브젝트 참조로서 건네받는 transferType 형의 데이터 요소의 배열에
해 지정됩니다. pixel 가 transferType 형의 원시적 배열이 아닌 경우는
<code>ClassCastException</code> 가 Throw 됩니다. <code>pixel</code> 가 이 <code>ColorModel</code>
 픽셀치를 포함할 수 있을 만큼 크지 않은 경우는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다. 표준화 성분은, 이 <code>ColorModel</code>
 <code>ColorSpace</code> 오브젝트에
해 지정된 성분마다의 최소와 최대의 사이의 float 치입니다. <code>normComponents</code> 배열이 <code>null</code>
 경우는
 새로운 배열을 할당할 수 있습니다. 그 <code>normComponents</code> 배열이 돌려주고집니다. 색성분과 알파 성분은,<code>normOffset</code> 로부터 시작되는 <code>normComponents</code> 배열에 포함됩니다. 이것은, 배열이 이 메서드로 할당할 수 있고 있는 경우도 같습니다. <code>normComponents</code> 배열이 <code>null</code> 가 아니고, 색성분과 알파 성분 (<code>normOffset</code> 로부터 시작된다)의 모든 것을 포함할 수 있을 만큼 크지 않은 경우는
<code>ArrayIndexOutOfBoundsException</code> 가 Throw 됩니다.
 <p>
서브 클래스가 디폴트와는 다른 방법으로 픽셀 샘플치를 색성분치에 변환하도록 설계되고 있는 경우는
 이 메서드를 서브 클래스에서 오버라이드(override) 할 필요가 있습니다. 이 클래스에
해 구현되는 디폴트의 변환은, 클래스의 코멘트에 기술되고 있습니다. 디폴트가 아닌 변환을 구현하는 서브 클래스는
 이 코멘트에 정의된 허용 변환의 제약에 따를 필요가 있습니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getNormalizedComponents(java.lang.Object, float[], int)">getNormalizedComponents</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pixel</CODE> - 지정된 픽셀<DD><CODE>normComponents</CODE> - 표준화 성분을 받는 배열<DD><CODE>normOffset</CODE> - 표준화 성분의 포함을 개시하는
<code>normComponents</code> 배열내의 오프셋(offset)
<DT><B>반환값:</B><DD>표준화 되고 있는 색성분 및 알파 성분이 포함되고 있는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - <code>pixel</code> 가 transferType 형의 원시적 배열이 아닌 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>normComponents</code>
 크기가 <code>normOffset</code>를
 기점으로 모든 색성분 및 알파 성분을 보관 유지하는데 충분하지 않은 경우
<DD><CODE><A HREF="../../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <code>pixel</code> 가 이 <code>ColorModel</code>
 픽셀치를 보관 유지하는데 충분한 크기가 아닌 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="coerceData(java.awt.image.WritableRaster, boolean)"><!-- --></A> <H3>
coerceData</H3>
<PRE>
public <A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A>  <B>coerceData</B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster,
                             boolean&nbsp;isAlphaPremultiplied)</PRE>
<DL>
<DD>라스터 데이터가 <CODE>isAlphaPremultiplied</CODE> 변수로 지정된 상태와 일치하도록 합니다. 이 때, 데이터는 이 <CODE>ColorModel</CODE> 에
해 현재 올바르게 기술되고 있다고 보여집니다. 이 메서드는
 컬러 라스터 데이터를 알파에서 곱셈 또는 제산합니다. 데이터가 올바른 상태에 있는 경우에는
 처리는 실시하지 않습니다. 데이터가 강제적으로 형태 변환될 필요가 있는 경우, 이 메서드는 <CODE>isAlphaPremultiplied</CODE> 플래그를 올바르게 설정한, 이 <CODE>ColorModel</CODE>
 인스턴스도 돌려줍니다. <code>ColorModel</code>는
 서브 클래스화할 수 있기 때문에
 서브 클래스는 이 메서드의 구현을 상속합니다만, 서브 클래스가 그 구현을 오버라이드(override) 하지 않고, 게다가 지원되어 있지 않은 <code>transferType</code>를
 사용했을 경우, 예외가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#coerceData(java.awt.image.WritableRaster, boolean)">coerceData</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - <code>WritableRaster</code> 데이터<DD><CODE>isAlphaPremultiplied</CODE> - 알파가 미리 곱셈되고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>반환값:</B><DD>강제적으로 형태 변환된 데이터를 나타내는 <code>ColorModel</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>raster</code> 가 <code>null</code> 로 강제 변환이 필요한 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <CODE>ComponentColorModel</CODE>
 전송형이, 지원되고 있는 전송형 (<CODE>DataBuffer.TYPE_BYTE</CODE>,<CODE>DataBuffer.TYPE_USHORT</CODE>,<CODE>DataBuffer.TYPE_INT</CODE>,<CODE>DataBuffer.TYPE_SHORT</CODE>,<CODE>DataBuffer.TYPE_FLOAT</CODE>,<CODE>DataBuffer.TYPE_DOUBLE</CODE>)의 머지않아도 아닌 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isCompatibleRaster(java.awt.image.Raster)"><!-- --></A> <H3>
isCompatibleRaster</H3>
<PRE>
public boolean <B>isCompatibleRaster</B>(<A HREF="../../../java/awt/image/Raster.html" title="java.awt.image 안의 클래스">Raster</A> &nbsp;raster)</PRE>
<DL>
<DD><CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우에 true를
 돌려주고, 그렇지 않은 경우는 false를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#isCompatibleRaster(java.awt.image.Raster)">isCompatibleRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - 호환성을 판정하는 <CODE>Raster</CODE> 오브젝트
<DT><B>반환값:</B><DD><CODE>raster</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우는 <CODE>true</CODE>, 그렇지 않은 경우는 <CODE>false</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="createCompatibleWritableRaster(int, int)"><!-- --></A> <H3>
createCompatibleWritableRaster</H3>
<PRE>
public <A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A>  <B>createCompatibleWritableRaster</B>(int&nbsp;w,
                                                     int&nbsp;h)</PRE>
<DL>
<DD>지정된 폭 및 높이로 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃 (<CODE>SampleModel</CODE>)을 가지는 <CODE>WritableRaster</CODE>를
 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#createCompatibleWritableRaster(int, int)">createCompatibleWritableRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>w</CODE> - 생성하는 <CODE>WritableRaster</CODE>
 폭<DD><CODE>h</CODE> - 생성하는 <CODE>WritableRaster</CODE>
 높이
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 와 호환성이 있는 <CODE>WritableRaster</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스"><CODE>WritableRaster</CODE></A>,
 
<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createCompatibleSampleModel(int, int)"><!-- --></A> <H3>
createCompatibleSampleModel</H3>
<PRE>
public <A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스">SampleModel</A>  <B>createCompatibleSampleModel</B>(int&nbsp;w,
                                               int&nbsp;h)</PRE>
<DL>
<DD>지정된 폭 및 높이로 이 <CODE>ColorModel</CODE> 와 호환성이 있는 데이터 레이아웃을 가지는 <CODE>SampleModel</CODE>를
 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#createCompatibleSampleModel(int, int)">createCompatibleSampleModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>w</CODE> - 생성하는 <CODE>SampleModel</CODE>
 폭<DD><CODE>h</CODE> - 생성하는 <CODE>SampleModel</CODE>
 높이
<DT><B>반환값:</B><DD>이 <CODE>ColorModel</CODE> 와 호환성이 있는 <CODE>SampleModel</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isCompatibleSampleModel(java.awt.image.SampleModel)"><!-- --></A> <H3>
isCompatibleSampleModel</H3>
<PRE>
public boolean <B>isCompatibleSampleModel</B>(<A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 안의 클래스">SampleModel</A> &nbsp;sm)</PRE>
<DL>
<DD>지정된 <CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있을지 어떨지를 판정합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#isCompatibleSampleModel(java.awt.image.SampleModel)">isCompatibleSampleModel</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sm</CODE> - 호환성을 판정하는 <CODE>SampleModel</CODE>
<DT><B>반환값:</B><DD><CODE>SampleModel</CODE> 가 이 <CODE>ColorModel</CODE> 와 호환성이 있는 경우는 <CODE>true</CODE>, 그렇지 않은 경우는 <CODE>false</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/image/SampleModel.html" title="java.awt.image 내의 클래스"><CODE>SampleModel</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAlphaRaster(java.awt.image.WritableRaster)"><!-- --></A> <H3>
getAlphaRaster</H3>
<PRE>
public <A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 내의 클래스">WritableRaster</A>  <B>getAlphaRaster</B>(<A HREF="../../../java/awt/image/WritableRaster.html" title="java.awt.image 안의 클래스">WritableRaster</A> &nbsp;raster)</PRE>
<DL>
<DD>이미지의 알파 채널을 표현하는 <CODE>Raster</CODE>를
, 입력된 <CODE>Raster</CODE> 로부터 추출해 돌려줍니다. 이 메서드는
 이 <CODE>ColorModel</CODE> 에 관련한 <CODE>Raster</CODE> 오브젝트에 알파 밴드가 있으면, 그 알파 밴드를 이미지 데이터의 최종 밴드로서 포함하고 있다고 봅니다. 이 <CODE>ColorModel</CODE> 에 관련한 공간 알파 채널이 그 밖에 없는 경우는
 null를
 돌려줍니다. 이 메서드는 새로운 <CODE>Raster</CODE>를
 작성합니다만, 데이터 배열은 공유하게 됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#getAlphaRaster(java.awt.image.WritableRaster)">getAlphaRaster</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>raster</CODE> - 알파 채널을 추출하는 <CODE>WritableRaster</CODE>
<DT><B>반환값:</B><DD>이미지의 알파 채널이 포함되고 있는 <CODE>WritableRaster</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 컬러 모델과 다른 컬러 모델이 동일한지 어떤지를 비교합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스">ColorModel</A> </CODE> 내의 <CODE><A HREF="../../../java/awt/image/ColorModel.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 이 컬러 모델과 비교하는 오브젝트
<DT><B>반환값:</B><DD>2 개의 컬러 모델 오브젝트가 동일한 경우는 <CODE>true</CODE>, 그렇지 않은 경우는 <CODE>false</CODE><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>,
 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ComponentColorModel.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/image/ColorModel.html" title="java.awt.image 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/image/ComponentSampleModel.html" title="java.awt.image 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/image/ComponentColorModel.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ComponentColorModel.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#fields_inherited_from_class_java.awt.image.ColorModel">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

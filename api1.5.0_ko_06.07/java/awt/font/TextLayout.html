<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:55:44 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
TextLayout (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.font.TextLayout class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="TextLayout (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.font</FONT>
<BR>
클래스 TextLayout</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.font.TextLayout</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>TextLayout</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>TextLayout</code>는

 서식 첨부 문자 데이터의 불변의 그래픽 표현입니다.
 <p>
이 클래스는 다음의 기능을 제공합니다. <ul> <li>암묵적인 쌍방향의 분석과 늘어놓고 대체<li>커서의 위치 지정과 이동 (혼합 방향 텍스트를 위한 분할 커서를 포함한다)<li>하이라이트 (혼합 방향 텍스트를 위한 논리적 하이라이트와 시각적 하이라이트를 포함한다)<li>복수의 baseline (낭만 baseline, 매달려 baseline 및 센터 baseline)<li>히트의 테스트<li>위치 가지런히 하고<li>디폴트 폰트의 치환<li>아센트, 디 센트 및 유효폭등의 시학 정보<li>렌더링 
</ul>

 <p>
<code>TextLayout</code> 오브젝트는
<code>draw</code> 메서드를 사용해 렌더링 할 수 있습니다.
 <p>
<code>TextLayout</code>는

 직접 또는 <A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 안의 클래스"><CODE>LineBreakMeasurer</CODE></A> 를
 개입시켜 작성할 수 있습니다. 직접 작성되는 경우, 소스 텍스트는 1 개의 단락을 나타냅니다. <code>LineBreakMeasurer</code> 에서는
 특정의 폭에 들어가는 복수의 행에 서식 첨부 텍스트를 분할할 수 있습니다. 자세한 것은,<code>LineBreakMeasurer</code>
 문서를 참조하십시오.
 <p>
<code>TextLayout</code>
 구축은, 논리적이게는 다음의 순서로 행해집니다. <ul> <li>단락 속성이 추출되어 조사할 수 있다<li>쌍방향이 늘어놓고 바꾸고를 위해서 텍스트가 분석되어 필요한 경우는 늘어놓고 바꾸고 정보가 계산된다<li>텍스트가 스타일 런에 부분화된다<li>스타일 런용의 폰트가 선택된다. 선택 방법은, 최초로 속성 <A HREF="../../../java/awt/font/TextAttribute.html#FONT"><CODE>TextAttribute.FONT</CODE></A>  가 있는 경우는 폰트가 사용되어 그렇지 않은 경우는
 정의 끝난 속성을 사용해 디폴트 폰트가 계산된다<li>텍스트가 복수의 baseline에 있는 경우, 런 또는 서브 런은 공통의 baseline를 공유하는 서브 런에 한층 더 분할된다<li>선택된 폰트를 사용해 각 런에 그래프
베크톨이 생성된다<li>최종적인 쌍방향이 늘어놓고 바꾸고가 그래프
베크톨로 실행된다 
</ul>

 <p>
<code>TextLayout</code> 오브젝트의 메서드로부터 돌려주고지는 모든 그래픽 정보는
<code>TextLayout</code> 오브젝트의 baseline와 좌단의 교점인 <code>TextLayout</code>
 원점을 기준으로 하고 있습니다. 또,<code>TextLayout</code> 오브젝트의 메서드에게 건네지는 좌표는
<code>TextLayout</code> 오브젝트의 원점을 기준으로 하고 있는 것이라고 보여집니다. 보통
, 클라이언트는
<code>TextLayout</code> 오브젝트의 좌표계와 다른 오브젝트 (<A HREF="../../../java/awt/Graphics.html" title="java.awt 안의 클래스"><CODE>Graphics</CODE></A>  오브젝트등)의 좌표계와의 사이에 변환이 필요하게 됩니다.
 <p>
<code>TextLayout</code> 오브젝트는
 서식 첨부 텍스트로부터 구축됩니다만, 소스 텍스트에의 참조는 보관 유지하지 않습니다. 이 때문에
<code>TextLayout</code>를
 생성하기 위해서 사용된 텍스트에 그 후 변경이 더해져도,<code>TextLayout</code> 에 영향은 없습니다.
 <p>
<code>TextLayout</code> 오브젝트의 3 개의 메서드 (<code>getNextRightHit</code>,<code>getNextLeftHit</code> 및 <code>hitTestChar</code>)는
<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스"><CODE>TextHitInfo</CODE></A> 
 인스턴스를 돌려줍니다. 그러한 <code>TextHitInfo</code> 오브젝트에 포함되는 오프셋(offset)는
<code>TextLayout</code>를
 작성하기 위해서 사용된 텍스트는 아니고,<code>TextLayout</code>
 선두를 기준으로 합니다. 똑같이,<code>TextHitInfo</code>
 인스턴스를 파라미터로서 받는 <code>TextLayout</code>
 메서드도,<code>TextHitInfo</code> 오브젝트의 오프셋(offset)의 기준은 <code>TextLayout</code> 이며, 기본이 되는 텍스트 스토리지 모델은 아니면 상정합니다.
 <p>
<strong>예</strong>:<p> <code>TextLayout</code> 와 그 경계의 구형의 작성 및 렌더링<blockquote>
 <pre>
 Graphics2D g = ...;
 Point2D loc = ...;
 Font font = Font.getFont("Helvetica-bold-italic");
 FontRenderContext frc = g.getFontRenderContext();
 TextLayout layout = new TextLayout("This is a string", font, frc);
 layout.draw(g, (float) loc.getX(), (float) loc.getY());
Rectangle2D bounds = layout.getBounds(); bounds.setRect(bounds.getX() +loc.getX(), bounds.getY() +loc.getY(), bounds.getWidth(), bounds.getHeight()); g.draw(bounds); </pre> </blockquote>
 <p>
<code>TextLayout</code> 로 히트를 테스트합니다 (특정의 그래픽 위치에 있는 문자를 판정한다). <blockquote>
 <pre>
 Point2D click = ...;
 TextHitInfo hit = layout.hitTestChar( (float) (click.getX() - loc.getX()), (float) (click.getY() - loc.getY()));
 </pre>
 </blockquote>
 <p>
오른쪽 커서 키가 밀렸던 것에 반응합니다. <blockquote>
 <pre>
 int insertionIndex = ...;
 TextHitInfo next = layout.getNextRightHit(insertionIndex);
 if (next ! = null) { // translate graphics to origin of layout on screen g.translate(loc.getX(), loc.getY());
 Shape[] carets = layout.getCaretShapes(next.getInsertionIndex());
 g.draw(carets[0]);
 if (carets[1] ! = null) { g.draw(carets[1]);
 } } </pre>
</blockquote>
 <p>
소스 텍스트의 부분 캐릭터 라인에 대응하는 선택 범위를 렌더링 합니다. 선택된 영역은, 시각적으로 연속하지 않은 경우가 있습니다. <blockquote>
 <pre>
 // selStart, selLimit should be relative to the layout, // not to the source text
int selStart = ..., selLimit = ...; Color selectionColor = ...; Shape selection = layout.getLogicalHighlightShape(selStart, selLimit); // selection may consist of disjoint areas // graphics is assumed to be tranlated to origin of layout g.setColor(selectionColor); g.fill(selection); </pre></blockquote>
 <p>
시각적으로 연속한 선택 범위를 렌더링 합니다. 선택 범위는
 소스 텍스트의 복수의 부분 캐릭터 라인에 대응하는 일이 있습니다. 대응하는 소스 텍스트의 부분 캐릭터 라인의 범위는
<code>getLogicalRangesForVisualSelection()</code> 에
해 취득할 수 있습니다. <blockquote>
 <pre>
 TextHitInfo selStart = ..., selLimit = ...;
 Shape selection = layout.getVisualHighlightShape(selStart, selLimit);
 g.setColor(selectionColor);
 g.fill(selection);
 int[] ranges = getLogicalRangesForVisualSelection(selStart, selLimit);
 // ranges[0], ranges[1] is the first selection range, // ranges[2], ranges[3] is the second selection range, etc.  </pre>
</blockquote>
 <p>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html" title="java.awt.font 내의 클래스"><CODE>LineBreakMeasurer</CODE></A>,
 
<A HREF="../../../java/awt/font/TextAttribute.html" title="java.awt.font 안의 클래스"><CODE>TextAttribute</CODE></A>,
 
<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스"><CODE>TextHitInfo</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret의 장소를 결정하는 폴리시를 정의합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스">TextLayout.CaretPolicy</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#DEFAULT_CARET_POLICY">DEFAULT_CARET_POLICY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>CaretPolicy</code>는

 폴리시가 클라이언트에
해 지정되어 있지 않은 경우에 사용됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서식 첨부 텍스트의 반복자로부터 <code>TextLayout</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
           <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code> 및 <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 <code>TextLayout</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)">TextLayout</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
           <A HREF="../../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 내의 클래스">AttributedCharacterIterator.Attribute</A>,
? &gt;&nbsp;attributes,
           <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>String</code> 및 속성 세트로부터 <code>TextLayout</code>를
 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#draw(java.awt.Graphics2D, float, float)">draw</A> </B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> &nbsp;g2,
     float&nbsp;x,
     float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 동안의 클래스"><CODE>Graphics2D</CODE></A>  컨텍스트
의 지정된 위치에 이 <code>TextLayout</code>를
 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Object</code> 가 <code>TextLayout</code> 오브젝트로 지정된 <code>Object</code> 가 이 <code>TextLayout</code> 와 동일한 경우에 <code>true</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#equals(java.awt.font.TextLayout)">equals</A> </B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스">TextLayout</A> &nbsp;rhs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 레이아웃이 동일한 경우에 <code>true</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()">getAdvance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 유효폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getAscent()">getAscent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 아센트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()">getBaseline</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 baseline를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()">getBaselineOffsets</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 로 사용되는 baseline의 오프셋(offset) 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBlackBoxBounds(int, int)">getBlackBoxBounds</A> </B>(int&nbsp;firstEndpoint,
                  int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위에 있는 모든 문자의 블랙 박스 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getBounds()">getBounds</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo)">getCaretInfo</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretInfo</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
             <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo)">getCaretShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 자연 경계내의 지정된 히트에 있는 caret를 나타내는 <code>Shape</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getCaretShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 경계내의 지정된 히트에 있는 caret를 나타내는 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A> 를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int)">getCaretShapes</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D)">getCaretShapes</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)">getCaretShapes</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterCount()">getCharacterCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 가 나타내는 문자수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getCharacterLevel(int)">getCharacterLevel</A> </B>(int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>index</code> 에 있는 문자의 레벨을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getDescent()">getDescent</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 디 센트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)">getJustifiedLayout</A> </B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폭에 행 가지런히 하고 된, 이 <code>TextLayout</code>
 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLeading()">getLeading</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>TextLayout</code>
 leading를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int)">getLogicalHighlightShape</A> </B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 이 <code>TextLayout</code>
 자연 경계까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)">getLogicalHighlightShape</A> </B>(int&nbsp;firstEndpoint,
                         int&nbsp;secondEndpoint,
                         <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 지정된 <code>bounds</code> 까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getLogicalRangesForVisualSelection</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                   <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시각적인 선택 범위에 대응하는 텍스트의 논리적인 범위를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int)">getNextLeftHit</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextLeftHit</A> </B>(int&nbsp;offset,
               <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextLeftHit(java.awt.font.TextHitInfo)">getNextLeftHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int)">getNextRightHit</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)">getNextRightHit</A> </B>(int&nbsp;offset,
                <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getNextRightHit(java.awt.font.TextHitInfo)">getNextRightHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getOutline(java.awt.geom.AffineTransform)">getOutline</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 윤곽을 나타내는 <code>Shape</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisibleAdvance()">getVisibleAdvance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 유효폭을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)">getVisualHighlightShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 시각적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 경계까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)">getVisualHighlightShape</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                        <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint,
                        <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 범위의 시각적인 선택 범위를 둘러싸는 윤곽선을,<code>bounds</code> 까지 확장해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#getVisualOtherHit(java.awt.font.TextHitInfo)">getVisualOtherHit</A> </B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 히트의 caret의 반대측의 히트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#handleJustify(float)">handleJustify</A> </B>(float&nbsp;justificationWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 레이아웃을 행 가지런히 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float)">hitTestChar</A> </B>(float&nbsp;x,
            float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 점에 대응하는 <code>TextHitInfo</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#hitTestChar(float, float, java.awt.geom.Rectangle2D)">hitTestChar</A> </B>(float&nbsp;x,
            float&nbsp;y,
            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 점에 대응하는 <code>TextHitInfo</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isLeftToRight()">isLeftToRight</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 베이스가 될 방향이 왼쪽에서 오른쪽의 경우에 <code>true</code>를
 돌려주고, 오른쪽에서 왼쪽의 경우에 <code>false</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#isVertical()">isVertical</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code> 가 수직의 경우에 <code>true</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/TextLayout.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>TextLayout</code>
 디버그 정보를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_CARET_POLICY"><!-- --></A> <H3>
DEFAULT_CARET_POLICY</H3>
<PRE>
public static final <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스">TextLayout.CaretPolicy</A>  <B>DEFAULT_CARET_POLICY</B></PRE>
<DL>
<DD>이 <code>CaretPolicy</code>는

 폴리시가 클라이언트에
해 지정되어 있지 않은 경우에 사용됩니다. 이 폴리시에서는
 방향이 행의 방향과 같은 문자의 히트가, 반대 방향의 문자의 히트보다 강해집니다. 문자의 방향이 같은 경우, 문자의 리딩 엣지의 히트가, 문자의 트레이 링 엣지의 히트보다 강해집니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TextLayout(java.lang.String, java.awt.Font, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
                  <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD><code>String</code> 및 <A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 <code>TextLayout</code>를
 구축합니다. 모든 텍스트는
 지정된 <code>Font</code>를
 사용해 서식이 설정됩니다.
 <p>
<code>String</code> 에는
 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는
 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>string</CODE> - 표시하는 텍스트<DD><CODE>font</CODE> - 텍스트의 서식을 설정하기 위해서 사용되는 <code>Font</code><DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한 그래픽스 디바이스에 관한 정보를 포함한다. 텍스트 측정은, 디바이스의 해상도에
해 조금 달라, 에일리어징 제거등의 속성에 따라서 다르다. 이 파라미터는
<code>TextLayout</code> 와 유저 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>
<HR>

<A NAME="TextLayout(java.lang.String, java.util.Map, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;string,
                  <A HREF="../../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?  extends <A HREF="../../../java/text/AttributedCharacterIterator.Attribute.html" title="java.text 내의 클래스">AttributedCharacterIterator.Attribute</A>,
? &gt;&nbsp;attributes,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD><code>String</code> 및 속성 세트로부터 <code>TextLayout</code>를
 구축합니다.
 <p>
모든 텍스트는
 지정된 속성에
해 서식이 설정됩니다.
 <p>
<code>string</code> 에는
 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는
 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>string</CODE> - 표시하는 텍스트<DD><CODE>attributes</CODE> - 텍스트의 서식을 설정하기 위해서 사용되는 속성<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한 그래픽스 디바이스에 관한 정보를 포함한다. 텍스트 측정은, 디바이스의 해상도에
해 조금 달라, 에일리어징 제거등의 속성에 따라서 다르다. 이 파라미터는
<code>TextLayout</code> 와 유저 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>
<HR>

<A NAME="TextLayout(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
TextLayout</H3>
<PRE>
public <B>TextLayout</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>서식 첨부 텍스트의 반복자로부터 <code>TextLayout</code>를
 구축합니다.
 <p>
반복자는
 1 단락의 텍스트를 지정할 필요가 있습니다. 쌍방향 알고리즘에서는
 단락 전체가 요구되기 때문입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 표시하는 서식 첨부 텍스트<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한 그래픽스 디바이스에 관한 정보를 포함한다. 텍스트 측정은, 디바이스의 해상도에
해 조금 달라, 에일리어징 제거등의 속성에 따라서 다르다. 이 파라미터는
<code>TextLayout</code> 와 유저 공간의 사이의 이동은 지정하지 않는다</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
protected <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 카피를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 인스턴스의 복제<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getJustifiedLayout(float)"><!-- --></A> <H3>
getJustifiedLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>getJustifiedLayout</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>지정된 폭에 행 가지런히 하고 된, 이 <code>TextLayout</code>
 카피를 작성합니다.
 <p>
이 <code>TextLayout</code> 가 벌써 행 가지런히 하고 되고 있는 경우는 예외가 Throw 됩니다. 이 <code>TextLayout</code> 오브젝트의 행 가지런히 하고 비율이 제로의 경우, 이 <code>TextLayout</code> 과 동일한 <code>TextLayout</code> 가 돌려주고집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>justificationWidth</CODE> - 행 가지런히 하고 하기 위해서 사용하는 폭. 최선의 결과를 얻기 위해서는
 행의 현재의 유효폭과의 차이는 작은 것이 좋다
<DT><B>반환값:</B><DD>지정된 폭에 행 가지런히 하고 된 <code>TextLayout</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/Error.html" title="java.lang 안의 클래스">Error</A> </CODE> - 이 레이아웃이 벌써 행 가지런히 하고 되고 있는 경우, Error 가 Throw 된다</DL>
</DD>
</DL>
<HR>

<A NAME="handleJustify(float)"><!-- --></A> <H3>
handleJustify</H3>
<PRE>
protected void <B>handleJustify</B>(float&nbsp;justificationWidth)</PRE>
<DL>
<DD>이 레이아웃을 행 가지런히 합니다. 행 가지런히 하고를 제어하기 위해서 사브크라사에
해 오버라이드(override) 됩니다 (사브크라사가 있는 경우).
레이아웃은, 단락의 속성 (소스 텍스트로부터 파생. 레이아웃 속성에
해 디폴트로 설정되는 경우가 있다)가 제로 이외의 행 가지런히 하고 비율을 나타내는 경우에만 행 가지런히 하고를 실시합니다. 텍스트는
 지정된 폭에 행 가지런히 하고 됩니다. 현재의 구현은, 행 가지런히 하고 폭을 채우기 위해서 한깅판크츄에이션이나 말미의 공백도 조정합니다. 레이아웃은, 일단 행 가지런히 하고 된 뒤는
 행 가지런히 다시 할 수가 없습니다.
 <p>
코드에 따라서는
 레이아웃의 불변성에
존하는 경우가 있습니다. 사브크라사는 이 메서드를 직접 호출하는 것이 아니라, getJustifiedLayout를
 호출하는 것이 좋을 것입니다. getJustifiedLayout는

 이 레이아웃의 복제에 대해서 이 메서드를 호출하므로 원의 레이아웃은 보존됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>justificationWidth</CODE> - 행 가지런히 하고 하기 위해서 사용하는 폭. 최선의 결과를 얻기 위해서는
 행의 현재의 유효폭과의 차이는 작은 것이 좋은<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getJustifiedLayout(float)"><CODE>getJustifiedLayout(float)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBaseline()"><!-- --></A> <H3>
getBaseline</H3>
<PRE>
public byte <B>getBaseline</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 baseline를 돌려줍니다. baseline는
<code>Font</code> 로 정의되는 값 (roman, centered, hanging)의 1 개입니다. 아센트 및 디 센트는
 이 baseline를 기준으로 합니다. <code>baselineOffsets</code> 도 이 baseline를 기준으로 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 baseline<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaselineOffsets()"><CODE>getBaselineOffsets()</CODE></A>,
 
<A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBaselineOffsets()"><!-- --></A> <H3>
getBaselineOffsets</H3>
<PRE>
public float[] <B>getBaselineOffsets</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 로 사용되는 baseline의 오프셋(offset) 배열을 돌려줍니다.
 <p>
이 배열은,<code>Font</code> 로 정의되는 값 (roman, centered, hanging)의 1 개로 인덱스 붙이고 됩니다. 이러한 값은, 이 <code>TextLayout</code> 오브젝트의 baseline를 기준으로 합니다. 그 때문에
<code>getBaselineOffsets[getBaseline()] == 0</code> 이 됩니다. 오프셋(offset)를 <code>TextLayout</code> 오브젝트의 baseline의 위치에 가산하면, 새로운 baseline의 위치를 취득할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 에 사용되는 baseline를 포함하는 오프셋(offset) 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBaseline()"><CODE>getBaseline()</CODE></A>,
 
<A HREF="../../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAdvance()"><!-- --></A> <H3>
getAdvance</H3>
<PRE>
public float <B>getAdvance</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 유효폭을 돌려줍니다. 유효폭은, 행의 방향으로 측정한, 원점에서 우단 (하단)의 문자의 유효폭까지의 거리입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 유효폭</DL>
</DD>
</DL>
<HR>

<A NAME="getVisibleAdvance()"><!-- --></A> <H3>
getVisibleAdvance</H3>
<PRE>
public float <B>getVisibleAdvance</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 유효폭을 돌려줍니다. 말미의 공백은 포함되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 말미의 공백을 제외한 유효폭<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getAdvance()"><CODE>getAdvance()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAscent()"><!-- --></A> <H3>
getAscent</H3>
<PRE>
public float <B>getAscent</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 아센트를 돌려줍니다. 아센트는
<code>TextLayout</code> 위 ( 오른쪽)로부터 baseline까지의 거리입니다. 이 거리는 항상 정의 값 또는 제로입니다. 아센트는
 상 첨부 텍스트를 포함하기 위해서 충분한 크기이며, 각 그래프
의 아센트, 오프셋(offset) 및 baseline의 합계의 최대치입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 아센트</DL>
</DD>
</DL>
<HR>

<A NAME="getDescent()"><!-- --></A> <H3>
getDescent</H3>
<PRE>
public float <B>getDescent</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 디 센트를 돌려줍니다. 디 센트는
 baseline로부터 <code>TextLayout</code> 아래 (왼쪽)까지의 거리입니다. 이 거리는 항상 정의 값 또는 제로입니다. 디 센트는
 하부나무 텍스트를 포함하기 위해서 충분한 크기이며, 각 그래프
의 디 센트, 오프셋(offset) 및 baseline의 합계의 최대치입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 디 센트</DL>
</DD>
</DL>
<HR>

<A NAME="getLeading()"><!-- --></A> <H3>
getLeading</H3>
<PRE>
public float <B>getLeading</B>()</PRE>
<DL>
<DD><code>TextLayout</code>
 leading를 돌려줍니다. leading는
 이 <code>TextLayout</code> 용으로서 추천 되고 있는 행간 스페이스입니다.
 <p>
leading는
<code>TextLayout</code>
 모든 그래프
베크톨의 leading, 디 센트 및 baseline로부터 계산됩니다. 알고리즘은, 대략 다음과 같습니다. <blockquote>
 <pre>
 maxD = 0;
 maxDL = 0;
 for (GlyphVector g in all glyphvectors) { maxD = max(maxD, g.getDescent() + offsets[g.getBaseline()]);
 maxDL = max(maxDL, g.getDescent() + g.getLeading() + offsets[g.getBaseline()]);
 } return maxDL - maxD;
 </pre>
</blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 선두</DL>
</DD>
</DL>
<HR>

<A NAME="getBounds()"><!-- --></A> <H3>
getBounds</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 내의 클래스">Rectangle2D</A>  <B>getBounds</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 경계를 돌려줍니다. 경계에는
<code>TextLayout</code>를
 렌더링 할 수 있는 모든 픽셀이 포함됩니다. <code>TextLayout</code>
 아센트, 디 센트, 원점, 또는 유효폭과 완전하게는 일치하지 않는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 경계인 <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 동안의 클래스"><CODE>Rectangle2D</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isLeftToRight()"><!-- --></A> <H3>
isLeftToRight</H3>
<PRE>
public boolean <B>isLeftToRight</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 베이스가 될 방향이 왼쪽에서 오른쪽의 경우에 <code>true</code>를
 돌려주고, 오른쪽에서 왼쪽의 경우에 <code>false</code>를
 돌려줍니다. <code>TextLayout</code> 에는
 왼쪽에서 오른쪽 (LTR) 또는 오른쪽에서 왼쪽 (RTL)의 어느 쪽인가의 베이스가 될 방향이 있습니다. 베이스가 될 방향은, 행의 텍스트의 실제의 방향 (LTR, RTL, 또는 혼합)에는
존하지 않습니다. 왼쪽에서 오른쪽의 레이아웃은, 디폴트에서는 좌단 가지런히 하가 됩니다. 레이아웃이 탭 첨부의 행에 놓여졌을 경우, 탭은 왼쪽에서 오른쪽이 되므로 논리적으로 연속하는 레이아웃은 왼쪽에서 오른쪽으로 배치됩니다. RTL 레이아웃의 경우는 이 반대입니다. 이 경우, 디폴트에서는 우단 가지런히 해 탭은 오른쪽에서 왼쪽이 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 베이스가 될 방향이 왼쪽에서 오른쪽의 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="isVertical()"><!-- --></A> <H3>
isVertical</H3>
<PRE>
public boolean <B>isVertical</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 가 수직의 경우에 <code>true</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code> 가 수직의 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterCount()"><!-- --></A> <H3>
getCharacterCount</H3>
<PRE>
public int <B>getCharacterCount</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code> 가 나타내는 문자수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 문자수</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
                            <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD><code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. 배열의 최초의 요소는
 caret와 baseline의 교점입니다. 배열의 2 번째의 요소는
 caret의 역기울기 (런/라이즈)입니다.
 <p>
이 메서드는
 정보  위해서만 사용됩니다. caret를 표시하려면,
<code>getCaretShapes</code>를
 사용해 주세요.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code>
 문자의 히트<DD><CODE>bounds</CODE> - caret 정보가 구축되는 경계
<DT><B>반환값:</B><DD>caret의 위치와 기울기가 포함되고 있는 2 요소 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><CODE>getCaretShapes(int, Rectangle2D, TextLayout.CaretPolicy)</CODE></A>,
 
<A HREF="../../../java/awt/Font.html#getItalicAngle()"><CODE>Font.getItalicAngle()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCaretInfo(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getCaretInfo</H3>
<PRE>
public float[] <B>getCaretInfo</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD><code>hit</code> 에 대응하는 caret에 대한 정보를 돌려줍니다. 이 메서드는
<code>getCaretInfo</code>
 간이 overload이며, 이 <code>TextLayout</code>
 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code>
 문자의 히트
<DT><B>반환값:</B><DD>히트에 대응하는 caret에 대한 정보</DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code>를
 돌려줍니다. 히트 문자의 인덱스가 경계내에 없는 경우는
<A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스"><CODE>IllegalArgumentException</CODE></A>  가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 레이아웃의 문자의 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(int&nbsp;offset,
                                   <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주고집니다. 히트는
 지정된 폴리시에
한, 지정된 오프셋(offset) 위치의 강한 caret의 우측에 있습니다. 돌려주고지는 히트는
 지정된 폴리시에
한, 2 개의 히트의 강한 (분)빌트인니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 삽입 오프셋(offset). 0 보다 작은 값이나 <code>TextLayout</code> 오브젝트의 문자 카운트보다 큰 값은 불가<DD><CODE>policy</CODE> - 강한 caret를 선택하기 위해서 사용되는 폴리시
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextRightHit(int)"><!-- --></A> <H3>
getNextRightHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextRightHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>오른쪽 (하) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주고집니다. 히트는
 디폴트의 폴리시에
한, 지정된 오프셋(offset) 위치의 강한 caret의 오른쪽에 있습니다. 돌려주고지는 히트는
 디폴트의 폴리시에
한, 2 개의 히트의 강한 (분)빌트인니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 삽입 오프셋(offset). 0 보다 작은 값이나 <code>TextLayout</code> 오브젝트의 문자 카운트보다 큰 값은 불가
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 오른쪽 (하) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주고집니다. 히트 문자의 인덱스가 경계내에 없는 경우는
<code>IllegalArgumentException</code> 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 이 <code>TextLayout</code>
 문자의 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(int&nbsp;offset,
                                  <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주고집니다. 히트는
 지정된 폴리시에
한, 지정된 오프셋(offset) 위치의 강한 caret의 왼쪽에 있습니다. 돌려주고지는 히트는
 지정된 폴리시에
한, 2 개의 히트의 강한 (분)빌트인니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 삽입 오프셋(offset). 0 보다 작은 값이나 <code>TextLayout</code> 오브젝트의 문자 카운트보다 큰 값은 불가<DD><CODE>policy</CODE> - 강한 caret를 선택하기 위해서 사용되는 폴리시
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getNextLeftHit(int)"><!-- --></A> <H3>
getNextLeftHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getNextLeftHit</B>(int&nbsp;offset)</PRE>
<DL>
<DD>왼쪽 (상) 방향의 다음의 caret의 히트를 돌려줍니다. 이 방향으로 히트가 없는 경우는 <code>null</code> 가 돌려주고집니다. 히트는
 디폴트의 폴리시에
한, 지정된 오프셋(offset) 위치의 강한 caret의 왼쪽입니다. 돌려주고지는 히트는
 디폴트의 폴리시에
한, 2 개의 히트의 강한 (분)빌트인니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 삽입 오프셋(offset). 0 보다 작은 값이나 <code>TextLayout</code> 오브젝트의 문자 카운트보다 큰 값은 불가
<DT><B>반환값:</B><DD>지정된 히트의 caret에 대해서 왼쪽 (상) 방향에 위치하는 다음의 caret의 히트, 또는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getVisualOtherHit(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getVisualOtherHit</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>getVisualOtherHit</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>지정된 히트의 caret의 반대측의 히트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - 지정된 히트
<DT><B>반환값:</B><DD>지정된 히트의 caret의 반대 측에 있는 히트</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit,
                           <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 경계내의 지정된 히트에 있는 caret를 나타내는 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A> 를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - caret를 생성하는 히트<DD><CODE>bounds</CODE> - caret의 생성으로 사용하는 <code>TextLayout</code>
 경계
<DT><B>반환값:</B><DD>caret를 나타내는 <code>Shape</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShape(java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getCaretShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getCaretShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;hit)</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 자연 경계내의 지정된 히트에 있는 caret를 나타내는 <code>Shape</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hit</CODE> - caret를 생성하는 히트
<DT><B>반환값:</B><DD>caret를 나타내는 <code>Shape</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterLevel(int)"><!-- --></A> <H3>
getCharacterLevel</H3>
<PRE>
public byte <B>getCharacterLevel</B>(int&nbsp;index)</PRE>
<DL>
<DD><code>index</code> 에 있는 문자의 레벨을 돌려줍니다. 인덱스 -1 및 <code>characterCount</code> 에는
 이 <code>TextLayout</code>
 기저 레벨을 할당할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>index</CODE> - 레벨을 얻는
 문자의 인덱스
<DT><B>반환값:</B><DD>지정된 인덱스에 있는 문자의 레벨</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D, java.awt.font.TextLayout.CaretPolicy)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds,
                              <A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 안의 클래스">TextLayout.CaretPolicy</A> &nbsp;policy)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 오프셋(offset)<DD><CODE>bounds</CODE> - caret를 확장하는 경계<DD><CODE>policy</CODE> - 지정한 <code>CaretPolicy</code>
<DT><B>반환값:</B><DD>2 살의 패스의 배열. 요소 0 은 강한 caret. 2 개의 caret가 있는 경우, 요소 1 은 약한 caret. 그렇지 않은 경우, 요소 1 은 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset,
                              <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. 이 메서드는
<code>getCaretShapes</code>
 간이 overload이며, 디폴트의 caret 폴리시를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 오프셋(offset)<DD><CODE>bounds</CODE> - caret를 확장하는 경계
<DT><B>반환값:</B><DD><code>DEFAULT_CARET_POLICY</code> 에서의 정의에
한, 강한 caret와 약한 caret에 대응하는 2 살의 패스</DL>
</DD>
</DL>
<HR>

<A NAME="getCaretShapes(int)"><!-- --></A> <H3>
getCaretShapes</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> [] <B>getCaretShapes</B>(int&nbsp;offset)</PRE>
<DL>
<DD>강한 caret와 약한 caret에 대응하는 2 개의 윤곽선을 돌려줍니다. 이 메서드는
<code>getCaretShapes</code>
 간이 overload이며, 디폴트의 caret 폴리시 및 이 <code>TextLayout</code> 오브젝트의 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 이 <code>TextLayout</code>
 오프셋(offset)
<DT><B>반환값:</B><DD><code>DEFAULT_CARET_POLICY</code> 에서의 정의에
한, 강한 caret와 약한 caret에 대응하는 2 살의 패스</DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getLogicalRangesForVisualSelection</H3>
<PRE>
public int[] <B>getLogicalRangesForVisualSelection</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                                <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</PRE>
<DL>
<DD>시각적인 선택 범위에 대응하는 텍스트의 논리적인 범위를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 범위의 이제(벌써) 한편의 단 점 <code>firstEndpoint</code> 보다 작아도 가능
<DT><B>반환값:</B><DD>선택된 범위의 개시/리밋트의 페어를 나타내는 정수의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint,
                                     <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 범위의 시각적인 선택 범위를 둘러싸는 윤곽선을,<code>bounds</code> 까지 확장해 돌려줍니다.
 <p>
선택 범위에
 좌단 (상단)의 위치가 포함되는 경우, 그 선택 범위는 <code>bounds</code>
 왼쪽 (위)까지 확장됩니다. 그 선택 범위에 우단 (하단)의 위치가 포함되는 경우, 선택 범위는 경계의 오른쪽 (아래)까지 확장됩니다. 선택 범위의 높이 (수직선상의 폭)는
 항상 <code>bounds</code> 까지 확장됩니다.
 <p>
선택 범위는 항상 연속하고 있습니다만, 혼합 방향 텍스트의 행의 경우, 논리적으로 선택된 텍스트는 불연속이 되는 일이 있습니다. 선택된 텍스트의 논리적인 범위는
<code>getLogicalRangesForVisualSelection</code>를
 사용해 취득할 수 있습니다. 예를 들어, 「ABCdef」라고 하는 텍스트를 예에 생각해 보겠습니다. 대문자는 오른쪽에서 왼쪽의 텍스트를 나타내, 오른쪽에서 왼쪽의 행으로 렌더링 되어 시각적인 선택 범위는 0L ( 「A」의 리딩 엣지)에서 3T ( 「d」의 트레이 링 엣지)입니다. 이 텍스트는 다음과 같이 표시됩니다. 밑줄 첨부 볼드의 영역은 선택 범위를 나타내고 있습니다. <br>
 <pre>
 d<u><b>efCBA  </b></u></pre> 논리적인 선택 범위는
 0 ~ 3, 4 ~ 6 (ABC, ef)입니다. 왜냐하면, 시각적으로 연속한 텍스트는 논리적이게는 불연속이기 때문입니다. 또, 레이아웃의 우단의 위치 ( 「A」의 우측)가 선택되고 있으므로 선택 범위는 경계의 오른쪽까지 확장됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 선택 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 선택 범위의 이제(벌써) 한편의 단 점<DD><CODE>bounds</CODE> - 선택 범위가 확장되는 경계의 구형
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code><DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getLogicalRangesForVisualSelection(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><CODE>getLogicalRangesForVisualSelection(TextHitInfo, TextHitInfo)</CODE></A>,
 
<A HREF="../../../java/awt/font/TextLayout.html#getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><CODE>getLogicalHighlightShape(int, int, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo)"><!-- --></A> <H3>
getVisualHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getVisualHighlightShape</B>(<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;firstEndpoint,
                                     <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 안의 클래스">TextHitInfo</A> &nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위의 시각적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 경계까지 확장해 돌려줍니다. 이 메서드는
<code>getVisualHighlightShape</code>
 간이 overload이며, 이 <code>TextLayout</code>
 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 시각적인 선택 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 시각적인 선택 범위의 이제(벌써) 한편의 단 점
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint,
                                      <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 지정된 <code>bounds</code> 까지 확장해 돌려줍니다.
 <p>
선택 범위에 최초의 논리 문자가 포함되어 있는 경우, 그 선택 범위는 이 <code>TextLayout</code>
 선두의 앞의 <code>bounds</code>
 부분까지 확장됩니다. 선택 범위에 마지막 논리 문자가 포함되어 있는 경우, 그 선택 범위는 이 <code>TextLayout</code>
 마지막 나머지의 <code>bounds</code>
 부분까지 확장됩니다. 선택 범위의 높이 (수직선상의 폭)는
 항상 <code>bounds</code> 까지 확장됩니다.
 <p>
혼합 방향 텍스트의 행의 경우, 선택 범위가 불연속이 되는 일이 있습니다. 선두와 리밋트의 사이의 논리적인 범위에 위치하는 문자만이 선택되어 있는 것처럼 보입니다. 예를 들어, 「ABCdef」라고 하는 텍스트를 예에 생각해 보겠습니다. 대문자는 오른쪽에서 왼쪽의 텍스트를 나타내, 오른쪽에서 왼쪽의 행으로 렌더링 되어 논리적인 선택 범위는 0 ~ 4 (ABCd)입니다. 텍스트는 다음과 같이 표시됩니다. 선택 범위는 볼드로 표시되어 확장 부분은 밑줄로 표시됩니다. <br>
 <pre>
 <u><b>d</b></u>ef<u><b>CBA  </b></u></pre> 선택 범위는 불연속입니다. 그 이유는
 선택된 문자가 시각적으로 불연속이기 때문입니다. 또, 선택 범위에 최초의 논리 문자 (A)가 포함되기 때문에
 선택 범위는 레이아웃의 선두보다 전의 <code>bounds</code>
 부분까지 확장됩니다. 이 경우 ( 오른쪽에서 왼쪽의 행)는
<code>bounds</code>
 오른쪽의 부분입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 선택하는 문자의 범위의 단 점<DD><CODE>secondEndpoint</CODE> - 선택하는 문자의 범위의 이제(벌써) 한편의 단 점 <code>firstEndpoint</code> 보다 작아도 가능. min(firstEndpoint, secondEndpoint)의 문자는 범위에 포함되지만, max(firstEndpoint, secondEndpoint)는 범위로부터 제외되는<DD><CODE>bounds</CODE> - 선택 범위가 확장되는 경계의 구형
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 영역<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getVisualHighlightShape(java.awt.font.TextHitInfo, java.awt.font.TextHitInfo, java.awt.geom.Rectangle2D)"><CODE>getVisualHighlightShape(TextHitInfo, TextHitInfo, Rectangle2D)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLogicalHighlightShape(int, int)"><!-- --></A> <H3>
getLogicalHighlightShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getLogicalHighlightShape</B>(int&nbsp;firstEndpoint,
                                      int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위의 논리적인 선택 범위를 둘러싸는 <code>Shape</code>를
, 이 <code>TextLayout</code>
 자연 경계까지 확장해 돌려줍니다. 이 메서드는
<code>getLogicalHighlightShape</code>
 간이 overload이며, 이 <code>TextLayout</code>
 자연 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 선택하는 문자의 범위의 단 점<DD><CODE>secondEndpoint</CODE> - 선택하는 문자의 범위의 이제(벌써) 한편의 단 점 <code>firstEndpoint</code> 보다 작아도 가능. min(firstEndpoint, secondEndpoint)의 문자는 범위에 포함되지만, max(firstEndpoint, secondEndpoint)는 범위로부터 제외된다
<DT><B>반환값:</B><DD>선택 범위를 둘러싸는 <code>Shape</code></DL>
</DD>
</DL>
<HR>

<A NAME="getBlackBoxBounds(int, int)"><!-- --></A> <H3>
getBlackBoxBounds</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getBlackBoxBounds</B>(int&nbsp;firstEndpoint,
                               int&nbsp;secondEndpoint)</PRE>
<DL>
<DD>지정된 범위에 있는 모든 문자의 블랙 박스 경계를 돌려줍니다. 블랙 박스 경계란
 개시와 리밋트의 사이의 모든 문자에 대응하는 모든 그래프
의 바운딘그복스의 결합으로 구성되는 영역입니다. 이 윤곽선은, 분리하고 있는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>firstEndpoint</CODE> - 문자의 범위의 한편의 단 점<DD><CODE>secondEndpoint</CODE> - 문자의 범위의 이제(벌써) 한편의 단 점 <code>firstEndpoint</code> 보다 작아도 가능
<DT><B>반환값:</B><DD>블랙 박스 경계를 둘러싸는<code>패스</code></DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float, java.awt.geom.Rectangle2D)"><!-- --></A> <H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y,
                               <A HREF="../../../java/awt/geom/Rectangle2D.html" title="java.awt.geom 안의 클래스">Rectangle2D</A> &nbsp;bounds)</PRE>
<DL>
<DD>지정된 점에 대응하는 <code>TextHitInfo</code>를
 돌려줍니다. <code>TextLayout</code>
 경계의 외측의 좌표는
 행의 문자의 위치에 관계없이, 최초의 논리 문자의 리딩 엣지, 또는 마지막 논리 문자의 트레이 링 엣지의 어느 쪽인지 적절한 (분)편의 히트에 대응합니다. baseline에 따른 방향만이, 이 평가에 사용됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 이 <code>TextLayout</code>
 원점으로부터의 x 오프셋(offset)<DD><CODE>y</CODE> - 이 <code>TextLayout</code>
 원점으로부터의 y 오프셋(offset)<DD><CODE>bounds</CODE> - <code>TextLayout</code>
 경계
<DT><B>반환값:</B><DD>지정된 점보다 아래의 문자 및 엣지 (선두 또는 말미)를 기술하는 히트</DL>
</DD>
</DL>
<HR>

<A NAME="hitTestChar(float, float)"><!-- --></A> <H3>
hitTestChar</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스">TextHitInfo</A>  <B>hitTestChar</B>(float&nbsp;x,
                               float&nbsp;y)</PRE>
<DL>
<DD>지정된 점에 대응하는 <code>TextHitInfo</code>를
 돌려줍니다. 이 메서드는
<code>hitTestChar</code>
 간이 overload이며, 이 <code>TextLayout</code>
 자연스러운 경계를 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 이 <code>TextLayout</code>
 원점으로부터의 x 오프셋(offset)<DD><CODE>y</CODE> - 이 <code>TextLayout</code>
 원점으로부터의 y 오프셋(offset)
<DT><B>반환값:</B><DD>지정된 점보다 아래의 문자 및 엣지 (선두 또는 말미)를 기술하는 히트</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 해시 코드<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>,
 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>지정된 <code>Object</code> 가 <code>TextLayout</code> 오브젝트로 지정된 <code>Object</code> 가 이 <code>TextLayout</code> 와 동일한 경우에 <code>true</code>를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 동일한지 어떤지가 판정되는 <code>Object</code>
<DT><B>반환값:</B><DD>지정된 <code>Object</code> 가 이 <code>TextLayout</code> 와 동일한 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>,
 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.awt.font.TextLayout)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스">TextLayout</A> &nbsp;rhs)</PRE>
<DL>
<DD>2 개의 레이아웃이 동일한 경우에 <code>true</code>를
 돌려줍니다. 2 개의 레이아웃은, 그것들이 같은 순서로 같은 그래프
베크톨을 포함하고 있는 경우에 동일해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rhs</CODE> - 이 <code>TextLayout</code> 와 비교하는 <code>TextLayout</code>
<DT><B>반환값:</B><DD>지정된 <code>TextLayout</code> 이 이 <code>TextLayout</code> 와 동일한 경우는 <code>true</code></DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 디버그 정보를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 <code>textLine</code>를
 나타내는 <code>String</code></DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Graphics2D, float, float)"><!-- --></A> <H3>
draw</H3>
<PRE>
public void <B>draw</B>(<A HREF="../../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> &nbsp;g2,
                 float&nbsp;x,
                 float&nbsp;y)</PRE>
<DL>
<DD>지정된 <A HREF="../../../java/awt/Graphics2D.html" title="java.awt 동안의 클래스"><CODE>Graphics2D</CODE></A>  컨텍스트
의 지정된 위치에 이 <code>TextLayout</code>를
 렌더링 합니다. 레이아웃의 원점은 x, &nbsp;y 입니다. 렌더링는
 이 정도치의 <code>getBounds()</code> 내의 임의의 점에 접합니다. <code>g2</code>는
 변경되지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g2</CODE> - 레이아웃의 렌더링처의 <code>Graphics2D</code> 컨텍스트
<DD><CODE>x, &nbsp;y</CODE> - 이 <code>TextLayout</code>
 원점의 좌표<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html#getBounds()"><CODE>getBounds()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getOutline(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
getOutline</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getOutline</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;tx)</PRE>
<DL>
<DD>이 <code>TextLayout</code>
 윤곽을 나타내는 <code>Shape</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 이 <code>TextLayout</code>
 윤곽에 적용하는 임의 지정 <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 중의 클래스"><CODE>AffineTransform</CODE></A> 
<DT><B>반환값:</B><DD>이 <code>TextLayout</code>
 윤곽인 <code>Shape</code></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/TextLayout.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/font/TextHitInfo.html" title="java.awt.font 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/TextLayout.CaretPolicy.html" title="java.awt.font 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/font/TextLayout.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="TextLayout.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

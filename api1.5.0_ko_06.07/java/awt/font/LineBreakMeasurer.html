<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:55:43 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
LineBreakMeasurer (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.font.LineBreakMeasurer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="LineBreakMeasurer (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LineBreakMeasurer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/font/ImageGraphicAttribute.html" title="java.awt.font 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/LineMetrics.html" title="java.awt.font 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/font/LineBreakMeasurer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="LineBreakMeasurer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.font</FONT>
<BR>
클래스 LineBreakMeasurer</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.font.LineBreakMeasurer</B>
</PRE>
<HR>
<DL>
<DT><PRE>public final class <B>LineBreakMeasurer</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>LineBreakMeasurer</code> 클래스를 사용하면, 서식 첨부 텍스트를, 특정의 가시 유효폭에 들어가는 행 (또는 세그먼트(segment))으로 나눌 수가 있습니다. 이것은, 고유의 폭 (<b>랩핑폭</b>으로 불린다)에 들어가는 텍스트의 단락을 클라이언트에 표시하는 경우에 편리합니다.
 <p>
<code>LineBreakMeasurer</code>는

 서식 첨부 텍스트에 대한 반복자를 사용해 구축됩니다. 반복자의 범위는 텍스트내의 1 개의 단락입니다. <code>LineBreakMeasurer</code>는

 다음의 텍스트 세그먼트(segment)를 개시하기 위해서, 텍스트내의 위치를 포함합니다. 처음은, 이 정도치가 텍스트의 시점입니다. 단락의 방향은, 쌍방향 포맷 규칙에 따라, 전방향 (왼쪽에서 오른쪽 또는 오른쪽에서 왼쪽)에 이릅니다. 단락으로부터 취득된 모든 세그먼트(segment)는
 그 단락과 같은 방향이 됩니다.
 <p>
텍스트의 세그먼트(segment)는
<code>nextLayout</code> 메서드를 호출하는 것으로 취득됩니다. 이 메서드는
 랩핑폭에 들어가는 텍스트를 나타내는 <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 동안의 클래스"><CODE>TextLayout</CODE></A> 를
 돌려줍니다. <code>nextLayout</code> 메서드는
<code>nextLayout</code> 가 돌려준 레이아웃의 구석에 현재의 위치를 이동합니다.
 <p>
<code>LineBreakMeasurer</code>는

 가장 일반적인 다음의 개행을 구현합니다. 랩핑폭에 들어가는 모든 단어는
 같은 행에 배치됩니다. 최초의 단어가 수습되지 않으면, 랩핑폭에 들어갈 뿐의 문자가 그 행에 배치됩니다. 각 행에는 적어도 1 문자가 배치됩니다.
 <p>
<code>LineBreakMeasurer</code> 에
해 돌려주고지는 <code>TextLayout</code>
 인스턴스는
 탭을 폭 0
 스페이스와 같게 취급합니다. 위치 결정을 위해서 탭 단락의 세그먼트(segment)를 얻는
 클라이언트는
 텍스트에 대한 리밋트 오프셋(offset)를 취하는 <code>nextLayout</code>
 overload를 사용하도록 해 주세요. 리밋트 오프셋(offset)는
 탭 이후의 최초의 문자입니다. 이 메서드가 돌려주는 <code>TextLayout</code> 오브젝트는
 지정된 리밋트 (현재의 위치와 리밋트와의 사이의 텍스트가 랩핑폭에 들어가지 않는 경우에는
 리밋트의 전)로 끝납니다.
 <p>
탭 단락의 텍스트를 레이아웃 하는 클라이언트에는
 최초의 세그먼트(segment)를 행에 배치한 뒤, 약간 다른 개행 폴리시가 필요합니다. 나머지의 영역에 일부의 단어를 거두는 것이 아니라, 전체를 다음의 행에 배치합니다. 폴리시의 이 변경은,<code>boolean</code> 파라미터를 취하는 <code>nextLayout</code>
 overload로 요구할 수 있습니다. 이 파라미터가 <code>true</code>
 경우,<code>nextLayout</code>는

 최초의 단어가 지정된 영역에 들어가지 않을 때에 <code>null</code>를
 돌려줍니다. 아래와 같은 탭 샘플을 참조하십시오.
 <p>
보통
,<code>LineBreakMeasurer</code>
 작성에 사용된 텍스트가 변경되었을 경우는
 변경을 반영하기 위해서 새로운 <code>LineBreakMeasurer</code>를
 작성할 필요가 있습니다 (지금까지의 <code>LineBreakMeasurer</code>는
 그대로 정상적으로 동작하지만, 텍스트의 변경에는 대응하지 않는다). 다만, 텍스트의 변경이 1 문자의 삽입 또는 삭제의 경우에는
<code>insertChar</code> 또는 <code>deleteChar</code>를
 호출해, 기존의 <code>LineBreakMeasurer</code>를
 「갱신」해도 괜찮습니다. 기존의 <code>LineBreakMeasurer</code>를
 갱신하는 (분)편이, 새롭게 작성하는 것보다도 처리 시간이 걸리지 않습니다. 유저의 키 입력에
해 텍스트를 변경하는 경우는
 이러한 방법을 이용하면 좋을 것입니다.
 <p>
<strong>예</strong>:<p> 컴퍼넌트에 단락을 렌더링 합니다.  <blockquote>
 
 <pre>

 public void paint(Graphics graphics) {

     Point2D pen = new Point2D(10, 20);
     Graphics2D g2d = (Graphics2D) graphics;
     FontRenderContext frc = g2d.getFontRenderContext();

     // let styledText be an AttributedCharacterIterator containing at least
     // one character

     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, frc);
     float wrappingWidth = getSize(). width - 15;

     while (measurer.getPosition() < fStyledText.length()) {

         TextLayout layout = measurer.nextLayout(wrappingWidth);

         pen.y += (layout.getAscent());
         float dx = layout.isLeftToRight() ?
             0 : (wrappingWidth - layout.getAdvance());

         layout.draw(graphics, pen.x + dx, pen.y);
         pen.y += layout.getDescent() + layout.getLeading();
     }
 }
 </pre>
 </blockquote>
 <p>
탭 첨부의 텍스트를 렌더링 합니다. 알기 쉽게하기 위해, 텍스트의 방향은 모두 왼쪽에서 오른쪽으로 합니다.  <blockquote>
 
 <pre>

 public void paint(Graphics graphics) {

     float leftMargin = 10, rightMargin = 310;
     float[] tabStops = { 100, 250 };

     // assume styledText is an AttributedCharacterIterator, and the number
     // of tabs in styledText is tabCount

     int[] tabLocations = new int[tabCount+1];

     int i = 0;
     for (char c = styledText.first(); c ! = styledText.DONE; c = styledText.next()) {
         if (c == '\t') {
             tabLocations[i++] = styledText.getIndex();
         }
     }
     tabLocations[tabCount] = styledText.getEndIndex() - 1;

     // Now tabLocations has an entry for every tab's offset in
     // the text.   For convenience, the last entry is tabLocations
     // is the offset of the last character in the text.

     LineBreakMeasurer measurer = new LineBreakMeasurer(styledText);
     int currentTab = 0;
     float verticalPos = 20;

     while (measurer.getPosition() < styledText.getEndIndex()) {

         // Lay out and draw each line.   All segments on a line
         // must be computed before any drawing can occur, since
         // we must know the largest ascent on the line.
         // TextLayouts are computed and stored in a Vector;
         // their horizontal positions are stored in a parallel
         // Vector.

         // lineContainsText is true after first segment is drawn
         boolean lineContainsText = false;
         boolean lineComplete = false;
         float maxAscent = 0, maxDescent = 0;
         float horizontalPos = leftMargin;
         Vector layouts = new Vector(1);
         Vector penPositions = new Vector(1);

         while (! lineComplete) {
             float wrappingWidth = rightMargin - horizontalPos;
             TextLayout layout =
                     measurer.nextLayout(wrappingWidth,
                                         tabLocations[currentTab]+1,
                                         lineContainsText);

             // layout can be null if lineContainsText is true
             if (layout ! = null) {
                 layouts.addElement(layout);
                 penPositions.addElement(new Float(horizontalPos));
                 horizontalPos += layout.getAdvance();
                 maxAscent = Math.max(maxAscent, layout.getAscent());
                 maxDescent = Math.max(maxDescent,
                     layout.getDescent() + layout.getLeading());
             } else {
                 lineComplete = true;
             }

             lineContainsText = true;

             if (measurer.getPosition() == tabLocations[currentTab]+1) {
                 currentTab++;
             }

             if (measurer.getPosition() == styledText.getEndIndex())
                 lineComplete = true;
             else if (horizontalPos >= tabStops[tabStops.length-1])
                 lineComplete = true;

             if (! lineComplete) {
                 // move to next tab stop
                 int j;
                 for (j=0; horizontalPos >= tabStops[j]; j++) {}
                 horizontalPos = tabStops[j];
             }
         }

         verticalPos += maxAscent;

         Enumeration layoutEnum = layouts.elements();
         Enumeration positionEnum = penPositions.elements();

         // now iterate through layouts and draw them
         while (layoutEnum.hasMoreElements()) {
             TextLayout nextLayout = (TextLayout) layoutEnum.nextElement();
             Float nextPosition = (Float) positionEnum.nextElement();
             nextLayout.draw(graphics, nextPosition.floatValue(), verticalPos);
         }

         verticalPos += maxDescent;
     }
 }
 </pre>
 </blockquote>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스"><CODE>TextLayout</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#LineBreakMeasurer(java.text.AttributedCharacterIterator, java.text.BreakIterator, java.awt.font.FontRenderContext)">LineBreakMeasurer</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/text/BreakIterator.html" title="java.text 안의 클래스">BreakIterator</A> &nbsp;breakIter,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 텍스트에 대한 <code>LineBreakMeasurer</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#LineBreakMeasurer(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)">LineBreakMeasurer</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                  <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 텍스트에 대한 <code>LineBreakMeasurer</code>를
 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)">deleteChar</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
           int&nbsp;deletePos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;텍스트로부터 문자가 1 개 삭제된 뒤에 <code>LineBreakMeasurer</code>를
 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#getPosition()">getPosition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>LineBreakMeasurer</code>
 현재의 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)">insertChar</A> </B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
           int&nbsp;insertPos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;텍스트에 문자가 1 개 삽입된 뒤에 <code>LineBreakMeasurer</code>를
 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextLayout(float)">nextLayout</A> </B>(float&nbsp;wrappingWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃을 돌려주고, 현재의 위치를 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextLayout(float, int, boolean)">nextLayout</A> </B>(float&nbsp;wrappingWidth,
           int&nbsp;offsetLimit,
           boolean&nbsp;requireNextWord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃을 돌려주고, 현재의 위치를 갱신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextOffset(float)">nextOffset</A> </B>(float&nbsp;wrappingWidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃의 마지막 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#nextOffset(float, int, boolean)">nextOffset</A> </B>(float&nbsp;wrappingWidth,
           int&nbsp;offsetLimit,
           boolean&nbsp;requireNextWord)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다음의 레이아웃의 마지막 위치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/font/LineBreakMeasurer.html#setPosition(int)">setPosition</A> </B>(int&nbsp;newPosition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>LineBreakMeasurer</code>
 현재의 위치를 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="LineBreakMeasurer(java.text.AttributedCharacterIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
LineBreakMeasurer</H3>
<PRE>
public <B>LineBreakMeasurer</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                         <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>지정된 텍스트에 대한 <code>LineBreakMeasurer</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 이 <code>LineBreakMeasurer</code> 가 <code>TextLayout</code> 오브젝트의 생성 대상으로 하는 텍스트. 이 텍스트에는
 1 개 이상의 문자가 포함되어 있지 않으면 안 된다. <code>iter</code> 로 얻을 수 있는 텍스트가 변경되었을 경우, 그 후의 이 <code>LineBreakMeasurer</code>
 인스턴스에의 호출의 결과는
 보증되지 않는다 (다만, 나중에 <code>insertChar</code> 또는 <code>deleteChar</code>를
 호출하는 경우를 제외하다. 관련 항목을 참조)<DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한 그래픽스 디바이스에 관한 정보가 있다. 텍스트 측정은, 디바이스의 해상도에
해 조금 달라, 에일리어징 제거와 같은 속성에 따라서 다르다. 이 파라미터는
<code>LineBreakMeasurer</code> 와 유저 공간의 사이의 이동은 지정하지 않는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A>,
 
<A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="LineBreakMeasurer(java.text.AttributedCharacterIterator, java.text.BreakIterator, java.awt.font.FontRenderContext)"><!-- --></A> <H3>
LineBreakMeasurer</H3>
<PRE>
public <B>LineBreakMeasurer</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;text,
                         <A HREF="../../../java/text/BreakIterator.html" title="java.text 안의 클래스">BreakIterator</A> &nbsp;breakIter,
                         <A HREF="../../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스">FontRenderContext</A> &nbsp;frc)</PRE>
<DL>
<DD>지정된 텍스트에 대한 <code>LineBreakMeasurer</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>text</CODE> - 이 <code>LineBreakMeasurer</code> 가 <code>TextLayout</code> 오브젝트의 생성 대상으로 하는 텍스트. 이 텍스트에는
 1 개 이상의 문자가 포함되어 있지 않으면 안 된다. <code>iter</code> 로 얻을 수 있는 텍스트가 변경되었을 경우, 그 후의 이 <code>LineBreakMeasurer</code>
 인스턴스에의 호출의 결과는
 보증되지 않는다 (다만, 나중에 <code>insertChar</code> 또는 <code>deleteChar</code>를
 호출하는 경우를 제외하다. 관련 항목을 참조)<DD><CODE>breakIter</CODE> - 개행을 정의하는 <A HREF="../../../java/text/BreakIterator.html" title="java.text 동안의 클래스"><CODE>BreakIterator</CODE></A> <DD><CODE>frc</CODE> - 텍스트를 정확하게 측정하기 위해서 필요한 그래픽스 디바이스에 관한 정보가 있다. 텍스트 측정은, 디바이스의 해상도에
해 조금 달라, 에일리어징 제거와 같은 속성에 따라서 다르다. 이 파라미터는
<code>LineBreakMeasurer</code> 와 유저 공간의 사이의 이동은 지정하지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 텍스트가 1 문자에 못 미친 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A>,
 
<A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="nextOffset(float)"><!-- --></A> <H3>
nextOffset</H3>
<PRE>
public int <B>nextOffset</B>(float&nbsp;wrappingWidth)</PRE>
<DL>
<DD>다음의 레이아웃의 마지막 위치를 돌려줍니다. <code>LineBreakMeasurer</code>
 현재의 위치를 갱신하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에 허용 되는 최대의 가시 유효폭
<DT><B>반환값:</B><DD>다음의 <code>TextLayout</code>
 리밋트를 나타내는 텍스트내의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="nextOffset(float, int, boolean)"><!-- --></A> <H3>
nextOffset</H3>
<PRE>
public int <B>nextOffset</B>(float&nbsp;wrappingWidth,
                      int&nbsp;offsetLimit,
                      boolean&nbsp;requireNextWord)</PRE>
<DL>
<DD>다음의 레이아웃의 마지막 위치를 돌려줍니다. <code>LineBreakMeasurer</code>
 현재의 위치를 갱신하지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에 허용 되는 최대의 가시 유효폭<DD><CODE>offsetLimit</CODE> - 리밋트 이후의 텍스트가 랩핑폭에 들어가는 경우에서도, 다음의 레이아웃에 포함되지 않는 최초의 문자. <code>offsetLimit</code>는

 현재의 위치보다 크지 않으면 안 되는<DD><CODE>requireNextWord</CODE> - <code>true</code>
 경우, 다음의 단어 전체가 <code>wrappingWidth</code> 에 들어가지 않을 때에 현재의 위치가 돌려주고진다. <code>false</code>
 경우, 돌려주고지는 좌표는 현재의 위치보다 적어도 1 크다
<DT><B>반환값:</B><DD>다음의 <code>TextLayout</code>
 리밋트를 나타내는 텍스트내의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="nextLayout(float)"><!-- --></A> <H3>
nextLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>nextLayout</B>(float&nbsp;wrappingWidth)</PRE>
<DL>
<DD>다음의 레이아웃을 돌려주고, 현재의 위치를 갱신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에 허용 되는 최대의 가시 유효폭
<DT><B>반환값:</B><DD><code>wrappingWidth</code> 에 들어가는 다음의 행을 나타내, 현재의 위치로부터 시작되는 <code>TextLayout</code></DL>
</DD>
</DL>
<HR>

<A NAME="nextLayout(float, int, boolean)"><!-- --></A> <H3>
nextLayout</H3>
<PRE>
public <A HREF="../../../java/awt/font/TextLayout.html" title="java.awt.font 내의 클래스">TextLayout</A>  <B>nextLayout</B>(float&nbsp;wrappingWidth,
                             int&nbsp;offsetLimit,
                             boolean&nbsp;requireNextWord)</PRE>
<DL>
<DD>다음의 레이아웃을 돌려주고, 현재의 위치를 갱신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>wrappingWidth</CODE> - 다음의 레이아웃내의 텍스트에 허용 되는 최대의 가시 유효폭<DD><CODE>offsetLimit</CODE> - 리밋트 이후의 텍스트가 랩핑폭에 들어가는 경우에서도, 다음의 레이아웃에 포함되지 않는 최초의 문자. <code>offsetLimit</code>는

 현재의 위치보다 크지 않으면 안 되는<DD><CODE>requireNextWord</CODE> - <code>true</code>
 경우, 한편 현재의 위치에 있는 단어 전체가 랩핑폭에 들어가지 않는 경우,<code>null</code> 가 돌려주고진다. <code>false</code>
 경우, 적어도 현재의 위치에 있는 문자를 포함한, 유효한 레이아웃이 돌려주고진다
<DT><B>반환값:</B><DD><code>wrappingWidth</code> 에 들어가는 다음의 행을 나타내, 현재의 위치로부터 시작되는 <code>TextLayout</code>. 현재의 위치가,<code>LineBreakMeasurer</code>
 사용하는 텍스트의 종단에 있는 경우,<code>null</code> 가 돌려주고진다</DL>
</DD>
</DL>
<HR>

<A NAME="getPosition()"><!-- --></A> <H3>
getPosition</H3>
<PRE>
public int <B>getPosition</B>()</PRE>
<DL>
<DD><code>LineBreakMeasurer</code>
 현재의 위치를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>LineBreakMeasurer</code>
 현재의 위치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#setPosition(int)"><CODE>setPosition(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPosition(int)"><!-- --></A> <H3>
setPosition</H3>
<PRE>
public void <B>setPosition</B>(int&nbsp;newPosition)</PRE>
<DL>
<DD><code>LineBreakMeasurer</code>
 현재의 위치를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newPosition</CODE> - <code>LineBreakMeasurer</code>
 현재의 위치. 이 정도치는
<code>LineBreakMeasurer</code>를
 작성하기 위해서 사용되는 텍스트 (또는
<code>insertChar</code> 나 <code>deleteChar</code> 에 마지막에 건네받은 텍스트) 내에 있는<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#getPosition()"><CODE>getPosition()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="insertChar(java.text.AttributedCharacterIterator, int)"><!-- --></A> <H3>
insertChar</H3>
<PRE>
public void <B>insertChar</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
                       int&nbsp;insertPos)</PRE>
<DL>
<DD>텍스트에 문자가 1 개 삽입된 뒤에 <code>LineBreakMeasurer</code>를
 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newParagraph</CODE> - 삽입 후의 텍스트<DD><CODE>insertPos</CODE> - 텍스트내의, 문자가 삽입된 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>insertPos</code> 가 <code>newParagraph</code>
 개시 위치보다 전, 또는 <code>newParagraph</code>
 종료 위치와 같은가, 그 이후인 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>newParagraph</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#deleteChar(java.text.AttributedCharacterIterator, int)"><CODE>deleteChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deleteChar(java.text.AttributedCharacterIterator, int)"><!-- --></A> <H3>
deleteChar</H3>
<PRE>
public void <B>deleteChar</B>(<A HREF="../../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;newParagraph,
                       int&nbsp;deletePos)</PRE>
<DL>
<DD>텍스트로부터 문자가 1 개 삭제된 뒤에 <code>LineBreakMeasurer</code>를
 갱신해, 현재의 위치를 그 단락의 선두로 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newParagraph</CODE> - 삭제 후의 텍스트<DD><CODE>deletePos</CODE> - 텍스트내의, 문자가 삭제된 위치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IndexOutOfBoundsException.html" title="java.lang 안의 클래스">IndexOutOfBoundsException</A> </CODE> - <code>deletePos</code> 가 <code>newParagraph</code>
 개시 위치보다 전, 또는 <code>newParagraph</code>
 종료 위치에서(보다) 뒤인 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>newParagraph</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/font/LineBreakMeasurer.html#insertChar(java.text.AttributedCharacterIterator, int)"><CODE>insertChar(java.text.AttributedCharacterIterator, int)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/LineBreakMeasurer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/awt/font/ImageGraphicAttribute.html" title="java.awt.font 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/awt/font/LineMetrics.html" title="java.awt.font 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/font/LineBreakMeasurer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="LineBreakMeasurer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

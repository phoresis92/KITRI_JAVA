<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:54:27 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Graphics (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.Graphics class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graphics (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/awt/GradientPaint.html" title="java.awt 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/Graphics2D.html" title="java.awt 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/awt/Graphics.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
클래스 Graphics</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.Graphics</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../javax/swing/DebugGraphics.html" title="javax.swing 내의 클래스">DebugGraphics</A>,
 <A HREF="../../java/awt/Graphics2D.html" title="java.awt 안의 클래스">Graphics2D</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>Graphics</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>Graphics</code> 클래스는
 모든 그래픽 컨텍스트
의 추상 base class입니다. 그래픽 컨텍스트
에
해 어플리케이션은, 각종 디바이스에
해 실현되는 컴퍼넌트상이나 오프 스크린 이미지상에 렌더링 할 수 있습니다.
 <p>
<code>Graphics</code> 오브젝트는
 Java 가 지원하는 기본적인 렌더링 조작에 필요한 상태 정보를 캡슐화합니다. 이 상태 정보에는
 다음의 프로퍼티가 있습니다.
 <p>
<ul> <li>렌더링 대상의 <code>Component</code> 오브젝트<li>렌더링를 위한 변환의 기점과 클리핑 좌표<li>현재의 클립<li>현재의 색<li>현재의 폰트<li>현재의 논리 픽셀 조작 기능 (XOR 또는 Paint)<li>현재의 XOR 변경색 (<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A>  참조) 
</ul>

 <p>
좌표축은 무한하게 가늘고, 출력 디바이스의 픽셀간에 존재합니다. 도형의 윤곽을 그리는 조작은, 픽셀 사이즈의 펜을 픽셀간의 무한하게 가는 윤곽선에 따라 움직여 가는 것에
해 동작합니다. 펜은, 윤곽선의 엥커 포인트에 매달려, 한편 우측에 위치하고 있습니다. 도형의 내부를 묻는 조작은, 무한하게 가는 윤곽선의 내부를 묻는 것으로 동작합니다. 수평의 문자를 렌더링 하는 조작은, baseline 좌표보다 위에 문자 그래프
의 아센다 부분을 모두 렌더링 합니다.
 <p>
그래픽스 펜은 그 궤도의 윤곽선에 매달려, 한편 우측에 위치하고 있습니다. 이것은, 다음 일을 나타냅니다.
 <p><ul>
<li>지정된 구형을 커버하는 도형을 그리는 경우, 그 도형으로 오른쪽과 최하부의 옆에 픽셀을 이제(벌써) 일렬 여분으로 표시하도록 한다. 그 점에서, 같은 구형의 내부를 묻는 것과는 다르다<li>텍스트 라인의 baseline와 같은 <i>y</i> 좌표에 따라 수평선을 그리는 경우, 문자가 baseline보다 아래에 늘어나는 부분을 제외해, 텍스트보다 완전하게 아래에 선을 그린다
</ul>
<p> 이 <code>Graphics</code>
 메서드의 인수로서 사용되는 모든 좌표치는
 메서드의 호출전에
 이 <code>Graphics</code> 오브젝트의 변환 바탕으로 상대적인 것이라고 보여집니다.
 <p>
모든 렌더링 조작은,<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스"><CODE>Shape</CODE></A>  가 유저 공간으로 지정해,<code>Graphics</code> 오브젝트를 사용해 프로그램이 제어하는 현재의 클립에 둘러싸인 에리어에 있는 픽셀만을 변경합니다. 이 「유저 클립」은 디바이스 공간에 변환되어 윈도우의 가시 및 디바이스의 크기에
해 정의되는 「디바이스 클립」이라고 결합됩니다. 유저 클립과 디바이스 클립의 결합은, 최종적인 클리핑 영역을 결정하는 「복합 클립」을 정의합니다. 렌더링 시스템은, 유저 클립을 변경해 복합 클립의 결과를 반영할 수 없습니다. 유저 클립은 <code>setClip</code> 또는 <code>clipRect</code> 메서드만으로 변경할 수 있습니다. 모든 렌더링나 기입은, 현재의 색으로 현재의 페인트 모드와 폰트를 사용해 행해집니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html" title="java.awt 내의 클래스"><CODE>Component</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>setPaintMode()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>setFont(java.awt.Font)</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#Graphics()">Graphics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Graphics</code> 오브젝트를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)">clearRect</A> </B>(int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을, 현재의 렌더링 표면의 백그라운드 컬러로 전부 칠하는 것으로 클리어 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)">clipRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클립과 지정된 구형을 교차시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#copyArea(int, int, int, int, int, int)">copyArea</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;dx,
         int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컴퍼넌트의 영역을,<code>dx</code> 와 <code>dy</code> 로 지정된 거리로 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#create()">create</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 오브젝트의 카피인, 새로운 <code>Graphics</code> 오브젝트를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#create(int, int, int, int)">create</A> </B>(int&nbsp;x,
       int&nbsp;y,
       int&nbsp;width,
       int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 오브젝트에 근거한 새로운 <code>Graphics</code> 오브젝트를, 새로운 변환 및 클립 영역에서 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#dispose()">dispose</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
을 파기해, 사용중의 system resource가 있으면 그것을 해방합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 3D 로 강조 표시해 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 커버하는 원호 또는 타원호의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)">drawBytes</A> </B>(byte[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;length,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 바이트 배열에
해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)">drawChars</A> </B>(char[]&nbsp;data,
          int&nbsp;offset,
          int&nbsp;length,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 문자 배열에
해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 현재 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 내부에 들어가도록 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;width,
          int&nbsp;height,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 내부에 들어가도록 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          int&nbsp;dx1,
          int&nbsp;dy1,
          int&nbsp;dx2,
          int&nbsp;dy2,
          int&nbsp;sx1,
          int&nbsp;sy1,
          int&nbsp;sx2,
          int&nbsp;sy2,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawLine(int, int, int, int)">drawLine</A> </B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 좌표계의 점 <code>(x1, &nbsp;y1)</code> 과 점 <code>(x2, &nbsp;y2)</code> 과의 사이에 현재의 색을 사용해 선을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)">drawOval</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;타원의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)">drawPolygon</A> </B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의된 닫은 다각형을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolygon(java.awt.Polygon)">drawPolygon</A> </B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Polygon</code> 오브젝트에
해 정의되는 다각형의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)">drawPolyline</A> </B>(int[]&nbsp;xPoints,
             int[]&nbsp;yPoints,
             int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되고 연속적으로 연결된 직선을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)">drawRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A> </B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;둥근 코너 첨부의 윤곽의 구형을, 이 그래픽스 컨텍스트
의 현재의 색을 사용해 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 색을 사용해, 지정된 반복자에
해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 캐릭터 라인에
해 지정된 텍스트를 그립니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 색으로 강조 표시된 3 차원 구형을 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 커버하는 원호 또는 타원호를 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)">fillOval</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형안의 타원형을 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)">fillPolygon</A> </B>(int[]&nbsp;xPoints,
            int[]&nbsp;yPoints,
            int&nbsp;nPoints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되는 닫은 다각형을 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillPolygon(java.awt.Polygon)">fillPolygon</A> </B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Polygon 오브젝트로 정의된 다각형을 그래픽스 컨텍스트
의 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)">fillRect</A> </B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형을 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A> </B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 둥근 코너 첨부의 구형을 현재의 색으로 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;참조되지 않게 된, 이 그래픽스 컨텍스트
을 파기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClip()">getClip</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipBounds()">getClipBounds</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역의 경계의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipBounds(java.awt.Rectangle)">getClipBounds</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역의 경계의 구형을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getClipRect()">getClipRect</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>getClipBounds()</code> 로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getColor()">getColor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 색을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스">Font</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFont()">getFont</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 폰트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFontMetrics()">getFontMetrics</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 폰트의 폰트 시학을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)">getFontMetrics</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;f)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 폰트의 폰트 시학을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#hitClip(int, int, int, int)">hitClip</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형 영역이 현재의 클리핑 영역과 교차하는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)">setClip</A> </B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 좌표가 지정한 구형에 현재의 클립을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)">setClip</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;clip)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클리핑 영역을 임의의 클립 형상으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)">setColor</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 색을, 지정된 색으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)">setFont</A> </B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 폰트를, 지정된 폰트로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setPaintMode()">setPaintMode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 색으로 목적지를 덧쓰기하도록, 페인트 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)">setXORMode</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 그래픽스 컨텍스트
의 현재의 색과 새롭게 지정된 색을 바꾸도록(듯이), 그래픽스 컨텍스트
의 페인트 모드를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics</code> 오브젝트의 값을 표현하고 있는
<code>String</code> 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics.html#translate(int, int)">translate</A> </B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그래픽스 컨텍스트
의 원점을 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Graphics()"><!-- --></A> <H3>
Graphics</H3>
<PRE>
protected <B>Graphics</B>()</PRE>
<DL>
<DD>새로운 <code>Graphics</code> 오브젝트를 작성합니다. 이 생성자는
 그래픽스 컨텍스트
의 디폴트 생성자
입니다.  
 <p>
<code>Graphics</code>는
 abstract 클래스이므로 어플리케이션은 이 생성자를 직접 호출할 수 없습니다. 그래픽스 컨텍스트
은, 다른 그래픽스 컨텍스트
으로부터 취득되는지, 컴퍼넌트로 <code>getGraphics</code>를
 호출하는 것에
해 작성됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#create()"><CODE>create()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="create()"><!-- --></A> <H3>
create</H3>
<PRE>
public abstract <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>create</B>()</PRE>
<DL>
<DD>이 <code>Graphics</code> 오브젝트의 카피인, 새로운 <code>Graphics</code> 오브젝트를 작성합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 컨텍스트
의 카피인, 새로운 그래픽스 컨텍스트
</DL>
</DD>
</DL>
<HR>

<A NAME="create(int, int, int, int)"><!-- --></A> <H3>
create</H3>
<PRE>
public <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A>  <B>create</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>이 <code>Graphics</code> 오브젝트에 근거한 새로운 <code>Graphics</code> 오브젝트를, 새로운 변환 및 클립 영역에서 작성합니다. 새로운 <code>Graphics</code> 오브젝트는 그 원점을, 지정된 점 (<i>x</i>, &nbsp;<i>y</i>)에 변환시킵니다. 그 클립 영역은, 원의 클립 영역과 지정된 구형과의 공통 부분에서 지정됩니다. 인수는 모두, 원의 <code>Graphics</code> 오브젝트의 좌표계에 변환됩니다. 새로운 그래픽스 컨텍스트
은, 다음의 2 점 이외에 붙어 원의 그래픽스 컨텍스트
과 같습니다.
 <p>
<ul> <li> 새로운 그래픽스 컨텍스트
은 (<i>x</i>, &nbsp;<i>y</i>)에
해 변환된다. 즉, 새로운 그래픽스 컨텍스트
의 점 (<code>0</code>, &nbsp;<code>0</code>)은 원의 그래픽스 컨텍스트
의 점 (<i>x</i>, &nbsp;<i>y</i>)과 같게된다<li> 새로운 그래픽스 컨텍스트
은, 원의 그래픽스 컨텍스트
으로부터 상속된 변환 후의 클리핑 구형이 무엇으로 있을것이다와 추가의 클리핑 구형을 가진다. 새로운 클리핑 구형의 원점은 (<code>0</code>, &nbsp;<code>0</code>)에 있어, 그 사이즈는 <code>width</code> 인수와 <code>height</code> 인수로 지정된다 
</ul>

 <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 클리핑 구형의 폭<DD><CODE>height</CODE> - 클리핑 구형의 높이
<DT><B>반환값:</B><DD>새로운 그래픽스 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#translate(int, int)"><CODE>translate(int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD>그래픽스 컨텍스트
의 원점을 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 변환합니다. 이 그래픽스 컨텍스트
을, 새로운 원점이 이 그래픽스 컨텍스트
의 원의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)에 일치하도록 변경합니다. 이 그래픽스 컨텍스트
에 행해진, 이 이후의 렌더링 조작에 사용되는 좌표는 모두 이 원점에 상대적인 값이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A> <H3>
getColor</H3>
<PRE>
public abstract <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getColor</B>()</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 색을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 컨텍스트
의 현재의 색<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스"><CODE>Color</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setColor(java.awt.Color)"><!-- --></A> <H3>
setColor</H3>
<PRE>
public abstract void <B>setColor</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 색을, 지정된 색으로 설정합니다. 이 그래픽스 컨텍스트
을 사용하는 이 이후의 그래픽 관련 조작은, 여기서 지정된 색을 사용합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c</CODE> - 새로운 렌더링색<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스"><CODE>Color</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#getColor()"><CODE>getColor()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPaintMode()"><!-- --></A> <H3>
setPaintMode</H3>
<PRE>
public abstract void <B>setPaintMode</B>()</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 색으로 목적지를 덧쓰기하도록, 페인트 모드를 설정합니다. 이것은, 논리 픽셀 조작 기능을 페인트 모드, 즉 덧쓰기 모드(replace mode)로 설정합니다. 이 이후의 렌더링 조작은, 목적지를 현재의 색으로 덧쓰기합니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setXORMode(java.awt.Color)"><!-- --></A> <H3>
setXORMode</H3>
<PRE>
public abstract void <B>setXORMode</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;c1)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 색과 새롭게 지정된 색을 바꾸도록(듯이), 그래픽스 컨텍스트
의 페인트 모드를 설정합니다. 이것은, 논리 픽셀 조작을 XOR 모드로 실행하도록 지정합니다. XOR 모드에서는
 픽셀은 현재의 색과 지정된 XOR 교대색의 사이를 교대로 바뀝니다.
 <p>
렌더링 조작을 실행하면, 현재의 색의 픽셀이 지정된 색에 바뀌어, 그 역도 들어맞읍니다.
 <p>
여기서 다루어진 2 색 이외의 색을 가지는 픽셀은 예상할 수 없는 색에 변화합니다만, 그것들은 바탕으로 되돌릴 수 있게 되어 있습니다. 같은 그림을 2 회 렌더링 하면, 모든 픽셀은 초기의 설정색에 돌아옵니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>c1</CODE> - XOR
 교대색</DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A> <H3>
getFont</H3>
<PRE>
public abstract <A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스">Font</A>  <B>getFont</B>()</PRE>
<DL>
<DD>현재의 폰트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 컨텍스트
의 현재의 폰트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Font.html" title="java.awt 내의 클래스"><CODE>Font</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>setFont(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setFont(java.awt.Font)"><!-- --></A> <H3>
setFont</H3>
<PRE>
public abstract void <B>setFont</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;font)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 폰트를, 지정된 폰트로 설정합니다. 이 그래픽스 컨텍스트
을 사용하는
 이 이후의 텍스트 렌더링 조작은, 이 폰트를 사용합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>font</CODE> - 폰트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics()"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>()</PRE>
<DL>
<DD>현재의 폰트의 폰트 시학을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 컨텍스트
의 현재의 폰트의 폰트메트릭스<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A>,
 
<A HREF="../../java/awt/FontMetrics.html" title="java.awt 안의 클래스"><CODE>FontMetrics</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)"><CODE>getFontMetrics(Font)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getFontMetrics(java.awt.Font)"><!-- --></A> <H3>
getFontMetrics</H3>
<PRE>
public abstract <A HREF="../../java/awt/FontMetrics.html" title="java.awt 내의 클래스">FontMetrics</A>  <B>getFontMetrics</B>(<A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스">Font</A> &nbsp;f)</PRE>
<DL>
<DD>지정된 폰트의 폰트 시학을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>f</CODE> - 지정된 폰트
<DT><B>반환값:</B><DD>지정된 폰트의 폰트메트릭스<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getFont()"><CODE>getFont()</CODE></A>,
 
<A HREF="../../java/awt/FontMetrics.html" title="java.awt 안의 클래스"><CODE>FontMetrics</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#getFontMetrics()"><CODE>getFontMetrics()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getClipBounds()"><!-- --></A> <H3>
getClipBounds</H3>
<PRE>
public abstract <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipBounds</B>()</PRE>
<DL>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다. 이 메서드는
 디바이스 경계나 윈도우 가시에 관련한 클리핑에는
존하지 않는 유저 클립을 참조합니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code>를
 사용해 클리어 되고 있는 경우는
 이 메서드는 <code>null</code>를
 돌려줍니다. 구형내의 좌표는 이 그래픽스 컨텍스트
의 좌표계의 원점을 기준으로 하고 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형. 클립이 설정되어 있지 않은 경우는
<code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clipRect(int, int, int, int)"><!-- --></A> <H3>
clipRect</H3>
<PRE>
public abstract void <B>clipRect</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>현재의 클립과 지정된 구형을 교차시킵니다. 결과가 클립 되는 영역은 현재의 클리핑 영역과 지정한 구형의 교차 부분입니다. 클립이 설정되었던 적이 없는가, 또는 클립이 <code>setClip(null)</code>를
 사용해 클리어 되었기 때문에 현재의 클리핑 영역이 없는 경우는
 지정한 구형이 새로운 클립이 됩니다. 이 메서드로 디바이스 경계나 윈도우 가시에 관련한 클리핑에는
존하지 않는 유저 클립을 설정합니다. 이 메서드는 현재의 클립을 작게 하는 경우에 한정해 사용할 수 있습니다. 현재의 클립을 크게 하려면,
 임의의 setClip 메서드를 사용합니다. 클리핑 영역외에서 렌더링 조작을 행해도 효과는 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 교차해 클립 하는 구형의 x 좌표<DD><CODE>y</CODE> - 교차해 클립 하는 구형의 y 좌표<DD><CODE>width</CODE> - 교차해 클립 하는 구형의 폭<DD><CODE>height</CODE> - 교차해 클립 하는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setClip(int, int, int, int)"><!-- --></A> <H3>
setClip</H3>
<PRE>
public abstract void <B>setClip</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height)</PRE>
<DL>
<DD>지정한 좌표가 지정한 구형에 현재의 클립을 설정합니다. 이 메서드는
 디바이스 경계나 윈도우 가시에 관련한 클리핑에
존하지 않는 유저 클립을 설정합니다. 클리핑 영역외에서 렌더링 조작을 행해도 효과는 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 새로운 클립 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 새로운 클립 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 새로운 클립 구형의 폭<DD><CODE>height</CODE> - 새로운 클립 구형의 높이<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getClip()"><!-- --></A> <H3>
getClip</H3>
<PRE>
public abstract <A HREF="../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>getClip</B>()</PRE>
<DL>
<DD>현재의 클리핑 영역을 돌려줍니다. 이 메서드는
 디바이스 경계나 윈도우 가시에 관련한 클리핑에는
존하지 않는 유저 클립을 돌려줍니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code>를
 사용해 클리어 되고 있는 경우는
 이 메서드는 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역을 나타내는 <code>Shape</code> 오브젝트. 클립이 설정되어 있지 않은 경우는
<code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClipBounds()"><CODE>getClipBounds()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip(Shape)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setClip(java.awt.Shape)"><!-- --></A> <H3>
setClip</H3>
<PRE>
public abstract void <B>setClip</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;clip)</PRE>
<DL>
<DD>현재의 클리핑 영역을 임의의 클립 형상으로 설정합니다. 클립을 설정하기 위해서,<code>Shape</code> 인터페이스를 구현하는 모든 오브젝트를 사용할 수 있는 것은 아닙니다. 지원가 보증되고 있는 유일한 <code>Shape</code> 오브젝트는
<code>getClip</code> 메서드를 사용할까 <code>Rectangle</code> 오브젝트를 사용해 취득되는 <code>Shape</code> 오브젝트 뿐입니다. 이 메서드는
 디바이스 경계나 윈도우 가시에 관련한 크리크핑에
존하지 않는 유저 클립을 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>clip</CODE> - 클립 설정에 사용하는 <code>Shape</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#getClip()"><CODE>getClip()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)"><CODE>clipRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int)"><!-- --></A> <H3>
copyArea</H3>
<PRE>
public abstract void <B>copyArea</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height,
                              int&nbsp;dx,
                              int&nbsp;dy)</PRE>
<DL>
<DD>컴퍼넌트의 영역을,<code>dx</code> 와 <code>dy</code> 로 지정된 거리로 카피합니다. 이 메서드는 <code>x</code> 와 <code>y</code> 로 지정된 점으로부터, 컴퍼넌트의 아래방향 및 우측향의 영역을 카피합니다. 컴퍼넌트의 좌방향 및 윗방향의 영역을 카피하려면,
<code>dx</code> 와 <code>dy</code> 에 부의 값을 지정합니다. 소스의 구형이 있는 부분이 컴퍼넌트의 경계외에 있는 경우나 다른 컴퍼넌트나 윈도우로 숨겨지고 있는 경우는
<code>copyArea</code>는
 대응하고 있는 픽셀을 카피할 수 없습니다. 숨겨진 영역은, 그 컴퍼넌트의 <code>paint</code> 메서드를 호출하는 것으로 재렌더링 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 소스 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 소스 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 소스 구형의 폭<DD><CODE>height</CODE> - 소스 구형의 높이<DD><CODE>dx</CODE> - 픽셀을 카피하는 수평거리<DD><CODE>dy</CODE> - 픽셀을 카피하는 수직 거리</DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A> <H3>
drawLine</H3>
<PRE>
public abstract void <B>drawLine</B>(int&nbsp;x1,
                              int&nbsp;y1,
                              int&nbsp;x2,
                              int&nbsp;y2)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 좌표계의 점 <code>(x1, &nbsp;y1)</code> 과 점 <code>(x2, &nbsp;y2)</code> 과의 사이에 현재의 색을 사용해 선을 그립니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x1</CODE> - 최초의 점의 <i>x</i> 좌표<DD><CODE>y1</CODE> - 최초의 점의 <i>y</i> 좌표<DD><CODE>x2</CODE> - 2 번째의 점의 <i>x</i> 좌표<DD><CODE>y2</CODE> - 2 번째의 점의 <i>y</i> 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A> <H3>
fillRect</H3>
<PRE>
public abstract void <B>fillRect</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형을 전부 칠합니다. 구형의 좌단과 우단은 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width&nbsp;-&nbsp;1</code> 로 상단과 하단은 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height&nbsp;-&nbsp;1</code> 입니다. 이것으로 지정되는 구형은, 폭 <code>width</code> 픽셀, 높이 <code>height</code> 픽셀의 영역입니다. 구형은, 그래픽스 컨텍스트
의 현재의 색을 사용해 전부 칠해집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>clearRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)"><CODE>drawRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A> <H3>
drawRect</H3>
<PRE>
public void <B>drawRect</B>(int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 그립니다. 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height</code> 로 지정됩니다. 구형은, 그래픽스 컨텍스트
의 현재의 색을 사용해 렌더링 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 렌더링 되는 구형의 폭<DD><CODE>height</CODE> - 렌더링 되는 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)"><CODE>fillRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>clearRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clearRect(int, int, int, int)"><!-- --></A> <H3>
clearRect</H3>
<PRE>
public abstract void <B>clearRect</B>(int&nbsp;x,
                               int&nbsp;y,
                               int&nbsp;width,
                               int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형을, 현재의 렌더링 표면의 백그라운드 컬러로 전부 칠하는 것으로 클리어 합니다. 이 조작은, 현재의 페인트 모드를 사용하지 않습니다.
 <p>
Java&nbsp;1. 1 이후는
 오프 스크린의 이미지의 백그라운드 컬러는 시스템에
해 다릅니다. 어플리케이션은 <code>setColor</code> 에 이어 <code>fillRect</code>를
 사용하는 것에
해, 오프 스크린 이미지를 클리어 해 특정의 색으로 하는 것을 보증합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 클리어 대상의 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 클리어 대상의 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 클리어 대상의 구형의 폭<DD><CODE>height</CODE> - 클리어 대상의 구형의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)"><CODE>fillRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)"><CODE>drawRect(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>setPaintMode()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>setXORMode(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A> <H3>
drawRoundRect</H3>
<PRE>
public abstract void <B>drawRoundRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;arcWidth,
                                   int&nbsp;arcHeight)</PRE>
<DL>
<DD>둥근 코너 첨부의 윤곽의 구형을, 이 그래픽스 컨텍스트
의 현재의 색을 사용해 그립니다. 그려지는 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height</code> 로 지정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 렌더링 되는 구형의 폭<DD><CODE>height</CODE> - 렌더링 되는 구형의 높이<DD><CODE>arcWidth</CODE> - 4 구석의 호의 수평 방향의 직경<DD><CODE>arcHeight</CODE> - 4 구석의 호의 수직 방향의 직경<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)"><CODE>fillRoundRect(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A> <H3>
fillRoundRect</H3>
<PRE>
public abstract void <B>fillRoundRect</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;width,
                                   int&nbsp;height,
                                   int&nbsp;arcWidth,
                                   int&nbsp;arcHeight)</PRE>
<DL>
<DD>지정된 둥근 코너 첨부의 구형을 현재의 색으로 전부 칠합니다. 구형은, 좌단과 우단이 각각 <code>x</code> 와 <code>x&nbsp;+&nbsp;width&nbsp;-&nbsp;1</code>, 상단과 하단이 각각 <code>y</code> 와 <code>y&nbsp;+&nbsp;height&nbsp;-&nbsp;1</code> 로 지정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>arcWidth</CODE> - 4 구석의 호의 수평 방향의 직경<DD><CODE>arcHeight</CODE> - 4 구석의 호의 수직 방향의 직경<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)"><CODE>drawRoundRect(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="draw3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
draw3DRect</H3>
<PRE>
public void <B>draw3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 3D 로 강조 표시해 렌더링 합니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다.
 <p>
강조 표시 효과에 사용되는 색은 현재의 색으로부터 결정됩니다. 결과적으로 그려지는 구형은, 폭의 픽셀수가 <code>width&nbsp;+&nbsp;1</code>, 높이의 픽셀수가 <code>height&nbsp;+&nbsp;1</code>
 영역을 커버합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 렌더링 되는 구형의 폭<DD><CODE>height</CODE> - 렌더링 되는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 표면에 조각해 붐비어진 것처럼 보이는지를 지정하는 boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)"><CODE>fill3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
fill3DRect</H3>
<PRE>
public void <B>fill3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>현재의 색으로 강조 표시된 3 차원 구형을 전부 칠합니다. 구형의 구석은 경사를 붙일 수 있는 좌상구석으로부터 빛을 쬘 수 있던 것처럼 강조 표시됩니다. 강조 표시 효과에 사용되는 색은 현재의 색으로부터 결정됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 표면에 조각해 붐비어진 것처럼 보이는지를 지정하는 boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)"><CODE>draw3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawOval(int, int, int, int)"><!-- --></A> <H3>
drawOval</H3>
<PRE>
public abstract void <B>drawOval</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>타원의 윤곽을 그립니다. 인수의 <code>x</code>,<code>y</code>,<code>width</code>,<code>height</code> 로 지정되는 구형내에 들어가는 엔 또는 타원이 그려집니다.
 <p> 
타원은, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 타원의 좌상구석의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 타원의 좌상구석의 <i>y</i> 좌표<DD><CODE>width</CODE> - 렌더링 되는 타원의 폭<DD><CODE>height</CODE> - 렌더링 되는 타원의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)"><CODE>fillOval(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillOval(int, int, int, int)"><!-- --></A> <H3>
fillOval</H3>
<PRE>
public abstract void <B>fillOval</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형안의 타원형을 현재의 색으로 전부 칠합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 타원의 좌상구석의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 타원의 좌상구석의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 타원의 폭<DD><CODE>height</CODE> - 전부 칠해지는 타원의 높이<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)"><CODE>drawOval(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A> <H3>
drawArc</H3>
<PRE>
public abstract void <B>drawArc</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;startAngle,
                             int&nbsp;arcAngle)</PRE>
<DL>
<DD>지정된 구형을 커버하는 원호 또는 타원호의 윤곽을 그립니다.
 <p>
<code>startAngle</code> 로부터 시작되어 <code>arcAngle</code>
 각도로 전개된 호가, 현재의 색을 사용해 그려집니다. 각도는 3 시의 위치를 0 번으로서 변환되어 정의 값은 반시계방향, 부의 값은 시계 방향의 회전을 나타냅니다.
 <p>
호의 중심은, 원점이 (<i>x</i>, &nbsp;<i>y</i>)로 사이즈가 <code>width</code> 인수와 <code>height</code> 인수로 지정되는 구형의 중심이 됩니다.
 <p>
그려지는 호는
 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.
 <p>
각도의 크기는
 직각이 아닌 경계의 구형을 기준으로 지정해, 타원의 중심으로부터 경계의 구형의 우상구석까지를 묶는 선이 항상 45 번이 되도록 합니다. 경계의 구형의 축의 길이가 꽤 다른 경우에는
 호세그먼트(segment)의 개시 각도와 종료 각도는 경계의 타원에 있어 가장 긴 직경에 따라 한층 더 경사합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 고의 좌상구석의 <i>x</i> 좌표<DD><CODE>y</CODE> - 렌더링 되는 고의 좌상구석의 <i>y</i> 좌표<DD><CODE>width</CODE> - 렌더링 되는 고의 폭<DD><CODE>height</CODE> - 렌더링 되는 고의 높이<DD><CODE>startAngle</CODE> - 개시 각도<DD><CODE>arcAngle</CODE> - 개시 각도에 대한 호의 전개 각도의 크기<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)"><CODE>fillArc(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A> <H3>
fillArc</H3>
<PRE>
public abstract void <B>fillArc</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;startAngle,
                             int&nbsp;arcAngle)</PRE>
<DL>
<DD>지정된 구형을 커버하는 원호 또는 타원호를 전부 칠합니다.
 <p>
<code>startAngle</code> 로부터 시작되어 <code>arcAngle</code>
 각도로 전개된 호가 그려집니다. 각도는 3 시의 위치를 0 번으로서 변환되어 정의 값은 반시계방향, 부의 값은 시계 방향의 회전을 나타냅니다.
 <p>
호의 중심은, 원점이 (<i>x</i>, &nbsp;<i>y</i>)로 사이즈가 <code>width</code> 인수와 <code>height</code> 인수로 지정되는 구형의 중심이 됩니다.
 <p>
그려지는 호는
 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다.
 <p>
각도의 크기는
 직각이 아닌 경계의 구형을 기준으로 지정해, 타원의 중심으로부터 경계의 구형의 우상구석까지를 묶는 선이 항상 45 번이 되도록 합니다. 경계의 구형의 축의 길이가 꽤 다른 경우에는
 호세그먼트(segment)의 개시 각도와 종료 각도는 경계의 타원에 있어 가장 긴 직경에 따라 한층 더 경사합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 고의 좌상구석의 <i>x</i> 좌표<DD><CODE>y</CODE> - 전부 칠해지는 고의 좌상구석의 <i>y</i> 좌표<DD><CODE>width</CODE> - 전부 칠해지는 고의 폭<DD><CODE>height</CODE> - 전부 칠해지는 고의 높이<DD><CODE>startAngle</CODE> - 개시 각도<DD><CODE>arcAngle</CODE> - 개시 각도에 대한 호의 전개 각도의 크기<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)"><CODE>drawArc(int, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolyline(int[], int[], int)"><!-- --></A> <H3>
drawPolyline</H3>
<PRE>
public abstract void <B>drawPolyline</B>(int[]&nbsp;xPoints,
                                  int[]&nbsp;yPoints,
                                  int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되고 연속적으로 연결된 직선을 그립니다. 좌표 (<i>x</i>, &nbsp;<i>y</i>)의 각 페어는 점을 정의합니다. 최초의 좌표와 마지막 좌표가 일치하지 않는 경우, 도형은 닫지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <i>x</i> 점의 배열<DD><CODE>yPoints</CODE> - <i>y</i> 점의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[], int[], int)"><!-- --></A> <H3>
drawPolygon</H3>
<PRE>
public abstract void <B>drawPolygon</B>(int[]&nbsp;xPoints,
                                 int[]&nbsp;yPoints,
                                 int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의된 닫은 다각형을 그립니다. 좌표 (<i>x</i>, &nbsp;<i>y</i>)의 각 페어는 점을 정의합니다.
 <p>
이 메서드는
<code>nPoint</code> 라인 세그먼트(segment)에
해 정의되는 다각형을 그립니다. 이 경우, 최초의 <code>nPoint&nbsp;-&nbsp;1</code> 라인 세그먼트(segment)는
 1 &nbsp;&le;&nbsp;<i>i</i>&nbsp;&le;&nbsp;<code>nPoints</code> 에 대한,<code>(xPoints[i&nbsp;-&nbsp;1], &nbsp;yPoints[i&nbsp;-&nbsp;1])</code> 로부터 <code>(xPoints[i], &nbsp;yPoints[i])</code> 까지의 라인 세그먼트(segment)입니다. 마지막 점과 최초의 점이 일치하지 않는 경우, 그것들을 접속하는 라인을 렌더링 하면 그림은 자동적으로 덮습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <code>x</code> 좌표의 배열<DD><CODE>yPoints</CODE> - <code>y</code> 좌표의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)"><CODE>fillPolygon(int[], int[], int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)"><CODE>drawPolyline(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(java.awt.Polygon)"><!-- --></A> <H3>
drawPolygon</H3>
<PRE>
public void <B>drawPolygon</B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 <code>Polygon</code> 오브젝트에
해 정의되는 다각형의 윤곽을 그립니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - 렌더링 대상의 다각형<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)"><CODE>fillPolygon(int[], int[], int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)"><CODE>drawPolyline(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[], int[], int)"><!-- --></A> <H3>
fillPolygon</H3>
<PRE>
public abstract void <B>fillPolygon</B>(int[]&nbsp;xPoints,
                                 int[]&nbsp;yPoints,
                                 int&nbsp;nPoints)</PRE>
<DL>
<DD><i>x</i> 좌표와 <i>y</i> 좌표의 배열로 정의되는 닫은 다각형을 전부 칠합니다.
 <p>
이 메서드는
<code>nPoint</code> 라인 세그먼트(segment)에
해 정의되는 다각형을 그립니다. 이 경우, 최초의 <code>nPoint&nbsp;-&nbsp;1</code> 라인 세그먼트(segment)는
 1 &nbsp;&le;&nbsp;<i>i</i>&nbsp;&le;&nbsp;<code>nPoints</code> 에 대한,<code>(xPoints[i&nbsp;-&nbsp;1], &nbsp;yPoints[i&nbsp;-&nbsp;1])</code> 로부터 <code>(xPoints[i], &nbsp;yPoints[i])</code> 까지의 라인 세그먼트(segment)입니다. 마지막 점과 최초의 점이 일치하지 않는 경우, 그것들을 접속하는 라인을 렌더링 하면 그림은 자동적으로 덮습니다.
 <p>
다각형내의 영역은, 우기 전부 칠해 규칙 (교호 규칙이라고도 한다)을 사용해 정의됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>xPoints</CODE> - <code>x</code> 좌표의 배열<DD><CODE>yPoints</CODE> - <code>y</code> 좌표의 배열<DD><CODE>nPoints</CODE> - 점의 총수<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(java.awt.Polygon)"><!-- --></A> <H3>
fillPolygon</H3>
<PRE>
public void <B>fillPolygon</B>(<A HREF="../../java/awt/Polygon.html" title="java.awt 안의 클래스">Polygon</A> &nbsp;p)</PRE>
<DL>
<DD>지정된 Polygon 오브젝트로 정의된 다각형을 그래픽스 컨텍스트
의 현재의 색으로 전부 칠합니다.
 <p>
다각형내의 영역은, 우기 전부 칠해 규칙 (교호 규칙이라고도 한다)을 사용해 정의됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>p</CODE> - 전부 칠해 대상의 다각형<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)"><CODE>drawPolygon(int[], int[], int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 캐릭터 라인에
해 지정된 텍스트를 그립니다. 좌단의 문자의 baseline는
 이 그래픽스 컨텍스트
의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 렌더링 되는 캐릭터 라인<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 색을 사용해, 지정된 반복자에
해 지정된 텍스트를 그립니다. 반복자는 각 문자의 폰트를 지정할 필요가 있습니다. 좌단의 문자의 baseline는
 이 그래픽스 컨텍스트
의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - 렌더링 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawChars(char[], int, int, int, int)"><!-- --></A> <H3>
drawChars</H3>
<PRE>
public void <B>drawChars</B>(char[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;length,
                      int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 문자 배열에
해 지정된 텍스트를 그립니다. 최초의 문자의 baseline는
 이 그래픽스 컨텍스트
의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 렌더링 되는 문자의 배열<DD><CODE>offset</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>length</CODE> - 렌더링 되는 문자수<DD><CODE>x</CODE> - 텍스트의 baseline의 <i>x</i> 좌표<DD><CODE>y</CODE> - 텍스트의 baseline의 <i>y</i> 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>drawBytes(byte[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawBytes(byte[], int, int, int, int)"><!-- --></A> <H3>
drawBytes</H3>
<PRE>
public void <B>drawBytes</B>(byte[]&nbsp;data,
                      int&nbsp;offset,
                      int&nbsp;length,
                      int&nbsp;x,
                      int&nbsp;y)</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
의 현재의 폰트와 색을 사용해, 지정된 바이트 배열에
해 지정된 텍스트를 그립니다. 최초의 문자의 baseline는
 이 그래픽스 컨텍스트
의 좌표계의 위치 (<i>x</i>, &nbsp;<i>y</i>)에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 렌더링 되는 데이터<DD><CODE>offset</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>length</CODE> - 렌더링 되는 바이트수<DD><CODE>x</CODE> - 텍스트의 baseline의 <i>x</i> 좌표<DD><CODE>y</CODE> - 텍스트의 baseline의 <i>y</i> 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>drawChars(char[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)"><CODE>drawString(java.lang.String, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 현재 이용 가능한 부분을 그립니다. 이미지는
 이 그래픽스 컨텍스트
의 좌표 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 그 좌상구석을 맞추어 그려집니다. 이미지내의 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.
 <p>
완전한 이미지가 로드가 끝난 상태가 아니고, 현재의 출력 디바이스에 대해서 디저링이 끝난 상태 및 변환이 끝난 상태가 아니어도, 이 메서드는 모든 경우에 즉시 복귀합니다.
 <p>
이미지가 완전하게 로드 되어 픽셀이 변경되지 않게 되었을 경우,<code>drawImage</code>는
 <code>true</code>를
 돌려줍니다. 이미지가 완전하게 로드되어 있지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려주고, 이미지의 한층 더 많은 부분이 이용 가능하게 되는지, 애니메이션의 다른 프레임에 렌더링 되어 이미지를 로드하는 프로세스에
해 지정의 이미지 옵저버에 통지됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 통지되는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;width,
                                  int&nbsp;height,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 구형의 내부에 들어가도록 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다.
 <p>
이미지는
 이 그래픽스 컨텍스트
의 좌표 공간의 지정된 구형내에 렌더링 되어 필요에 따라서 슬캘링 됩니다. 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.
 <p>
이 메서드는
 이미지 전체가 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면, 이미지를 로드하는 프로세스가, 그 <code>imageUpdate</code> 메서드를 호출하는 것에
해 이미지 옵저버에 통지합니다.
 <p>
슬캘링 하고 있지 않는 이미지를 이 출력 디바이스용으로 구축하고 있다고 하는 이유만으로 슬캘링 한 이미지를 즉시 사용할 수 있다고는인가 선. 이미지는 사이즈 마다 개별적으로 캐쉬되어 원의 데이터로부터 다른 이미지 작성 순서에
해 생성되는 일도 있기 때문입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 구형의 폭<DD><CODE>height</CODE> - 구형의 높이<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 통지되는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 현재 이용 가능한 부분만큼을 그립니다. 이미지는
 이 그래픽스 컨텍스트
의 좌표 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 그 좌상구석을 맞추어 렌더링 됩니다. 투명 픽셀은, 지정된 백그라운드 컬러로 그려집니다.
 <p> 
이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.
 <p>
완전한 이미지가 로드가 끝난 상태가 아니고, 현재의 출력 디바이스에 대해서 디저링이 끝난 상태 및 변환이 끝난 상태가 아니어도, 이 메서드는 모든 경우에 즉시 복귀합니다.
 <p>
이미지가 완전하게 로드 되어 픽셀이 변경되지 않게 되었을 경우,<code>drawImage</code>는
 <code>true</code>를
 돌려줍니다. 이미지가 완전하게 로드되어 있지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려주고, 이미지의 한층 더 많은 부분이 이용 가능하게 되는지, 애니메이션의 다른 프레임에 렌더링 되어 이미지를 로드하는 프로세스에
해 지정의 이미지 옵저버에 통지됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에 칠해지는 백그라운드 컬러<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 통지되는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;width,
                                  int&nbsp;height,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 구형의 내부에 들어가도록 슬캘링 해, 지정된 이미지의 이용 가능한 부분을 그립니다.
 <p>
이미지는
 이 그래픽스 컨텍스트
의 좌표 공간의 지정된 구형내에 렌더링 되어 필요에 따라서 슬캘링 됩니다. 투명 픽셀은, 지정된 백그라운드 컬러로 렌더링 됩니다. 이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.
 <p>
이 메서드는
 이미지 전체가 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면, 이미지를 로드하는 프로세스에
해 지정의 이미지 옵저버에 통지됩니다.
 <p>
슬캘링 하고 있지 않는 이미지를 이 출력 디바이스용으로 구축하고 있다고 하는 이유만으로 슬캘링 한 이미지를 즉시 사용할 수 있다고는인가 선. 이미지는 사이즈 마다 개별적으로 캐쉬되어 원의 데이터로부터 다른 이미지 작성 순서에
해 생성되는 일도 있기 때문입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - <i>x</i> 좌표<DD><CODE>y</CODE> - <i>y</i> 좌표<DD><CODE>width</CODE> - 구형의 폭<DD><CODE>height</CODE> - 구형의 높이<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에 칠해지는 백그라운드 컬러<DD><CODE>observer</CODE> - 이미지가 한층 더 변환되는 것이 통지되는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;dx1,
                                  int&nbsp;dy1,
                                  int&nbsp;dx2,
                                  int&nbsp;dy2,
                                  int&nbsp;sx1,
                                  int&nbsp;sy1,
                                  int&nbsp;sx2,
                                  int&nbsp;sy2,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. 지정된 영역의 내부에 들어가도록 즉시 슬캘링 되고 그려집니다. 투명 픽셀은, 거기에 벌써 존재하는 어떠한 픽셀에도 영향을 주지 않습니다.
 <p>
이 메서드는
 렌더링 되는 이미지 영역이 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면, 이미지를 로드하는 프로세스에
해 지정의 이미지 옵저버에 통지됩니다.
 <p>
이 메서드는 항상 슬캘링되어 있지 않은 이미지를 사용해, 슬캘링 된 구형을 그려, 필요한 슬캘링을 즉시 실행합니다. 이것은 이 조작에 대해서는
 캐쉬된 슬캘링 끝난 이미지를 사용하지 않습니다. 소스 구형의 최초의 좌표를 목적지 구형의 최초의 좌표에
 소스의 2 번째의 좌표를 목적지의 2 번째의 좌표에라고 하는 대응으로 매핑 해, 소스로부터 목적지에의 이미지의 슬캘링을 실행합니다. 서브 이미지는
 그 할당을 유지하는 필요성에 응해 슬캘링 되고 반전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>dx1</CODE> - 목적지 구형의 최초의 구석의 <i>x</i> 좌표<DD><CODE>dy1</CODE> - 목적지 구형의 최초의 구석의 <i>y</i> 좌표<DD><CODE>dx2</CODE> - 목적지 구형의 2 번째의 구석의 <i>x</i> 좌표<DD><CODE>dy2</CODE> - 목적지 구형의 2 번째의 구석의 <i>y</i> 좌표<DD><CODE>sx1</CODE> - 소스 구형의 최초의 구석의 <i>x</i> 좌표<DD><CODE>sy1</CODE> - 소스 구형의 최초의 구석의 <i>y</i> 좌표<DD><CODE>sx2</CODE> - 소스 구형의 2 번째의 구석의 <i>x</i> 좌표<DD><CODE>sy2</CODE> - 소스 구형의 2 번째의 구석의 <i>y</i> 좌표<DD><CODE>observer</CODE> - 이미지가 한층 더 슬캘링 되어 변환되는 것을 통지하는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  int&nbsp;dx1,
                                  int&nbsp;dy1,
                                  int&nbsp;dx2,
                                  int&nbsp;dy2,
                                  int&nbsp;sx1,
                                  int&nbsp;sy1,
                                  int&nbsp;sx2,
                                  int&nbsp;sy2,
                                  <A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;bgcolor,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;observer)</PRE>
<DL>
<DD>지정된 이미지의 지정된 영역의 이용 가능한 부분을 그립니다. 지정된 영역의 내부에 들어가도록 즉시 슬캘링 해 그립니다.
 <p>
투명 픽셀은 지정된 백그라운드 컬러로 렌더링 됩니다. 이 조작은, 지정된 이미지의 폭과 높이의 구형이 지정된 색으로 전부 칠하고 나서, 그 위에 이미지를 그리는 것에 상당합니다만, 아마 그것보다 효율적입니다.
 <p>
이 메서드는
 렌더링 되는 이미지 영역이 현재의 출력 디바이스에 대해서 슬캘링 끝나, 디저링 끝나, 변환이 끝난 상태가 아니어도, 모든 경우에 즉시 복귀합니다. 현재의 출력 표현이 아직 완전하지 않은 경우,<code>drawImage</code>는
 <code>false</code>를
 돌려줍니다. 보다 많은 이미지가 이용 가능하게 되면, 이미지를 로드하는 프로세스에
해 지정의 이미지 옵저버에 통지됩니다.
 <p>
이 메서드는 항상 슬캘링되어 있지 않은 이미지를 사용해, 슬캘링 된 구형을 그려, 필요한 슬캘링을 즉시 실행합니다. 이것은 이 조작에 대해서는
 캐쉬된 슬캘링 끝난 이미지를 사용하지 않습니다. 소스 구형의 최초의 좌표를 목적지 구형의 최초의 좌표에
 소스의 2 번째의 좌표를 목적지의 2 번째의 좌표에라고 하는 대응으로 매핑 해, 소스로부터 목적지에의 이미지의 슬캘링을 실행합니다. 서브 이미지는
 그 할당을 유지하는 필요성에 응해 슬캘링 되고 반전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>dx1</CODE> - 목적지 구형의 최초의 구석의 <i>x</i> 좌표<DD><CODE>dy1</CODE> - 목적지 구형의 최초의 구석의 <i>y</i> 좌표<DD><CODE>dx2</CODE> - 목적지 구형의 2 번째의 구석의 <i>x</i> 좌표<DD><CODE>dy2</CODE> - 목적지 구형의 2 번째의 구석의 <i>y</i> 좌표<DD><CODE>sx1</CODE> - 소스 구형의 최초의 구석의 <i>x</i> 좌표<DD><CODE>sy1</CODE> - 소스 구형의 최초의 구석의 <i>y</i> 좌표<DD><CODE>sx2</CODE> - 소스 구형의 2 번째의 구석의 <i>x</i> 좌표<DD><CODE>sy2</CODE> - 소스 구형의 2 번째의 구석의 <i>y</i> 좌표<DD><CODE>bgcolor</CODE> - 이미지의 불투명하지 않은 부분아래에 칠해지는 백그라운드 컬러<DD><CODE>observer</CODE> - 이미지가 한층 더 슬캘링 되어 변환되는 것을 통지하는 오브젝트
<DT><B>반환값:</B><DD>이미지 픽셀이 아직 변경중의 경우는 <code>false</code>, 그렇지 않은 경우는 <code>true</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Image.html" title="java.awt 내의 클래스"><CODE>Image</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A>,
 
<A HREF="../../java/awt/image/ImageObserver.html#imageUpdate(java.awt.Image, int, int, int, int, int)"><CODE>ImageObserver.imageUpdate(java.awt.Image, int, int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A> <H3>
dispose</H3>
<PRE>
public abstract void <B>dispose</B>()</PRE>
<DL>
<DD>이 그래픽스 컨텍스트
을 파기해, 사용중의 system resource가 있으면 그것을 해방합니다. <code>Graphics</code> 오브젝트를 <code>dispose</code>
 호출 후에 사용할 수 없습니다.
 <p>
Java 프로그램이 실행되고 있으면, 단시간 프레임내에서 다수의 <code>Graphics</code> 오브젝트를 작성할 수 있습니다. 가비지 컬렉터의 파이나라이즈프로세스도 같은 system resource를 파기합니다만, 관련된 자원을 수동으로 해방하는 것이 추천 됩니다. 즉, 장기간에 걸쳐 완료까지 실행되지 않을 가능성이 있는 파이나라이즈프로세스에
존하는 것보다도, 이 메서드를 호출해 자원을 수동으로 해방해 주세요.
 <p>
컴퍼넌트의 <code>paint</code> 메서드와 <code>update</code> 메서드에 인수로서 제공되는 Graphics 오브젝트는
 이러한 메서드가 복귀했을 때에 시스템에
해 자동적으로 해방됩니다. 효율성을 확보하려면,
<code>Graphics</code> 오브젝트가 컴퍼넌트 또는 다른 <code>Graphics</code> 오브젝트로부터 직접 작성되었을 경우만, 그 오브젝트를 사용해 종료했을 때에 <code>dispose</code>를
 호출하도록 프로그래밍 하지 않으면 안됩니다.
<P>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#finalize()"><CODE>finalize()</CODE></A>,
 
<A HREF="../../java/awt/Component.html#paint(java.awt.Graphics)"><CODE>Component.paint(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#update(java.awt.Graphics)"><CODE>Component.update(java.awt.Graphics)</CODE></A>,
 
<A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#create()"><CODE>create()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
public void <B>finalize</B>()</PRE>
<DL>
<DD>참조되지 않게 된, 이 그래픽스 컨텍스트
을 파기합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#finalize()">finalize</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#dispose()"><CODE>dispose()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <code>Graphics</code> 오브젝트의 값을 표현하고 있는
<code>String</code> 오브젝트를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 그래픽스 컨텍스트
의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="getClipRect()"><!-- --></A> <H3>
getClipRect</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipRect</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>JDK 버젼 1.1 이후는
<code>getClipBounds()</code> 로 옮겨졌습니다. </I>
<P>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형. 클립이 설정되어 있지 않은 경우는
<code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="hitClip(int, int, int, int)"><!-- --></A> <H3>
hitClip</H3>
<PRE>
public boolean <B>hitClip</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height)</PRE>
<DL>
<DD>지정된 구형 영역이 현재의 클리핑 영역과 교차하는 경우는 true를
 돌려줍니다. 지정된 구형 영역의 좌표는 유저 공간 좌표에 있어, 이 그래픽스 컨텍스트
의 좌표계의 원점을 기준으로 하고 있습니다. 이 메서드는
 결과를 재빠르게 계산하는 알고리즘을 사용합니다만, 지정된 구형 영역이 클리핑 영역과 교차하지 않는 경우에서도 true를
 돌려주는 경우가 있습니다. 이 때문에
 이용하는 알고리즘에는 정밀도와 속도와의 타협이 필요하게 됩니다. 다만, 지정된 구형 영역이 현재의 클리핑 영역과 교차하지 않는 것이 보증되지 않는 한 false를
 돌려줄 것은 없습니다. 이 메서드로 사용하는 클리핑 영역은, 디바이스 또는 이미지 경계와 윈도우 가시에 관련한 클리핑과 동시에
 이 그래픽스 컨텍스트
의 클립 메서드에
해 지정된 유저 클립의 교차를 표현할 수가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 x 좌표<DD><CODE>y</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 y 좌표<DD><CODE>width</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 폭<DD><CODE>height</CODE> - 현재의 클리핑 영역이라고 비교되는 구형의 높이
<DT><B>반환값:</B><DD>지정된 구형이 현재의 클립의 경계와 교차하는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="getClipBounds(java.awt.Rectangle)"><!-- --></A> <H3>
getClipBounds</H3>
<PRE>
public <A HREF="../../java/awt/Rectangle.html" title="java.awt 내의 클래스">Rectangle</A>  <B>getClipBounds</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;r)</PRE>
<DL>
<DD>현재의 클리핑 영역의 경계의 구형을 돌려줍니다. 구형내의 좌표는 이 그래픽스 컨텍스트
의 좌표계의 원점을 기준으로 하고 있습니다. 이 메서드는 <A HREF="../../java/awt/Graphics.html#getClipBounds()"><CODE>getClipBounds</CODE></A>  과는 달리, 새로운 것을 할당하지 말고 기존의 구형을 사용합니다. 이 메서드는
 디바이스 경계나 윈도우 가시에 관련한 클리핑에는
존하지 않는 유저 클립을 참조합니다. 클립이 설정되어 있지 않은 경우, 또는 클립이 <code>setClip(null)</code>를
 사용해 클리어 되고 있는 경우는
 이 메서드는 지정한 <code>Rectangle</code>를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 현재의 클리핑 영역의 카피처의 구형. 이 구형에 현재의 값이 있으면 덧쓰기된다
<DT><B>반환값:</B><DD>현재의 클리핑 영역의 경계의 구형</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/awt/GradientPaint.html" title="java.awt 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/Graphics2D.html" title="java.awt 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/awt/Graphics.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Graphics.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:55:45 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
AffineTransform (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.geom.AffineTransform class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AffineTransform (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AffineTransform.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/awt/geom/Arc2D.html" title="java.awt.geom 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/geom/AffineTransform.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="AffineTransform.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt.geom</FONT>
<BR>
클래스 AffineTransform</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.geom.AffineTransform</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A>,
 <A HREF="../../../java/lang/Cloneable.html" title="java.lang 안의 인터페이스">Cloneable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>AffineTransform</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A>,
 <A HREF="../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>AffineTransform</code> 클래스는
 선의 직선성과 평행성을 유지한채로 2 차원 좌표간의 선형 매핑을 실행하는 2 차원 아핀 변환을 표현합니다. 아핀 변환은, 일련의 평행이동, 슬캘링, 반전, 회전, 변형에
해 구성됩니다.
 <p>
이러한 좌표변화는
 암묵으로 지정된 [ 0 0 1 ] 이라고 하는 맨 마지막 줄을 가지는 3 행× 3 열의 행렬에
해 표현할 수 있습니다. 이 행렬은, 다음의 처리에 따라, 좌표를 열이라고 봐, 좌표 벡터를 행렬로 곱셈하는 것에
해, 전송원좌표 <code>(x, &nbsp;y)</code>를
 전송처 좌표 <code>(x', &nbsp;y')</code> 로 변환합니다.
 
 <pre>

        [ x']   [  m00  m01  m02  ] [ x ]   [ m00x + m01y + m02 ]
        [ y'] = [  m10  m11  m12  ] [ y ] = [ m10x + m11y + m12 ]
        [ 1 ]   [   0    0    1   ] [ 1 ]   [         1         ]
 </pre>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../serialized-form.html#java.awt.geom.AffineTransform">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP">TYPE_FLIP</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 어느 축을 중심으로 하는 경상반전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION">TYPE_GENERAL_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 임의의 각도에
한 회전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE">TYPE_GENERAL_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 범용적인 슬캘링을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM">TYPE_GENERAL_TRANSFORM</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는
 이 오브젝트에
해 정의되는 변환이, 입력 좌표의 임의의 변환을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY">TYPE_IDENTITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는
 이 오브젝트에
해 정의되는 변환이 항등변환인 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_MASK_ROTATION">TYPE_MASK_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는
 회전 flag bit의 어떤 것인가의 비트 마스크입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_MASK_SCALE">TYPE_MASK_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 정수는
 스케일 flag bit의 어떤 것인가의 비트 마스크입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION">TYPE_QUADRANT_ROTATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 90 번의 배수에 4분원 회전을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION">TYPE_TRANSLATION</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 1 개의 이동을 실행하는 것을 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE">TYPE_UNIFORM_SCALE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 한결같은 슬캘링을 실행하는 것을 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform()">AffineTransform</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;항등변환을 표현하는 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(java.awt.geom.AffineTransform)">AffineTransform</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>AffineTransform</code> 오브젝트의 카피인, 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(double[])">AffineTransform</A> </B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 배정밀도치의 배열로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(double, double, double, double, double, double)">AffineTransform</A> </B>(double&nbsp;m00,
                double&nbsp;m10,
                double&nbsp;m01,
                double&nbsp;m11,
                double&nbsp;m02,
                double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 배정밀도치로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(float[])">AffineTransform</A> </B>(float[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 부동 소수점치의 배열로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#AffineTransform(float, float, float, float, float, float)">AffineTransform</A> </B>(float&nbsp;m00,
                float&nbsp;m10,
                float&nbsp;m01,
                float&nbsp;m11,
                float&nbsp;m02,
                float&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 부동 소수점치로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 오브젝트의 카피를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#concatenate(java.awt.geom.AffineTransform)">concatenate</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Tx</code> 에
해 원의 유저 공간에 맵 된 새로운 유저 공간을 제공하기 위해서 가장 일반적으로 사용되는 방법으로<code>AffineTransform</code> <code>Tx</code>를
 이 <code>AffineTransform</code> Cx 에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#createInverse()">createInverse</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;역변환을 표현하는 <code>AffineTransform</code> 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#createTransformedShape(java.awt.Shape)">createTransformedShape</A> </B>(<A HREF="../../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;pSrc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Shape</code>를
 이 변환에
해 변환해, 그 <code>Shape</code>
 지오메트리에
해 정의되는 새로운 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#deltaTransform(double[], int, double[], int, int)">deltaTransform</A> </B>(double[]&nbsp;srcPts,
               int&nbsp;srcOff,
               double[]&nbsp;dstPts,
               int&nbsp;dstOff,
               int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해 상대적인 거리 벡터의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#deltaTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)">deltaTransform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
               <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>ptSrc</code> 에
해 지정되는 상대적인 거리 벡터를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 이, 지정된 인수와 같은 아핀 좌표변화를 표현하는 경우에 <code>true</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getDeterminant()">getDeterminant</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;변환의 행렬 표현의 행렬식을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])">getMatrix</A> </B>(double[]&nbsp;flatmatrix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬내의 6 개의 지정 가능한 값을 꺼내, 배정밀도치의 배열에 배치합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double)">getRotateInstance</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;회전 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getRotateInstance(double, double, double)">getRotateInstance</A> </B>(double&nbsp;theta,
                  double&nbsp;x,
                  double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleInstance(double, double)">getScaleInstance</A> </B>(double&nbsp;sx,
                 double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;슬캘링 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleX()">getScaleX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 X 좌표 슬캘링 요소 (m00)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleY()">getScaleY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 Y 좌표 슬캘링 요소 (m11)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearInstance(double, double)">getShearInstance</A> </B>(double&nbsp;shx,
                 double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;셔링 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearX()">getShearX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 X 좌표 셔링 요소 (m01)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getShearY()">getShearY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 Y 좌표 셔링 요소 (m10)를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateInstance(double, double)">getTranslateInstance</A> </B>(double&nbsp;tx,
                     double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;평행이동 변환을 표현하는 변환을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateX()">getTranslateX</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 평행이동 요소 (m02)의 X 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateY()">getTranslateY</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3×3 아핀 변환 행렬의 평행이동 요소 (m12)의 Y 좌표를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#getType()">getType</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환의 변환 프로퍼티를 기술하는 flag bit를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환의 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(double[], int, double[], int, int)">inverseTransform</A> </B>(double[]&nbsp;srcPts,
                 int&nbsp;srcOff,
                 double[]&nbsp;dstPts,
                 int&nbsp;dstOff,
                 int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해 배정밀도의 좌표의 배열을 역변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)">inverseTransform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                 <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>ptSrc</code>를
 역변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#isIdentity()">isIdentity</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>AffineTransform</code> 이 항등변환인 경우에 <code>true</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#preConcatenate(java.awt.geom.AffineTransform)">preConcatenate</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Tx</code> 가 기존의 유저 공간은 아니고 절대 픽셀 공간을 기준(? 좌표변화를 변경하는 등 일반적으로는 그다지 사용되지 않는 방법으로<code>AffineTransform</code> <code>Tx</code>를
 이 <code>AffineTransform</code> Cx 에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double)">rotate</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 회전 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#rotate(double, double, double)">rotate</A> </B>(double&nbsp;theta,
       double&nbsp;x,
       double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 엥커 포인트를 중심으로 해 좌표를 회전하는 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#scale(double, double)">scale</A> </B>(double&nbsp;sx,
      double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 슬캘링 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToIdentity()">setToIdentity</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 항등변환으로 다시 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double)">setToRotation</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToRotation(double, double, double)">setToRotation</A> </B>(double&nbsp;theta,
              double&nbsp;x,
              double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 후의 회전 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToScale(double, double)">setToScale</A> </B>(double&nbsp;sx,
           double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 슬캘링 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToShear(double, double)">setToShear</A> </B>(double&nbsp;shx,
           double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 셔링 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setToTranslation(double, double)">setToTranslation</A> </B>(double&nbsp;tx,
                 double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 변환으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A> </B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을, 지정된 <code>AffineTransform</code> 오브젝트내의 변환의 카피로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#setTransform(double, double, double, double, double, double)">setTransform</A> </B>(double&nbsp;m00,
             double&nbsp;m10,
             double&nbsp;m01,
             double&nbsp;m11,
             double&nbsp;m02,
             double&nbsp;m12)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 6 개의 배정밀도치에
해 지정되고 있는 행렬로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#shear(double, double)">shear</A> </B>(double&nbsp;shx,
      double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 셔링 변환에 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A> 
 값을 나타내는 <code>String</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(double[], int, double[], int, int)">transform</A> </B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해, 배정밀도의 좌표의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(double[], int, float[], int, int)">transform</A> </B>(double[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해 배정밀도의 좌표의 배열을 변환해, 결과를 float 치의 배열에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(float[], int, double[], int, int)">transform</A> </B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          double[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해 부동 소수점의 좌표의 배열을 변환해, 결과를 double 치의 배열에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(float[], int, float[], int, int)">transform</A> </B>(float[]&nbsp;srcPts,
          int&nbsp;srcOff,
          float[]&nbsp;dstPts,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해, 부동 소수점의 좌표의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)">transform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptSrc,
          int&nbsp;srcOff,
          <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptDst,
          int&nbsp;dstOff,
          int&nbsp;numPts)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환에
해 포인트 오브젝트의 배열을 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#transform(java.awt.geom.Point2D, java.awt.geom.Point2D)">transform</A> </B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
          <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>ptSrc</code>를
 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/awt/geom/AffineTransform.html#translate(double, double)">translate</A> </B>(double&nbsp;tx,
          double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 변환을 평행이동 변환에 연결합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="TYPE_IDENTITY"><!-- --></A> <H3>
TYPE_IDENTITY</H3>
<PRE>
public static final int <B>TYPE_IDENTITY</B></PRE>
<DL>
<DD>이 정수는
 이 오브젝트에
해 정의되는 변환이 항등변환인 것을 나타냅니다. 항등변환에서는
 출력 좌표가 항상 입력 좌표와 같게 됩니다. 이 변환이 항등변환이 아닌 경우, 형태는 정수 GENERAL_TRANSFORM 인가, 이 변환이 실행하는 다양한 좌표변화를 위한 적절한 flag bit의 편성의 어딘가에 됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_IDENTITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_TRANSLATION"><!-- --></A> <H3>
TYPE_TRANSLATION</H3>
<PRE>
public static final int <B>TYPE_TRANSLATION</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 1 개의 이동을 실행하는 것을 나타냅니다. 이동에서는
 벡터의 길이나 각도를 바꾸지 않고 좌표를 x 방향과 y 방향으로 일정량만 이동합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_TRANSLATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_UNIFORM_SCALE"><!-- --></A> <H3>
TYPE_UNIFORM_SCALE</H3>
<PRE>
public static final int <B>TYPE_UNIFORM_SCALE</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 한결같은 슬캘링을 실행하는 것을 나타냅니다. 일률적인 슬캘링에서는
 벡터간의 각도를 바꾸지 않고 벡터의 길이를 x 방향과 y 방향의 어느 쪽에도 일정량만 곱셈합니다. 이 flag bit는
 TYPE_GENERAL_SCALE 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_UNIFORM_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_SCALE"><!-- --></A> <H3>
TYPE_GENERAL_SCALE</H3>
<PRE>
public static final int <B>TYPE_GENERAL_SCALE</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 범용적인 슬캘링을 실행하는 것을 나타냅니다. 범용적인 슬캘링에서는
 수직인 벡터간의 각도를 바꾸지 않고 벡터의 길이를 x 방향과 y 방향으로 다른 양만 곱셈합니다. 이 flag bit는
 TYPE_UNIFORM_SCALE 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_MASK_SCALE"><!-- --></A> <H3>
TYPE_MASK_SCALE</H3>
<PRE>
public static final int <B>TYPE_MASK_SCALE</B></PRE>
<DL>
<DD>이 정수는
 스케일 flag bit의 어떤 것인가의 비트 마스크입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_SCALE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_FLIP"><!-- --></A> <H3>
TYPE_FLIP</H3>
<PRE>
public static final int <B>TYPE_FLIP</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 어느 축을 중심으로 하는 경상반전을 실행하는 것을 나타냅니다. 경상반전에
해, 일반적으로 오른손의 좌표계가 왼손의 좌표계로 변경됩니다. 오른손의 좌표계는
 오른손의 엄지의 첨단을 응시하고 있는 상태로 엄지 이외의 손가락을 굽히는 것과 같은 방향으로 정의 X 축이 반시계방향으로 회전해 정의 Y 축으로 겹치는 것입니다. 왼손의 좌표계는
 왼손의 엄지 이외를 굽히는 것과 같은 방향으로 정의 X 축이 시계 방향으로 회전해 정의 Y 축으로 겹치는 것입니다. 적절한 조정 회전을 지정하면 회전의 각도는 모두 같게 되므로 원의 반전 또는 밀러 변환의 각도를 판정하는 산술적 방법은 없습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_FLIP">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_QUADRANT_ROTATION"><!-- --></A> <H3>
TYPE_QUADRANT_ROTATION</H3>
<PRE>
public static final int <B>TYPE_QUADRANT_ROTATION</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 90 번의 배수에 4분원 회전을 실행하는 것을 나타냅니다. 회전에서는
 벡터의 길이를 바꾸지 않고,
 원의 방향 에 관계없이 같은 양만 벡터의 각도를 변경합니다. 이 flag bit는
 TYPE_GENERAL_ROTATION 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_QUADRANT_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_ROTATION"><!-- --></A> <H3>
TYPE_GENERAL_ROTATION</H3>
<PRE>
public static final int <B>TYPE_GENERAL_ROTATION</B></PRE>
<DL>
<DD>이 flag bit는
 이 오브젝트에
해 정의되는 변환이, 다른 flag bit에
해 지정되는 변환에 가세해, 임의의 각도에
한 회전을 실행하는 것을 나타냅니다. 회전에서는
 벡터의 길이를 바꾸지 않고,
 원의 방향 에 관계없이 같은 양만 벡터의 각도를 변경합니다. 이 flag bit는
 TYPE_QUADRANT_ROTATION 플래그와 서로 배타적입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_MASK_ROTATION"><!-- --></A> <H3>
TYPE_MASK_ROTATION</H3>
<PRE>
public static final int <B>TYPE_MASK_ROTATION</B></PRE>
<DL>
<DD>이 정수는
 회전 flag bit의 어떤 것인가의 비트 마스크입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_MASK_ROTATION">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="TYPE_GENERAL_TRANSFORM"><!-- --></A> <H3>
TYPE_GENERAL_TRANSFORM</H3>
<PRE>
public static final int <B>TYPE_GENERAL_TRANSFORM</B></PRE>
<DL>
<DD>이 정수는
 이 오브젝트에
해 정의되는 변환이, 입력 좌표의 임의의 변환을 실행하는 것을 나타냅니다. 이 변환을 상기의 정수의 어떤 것인가에 분류되는 경우, 형태는 정수 TYPE_IDENTITY 인가, 이 변환이 실행하는 다양한 좌표변화를 위한 적절한 flag bit의 편성의 어딘가에 됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_FLIP"><CODE>TYPE_FLIP</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../constant-values.html#java.awt.geom.AffineTransform.TYPE_GENERAL_TRANSFORM">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AffineTransform()"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>()</PRE>
<DL>
<DD>항등변환을 표현하는 새로운 <code>AffineTransform</code>를
 구축합니다.
<P>
</DL>
<HR>

<A NAME="AffineTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD>지정된 <code>AffineTransform</code> 오브젝트의 카피인, 새로운 <code>AffineTransform</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 카피하는 <code>AffineTransform</code> 오브젝트</DL>
</DL>
<HR>

<A NAME="AffineTransform(float, float, float, float, float, float)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(float&nbsp;m00,
                       float&nbsp;m10,
                       float&nbsp;m01,
                       float&nbsp;m11,
                       float&nbsp;m02,
                       float&nbsp;m12)</PRE>
<DL>
<DD>3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 부동 소수점치로부터, 새로운 <code>AffineTransform</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>m00, &nbsp;m01, &nbsp;m02, &nbsp;m10, &nbsp;m11, &nbsp;m12</CODE> - 3x3 변환 행렬을 구성하는 6 개의 부동 소수점치</DL>
</DL>
<HR>

<A NAME="AffineTransform(float[])"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(float[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 부동 소수점치의 배열로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. 각 치는
 배열로부터 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]} 라고 하는 형식에서 꺼내집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 새로운 <code>AffineTransform</code> 오브젝트로 설정되는 각 치를 포함하고 있는 float 치의 배열. 배열의 길이는
 4 이상인 것이 전제. 배열의 길이가 6 보다 작은 경우, 최초의 4 개의 값만이 취득된다. 배열의 길이가 6 보다 큰 경우, 최초의 6 개의 값이 취득된다</DL>
</DL>
<HR>

<A NAME="AffineTransform(double, double, double, double, double, double)"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(double&nbsp;m00,
                       double&nbsp;m10,
                       double&nbsp;m01,
                       double&nbsp;m11,
                       double&nbsp;m02,
                       double&nbsp;m12)</PRE>
<DL>
<DD>3×3 변환 행렬의 6 개의 지정 가능 엔트리를 표현하는 6 개의 배정밀도치로부터, 새로운 <code>AffineTransform</code>를
 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>m00, &nbsp;m01, &nbsp;m02, &nbsp;m10, &nbsp;m11, &nbsp;m12</CODE> - 3x3 변환 행렬을 구성하는 6 개의 부동 소수점치</DL>
</DL>
<HR>

<A NAME="AffineTransform(double[])"><!-- --></A> <H3>
AffineTransform</H3>
<PRE>
public <B>AffineTransform</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 변환 행렬의 4 개의 비평행이동 엔트리 또는 6 개의 지정 가능 엔트리의 어느 쪽인지를 표현하는 배정밀도치의 배열로부터, 새로운 <code>AffineTransform</code>를
 구축합니다. 각 치는
 배열로부터 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;[m02&nbsp;m12]} 라고 하는 형식에서 꺼내집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 새로운 <code>AffineTransform</code> 오브젝트로 설정되는 각 치를 포함하고 있는 double 치의 배열. 배열의 길이는
 4 이상인 것이 전제. 배열의 길이가 6 보다 작은 경우, 최초의 4 개의 값만이 취득된다. 배열의 길이가 6 보다 큰 경우, 최초의 6 개의 값이 취득된다</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getTranslateInstance(double, double)"><!-- --></A> <H3>
getTranslateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getTranslateInstance</B>(double&nbsp;tx,
                                                   double&nbsp;ty)</PRE>
<DL>
<DD>평행이동 변환을 표현하는 변환을 돌려줍니다. 돌려주고지는 변환의 행렬 표현은, 다음과 같이 됩니다.
 
 <pre>

                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 되는 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 되는 거리
<DT><B>반환값:</B><DD>지정된 벡터로 작성된, 평행이동 변환을 나타내는 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;theta)</PRE>
<DL>
<DD>회전 변환을 표현하는 변환을 돌려줍니다. 돌려주고지는 변환의 행렬 표현은, 다음과 같이 됩니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도
<DT><B>반환값:</B><DD>지정된 회전 각도로 작성된, 회전 변환을 나타내는 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="getRotateInstance(double, double, double)"><!-- --></A> <H3>
getRotateInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getRotateInstance</B>(double&nbsp;theta,
                                                double&nbsp;x,
                                                double&nbsp;y)</PRE>
<DL>
<DD>엥커 포인트를 중심으로 해 좌표를 회전시키는 변환을 돌려줍니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록 이동해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서 이동하는 것에 상당합니다.
 <p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 
 <pre>

            AffineTransform Tx = new AffineTransform();
            Tx.setToTranslation(x, y);  // S3: final translation
            Tx.rotate(theta);           // S2: rotate around anchor
            Tx.translate(-x, -y);       // S1: translate anchor to origin
 </pre>
돌려주고지는 변환의 행렬 표현은, 다음과 같이 됩니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                [       0              0               1        ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도<DD><CODE>x, &nbsp;y</CODE> - 회전의 엥커 포인트의 좌표
<DT><B>반환값:</B><DD>지정된 점을 중심으로서 지정된 회전 각도로 좌표를 회전하는 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="getScaleInstance(double, double)"><!-- --></A> <H3>
getScaleInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getScaleInstance</B>(double&nbsp;sx,
                                               double&nbsp;sy)</PRE>
<DL>
<DD>슬캘링 변환을 표현하는 변환을 돌려줍니다. 돌려주고지는 변환의 행렬 표현은, 다음과 같이 됩니다.
 
 <pre>

                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서 사용하는 계수
<DT><B>반환값:</B><DD>지정된 계수로 좌표를 슬캘링 하는 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="getShearInstance(double, double)"><!-- --></A> <H3>
getShearInstance</H3>
<PRE>
public static <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getShearInstance</B>(double&nbsp;shx,
                                               double&nbsp;shy)</PRE>
<DL>
<DD>셔링 변환을 표현하는 변환을 돌려줍니다. 돌려주고지는 변환의 행렬 표현은, 다음과 같이 됩니다.
 
 <pre>

                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의 방향으로 이동하기 위해서 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의 방향으로 이동하기 위해서 사용하는 승수
<DT><B>반환값:</B><DD>지정된 승수로 좌표를 변형시키는 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="getType()"><!-- --></A> <H3>
getType</H3>
<PRE>
public int <B>getType</B>()</PRE>
<DL>
<DD>이 변환의 변환 프로퍼티를 기술하는 flag bit를 돌려줍니다. 돌려주고지는 값은, 정수 TYPE_IDENTITY 또는 TYPE_GENERAL_TRANSFORM
 어느 쪽인지, 혹은 적절한 flag bit의 편성이 됩니다. flag bit의 유효한 편성은, TYPE_UNIFORM_SCALE flag bit 또는 TYPE_GENERAL_SCALE flag bit의 어느 쪽일까하고, TYPE_QUADRANT_ROTATION flag bit 또는 TYPE_GENERAL_ROTATION flag bit의 어딘가에 더해, TYPE_TRANSLATION flag bit를 결합하는 배타적 논리합의 연산입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 변환에 적용되는 임의의 지정 플래그에
한 논리합의 편성<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_IDENTITY"><CODE>TYPE_IDENTITY</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_TRANSLATION"><CODE>TYPE_TRANSLATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_SCALE"><CODE>TYPE_GENERAL_SCALE</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_QUADRANT_ROTATION"><CODE>TYPE_QUADRANT_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_ROTATION"><CODE>TYPE_GENERAL_ROTATION</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_GENERAL_TRANSFORM"><CODE>TYPE_GENERAL_TRANSFORM</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDeterminant()"><!-- --></A> <H3>
getDeterminant</H3>
<PRE>
public double <B>getDeterminant</B>()</PRE>
<DL>
<DD>변환의 행렬 표현의 행렬식을 돌려줍니다. 행렬식은, 역변환의 존재를 판정하기 위해서도, X 와 Y
 슬캘링의 편성에
한 변환을 표현하는 1 개의 값을 취득하기 위해서도 사용할 수 있습니다.
 <p>
행렬식이 제로가 아닌 경우, 이 변환에는 역변환이 존재해, 역변환에
존하는 다양한 메서드는 <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스"><CODE>NoninvertibleTransformException</CODE></A> 를
 Throw 할 필요가 없습니다. 행렬식이 제로의 경우, 이 변환은 모든 입력 좌표를 선 또는 점에 맵 하므로 역변환할 수 없습니다. 행렬식이 충분히 제로에 가까운 경우, 역변환 오퍼레이션은
미가 있는 결과를 낼 수 있을 뿐의 정밀도를 확보 가능한 있고 경우가 있습니다.
 <p>
<code>getType</code> 메서드로 나타나도록(듯이), 이 변환이 한결같은 슬캘링을 표현하는 경우, 행렬식은 모든 점이 원점을 기준에 확장 또는 축소되는 한결같은 슬캘링 계수의 2 승을 나타냅니다. 이 변환이 한결같지 않은 슬캘링 또는보다 범용적인 변환을 표현하는 경우, 행렬식이 나타내는 값은, 역변환이 가능한가 어떤가를 판정하기 위해인 만큼 사용할 수 있습니다.
 <p>
산술적으로 행렬식은 다음의 공식에서 계산됩니다.
 
 <pre>

                |  m00  m01  m02  |
                |  m10  m11  m12  |  =  m00 * m11 - m01 * m10
                |   0    0    1   |
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>좌표를 변환하기 위해서 사용되는 행렬의 행렬식<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getType()"><CODE>getType()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#createInverse()"><CODE>createInverse()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><CODE>inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#TYPE_UNIFORM_SCALE"><CODE>TYPE_UNIFORM_SCALE</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMatrix(double[])"><!-- --></A> <H3>
getMatrix</H3>
<PRE>
public void <B>getMatrix</B>(double[]&nbsp;flatmatrix)</PRE>
<DL>
<DD>3×3 아핀 변환 행렬내의 6 개의 지정 가능한 값을 꺼내, 배정밀도치의 배열에 배치합니다. 각 치는 배열에 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;m02&nbsp;m12&nbsp;} 라고 하는 형식에서 포함됩니다. 4 개의 double 치의 배열도 지정할 수 있습니다. 그 경우는
 배열의 비평행이동 부분을 나타내는 최초의 4 개의 요소만이 꺼내져 값은 배열에 {&nbsp;m00&nbsp;m10&nbsp;m01&nbsp;m11&nbsp;} 라고 하는 형식에서 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>flatmatrix</CODE> - 반환값을 포함하기 위해서 사용하는 double 치의 배열<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getScaleX()"><CODE>getScaleX()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getScaleY()"><CODE>getScaleY()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getShearX()"><CODE>getShearX()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getShearY()"><CODE>getShearY()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateX()"><CODE>getTranslateX()</CODE></A>,
 
<A HREF="../../../java/awt/geom/AffineTransform.html#getTranslateY()"><CODE>getTranslateY()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScaleX()"><!-- --></A> <H3>
getScaleX</H3>
<PRE>
public double <B>getScaleX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 X 좌표 슬캘링 요소 (m00)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 슬캘링 요소의 X 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getScaleY()"><!-- --></A> <H3>
getScaleY</H3>
<PRE>
public double <B>getScaleY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 Y 좌표 슬캘링 요소 (m11)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 슬캘링 요소의 Y 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShearX()"><!-- --></A> <H3>
getShearX</H3>
<PRE>
public double <B>getShearX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 X 좌표 셔링 요소 (m01)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 셔링 요소의 X 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getShearY()"><!-- --></A> <H3>
getShearY</H3>
<PRE>
public double <B>getShearY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 Y 좌표 셔링 요소 (m10)를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 셔링 요소의 Y 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A> <H3>
getTranslateX</H3>
<PRE>
public double <B>getTranslateX</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 평행이동 요소 (m02)의 X 좌표를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 평행이동 요소의 X 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A> <H3>
getTranslateY</H3>
<PRE>
public double <B>getTranslateY</B>()</PRE>
<DL>
<DD>3×3 아핀 변환 행렬의 평행이동 요소 (m12)의 Y 좌표를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>아핀 변환 행렬의 평행이동 요소의 Y 좌표를 나타내는 double 치<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getMatrix(double[])"><CODE>getMatrix(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A> <H3>
translate</H3>
<PRE>
public void <B>translate</B>(double&nbsp;tx,
                      double&nbsp;ty)</PRE>
<DL>
<DD>이 변환을 평행이동 변환에 연결합니다. 이것은, concatenate(T)를 호출하는 것에 상당합니다. 다만, T는
 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 되는 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 되는 거리</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>이 변환을 회전 변환에 연결합니다. 이것은, concatenate(R)를 호출하는 것에 상당합니다. 다만, R는
 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public void <B>rotate</B>(double&nbsp;theta,
                   double&nbsp;x,
                   double&nbsp;y)</PRE>
<DL>
<DD>이 변환을, 엥커 포인트를 중심으로 해 좌표를 회전하는 변환과 연결합니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록 평행이동 해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서 평행이동 하는 것에 상당합니다.
 <p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 
 <pre>

                translate(x, y);        // S3: final translation
                rotate(theta);          // S2: rotate around anchor
                translate(-x, -y);              // S1: translate anchor to origin
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도<DD><CODE>x, &nbsp;y</CODE> - 회전의 엥커 포인트의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double)"><!-- --></A> <H3>
scale</H3>
<PRE>
public void <B>scale</B>(double&nbsp;sx,
                  double&nbsp;sy)</PRE>
<DL>
<DD>이 변환을 슬캘링 변환에 연결합니다. 이것은, concatenate(S)를 호출하는 것에 상당합니다. 다만, S는
 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서 사용하는 계수</DL>
</DD>
</DL>
<HR>

<A NAME="shear(double, double)"><!-- --></A> <H3>
shear</H3>
<PRE>
public void <B>shear</B>(double&nbsp;shx,
                  double&nbsp;shy)</PRE>
<DL>
<DD>이 변환을 셔링 변환에 연결합니다. 이것은, concatenate(SH)를 호출하는 것에 상당합니다. 다만, SH는
 다음의 행렬로 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의 방향으로 이동하기 위해서 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의 방향으로 이동하기 위해서 사용하는 승수</DL>
</DD>
</DL>
<HR>

<A NAME="setToIdentity()"><!-- --></A> <H3>
setToIdentity</H3>
<PRE>
public void <B>setToIdentity</B>()</PRE>
<DL>
<DD>이 변환을 항등변환으로 다시 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setToTranslation(double, double)"><!-- --></A> <H3>
setToTranslation</H3>
<PRE>
public void <B>setToTranslation</B>(double&nbsp;tx,
                             double&nbsp;ty)</PRE>
<DL>
<DD>이 변환을 평행이동 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 
 <pre>

                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - 좌표가 X 축방향으로 평행이동 되는 거리<DD><CODE>ty</CODE> - 좌표가 Y 축방향으로 평행이동 되는 거리</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;theta)</PRE>
<DL>
<DD>이 변환을 회전 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도</DL>
</DD>
</DL>
<HR>

<A NAME="setToRotation(double, double, double)"><!-- --></A> <H3>
setToRotation</H3>
<PRE>
public void <B>setToRotation</B>(double&nbsp;theta,
                          double&nbsp;x,
                          double&nbsp;y)</PRE>
<DL>
<DD>이 변환을 평행이동 후의 회전 변환으로 설정합니다. 이 오퍼레이션은, 좌표를 엥커 포인트가 원점 (S1)이 되도록 이동해, 이러한 좌표를 새로운 원점 (S2)을 중심으로 회전하고 나서, 마지막에 그 중개적인 원점을 전의 엥커 포인트 (S3)의 좌표에 되돌리기 위해서 이동하는 것에 상당합니다.
 <p>
이 조작은, 다음의 일련의 호출해에 상당합니다.
 
 <pre>

            setToTranslation(x, y);     // S3: final translation
            rotate(theta);              // S2: rotate around anchor
            translate(-x, -y);          // S1: translate anchor to origin
 </pre>
이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    x-x*cos+y*sin  ]
                [   sin(theta)     cos(theta)    y-x*sin-y*cos  ]
                [       0              0               1        ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도<DD><CODE>x, &nbsp;y</CODE> - 회전의 엥커 포인트의 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="setToScale(double, double)"><!-- --></A> <H3>
setToScale</H3>
<PRE>
public void <B>setToScale</B>(double&nbsp;sx,
                       double&nbsp;sy)</PRE>
<DL>
<DD>이 변환을 슬캘링 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 
 <pre>

                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 좌표를 X 축방향으로 슬캘링 하기 위해서 사용하는 계수<DD><CODE>sy</CODE> - 좌표를 Y 축방향으로 슬캘링 하기 위해서 사용하는 계수</DL>
</DD>
</DL>
<HR>

<A NAME="setToShear(double, double)"><!-- --></A> <H3>
setToShear</H3>
<PRE>
public void <B>setToShear</B>(double&nbsp;shx,
                       double&nbsp;shy)</PRE>
<DL>
<DD>이 변환을 셔링 변환으로 설정합니다. 이 변환을 표현하는 행렬은 다음과 같이 됩니다.
 
 <pre>

                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 계수로 좌표를 정의 X 축의 방향으로 이동하기 위해서 사용하는 승수<DD><CODE>shy</CODE> - X 좌표의 계수로 좌표를 정의 Y 축의 방향으로 이동하기 위해서 사용하는 승수</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD>이 변환을, 지정된 <code>AffineTransform</code> 오브젝트내의 변환의 카피로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 변환의 카피원의 <code>AffineTransform</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(double, double, double, double, double, double)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public void <B>setTransform</B>(double&nbsp;m00,
                         double&nbsp;m10,
                         double&nbsp;m01,
                         double&nbsp;m11,
                         double&nbsp;m02,
                         double&nbsp;m12)</PRE>
<DL>
<DD>이 변환을 6 개의 배정밀도치에
해 지정되고 있는 행렬로 설정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>m00, &nbsp;m01, &nbsp;m02, &nbsp;m10, &nbsp;m11, &nbsp;m12</CODE> - 3x3 변환 행렬을 구성하는 6 개의 부동 소수점치</DL>
</DD>
</DL>
<HR>

<A NAME="concatenate(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
concatenate</H3>
<PRE>
public void <B>concatenate</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Tx</code> 에
해 원의 유저 공간에 맵 된 새로운 유저 공간을 제공하기 위해서 가장 일반적으로 사용되는 방법으로<code>AffineTransform</code> <code>Tx</code>를
 이 <code>AffineTransform</code> Cx 에 연결합니다. Cx를
 갱신하면, 결합된 변환을 실행할 수 있습니다. 갱신된 변환 Cx'로 점 p를
 변환하는 것은, 최초로 <code>Tx</code> 로 p를
 변환하고 나서, 그 결과를 원의 변환 Cx 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Cx(Tx(p))입니다. 행렬 표기에서는
 이 변환 Cx 가 행렬 [this] 로 표현되어<code>Tx</code> 가 행렬 [Tx] 로 표현되는 경우, 이 메서드는 다음의 처리를 실시합니다.
 
 <pre>

                [this] = [this] x [Tx]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 이 <code>AffineTransform</code> 오브젝트에 연결되는 <code>AffineTransform</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#preConcatenate(java.awt.geom.AffineTransform)"><CODE>preConcatenate(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="preConcatenate(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
preConcatenate</H3>
<PRE>
public void <B>preConcatenate</B>(<A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Tx</code> 가 기존의 유저 공간은 아니고 절대 픽셀 공간을 기준(? 좌표변화를 변경하는 등 일반적으로는 그다지 사용되지 않는 방법으로<code>AffineTransform</code> <code>Tx</code>를
 이 <code>AffineTransform</code> Cx 에 연결합니다. Cx를
 갱신하면, 결합된 변환을 실행할 수 있습니다. 갱신된 변환 Cx'로 점 p를
 변환하는 것은, 최초로 원의 변환 Cx 로 p를
 변환하고 나서, 그 결과를 <code>Tx</code> 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Tx(Cx(p))입니다. 행렬 표기에서는
 이 변환 Cx 가 행렬 [this] 로 표현되어<code>Tx</code> 가 행렬 [Tx] 로 표현되는 경우, 이 메서드는 다음의 처리를 실시합니다.
 
 <pre>

                [this] = [Tx] x [this]
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 이 <code>AffineTransform</code> 오브젝트에 연결되는 <code>AffineTransform</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#concatenate(java.awt.geom.AffineTransform)"><CODE>concatenate(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="createInverse()"><!-- --></A> <H3>
createInverse</H3>
<PRE>
public <A HREF="../../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>createInverse</B>()
                              throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>역변환을 표현하는 <code>AffineTransform</code> 오브젝트를 돌려줍니다. 이 변환 Tx
 역변환 Tx'는
 Tx 에
해 변환된 좌표를 그 원의 좌표에 맵 해 되돌립니다. 즉, Tx'(Tx(p)) = p = Tx(Tx'(p))입니다.
 <p>
이 변환이 모든 좌표를 점이나 선에 맵 하는 경우, 변환은 역사상을 가지지 않습니다. 이것은, 전송처의 점이나 선에 없는 좌표가 역사상을 가지지 않기 때문입니다. <code>getDeterminant</code> 메서드를 사용하면, 이 변환이 역사상을 가질지 어떨지를 판정할 수 있습니다. 이 변환이 역사상을 가지지 않는 경우,<code>createInverse</code> 메서드가 불려 가면, 예외가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>역변환을 표현하는 새로운 <code>AffineTransform</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/awt/geom/AffineTransform.html#getDeterminant()"><CODE>getDeterminant()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
transform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>transform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                         <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</PRE>
<DL>
<DD>지정된 <code>ptSrc</code>를
 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. <code>ptDst</code> 가 <code>null</code>
 경우, 새로운 <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 동안의 클래스"><CODE>Point2D</CODE></A>  오브젝트를 할당할 수 있고 나서, 변환의 결과가 이 오브젝트에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주고집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 오브젝트의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 변환 대상의 지정된 <code>Point2D</code><DD><CODE>ptDst</CODE> - <code>ptSrc</code>
 변환 결과를 포함하고 있는 지정된 <code>Point2D</code>
<DT><B>반환값:</B><DD><code>ptSrc</code>를
 변환해, 결과를 <code>ptDst</code> 에 포함한 뒤의 <code>ptDst</code></DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.Point2D[], int, java.awt.geom.Point2D[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptSrc,
                      int&nbsp;srcOff,
                      <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> []&nbsp;ptDst,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해 포인트 오브젝트의 배열을 변환합니다. <code>ptDst</code> 배열의 요소의 어떤 것인가가 <code>null</code> 이면, 새로운 <code>Point2D</code> 오브젝트를 할당할 수 있어 변환의 결과가 포함되기 전에 그 요소에 포함됩니다.
 <p>
다만, 이 메서드는
 전송원배열에 놓여져 계산의 전송원으로서 사용되는 <code>Point2D</code> 오브젝트에 결과를 포함하는 것에
해 일으켜지는 문제를 피하기 위한 예방 조치를 취하고 있지 않습니다. 이 메서드는
 지정된 <code>Point2D</code> 오브젝트가 같은 1 개의 점의 변환 오퍼레이션의 전송원과 전송처의 양쪽 모두인 경우, 오퍼랜드 위에 결과가 포함되지 않게, 결과를 계산의 종료후까지 포함하지 않는 것을 보증합니다. 그러나, 전송처 <code>Point2D</code> 오브젝트가 다른 오퍼레이션의 전송원배열에 놓여져 전송원 <code>Point2D</code> 오브젝트가 되는 경우, 그 점의 원의 좌표는 변환 가능하게 되기 전에 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 전송원의 포인트 오브젝트가 포함되고 있는 배열<DD><CODE>ptDst</CODE> - 변환된 포인트 오브젝트가 포함되는 배열<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 포인트 오브젝트에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 오브젝트의 수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, float[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해, 부동 소수점의 좌표의 배열을 변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메서드는
 전송원의 좌표가 변환 가능하게 되기 전에
 지금까지의 오퍼레이션에
해 덧쓰기되지 않는 것을 보증합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주고지고 있는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 돌려주고지는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 점의 수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, double[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해, 배정밀도의 좌표의 배열을 변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메서드는
 전송원의 좌표가 변환 가능하게 되기 전에
 지금까지의 오퍼레이션에
해 덧쓰기되지 않는 것을 보증합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주고지고 있는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 돌려주고지는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 오브젝트의 수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(float[], int, double[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(float[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      double[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해 부동 소수점의 좌표의 배열을 변환해, 결과를 double 치의 배열에 포함합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주고지고 있는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 돌려주고지는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 점의 수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(double[], int, float[], int, int)"><!-- --></A> <H3>
transform</H3>
<PRE>
public void <B>transform</B>(double[]&nbsp;srcPts,
                      int&nbsp;srcOff,
                      float[]&nbsp;dstPts,
                      int&nbsp;dstOff,
                      int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해 배정밀도의 좌표의 배열을 변환해, 결과를 float 치의 배열에 포함합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주고지고 있는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 돌려주고지는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 오브젝트의 수</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
inverseTransform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>inverseTransform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                                <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)
                         throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>지정된 <code>ptSrc</code>를
 역변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. <code>ptDst</code> 가 <code>null</code>
 경우, 새로운 <code>Point2D</code> 오브젝트를 할당할 수 있고 나서, 변환의 결과가 이 오브젝트에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주고집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 오브젝트의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 역변환되는 점<DD><CODE>ptDst</CODE> - 결과적으로 생성되는 변환 후의 점
<DT><B>반환값:</B><DD>역변환의 결과를 포함하고 있는 <code>ptDst</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="inverseTransform(double[], int, double[], int, int)"><!-- --></A> <H3>
inverseTransform</H3>
<PRE>
public void <B>inverseTransform</B>(double[]&nbsp;srcPts,
                             int&nbsp;srcOff,
                             double[]&nbsp;dstPts,
                             int&nbsp;dstOff,
                             int&nbsp;numPts)
                      throws <A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 내의 클래스">NoninvertibleTransformException</A> </PRE>
<DL>
<DD>이 변환에
해 배정밀도의 좌표의 배열을 역변환합니다. 2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메서드는
 전송원의 좌표가 변환 가능하게 되기 전에
 지금까지의 오퍼레이션에
해 덧쓰기되지 않는 것을 보증합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 점좌표가 돌려주고지고 있는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환된 점좌표가 돌려주고지는 배열. 각 점은 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 점에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 포인트 오브젝트가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 포인트 오브젝트의 수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/awt/geom/NoninvertibleTransformException.html" title="java.awt.geom 안의 클래스">NoninvertibleTransformException</A> </CODE> - 행렬을 반전할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="deltaTransform(java.awt.geom.Point2D, java.awt.geom.Point2D)"><!-- --></A> <H3>
deltaTransform</H3>
<PRE>
public <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 내의 클래스">Point2D</A>  <B>deltaTransform</B>(<A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptSrc,
                              <A HREF="../../../java/awt/geom/Point2D.html" title="java.awt.geom 안의 클래스">Point2D</A> &nbsp;ptDst)</PRE>
<DL>
<DD><code>ptSrc</code> 에
해 지정되는 상대적인 거리 벡터를 변환해, 그 결과를 <code>ptDst</code> 에 포함합니다. 상대적 거리 벡터는
 아핀 변환 행렬의 평행이동 컴퍼넌트를 적용하는 일 없이, 다음의 식을 사용해 변환됩니다.
 
 <pre>

        [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
        [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
        [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
 </pre>
<code>ptDst</code> 가 <code>null</code>
 경우, 새로운 <code>Point2D</code> 오브젝트를 할당할 수 있고 나서, 변환의 결과가 이 오브젝트에 포함됩니다. 어느 쪽의 경우도, 편의상, 변환 후의 점을 포함하고 있는 <code>ptDst</code> 가 돌려주고집니다. <code>ptSrc</code> 와 <code>ptDst</code> 가 같은 오브젝트의 경우, 입력점은 변환 후의 점으로써 적절히 덧쓰기됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>ptSrc</CODE> - 델타 변환되는 거리 벡터<DD><CODE>ptDst</CODE> - 결과적으로 변환된 거리 벡터
<DT><B>반환값:</B><DD>변환의 결과를 포함하고 있는 <code>ptDst</code></DL>
</DD>
</DL>
<HR>

<A NAME="deltaTransform(double[], int, double[], int, int)"><!-- --></A> <H3>
deltaTransform</H3>
<PRE>
public void <B>deltaTransform</B>(double[]&nbsp;srcPts,
                           int&nbsp;srcOff,
                           double[]&nbsp;dstPts,
                           int&nbsp;dstOff,
                           int&nbsp;numPts)</PRE>
<DL>
<DD>이 변환에
해 상대적인 거리 벡터의 배열을 변환합니다. 상대적 거리 벡터는
 아핀 변환 행렬의 평행이동 컴퍼넌트를 적용하는 일 없이, 다음의 식을 사용해 변환됩니다.
 
 <pre>

        [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]
        [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]
        [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]
 </pre>
2 개의 좌표 배열 섹션은 완전하게 같은가, 결과의 유효성에 영향을 주지 않고 같은 배열의 섹션을 오버랩 한 것입니다. 이 메서드는
 전송원의 좌표가 변환 가능하게 되기 전에
 지금까지의 오퍼레이션에
해 덧쓰기되지 않는 것을 보증합니다. 좌표는
 지정된 오프셋(offset)로부터 시작되는 배열에 <code>[x0, y0, x1, y1, ..., xn, yn]</code> 라고 하는 순서로 포함됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>srcPts</CODE> - 전송원의 거리 벡터가 포함되고 있는 배열. 각 벡터는
 상대 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>dstPts</CODE> - 변환 끝난 거리 벡터가 돌려주고지는 배열. 각 벡터는 상대 x, &nbsp;y 좌표의 페어로서 포함되는<DD><CODE>srcOff</CODE> - 전송원배열에서의 변환되는 최초의 벡터에의 오프셋(offset)<DD><CODE>dstOff</CODE> - 최초의 변환 벡터가 포함되는 전송처 배열내의 위치에의 오프셋(offset)<DD><CODE>numPts</CODE> - 변환되는 벡터 좌표 페어의 수</DL>
</DD>
</DL>
<HR>

<A NAME="createTransformedShape(java.awt.Shape)"><!-- --></A> <H3>
createTransformedShape</H3>
<PRE>
public <A HREF="../../../java/awt/Shape.html" title="java.awt 내의 인터페이스">Shape</A>  <B>createTransformedShape</B>(<A HREF="../../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;pSrc)</PRE>
<DL>
<DD>지정된 <code>Shape</code>를
 이 변환에
해 변환해, 그 <code>Shape</code>
 지오메트리에
해 정의되는 새로운 <A HREF="../../../java/awt/Shape.html" title="java.awt 동안의 인터페이스"><CODE>Shape</CODE></A>  오브젝트를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>pSrc</CODE> - 이 변환으로 변환되는 지정된 <code>Shape</code> 오브젝트
<DT><B>반환값:</B><DD>변환된 <code>Shape</code>
 지오메트리를 정의하는 새로운 <code>Shape</code> 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A> 
 값을 나타내는 <code>String</code>를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Object</code>
 값을 나타내는 <code>String</code></DL>
</DD>
</DL>
<HR>

<A NAME="isIdentity()"><!-- --></A> <H3>
isIdentity</H3>
<PRE>
public boolean <B>isIdentity</B>()</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 이 항등변환인 경우에 <code>true</code>를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>AffineTransform</code> 가 항등변환인 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
public <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 오브젝트의 카피를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>AffineTransform</code> 오브젝트의 카피인 <code>Object</code><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>이 변환의 해시 코드를 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 변환의 해시 코드<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)"><CODE>Object.equals(java.lang.Object)</CODE></A>,
 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 <code>AffineTransform</code> 이, 지정된 인수와 같은 아핀 좌표변화를 표현하는 경우에 <code>true</code>를
 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 이 <code>AffineTransform</code> 와 같은가 어떤가가 비교되는 <code>Object</code>
<DT><B>반환값:</B><DD><code>obj</code> 가 이 <code>AffineTransform</code> 오브젝트와 같은 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/Object.html#hashCode()"><CODE>Object.hashCode()</CODE></A>,
 
<A HREF="../../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AffineTransform.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../java/awt/geom/Arc2D.html" title="java.awt.geom 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/awt/geom/AffineTransform.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="AffineTransform.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

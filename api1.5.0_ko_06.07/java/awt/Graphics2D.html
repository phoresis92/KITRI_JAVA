<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:54:28 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Graphics2D (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.awt.Graphics2D class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Graphics2D (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics2D.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/GraphicsConfigTemplate.html" title="java.awt 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/awt/Graphics2D.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Graphics2D.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.awt</FONT>
<BR>
클래스 Graphics2D</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">java.awt.Graphics</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.awt.Graphics2D</B>
</PRE>
<HR>
<DL>
<DT><PRE>public abstract class <B>Graphics2D</B><DT>extends <A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </DL>
</PRE>

<P>
<code>Graphics2D</code> 클래스는
 <A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스"><CODE>Graphics</CODE></A>  클래스를 확장해, 지오메트리, 좌표변화, 컬러 관리 및 텍스트 배치에 대해 고도의 제어를 실시합니다. 이 클래스는
 Java(TM) 플랫폼에서 2D
 도형, 텍스트 및 이미지를 렌더링하기 위한 기본 클래스입니다.
 <p>
<h2>좌표 공간</h2>
 <code>Graphics2D</code> 오브젝트에게 건네지는 모든 좌표는
 유저 공간 (어플리케이션에
해 사용된다)으로 불리는
 디바이스에
존하지 않는 좌표계로 지정됩니다. <code>Graphics2D</code> 오브젝트에는
 디바이스 공간에서 유저 공간의 좌표를 디바이스에
존하는 좌표로 변환하는 방법을 정의하는 <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 동안의 클래스"><CODE>AffineTransform</CODE></A>  오브젝트가, 렌더링 상태의 일부로서 포함됩니다.
 <p>
디바이스 공간의 좌표는
 보통
, 개별의 디바이스 픽셀을 나타내, 이러한 픽셀간에 무한하게 가는 간격에 늘어놓을 수 있고 있습니다. 일부의 <code>Graphics2D</code> 오브젝트에서는
 렌더링 조작을 수중에 넣을 수가 있습니다. 그래픽스 메타파일로서 수중에 넣는 것으로 후에 물리적인 해상도가 불명한 구상 디바이스를 사용해 재생할 수가 있습니다. 렌더링 조작을 수중에 넣으려면  해상도가 불명해서,<code>Graphics2D</code> <code>Transform</code>를
 설정해 유저 좌표를 가상 디바이스 공간으로 변환하도록 합니다. 타겟 디바이스가 예상되는 해상도가 개산 됩니다만, 그 견적이 올바르지 않은 경우에는
 재생시에 한층 더 변환을 적용할 필요가 있습니다.
 <p>
렌더링 속성 오브젝트에
해 실행되는 일부의 조작에는 디바이스 공간에서 처리되는 것도 있습니다만,<code>Graphics2D</code>
 메서드는 모두 유저 공간 좌표를 취급합니다.
 <p>
모든 <code>Graphics2D</code> 오브젝트는
 렌더링가 행해지는 위치를 정의하는 타겟과 관련지을 수 있고 있습니다. <A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 안의 클래스"><CODE>GraphicsConfiguration</CODE></A>  오브젝트는
 픽셀 형식 및 해상도라고 하는 렌더링 타겟의 특성을 정의합니다. <code>Graphics2D</code> 오브젝트에서는
 항상 같은 렌더링 타겟이 사용됩니다.
 <p>
<code>Graphics2D</code> 오브젝트가 작성될 때,<code>GraphicsConfiguration</code>는

<code>Graphics2D</code> (<A HREF="../../java/awt/Component.html" title="java.awt 안의 클래스"><CODE>Component</CODE></A>  또는 <A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스"><CODE>Image</CODE></A> )의 타겟으로서<a name="#deftransform">디폴트 변환</a>을 지정합니다. 이 디폴트 변환에서는
 유저 공간 좌표계를 화면과 프린터의 디바이스 좌표에 매핑 해, 원점을 디바이스의 타겟 영역의 좌상구석에
 우측으로 확장하려면 X 좌표를, 하부에 확장하려면 Y 좌표를 늘리는 것 같은 매핑을 실시합니다. 스크린 디바이스등의 72 dpi 에 가까운 디바이스의 경우, 디폴트 변환의 슬캘링은 그러한 디바이스의 식별 정보로 설정됩니다. 프린터등의 고해상도 디바이스의 경우, 디폴트 변환의 슬캘링은, 1 평방 인치 근처 약 72 유저 공간 좌표로 설정됩니다. 이미지 버퍼에서는
 디폴트의 변환은 <code>Identity</code> 변환입니다.
<h2>렌더링 프로세스</h2>
 렌더링 프로세스는
<code>Graphics2D</code> 렌더링 속성에
해 제어되는 4 개의 단계로 나눌 수가 있습니다. 렌더링에서는 이러한 스텝의 대부분을 최적화할 수 있습니다. 최적화는
 장래의 호출에 대비해 결과를 캐쉬에 포함해 두거나 복수의 가상 스텝을 실질적으로 1 개의 조작에 정리하거나 다양한 속성에 관한 단순한 공통의 문제점을, 조작외의 부분을 변경하는 것으로써 배제하거나 하는 것, 등에
해 행해집니다.
 <p>
렌더링 프로세스의 순서를 이하에 설명합니다. <ol> <li> 렌더링 하는 대상을 지정한다<li> 렌더링 조작을 현재의 </code>Clip</code> 에 제한한다. <code>Clip</code>는
 유저 공간 <A HREF="../../java/awt/Shape.html" title="java.awt 중의 인터페이스"><CODE>Shape</CODE></A>  에
해 지정되어<code>Graphics</code> 및 <code>Graphics2D</code>
 다양한 클립 조작 메서드를 사용해 프로그램에
해 제어됩니다. 이 「유저 클립」은, 현재의 <code>Transform</code> 에
해 디바이스 공간에 변환되어 윈도우의 가시성 및 디바이스의 크기에
해 정의되는 「디바이스 클립」이라고 결합됩니다. 유저 클립과 디바이스 클립의 결합에
해, 최종적인 클리핑 영역을 결정하는 「복합 클립」을 정의합니다. 렌더링 시스템은, 유저 클립을 변경해 복합 클립의 결과를 반영할 수 없습니다. <li> 렌더링 하는 색을 지정한다<li> <code>Graphics2D</code> 컨텍스트
의 현재 <A HREF="../../java/awt/Composite.html" title="java.awt 중의 인터페이스"><CODE>Composite</CODE></A>  속성을 사용해, 목적지의 렌더링 표면으로 지정된 색을 바른다</ol> <br> 3 종류의 렌더링 조작에 대해, 각각의 렌더링 프로세스의 상세를 이하에 설명합니다. <ol> <li> <b><a name="rendershape"><code>Shape</code>
 조작</a> </b><ol> <li> <code>draw(Shape)</code> 조작의 경우,<code>Graphics2D</code> 컨텍스트
의 현재 <A HREF="../../java/awt/Stroke.html" title="java.awt 중의 인터페이스"><CODE>Stroke</CODE></A>   속성으로 <A HREF="../../java/awt/Stroke.html#createStrokedShape(java.awt.Shape)"><CODE>createStrokedShape</CODE></A>   메서드를 사용해, 지정의 <code>Shape</code>
 윤곽을 포함하는 새로운 <code>Shape</code> 오브젝트가 구축됩니다. <li> <code>Shape</code>는

<code>Graphics2D</code> 컨텍스트
의 현재의 <code>Transform</code>를
 사용해 유저 공간으로부터 디바이스 공간에 변환됩니다. <li> <code>Shape</code>
 윤곽은,<code>Shape</code>
 <A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform)"><CODE>getPathIterator</CODE></A>  메서드를 사용해 추출됩니다. 이 메서드는
<code>Shape</code>
 경계를 따라 반복 처리를 실시하는 <A HREF="../../java/awt/geom/PathIterator.html" title="java.awt.geom 동안의 인터페이스"><CODE>PathIterator</CODE></A>  오브젝트를 돌려줍니다. <li> x<code>PathIterator</code> 오브젝트에
해 돌려주고지는 곡선 세그먼트(segment)를 <code>Graphics2D</code> 오브젝트를 처리할 수 없는 경우는
<code>Shape</code>
 평탄화를 실시하는 대체 메서드 <A HREF="../../java/awt/Shape.html#getPathIterator(java.awt.geom.AffineTransform, double)"><CODE>getPathIterator</CODE></A> 를
 호출할 수가 있습니다. <li> <code>Graphics2D</code> 컨텍스트
의 현재 <A HREF="../../java/awt/Paint.html" title="java.awt 중의 인터페이스"><CODE>Paint</CODE></A>  가, 디바이스 공간에서 렌더링 하는 색을 지정하는 <A HREF="../../java/awt/PaintContext.html" title="java.awt 동안의 인터페이스"><CODE>PaintContext</CODE></A> 를
 취득하기 위해서 조회됩니다. </ol> <li> <b><a name=rendertext>텍스트 조작</a> </b> <ol> <li> 지정된 <code>String</code>를
 렌더링 하기 위해서 필요한 그래프
세트는
 이하의 순서로 지정됩니다. <ol> <li> 인수가 <code>String</code>
 경우, 폰트가 구현하는 기본 레이아웃 및 형상 결정 알고리즘에 관계없이 그것들을 이용해 표시하기 위해서,<code>Graphics2D</code> 컨텍스트
의 현재의 <code>Font</code>는
 <code>String</code>
 Unicode 캐릭터 라인을 그래프
세트로 변환하도록 요구됩니다. <li> 인수가 <A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스"><CODE>AttributedCharacterIterator</CODE></A> 
 경우, 반복자는
 매입 폰트 속성을 사용해, 그 자체를 <A HREF="../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스"><CODE>TextLayout</CODE></A>  로 변환하도록 요구됩니다. <code>TextLayout</code>는

 기입 방향이 다른 복수의 폰트를 위해서 자동적으로 Unicode
 쌍방향 레이아웃 조정을 실행하는
 보다 고성능인 그래프
레이아우트아르고리즘을 구현할 수 있습니다. <li> 인수가 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스"><CODE>GlyphVector</CODE></A> 
 경우,<code>GlyphVector</code> 오브젝트는
 각 그래프
의 위치를 나타내는 명시적인 좌표를 가지는 폰트 독자적인 적절한 그래프
코드를 벌써 포함하고 있습니다. </ol> <li> 현재의 <code>Font</code>를
 조회하면, 지정된 그래프
의 아우트라인을 취득할 수 있습니다. 이러한 아우트라인은, 순서 1 으로 지정된 각 그래프
의 위치를 기준으로 한 유저 공간의 형상으로서 처리됩니다. <li> 문자의 아우트라인이,<a href="#rendershape">「<code>Shape</code>
 조작」</a>으로 설명한 것처럼 전부 칠해집니다. <li> 현재의 <code>Paint</code> 가, 디바이스 공간에서 렌더링 하는 색을 지정하는 <code>PaintContext</code>를
 취득하기 위해서 조회됩니다. </ol> <li> <b><a name= renderingimage><code>Image</code>
 조작</a> </b><ol> <li> 대상이 되는 영역은, 소스 <code>Image</code>
 바운딘그복스로 정의됩니다. 이 바운딘그복스는
<code>Image</code> 오브젝트의 로컬인 좌표계인 이미지 공간에서 지정됩니다. <li> <code>AffineTransform</code> 이 <A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)"><CODE>drawImage(Image, AffineTransform, ImageObserver)</CODE></A>  에게 건네지는 경우는
 이미지 공간으로부터 유저 공간에 바운딘그복스를 변환하기 위해서, 그 <code>AffineTransform</code> 가 사용됩니다. <code>AffineTransform</code> 가 지정되지 않는 경우, 바운딘그복스는 벌써 유저 공간에 있는 것으로서 다루어집니다. <li> 소스 <code>Image</code>
 바운딘그복스는
 현재의 <code>Transform</code>를
 사용해 유저 공간으로부터 디바이스 공간에 변환됩니다. 다만, 바운딘그복스를 변환한 결과가, 디바이스 공간에서 구형 영역이 된다고는 할 수 없습니다. <li> <code>Image</code> 오브젝트는 렌더링 하는 색을 지정합니다. 색은, 현재의 <code>Transform</code> 와 옵션의 이미지 변환에
해 지정된 소스로부터 목적지에의 매핑에 따라 샘플링 됩니다.  </ol> </ol>
<h2>디폴트의 렌더링 속성</h2>
 <code>Graphics2D</code> 렌더링 속성의 기정치를 이하에 나타냅니다. <dl compact> <dt><i><code>Paint</code></i> <dd><code>Component</code>
 색<dt><i><code>Font</code></i> <dd><code>Component</code>
 <code>Font</code><dt><i><code>Stroke</code></i> <dd>선폭 1, 파선 이루어, 마이타세그먼트 결합 및 모퉁이 엔드 캡을 가지는 모퉁이 펜<dt><i><code>Transform</code></i> <dd><code>Component</code>
 <code>GraphicsConfiguration</code> 용의 <A HREF="../../java/awt/GraphicsConfiguration.html#getDefaultTransform()"><CODE>getDefaultTransform</CODE></A> <dt><i><code>Composite</code></i> <dd><A HREF="../../java/awt/AlphaComposite.html#SRC_OVER"><CODE>AlphaComposite.SRC_OVER</CODE></A>  규칙<dt><i><code>Clip</code></i> <dd>렌더링 <code>Clip</code> 이루어, 출력은 <code>Component</code> 에 클립 된다 </dl>
<h2>렌더링 호환성</h2>
 JDK<sup><font size=-2>TM</font></sup> 1.1 렌더링 모델은, 좌표가 픽셀간의 무한하게 가는 간격에 존재한다고 하는 픽셀화 모델에 근거합니다. 렌더링 조작은, 윤곽 선상의 엥커 포인트의 오른쪽 및 아래의 픽셀을 전부 칠하는 1 픽셀폭의 펜을 사용해 행해집니다. JDK 1.1 렌더링 모델은, 지정된 번호의 픽셀에 제대로 들어가지 않으면 안 되는 이산 펜에 정수 좌표를 변환할 필요가 있는
 플랫폼 렌더링의 대부분의 기존 클래스의 기능에 준거하고 있습니다.
 <p>
Java 2D(TM) (Java(TM) 2 플랫폼) API는

 평활화 렌더링을 지원하고 있습니다. 1 픽셀폭의 펜은, 픽셀 N+1 와 대비한 픽셀 N 에 완전하게 들어갈 필요는 없습니다. 펜은, 부분적으로 양쪽 모두의 픽셀에 걸릴 수가 있습니다. 이동하고 있는 펜의 인연이 양쪽 모두의 픽셀에 걸리면, 펜의 서브 픽셀 위치가 유저에게 표시되기 때문에
 대폭 펜의 바이어스 방향을 선택할 필요는 없습니다. 한편,<A HREF="../../java/awt/RenderingHints.html#KEY_ANTIALIASING"><CODE>KEY_ANTIALIASING</CODE></A>  힌트 키를 <A HREF="../../java/awt/RenderingHints.html#VALUE_ANTIALIAS_OFF"><CODE>VALUE_ANTIALIAS_OFF</CODE></A>  힌트치로 설정하는 것에
해 평활화를 무효로 했을 경우는
 디바이스 공간에서 정수 좌표에 따라 렌더링 하고 있을 때 등, 펜이 픽셀 경계를 넘으려 하고 있을 때 어느 쪽의 픽셀을 수정할까 판단하기 위해서, 렌더링은 바이어스를 적용할 필요가 있습니다. 평활화 렌더링의 기능에
해, 렌더링 모델은 펜의 바이어스를 지정하는 필요성이 없어졌습니다만, 화면상에서 1 픽셀폭의 수평선 및 수직선을 렌더링 하는 공통의 케이스에서는
 평활화 렌더링과 비평활화 렌더링은 똑같이 동작할 필요가 있습니다. <A HREF="../../java/awt/RenderingHints.html#KEY_ANTIALIASING"><CODE>KEY_ANTIALIASING</CODE></A>  힌트 키를 <A HREF="../../java/awt/RenderingHints.html#VALUE_ANTIALIAS_ON"><CODE>VALUE_ANTIALIAS_ON</CODE></A>  로 설정해 평활화를 유효하게 했기 때문에
 이 선폭이 돌연 2 배가 되어 불투명도가 반이 되는 것을 막으려면,
 그러한 선의 윤곽선을 모델로 지정하는 것에
해, 그 선이 특정의 픽셀세트를 완전하게 커버해 윤곽이 선명히 되도록 합니다.
 <p>
Java 2D API는
 JDK 1.1
 렌더링 동작과의 호환성을 유지하고 있어, Java 2D API 에서는 종래부터의 조작이나 기존의 렌더링의 동작으로 변경은 없습니다. 일반적인 <code>draw</code> 메서드 및 <code>fill</code> 메서드에 매핑 되는 종래의 메서드가 정의되고 있기 때문에
<code>Stroke</code> 속성과 <code>Transform</code> 속성의 설정 및 렌더링 힌트에 근거해 <code>Graphics2D</code> 가 <code>Graphics</code>를
 어떻게 확장하고 있을지가 명확하게 나타나고 있습니다. 그 정의는
 디폴트의 속성 설정에서는 똑같이 실행됩니다. 예를 들어, 디폴트의 <code>Stroke</code>는

 폭 1 및 파선 없음의 <code>BasicStroke</code> 이며, 화면 렌더링의 디폴트의 Transform는
 항등변환입니다.
 <p>
다음의 2 개의 규칙은, 비에일리어징 제거 또는 에일리어징 제거의 어느 쪽이 사용되고 있어도, 예측 가능한 렌더링 동작을 제공합니다. <ul> <li> 디바이스 픽셀간에 디바이스 좌표가 정의되어 그것에
해 에일리어징 제거와 에일리어징 제거의 렌더링의 사이에 일관성이 있는 결과를 얻을 수 있습니다. 좌표가 픽셀의 중심에 있도록 정의되었을 경우, 구형등의 형상에
해 커버되는 일부의 픽셀은 반밖에 커버되지 않습니다. 비에일리어징 제거의 렌더링의 경우, 반커버된 픽셀은 형상의 안쪽이나 외측의 어느 쪽인지가 렌더링 됩니다. 에일리어징 제거의 렌더링에서는
 형상의 엣지 전체에 있는 픽셀이 반만큼 커버됩니다. 그러나, 픽셀의 사이에 좌표가 정의되고 있으면, 구형등의 형상은, 에일리어징 제거를 사용해 렌더링 되는 제발에 관계없이, 반만큼 커버된 픽셀을 가질 것은 없습니다. <li> <code>BasicStroke</code> 오브젝트를 사용해 stroke 한 선 및 도형의 윤곽을 「정규화」하는 것으로 렌더링 가능한 다양한 위치에서 비에일리어징 제거 렌더링 또는 에일리어징 제거 렌더링 할 경우에
 일관성이 있는 윤곽을 렌더링 할 수가 있습니다. 이 정규화 프로세스는
<A HREF="../../java/awt/RenderingHints.html#KEY_STROKE_CONTROL"><CODE>KEY_STROKE_CONTROL</CODE></A>  힌트에
해 제어됩니다. 정확한 정규화 알고리즘은 지정됩니다만, 이 정규화의 목표는
 픽셀 구라두에 선이 어떻게 들어가는 것에 관계없이, 시각적으로 일관성이 있는 선을 렌더링 할 수 있도록 하는 것 및 에일리어징 제거 모드에서의 수평선 및 수직선을 보다 치밀하게 해, 에일리어징 제거되어 있지 않은 경우의 선이 될 수 있도록 접근하는 것입니다. 보통
의 정규화의 스텝에서는
 부동 소수점의 선폭이 동등의 가능성으로 짝수 또는 홀수의 픽셀수에 사사오입 할 수 있도록, 에일리어징 제거 된 선의 종단을 보다 픽셀의 중심에 해 겹치는 양을 줄이든가, 혹은 에일리어징 제거되어 있지 않은 선의 서브 픽셀의 위치 결정을 조정합니다. 이 프로세스에서는
 종단을 픽셀의 반까지 이동해 (일반적으로 양축으로 따라 정의 무한대 방향), 이러한 결과의 일관성을 높일 수가 있습니다.  
</ul>

 <p>
다음에 나타내는 일반적인 종래의 메서드의 정의는
 디폴트 속성 설정에서는 이전으로 지정된 동작과 같이 실행됩니다. <ul> <li> <code>fillRect</code>,<code>fillRoundRect</code>,<code>fillOval</code>,<code>fillArc</code>,<code>fillPolygon</code>,<code>clearRect</code> 등의 <code>fill</code> 조작의 경우는
 목적의 <code>Shape</code>를
 지정해 <A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)"><CODE>fill</CODE></A> 를
 호출할 수가 있습니다. 예를 들어 구형을 전부 칠하는 경우는

 
 <pre>

 fill(new Rectangle(x, y, w, h));
 </pre>
를 호출합니다.
 <p>
<li> 똑같이,<code>drawLine</code>,<code>drawRect</code>,<code>drawRoundRect</code>,<code>drawOval</code>,<code>drawArc</code>,<code>drawPolyline</code>,<code>drawPolygon</code> 등의 렌더링 조작의 경우는
 목적의 <code>Shape</code>를
 지정해 <A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)"><CODE>draw</CODE></A> 를
 호출할 수가 있습니다. 예를 들어 구형을 렌더링 하는 경우는

 
 <pre>

 draw(new Rectangle(x, y, w, h));
 </pre>
를 호출합니다.
 <p>
<li> <code>draw3DRect</code> 메서드와 <code>fill3DRect</code> 메서드는
<code>Graphics</code> 클래스에서는 <code>drawLine</code> 메서드와 <code>fillRect</code> 메서드를 사용해 구현되고 있습니다. 이러한 동작은,<code>Graphics2D</code> 컨텍스트
의 현재의 <code>Stroke</code> 오브젝트와 <code>Paint</code> 오브젝트에 근거해 예측할 수 있습니다. <code>Graphics2D</code> 클래스는
 현재의 <code>Paint</code>를
 오버라이드(override) 해, 이러한 2 개의 오브젝트의 구현을 현재의 <code>Color</code>를
 배타적으로 사용하는 버젼으로 오버라이드(override) 합니다. 이 클래스는
 기존의 메서드와 완전하게 동일한 동작을 기술하기 위해서,<code>Stroke</code>
 현재의 설정 (와)는 관계없는 것으로 <code>fillRect</code>를
 사용합니다.
</ul>
 <code>Graphics</code> 클래스는
 페인트 되는 색을 제어하기 위해서 <code>setColor</code> 메서드만을 정의합니다. Java 2D API는

<code>Color</code> 오브젝트를 확장해 새로운 <code>Paint</code> 인터페이스를 구현하므로 기존의 <code>setColor</code> 메서드는 현재의 <code>Paint</code> 속성을 <code>Color</code> 오브젝트로 설정하기 위한 간이 메서드가 되어 있습니다. <code>setColor(c)</code>는
 <code>setPaint(c)</code> 에 상당합니다.
 <p>
<code>Graphics</code> 클래스는
 색을 목적지에 적용하는 방법을 제어하기 위해서 2 개의 메서드를 정의합니다. <ol> <li> <code>setPaintMode</code> 메서드는
<code>setComposite(new AlphaComposite.SrcOver)</code> 에 상당하는 디폴트의 <code>Composite</code>를
 설정하는 간이 메서드로서 구현됩니다. <li> <code>setXORMode(Color xorcolor)</code> 메서드는
 소스 컬러의 <code>Alpha</code> 컴퍼넌트를 무시해, 목적지 컬러를 그 값으로 설정하는 특수한 <code>Composite</code> 오브젝트를 설정하기 위한 간이 메서드로서 구현됩니다.
 
 <pre>

 dstpixel = (PixelOf(srccolor) ^ PixelOf(xorcolor) ^ dstpixel);
 </pre>
 </ol>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#Graphics2D()">Graphics2D</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Graphics2D</code> 오브젝트를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#addRenderingHints(java.util.Map)">addRenderingHints</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렌더링 알고리즘에 관한 임의의 수의 추천 설정의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)">clip</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Clip</code> 가 지정된 <code>Shape</code>
 내부와 교차시켜, 결과적으로 생긴 공통 부분에 그 <code>Clip</code>를
 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)">draw</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> 컨텍스트
의 설정을 사용하는 것으로<code>Shape</code>
 윤곽을 stroke로 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 구형의 윤곽을 3D 로 강조 표시해 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawGlyphVector(java.awt.font.GlyphVector, float, float)">drawGlyphVector</A> </B>(<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스">GlyphVector</A> &nbsp;g,
                float&nbsp;x,
                float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 렌더링 속성을 사용하는 것으로 지정된 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 동안의 클래스"><CODE>GlyphVector</CODE></A> 
 텍스트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)">drawImage</A> </B>(<A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스">BufferedImage</A> &nbsp;img,
          <A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스">BufferedImageOp</A> &nbsp;op,
          int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 내의 인터페이스"><CODE>BufferedImageOp</CODE></A>  로 필터 처리되는 <code>BufferedImage</code>를
 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)">drawImage</A> </B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
          <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform,
          <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;obs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서, 이미지를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)">drawRenderableImage</A> </B>(<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스">RenderableImage</A> &nbsp;img,
                    <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A> 를
 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)">drawRenderedImage</A> </B>(<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스">RenderedImage</A> &nbsp;img,
                  <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스"><CODE>RenderedImage</CODE></A> 를
 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.text.AttributedCharacterIterator, float, float)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 현재의 <code>Paint</code>를
 사용하는 것으로 지정된 반복자의 텍스트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 현재의 <code>Paint</code>를
 사용하는 것으로 지정된 반복자의 텍스트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.lang.String, float, float)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s,
           float&nbsp;x,
           float&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 현재의 텍스트 속성 상태를 사용하는 것으로 특정의 <code>String</code> 에
해 지정된 텍스트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#drawString(java.lang.String, int, int)">drawString</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
           int&nbsp;x,
           int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 현재의 텍스트 속성 상태를 사용하는 것으로 지정된 <code>String</code>
 텍스트를 렌더링 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)">fill</A> </B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 설정을 사용하는 것으로<code>Shape</code>
 내부를 전부 칠합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;width,
           int&nbsp;height,
           boolean&nbsp;raised)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 색으로 전부 칠해지고 있는
 3D 로 강조 표시된 구형을 페인트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getBackground()">getBackground</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;영역을 클리어 하는데 사용하는 백그라운드 컬러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Composite.html" title="java.awt 내의 인터페이스">Composite</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getComposite()">getComposite</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Composite</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 내의 클래스">GraphicsConfiguration</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getDeviceConfiguration()">getDeviceConfiguration</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics2D</code> 에 관련한 디바이스 구성을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스">FontRenderContext</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getFontRenderContext()">getFontRenderContext</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <code>Graphics2D</code> 컨텍스트
에서의 <code>Font</code>
 렌더링 컨텍스트
을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Paint.html" title="java.awt 내의 인터페이스">Paint</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getPaint()">getPaint</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Paint</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getRenderingHint(java.awt.RenderingHints.Key)">getRenderingHint</A> </B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렌더링 알고리즘의 추천 설정의 값을 1 개 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스">RenderingHints</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getRenderingHints()">getRenderingHints</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렌더링 알고리즘의 추천 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/Stroke.html" title="java.awt 내의 인터페이스">Stroke</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getStroke()">getStroke</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Stroke</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#getTransform()">getTransform</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Transform</code>
 카피를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#hit(java.awt.Rectangle, java.awt.Shape, boolean)">hit</A> </B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rect,
    <A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s,
    boolean&nbsp;onStroke)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>Shape</code> 가 지정된 <A HREF="../../java/awt/Rectangle.html" title="java.awt 동안의 클래스"><CODE>Rectangle</CODE></A>  (디바이스 공간에 있다)와 교차할지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#rotate(double)">rotate</A> </B>(double&nbsp;theta)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code>를
 회전 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#rotate(double, double, double)">rotate</A> </B>(double&nbsp;theta,
       double&nbsp;x,
       double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code>를
 이동 후의 회전 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#scale(double, double)">scale</A> </B>(double&nbsp;sx,
      double&nbsp;sy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code>를
 슬캘링 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setBackground(java.awt.Color)">setBackground</A> </B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 백그라운드 컬러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)">setComposite</A> </B>(<A HREF="../../java/awt/Composite.html" title="java.awt 안의 인터페이스">Composite</A> &nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 <code>Composite</code>를
 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)">setPaint</A> </B>(<A HREF="../../java/awt/Paint.html" title="java.awt 안의 인터페이스">Paint</A> &nbsp;paint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
에 <code>Paint</code> 속성을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)">setRenderingHint</A> </B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey,
                 <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;hintValue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렌더링 알고리즘의 추천 설정의 값을 1 개 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setRenderingHints(java.util.Map)">setRenderingHints</A> </B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;렌더링 알고리즘의 모든 추천 설정의 값을, 지정된 <code>hints</code> 에 옮겨놓습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)">setStroke</A> </B>(<A HREF="../../java/awt/Stroke.html" title="java.awt 안의 인터페이스">Stroke</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 <code>Stroke</code>를
 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)">setTransform</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
으로 Transform를
 덧쓰기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#shear(double, double)">shear</A> </B>(double&nbsp;shx,
      double&nbsp;shy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code>를
 셔링 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)">transform</A> </B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>AffineTransform</code> 오브젝트를 이 <code>Graphics2D</code> 에서의 <code>Transform</code>를
 사용해, 후 지정 우선 적용이라고 하는 규칙에 따라 변환합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#translate(double, double)">translate</A> </B>(double&nbsp;tx,
          double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 <code>Graphics2D</code> <code>Transform</code>를
 이동 변환과 연결합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/awt/Graphics2D.html#translate(int, int)">translate</A> </B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Graphics2D</code> 컨텍스트
의 원점을, 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 이동합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.awt.Graphics"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.awt. <A HREF="../../java/awt/Graphics.html" title="java.awt 안의 클래스">Graphics</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)">clearRect</A>,
 <A HREF="../../java/awt/Graphics.html#clipRect(int, int, int, int)">clipRect</A>,
 <A HREF="../../java/awt/Graphics.html#copyArea(int, int, int, int, int, int)">copyArea</A>,
 <A HREF="../../java/awt/Graphics.html#create()">create</A>,
 <A HREF="../../java/awt/Graphics.html#create(int, int, int, int)">create</A>,
 <A HREF="../../java/awt/Graphics.html#dispose()">dispose</A>,
 <A HREF="../../java/awt/Graphics.html#drawArc(int, int, int, int, int, int)">drawArc</A>,
 <A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)">drawBytes</A>,
 <A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)">drawChars</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.Color, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawImage(java.awt.Image, int, int, int, int, int, int, int, int, java.awt.image.ImageObserver)">drawImage</A>,
 <A HREF="../../java/awt/Graphics.html#drawLine(int, int, int, int)">drawLine</A>,
 <A HREF="../../java/awt/Graphics.html#drawOval(int, int, int, int)">drawOval</A>,
 <A HREF="../../java/awt/Graphics.html#drawPolygon(int[], int[], int)">drawPolygon</A>,
 <A HREF="../../java/awt/Graphics.html#drawPolygon(java.awt.Polygon)">drawPolygon</A>,
 <A HREF="../../java/awt/Graphics.html#drawPolyline(int[], int[], int)">drawPolyline</A>,
 <A HREF="../../java/awt/Graphics.html#drawRect(int, int, int, int)">drawRect</A>,
 <A HREF="../../java/awt/Graphics.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A>,
 <A HREF="../../java/awt/Graphics.html#fillArc(int, int, int, int, int, int)">fillArc</A>,
 <A HREF="../../java/awt/Graphics.html#fillOval(int, int, int, int)">fillOval</A>,
 <A HREF="../../java/awt/Graphics.html#fillPolygon(int[], int[], int)">fillPolygon</A>,
 <A HREF="../../java/awt/Graphics.html#fillPolygon(java.awt.Polygon)">fillPolygon</A>,
 <A HREF="../../java/awt/Graphics.html#fillRect(int, int, int, int)">fillRect</A>,
 <A HREF="../../java/awt/Graphics.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A>,
 <A HREF="../../java/awt/Graphics.html#finalize()">finalize</A>,
 <A HREF="../../java/awt/Graphics.html#getClip()">getClip</A>,
 <A HREF="../../java/awt/Graphics.html#getClipBounds()">getClipBounds</A>,
 <A HREF="../../java/awt/Graphics.html#getClipBounds(java.awt.Rectangle)">getClipBounds</A>,
 <A HREF="../../java/awt/Graphics.html#getClipRect()">getClipRect</A>,
 <A HREF="../../java/awt/Graphics.html#getColor()">getColor</A>,
 <A HREF="../../java/awt/Graphics.html#getFont()">getFont</A>,
 <A HREF="../../java/awt/Graphics.html#getFontMetrics()">getFontMetrics</A>,
 <A HREF="../../java/awt/Graphics.html#getFontMetrics(java.awt.Font)">getFontMetrics</A>,
 <A HREF="../../java/awt/Graphics.html#hitClip(int, int, int, int)">hitClip</A>,
 <A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)">setClip</A>,
 <A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)">setClip</A>,
 <A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)">setColor</A>,
 <A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)">setFont</A>,
 <A HREF="../../java/awt/Graphics.html#setPaintMode()">setPaintMode</A>,
 <A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)">setXORMode</A>,
 <A HREF="../../java/awt/Graphics.html#toString()">toString</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Graphics2D()"><!-- --></A> <H3>
Graphics2D</H3>
<PRE>
protected <B>Graphics2D</B>()</PRE>
<DL>
<DD>새로운 <code>Graphics2D</code> 오브젝트를 구축합니다. <code>Graphics2D</code>는
 abstract 클래스이며, 다양한 출력 디바이스를 위해서 서브 클래스에서 커스터마이즈 되지 않으면 안 되기 때문에
<code>Graphics2D</code> 오브젝트를 직접 작성할 수 없습니다. 대신에
 다른 <code>Graphics2D</code> 오브젝트로부터 얻는
지,<code>Component</code> 에
해 작성하든가, 혹은 <A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스"><CODE>BufferedImage</CODE></A>  오브젝트등의 이미지로부터 취득하지 않으면 안됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Component.html#getGraphics()"><CODE>Component.getGraphics()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#create()"><CODE>Graphics.create()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="draw3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
draw3DRect</H3>
<PRE>
public void <B>draw3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>지정된 구형의 윤곽을 3D 로 강조 표시해 렌더링 합니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다.
 <p>
강조 표시 효과에 사용되는 색은, 현재의 색에 근거해 지정됩니다. 렌더링 된 구형은, 폭 <code>width&nbsp;+&nbsp;1</code> 픽셀, 높이 <code>height&nbsp;+&nbsp;1</code> 픽셀의 영역을 커버합니다. 이 메서드는
 현재의 <code>Color</code> 만을 사용해, 현재의 <code>Paint</code>는
 무시합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)">draw3DRect</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 렌더링 되는 구형의 x 좌표<DD><CODE>y</CODE> - 렌더링 되는 구형의 y 좌표<DD><CODE>width</CODE> - 렌더링 되는 구형의 폭<DD><CODE>height</CODE> - 렌더링 되는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 표면에 조각해 붐비어진 것처럼 보이는지를 지정하는 boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)"><CODE>Graphics.fill3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill3DRect(int, int, int, int, boolean)"><!-- --></A> <H3>
fill3DRect</H3>
<PRE>
public void <B>fill3DRect</B>(int&nbsp;x,
                       int&nbsp;y,
                       int&nbsp;width,
                       int&nbsp;height,
                       boolean&nbsp;raised)</PRE>
<DL>
<DD>현재의 색으로 전부 칠해지고 있는
 3D 로 강조 표시된 구형을 페인트 합니다. 구형의 구석은, 경사해, 좌상구석으로부터 빛을 쬔 것처럼 강조 표시됩니다. 강조 표시 효과 및 전부 칠해에 사용되는 색은, 현재의 <code>Color</code> 에
해 지정됩니다. 이 메서드는 현재의 <code>Color</code> 만을 사용해, 현재의 <code>Paint</code>는
 무시합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#fill3DRect(int, int, int, int, boolean)">fill3DRect</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 전부 칠해지는 구형의 x 좌표<DD><CODE>y</CODE> - 전부 칠해지는 구형의 y 좌표<DD><CODE>width</CODE> - 전부 칠해지는 구형의 폭<DD><CODE>height</CODE> - 전부 칠해지는 구형의 높이<DD><CODE>raised</CODE> - 구형이 표면으로부터 떠오른 것처럼 보이는지, 표면에 조각해 붐비어진 것처럼 보이는지를 지정하는 boolean 치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#draw3DRect(int, int, int, int, boolean)"><CODE>Graphics.draw3DRect(int, int, int, int, boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="draw(java.awt.Shape)"><!-- --></A> <H3>
draw</H3>
<PRE>
public abstract void <B>draw</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> 컨텍스트
의 설정을 사용하는 것으로<code>Shape</code>
 윤곽을 stroke로 렌더링 합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Composite</code> 및 <code>Stroke</code>
 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 렌더링 되는 <code>Shape</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.Image, java.awt.geom.AffineTransform, java.awt.image.ImageObserver)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract boolean <B>drawImage</B>(<A HREF="../../java/awt/Image.html" title="java.awt 안의 클래스">Image</A> &nbsp;img,
                                  <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform,
                                  <A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스">ImageObserver</A> &nbsp;obs)</PRE>
<DL>
<DD>이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서, 이미지를 렌더링 합니다. 유저 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에
해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 컨텍스트
의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code> 및 <code>Composite</code>
 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, 렌더링는 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 지정 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 유저 공간에의 변환<DD><CODE>obs</CODE> - <code>Image</code>
 것보다 많은 부분이 변환된다고 통지되는
<A HREF="../../java/awt/image/ImageObserver.html" title="java.awt.image 안의 인터페이스"><CODE>ImageObserver</CODE></A> 
<DT><B>반환값:</B><DD><code>Image</code> 가 모두 로드 되어 완전하게 렌더링 되었을 경우는 <code>true</code>,<code>Image</code> 가 아직 로드안의 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(java.awt.image.BufferedImage, java.awt.image.BufferedImageOp, int, int)"><!-- --></A> <H3>
drawImage</H3>
<PRE>
public abstract void <B>drawImage</B>(<A HREF="../../java/awt/image/BufferedImage.html" title="java.awt.image 안의 클래스">BufferedImage</A> &nbsp;img,
                               <A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스">BufferedImageOp</A> &nbsp;op,
                               int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD><A HREF="../../java/awt/image/BufferedImageOp.html" title="java.awt.image 안의 인터페이스"><CODE>BufferedImageOp</CODE></A>  로 필터 처리되는 <code>BufferedImage</code>를
 렌더링 합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code> 및 <code>Composite</code>
 각 속성이 있습니다. 이것은, 다음의 조작에 상당합니다.
 
 <pre>

 img1 = op.filter(img, null);
 drawImage(img1, new AffineTransform(1f, 0f, 0f, 1f, x, y), null);
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>op</CODE> - 렌더링전에 이미지에 적용되는 필터<DD><CODE>img</CODE> - 렌더링 되는 지정 <code>BufferedImage</code>. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>x</CODE> - 이미지의 좌상구석이 렌더링 되는 유저 공간의 위치의 x 좌표<DD><CODE>y</CODE> - 이미지의 좌상구석이 렌더링 되는 유저 공간의 위치의 y 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><!-- --></A> <H3>
drawRenderedImage</H3>
<PRE>
public abstract void <B>drawRenderedImage</B>(<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스">RenderedImage</A> &nbsp;img,
                                       <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</PRE>
<DL>
<DD>이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/RenderedImage.html" title="java.awt.image 안의 인터페이스"><CODE>RenderedImage</CODE></A> 를
 렌더링 합니다. 유저 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에
해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 컨텍스트
의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code> 및 <code>Composite</code>
 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, 렌더링는 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 유저 공간에의 변환<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawRenderableImage(java.awt.image.renderable.RenderableImage, java.awt.geom.AffineTransform)"><!-- --></A> <H3>
drawRenderableImage</H3>
<PRE>
public abstract void <B>drawRenderableImage</B>(<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스">RenderableImage</A> &nbsp;img,
                                         <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;xform)</PRE>
<DL>
<DD>이미지 공간으로부터 유저 공간에의 변환을 적용하고 나서,<A HREF="../../java/awt/image/renderable/RenderableImage.html" title="java.awt.image.renderable 안의 인터페이스"><CODE>RenderableImage</CODE></A> 를
 렌더링 합니다. 유저 공간으로부터 디바이스 공간에의 변환은,<code>Graphics2D</code> 에서의 현재의 <code>Transform</code> 에
해 행해집니다. 지정된 변환은,<code>Graphics2D</code> 컨텍스트
의 변환 속성에 적용되기 전에 이미지에 적용됩니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code> 및 <code>Composite</code>
 각 속성이 있습니다. 다만, 지정된 변환이 역변환을 가지지 않는 경우, 렌더링는 행해지지 않습니다. <p>  <code>Graphics2D</code> 오브젝트로 설정된 렌더링 힌트는
<code>RenderableImage</code>
 렌더링에 사용할 수 있습니다. 특정의 <code>RenderableImage</code> 에
해 인식된 특정의 힌트에 명시적인 제어가 필요한 경우나, 어느 힌트가 사용될까를 알아 둘 필요가 있는 경우에는
<code>RenderedImage</code>를
 <code>RenderableImage</code> 로부터 직접 취득해,<A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><CODE>(RenderedImage, AffineTransform) drawRenderedImage</CODE></A> 를
 사용해 렌더링 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>img</CODE> - 렌더링 되는 이미지. <code>img</code> 가 null
 경우에는 아무것도 실시하지 않는<DD><CODE>xform</CODE> - 이미지 공간으로부터 유저 공간에의 변환<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)"><CODE>drawRenderedImage(java.awt.image.RenderedImage, java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 현재의 텍스트 속성 상태를 사용하는 것으로 지정된 <code>String</code>
 텍스트를 렌더링 합니다. 최초의 문자의 baseline는
 유저 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Font</code> 및 <code>Composite</code>
 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는
 그래프
는 오른쪽에서 왼쪽으로 렌더링 됩니다. 이 경우, 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#drawString(java.lang.String, int, int)">drawString</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 렌더링 되는 캐릭터 라인<DD><CODE>x</CODE> - <code>String</code> 가 렌더링 되는 위치의 x 좌표<DD><CODE>y</CODE> - <code>String</code> 가 렌더링 되는 위치의 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>str</code> 가 <code>null</code>
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#drawBytes(byte[], int, int, int, int)"><CODE>Graphics.drawBytes(byte[], int, int, int, int)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#drawChars(char[], int, int, int, int)"><CODE>Graphics.drawChars(char[], int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, float, float)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 현재의 텍스트 속성 상태를 사용하는 것으로 특정의 <code>String</code> 에
해 지정된 텍스트를 렌더링 합니다. 최초의 문자의 baseline는
 유저 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code>,<code>Font</code> 및 <code>Composite</code>
 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는
 그래프
는 오른쪽에서 왼쪽으로 렌더링 됩니다. 이 경우에는
 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 렌더링 되는 <code>String</code><DD><CODE>x</CODE> - <code>String</code> 가 렌더링 되는 위치의 x 좌표<DD><CODE>y</CODE> - <code>String</code> 가 렌더링 되는 위치의 y 좌표
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>str</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setFont(java.awt.Font)"><CODE>Graphics.setFont(java.awt.Font)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, int, int)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                int&nbsp;x,
                                int&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 현재의 <code>Paint</code>를
 사용하는 것으로 지정된 반복자의 텍스트를 렌더링 합니다. 반복자는
 각 문자의 폰트를 지정하지 않으면 안됩니다. 최초의 문자의 baseline는
 유저 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code> 및 <code>Composite</code>
 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는
 그래프
는 오른쪽에서 왼쪽으로 렌더링 됩니다. 이 경우에는
 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#drawString(java.text.AttributedCharacterIterator, int, int)">drawString</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - 렌더링 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - 반복자의 텍스트가 렌더링 되는 x 좌표<DD><CODE>y</CODE> - 반복자의 텍스트가 렌더링 되는 y 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.text.AttributedCharacterIterator, float, float)"><!-- --></A> <H3>
drawString</H3>
<PRE>
public abstract void <B>drawString</B>(<A HREF="../../java/text/AttributedCharacterIterator.html" title="java.text 안의 인터페이스">AttributedCharacterIterator</A> &nbsp;iterator,
                                float&nbsp;x,
                                float&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 현재의 <code>Paint</code>를
 사용하는 것으로 지정된 반복자의 텍스트를 렌더링 합니다. 반복자는 각 문자의 폰트를 지정하지 않으면 안됩니다. 최초의 문자의 baseline는
 유저 공간의 것 (<i>x</i>, &nbsp;<i>y</i>)에 위치합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code> 및 <code>Composite</code>
 각 속성이 있습니다. 헤브라이어나 아라비아어등의 필기 시스템의 문자에서는
 그래프
는 오른쪽에서 왼쪽으로 렌더링 됩니다. 이 경우에는
 지정된 좌표는 baseline의 좌단의 문자 위치에 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>iterator</CODE> - 렌더링 되는 텍스트를 가지는 반복자<DD><CODE>x</CODE> - 반복자의 텍스트가 렌더링 되는 x 좌표<DD><CODE>y</CODE> - 반복자의 텍스트가 렌더링 되는 y 좌표<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="drawGlyphVector(java.awt.font.GlyphVector, float, float)"><!-- --></A> <H3>
drawGlyphVector</H3>
<PRE>
public abstract void <B>drawGlyphVector</B>(<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스">GlyphVector</A> &nbsp;g,
                                     float&nbsp;x,
                                     float&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 렌더링 속성을 사용하는 것으로 지정된 <A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 동안의 클래스"><CODE>GlyphVector</CODE></A> 
 텍스트를 렌더링 합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code> 및 <code>Composite</code>
 각 속성이 있습니다. <code>GlyphVector</code>는

 개개의 그래프
를 <A HREF="../../java/awt/Font.html" title="java.awt 안의 클래스"><CODE>Font</CODE></A>  로부터 지정합니다. 또,<code>GlyphVector</code>는

 그래프
의 위치도 포함할 수 있습니다. 이 메서드를 사용하면, 화면에 일련의 캐릭터 라인을 가장 빠르게 렌더링 할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>g</CODE> - 렌더링 되는 <code>GlyphVector</code><DD><CODE>x</CODE> - 그래프
가 렌더링 되는 유저 공간의 x 위치<DD><CODE>y</CODE> - 그래프
가 렌더링 되는 유저 공간의 y 위치<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Font.html#createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)"><CODE>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</CODE></A>,
 
<A HREF="../../java/awt/font/GlyphVector.html" title="java.awt.font 안의 클래스"><CODE>GlyphVector</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.awt.Shape)"><!-- --></A> <H3>
fill</H3>
<PRE>
public abstract void <B>fill</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 설정을 사용하는 것으로<code>Shape</code>
 내부를 전부 칠합니다. 적용되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code>,<code>Paint</code> 및 <code>Composite</code>
 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 전부 칠해지는 <code>Shape</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hit(java.awt.Rectangle, java.awt.Shape, boolean)"><!-- --></A> <H3>
hit</H3>
<PRE>
public abstract boolean <B>hit</B>(<A HREF="../../java/awt/Rectangle.html" title="java.awt 안의 클래스">Rectangle</A> &nbsp;rect,
                            <A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s,
                            boolean&nbsp;onStroke)</PRE>
<DL>
<DD>지정된 <code>Shape</code> 가 지정된 <A HREF="../../java/awt/Rectangle.html" title="java.awt 동안의 클래스"><CODE>Rectangle</CODE></A>  (디바이스 공간에 있다)와 교차할지 어떨지를 판정합니다. <code>onStroke</code> 가 false
 경우, 이 메서드는 지정된 <code>Shape</code>
 내부가 지정된 <code>Rectangle</code> 와 교차할지 어떨지를 조사합니다. <code>onStroke</code> 가 <code>true</code>
 경우, 이 메서드는 지정된 <code>Shape</code>
 윤곽의 <code>Stroke</code> 가 지정된 <code>Rectangle</code> 와 교차할지 어떨지를 조사합니다. 고려되는 렌더링 속성에는
<code>Clip</code>,<code>Transform</code> 및 <code>Stroke</code>
 각 속성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>rect</CODE> - 히트를 조사하는 디바이스 공간의 영역<DD><CODE>s</CODE> - 히트를 조사하는 <code>Shape</code><DD><CODE>onStroke</CODE> - stroke로 렌더링 된 형상을 조사할까 전부 칠해진 형상을 조사하는지를 선택하는 플래그. 플래그가 <code>true</code>
 경우는
<code>Stroke</code>
 윤곽이 조사할 수 있다. 플래그가 <code>false</code>
 경우는
 전부 칠해진 <code>Shape</code> 가 조사할 수 있다
<DT><B>반환값:</B><DD>히트가 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#fill(java.awt.Shape)"><CODE>fill(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#draw(java.awt.Shape)"><CODE>draw(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#clip(java.awt.Shape)"><CODE>clip(java.awt.Shape)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setClip(int, int, int, int)"><CODE>Graphics.setClip(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDeviceConfiguration()"><!-- --></A> <H3>
getDeviceConfiguration</H3>
<PRE>
public abstract <A HREF="../../java/awt/GraphicsConfiguration.html" title="java.awt 내의 클래스">GraphicsConfiguration</A>  <B>getDeviceConfiguration</B>()</PRE>
<DL>
<DD>이 <code>Graphics2D</code> 에 관련한 디바이스 구성을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <code>Graphics2D</code> 속성의 디바이스 구성</DL>
</DD>
</DL>
<HR>

<A NAME="setComposite(java.awt.Composite)"><!-- --></A> <H3>
setComposite</H3>
<PRE>
public abstract void <B>setComposite</B>(<A HREF="../../java/awt/Composite.html" title="java.awt 안의 인터페이스">Composite</A> &nbsp;comp)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 <code>Composite</code>를
 설정합니다. <code>Composite</code>는

<code>drawImage</code>,<code>drawString</code>,<code>draw</code> 및 <code>fill</code> 등의 모든 렌더링 메서드로 사용됩니다. <code>Composite</code>는

 그래픽스 디바이스에서의 렌더링 처리중에 새로운 픽셀이 기존의 픽셀과 어떻게 결합되는지를 지정합니다.
<p>이 <code>Graphics2D</code> 컨텍스트
이 표시 화면의 <code>Component</code> 에 렌더링 되고 있는 경우,<code>Composite</code>는
 <code>AlphaComposite</code> 클래스의 인스턴스가 아닌 커스텀 오브젝트입니다. 시큐러티 매니저가 있는 경우는
 시큐러티 매니저의 <code>checkPermission</code> 메서드가 액세스권 <code>AWTPermission("readDisplayPixels")</code>를
 지정해 불려 갑니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>comp</CODE> - 렌더링에 사용되는 <code>Composite</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 화면에 렌더링 하기 위해서 커스텀 <code>Composite</code> 오브젝트가 사용되고 있어 시큐러티 매니저가 설정되어 있는 경우에
 시큐러티 매니저의 <code>checkPermission</code> 메서드가 이 조작을 허가하지 않을 때<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setXORMode(java.awt.Color)"><CODE>Graphics.setXORMode(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setPaintMode()"><CODE>Graphics.setPaintMode()</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#getComposite()"><CODE>getComposite()</CODE></A>,
 
<A HREF="../../java/awt/AlphaComposite.html" title="java.awt 안의 클래스"><CODE>AlphaComposite</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/awt/AWTPermission.html" title="java.awt 안의 클래스"><CODE>AWTPermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPaint(java.awt.Paint)"><!-- --></A> <H3>
setPaint</H3>
<PRE>
public abstract void <B>setPaint</B>(<A HREF="../../java/awt/Paint.html" title="java.awt 안의 인터페이스">Paint</A> &nbsp;paint)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
에 <code>Paint</code> 속성을 설정합니다. 이 메서드를 <code>null</code> <code>Paint</code> 오브젝트로 호출해도, 이 <code>Graphics2D</code>
 현재의 <code>Paint</code> 속성에는 영향을 주지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>paint</CODE> - 렌더링 프로세스로 색을 생성하기 위해서 사용되는 <code>Paint</code> 오브젝트, 또는 <code>null</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#getPaint()"><CODE>getPaint()</CODE></A>,
 
<A HREF="../../java/awt/GradientPaint.html" title="java.awt 안의 클래스"><CODE>GradientPaint</CODE></A>,
 
<A HREF="../../java/awt/TexturePaint.html" title="java.awt 안의 클래스"><CODE>TexturePaint</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setStroke(java.awt.Stroke)"><!-- --></A> <H3>
setStroke</H3>
<PRE>
public abstract void <B>setStroke</B>(<A HREF="../../java/awt/Stroke.html" title="java.awt 안의 인터페이스">Stroke</A> &nbsp;s)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 <code>Stroke</code>를
 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 렌더링 프로세스로 <code>Shape</code>를
 stroke로 렌더링 하기 위해서 사용되는 <code>Stroke</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/BasicStroke.html" title="java.awt 내의 클래스"><CODE>BasicStroke</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#getStroke()"><CODE>getStroke()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)"><!-- --></A> <H3>
setRenderingHint</H3>
<PRE>
public abstract void <B>setRenderingHint</B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey,
                                      <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;hintValue)</PRE>
<DL>
<DD>렌더링 알고리즘의 추천 설정의 값을 1 개 설정합니다. Hint 카테고리에는
 렌더링 품질을 제어하는 것으로 렌더링 프로세스에서의 렌더링 속도와 렌더링 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hintKey</CODE> - 설정되는 힌트의 키<DD><CODE>hintValue</CODE> - 지정된 힌트 카테고리의 추천 설정을 나타내는 값<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getRenderingHint(java.awt.RenderingHints.Key)"><CODE>getRenderingHint(RenderingHints.Key)</CODE></A>,
 
<A HREF="../../java/awt/RenderingHints.html" title="java.awt 안의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHint(java.awt.RenderingHints.Key)"><!-- --></A> <H3>
getRenderingHint</H3>
<PRE>
public abstract <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getRenderingHint</B>(<A HREF="../../java/awt/RenderingHints.Key.html" title="java.awt 안의 클래스">RenderingHints.Key</A> &nbsp;hintKey)</PRE>
<DL>
<DD>렌더링 알고리즘의 추천 설정의 값을 1 개 돌려줍니다. Hint 카테고리에는
 렌더링 품질을 제어하는 것으로 렌더링 프로세스에서의 렌더링 속도와 렌더링 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hintKey</CODE> - 얻는
 힌트에 대응하는 키
<DT><B>반환값:</B><DD>지정된 힌트 키의 값을 나타내는 오브젝트. 몇개의 키와 그 키에 관련한 값은 <code>RenderingHints</code> 클래스에서 정의되고 있는<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setRenderingHint(java.awt.RenderingHints.Key, java.lang.Object)"><CODE>setRenderingHint(RenderingHints.Key, Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRenderingHints(java.util.Map)"><!-- --></A> <H3>
setRenderingHints</H3>
<PRE>
public abstract void <B>setRenderingHints</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</PRE>
<DL>
<DD>렌더링 알고리즘의 모든 추천 설정의 값을, 지정된 <code>hints</code> 에 옮겨놓습니다. 렌더링 힌트의 기존의 값은 모두 파기되어 기존의 힌트와 값의 새로운 세트가 지정된 <A HREF="../../java/util/Map.html" title="java.util 동안의 인터페이스"><CODE>Map</CODE></A>  오브젝트로부터 초기화됩니다. Hint 카테고리에는
 렌더링 품질을 제어하는 것으로 렌더링 프로세스에서의 렌더링 속도와 렌더링 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hints</CODE> - 설정되는 렌더링 힌트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getRenderingHints()"><CODE>getRenderingHints()</CODE></A>,
 
<A HREF="../../java/awt/RenderingHints.html" title="java.awt 안의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="addRenderingHints(java.util.Map)"><!-- --></A> <H3>
addRenderingHints</H3>
<PRE>
public abstract void <B>addRenderingHints</B>(<A HREF="../../java/util/Map.html" title="java.util 안의 인터페이스">Map</A> &lt;?,?&gt;&nbsp;hints)</PRE>
<DL>
<DD>렌더링 알고리즘에 관한 임의의 수의 추천 설정의 값을 설정합니다. 지정된 <code>Map</code> 오브젝트에 있는 렌더링 힌트의 값만이 변경됩니다. 지정된 오브젝트에 없는 추천 설정은 변경되지 않습니다. Hint 카테고리에는
 렌더링 품질을 제어하는 것으로 렌더링 프로세스에서의 렌더링 속도와 렌더링 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>hints</CODE> - 설정되는 렌더링 힌트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRenderingHints()"><!-- --></A> <H3>
getRenderingHints</H3>
<PRE>
public abstract <A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스">RenderingHints</A>  <B>getRenderingHints</B>()</PRE>
<DL>
<DD>렌더링 알고리즘의 추천 설정을 돌려줍니다. Hint 카테고리에는
 렌더링 품질을 제어하는 것으로 렌더링 프로세스에서의 렌더링 속도와 렌더링 품질과의 전체적인 타협점을 제어하는 것이 포함됩니다. 1 회의 오퍼레이션으로 지정된 모든 힌트 키와 값의 페어를 돌려줍니다. <code>RenderingHints</code> 클래스에서, 공통의 키와 값의 정의의 일부를 참조할 수 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 추천 설정을 포함하고 있는 <code>RenderingHints</code>
 인스턴스에의 참조<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/RenderingHints.html" title="java.awt 내의 클래스"><CODE>RenderingHints</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setRenderingHints(java.util.Map)"><CODE>setRenderingHints(Map)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="translate(int, int)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(int&nbsp;x,
                               int&nbsp;y)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 원점을, 현재의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)으로 이동합니다. <code>Graphics2D</code> 컨텍스트
을 수정해, 새로운 원점이 <code>Graphics2D</code> 컨텍스트
의 원의 좌표계의 점 (<i>x</i>, &nbsp;<i>y</i>)에 대응하도록 합니다. 이 그래픽스 컨텍스트
으로 그 이후의 렌더링 조작으로 사용되는 좌표는 모두, 이 새로운 원점을 기준으로 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스">Graphics</A> </CODE> 내의 <CODE><A HREF="../../java/awt/Graphics.html#translate(int, int)">translate</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>x</CODE> - 지정된 x 좌표<DD><CODE>y</CODE> - 지정된 y 좌표<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="translate(double, double)"><!-- --></A> <H3>
translate</H3>
<PRE>
public abstract void <B>translate</B>(double&nbsp;tx,
                               double&nbsp;ty)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code>를
 이동 변환과 연결합니다. 이후의 렌더링는
 이전의 위치를 기준으로 지정된 거리로 이동합니다. 이것은, transform(T)를 호출하는 것에 상당합니다. 다만, T는
 다음의 행렬에
해 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   1    0    tx  ]
                [   0    1    ty  ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tx</CODE> - x 축으로 따라 이동하는 거리<DD><CODE>ty</CODE> - y 축으로 따라 이동하는 거리</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public abstract void <B>rotate</B>(double&nbsp;theta)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code>를
 회전 변환과 연결합니다. 이후의 렌더링는
 이전의 원점을 기준으로 지정된 라디안으로 회전합니다. 이것은,<code>transform(R)</code>를
 호출하는 것에 상당합니다. 다만, R는
 다음의 행렬에
해 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   cos(theta)    -sin(theta)    0   ]
                [   sin(theta)     cos(theta)    0   ]
                [       0              0         1   ]
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도</DL>
</DD>
</DL>
<HR>

<A NAME="rotate(double, double, double)"><!-- --></A> <H3>
rotate</H3>
<PRE>
public abstract void <B>rotate</B>(double&nbsp;theta,
                            double&nbsp;x,
                            double&nbsp;y)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code>를
 이동 후의 회전 변환과 연결합니다. 이후의 렌더링는
 지정된 위치로 이동해, 지정된 라디안으로 회전해, 원의 평행이동과 같은 양으로 평행이동 다시 하는 것으로 작성되는 변환에
해 변환됩니다. 이것은, 다음의 calling sequence에 상당합니다.
 
 <pre>

                translate(x, y);
                rotate(theta);
                translate(-x, -y);
 </pre>
정의 각도 theta 로 회전하면, 정의 x 축의 점이 정의 y 축으로 향해 회전됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>theta</CODE> - 라디안으로 나타낸 회전 각도<DD><CODE>x</CODE> - 회전의 원점의 x 좌표<DD><CODE>y</CODE> - 회전의 원점의 y 좌표</DL>
</DD>
</DL>
<HR>

<A NAME="scale(double, double)"><!-- --></A> <H3>
scale</H3>
<PRE>
public abstract void <B>scale</B>(double&nbsp;sx,
                           double&nbsp;sy)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code>를
 슬캘링 변환과 연결합니다. 이후의 렌더링는
 이전의 슬캘링을 기준으로 지정된 슬캘링 계수에 따라 사이즈 변경됩니다. 이것은,<code>transform(S)</code>를
 호출하는 것에 상당합니다. 다만, S는
 다음의 행렬에
해 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   sx   0    0   ]
                [   0    sy   0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>sx</CODE> - 이후의 렌더링 조작의 X 좌표가 이전의 렌더링 조작을 기준에 곱셈되는 양<DD><CODE>sy</CODE> - 이후의 렌더링 조작의 Y 좌표가 이전의 렌더링 조작을 기준에 곱셈되는 양</DL>
</DD>
</DL>
<HR>

<A NAME="shear(double, double)"><!-- --></A> <H3>
shear</H3>
<PRE>
public abstract void <B>shear</B>(double&nbsp;shx,
                           double&nbsp;shy)</PRE>
<DL>
<DD>현재의 <code>Graphics2D</code> <code>Transform</code>를
 셔링 변환과 연결합니다. 이후의 렌더링는
 이전의 위치를 기준으로 지정된 승수로 셔링 됩니다. 이것은,<code>transform(SH)</code>를
 호출하는 것에 상당합니다. 다만, SH는
 다음의 행렬에
해 표현되는 <code>AffineTransform</code> 입니다.
 
 <pre>

                [   1   shx   0   ]
                [  shy   1    0   ]
                [   0    0    1   ]
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>shx</CODE> - Y 좌표의 함수로서 좌표를 정의 X 축방향으로 쉬프트하기 위한 승수<DD><CODE>shy</CODE> - X 좌표의 함수로서 좌표를 정의 Y 축방향으로 쉬프트하기 위한 승수</DL>
</DD>
</DL>
<HR>

<A NAME="transform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
transform</H3>
<PRE>
public abstract void <B>transform</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>AffineTransform</code> 오브젝트를 이 <code>Graphics2D</code> 에서의 <code>Transform</code>를
 사용해, 후 지정 우선 적용이라고 하는 규칙에 따라 변환합니다. 현재의 <code>Transform</code> 가 Cx 인 경우, Tx 에
한 변환의 결과는 새로운 <code>Transform</code> Cx'가 됩니다. Cx'는
 이 <code>Graphics2D</code> 용의 현재의 <code>Transform</code> 가 됩니다. 갱신된 <code>Transform</code> Cx'로 점 p를
 변환하는 것은, 최초로 Tx 로 p를
 변환하고 나서, 그 결과를 원의 <code>Transform</code> Cx 로 변환하는 것에 상당합니다. 즉, Cx'(p) = Cx(Tx(p))입니다. 필요에 따라서 Tx
 카피를 실시하면, Tx를
 그 이상 수정해도 렌더링에 영향을 주지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - 현재의 <code>Transform</code> 로 변환되는 <code>AffineTransform</code> 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스"><CODE>AffineTransform</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTransform(java.awt.geom.AffineTransform)"><!-- --></A> <H3>
setTransform</H3>
<PRE>
public abstract void <B>setTransform</B>(<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스">AffineTransform</A> &nbsp;Tx)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
으로 Transform를
 덧쓰기합니다. 경고: 이 메서드는 새로운 좌표변화를 기존의 변환상에서 적용하는 목적에서는 사용<b>하지 말아 주세요</b>. 이것은,<code>Graphics2D</code> 에는
 Swing 컴퍼넌트의 렌더링 또는 프린터의 해상도를 조정하기 위한 슬캘링 변환의 적용 등, 다른 목적을 위해서 필요한 변환이 벌써 포함되어 있기 때문입니다.
<p>좌표변화를 추가하기 위해서,<code>transform</code>,<code>rotate</code>,<code>scale</code>, 또는<code>shear</code> 메서드를 사용합니다. <code>setTransform</code>는

 이 예로 나타나고 있는 대로 렌더링 종료후에 원의 <code>Graphics2D</code> 변환을 복원하기 때문에인 만큼 사용됩니다.
 
 <pre>
<blockquote>
 // Get the current transform
 AffineTransform saveAT = g2.getTransform();
 // Perform transformation
 g2d.transform(...);
 // Render
 g2d.draw(...);
 // Restore original transform
 g2d.setTransform(saveAT);
 </blockquote></pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>Tx</CODE> - <code>getTransform</code> 메서드로부터 취득된 <code>AffineTransform</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#getTransform()"><CODE>getTransform()</CODE></A>,
 
<A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 안의 클래스"><CODE>AffineTransform</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTransform()"><!-- --></A> <H3>
getTransform</H3>
<PRE>
public abstract <A HREF="../../java/awt/geom/AffineTransform.html" title="java.awt.geom 내의 클래스">AffineTransform</A>  <B>getTransform</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Transform</code>
 카피를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD><code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>AffineTransform</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#transform(java.awt.geom.AffineTransform)"><CODE>transform(java.awt.geom.AffineTransform)</CODE></A>,
 
<A HREF="../../java/awt/Graphics2D.html#setTransform(java.awt.geom.AffineTransform)"><CODE>setTransform(java.awt.geom.AffineTransform)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPaint()"><!-- --></A> <H3>
getPaint</H3>
<PRE>
public abstract <A HREF="../../java/awt/Paint.html" title="java.awt 내의 인터페이스">Paint</A>  <B>getPaint</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Paint</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>색 또는 패턴을 정의하는 현재의 <code>Graphics2D</code> <code>Paint</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setPaint(java.awt.Paint)"><CODE>setPaint(java.awt.Paint)</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#setColor(java.awt.Color)"><CODE>Graphics.setColor(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getComposite()"><!-- --></A> <H3>
getComposite</H3>
<PRE>
public abstract <A HREF="../../java/awt/Composite.html" title="java.awt 내의 인터페이스">Composite</A>  <B>getComposite</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Composite</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>거듭해 맞댐 스타일을 정의하는 현재의 <code>Graphics2D</code> <code>Composite</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setComposite(java.awt.Composite)"><CODE>setComposite(java.awt.Composite)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setBackground(java.awt.Color)"><!-- --></A> <H3>
setBackground</H3>
<PRE>
public abstract void <B>setBackground</B>(<A HREF="../../java/awt/Color.html" title="java.awt 안의 클래스">Color</A> &nbsp;color)</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
의 백그라운드 컬러를 설정합니다. 백그라운드 컬러는
 영역을 클리어 하기 위해서 사용됩니다. <code>Graphics2D</code>를
 <code>Component</code> 용으로 작성하면, 백그라운드 컬러가 <code>Component</code> 로부터 상속됩니다. <code>Graphics2D</code> 컨텍스트
에서의 백그라운드 컬러를 설정해도, 그 이후의 <code>clearRect()</code> 호출해에 작용하는 것만으로<code>Component</code>
 백그라운드 컬러에는 영향을 미치지 않습니다. <code>Component</code>
 백그라운드를 변경하려면,
<code>Component</code>
 적절한 메서드를 사용합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>color</CODE> - 이후의 <code>clearRect()</code>
 호출로 사용되는 백그라운드 컬러<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#getBackground()"><CODE>getBackground()</CODE></A>,
 
<A HREF="../../java/awt/Graphics.html#clearRect(int, int, int, int)"><CODE>Graphics.clearRect(int, int, int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getBackground()"><!-- --></A> <H3>
getBackground</H3>
<PRE>
public abstract <A HREF="../../java/awt/Color.html" title="java.awt 내의 클래스">Color</A>  <B>getBackground</B>()</PRE>
<DL>
<DD>영역을 클리어 하는데 사용하는 백그라운드 컬러를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>백그라운드 컬러를 정의하는 현재의 <code>Graphics2D</code> <code>Color</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setBackground(java.awt.Color)"><CODE>setBackground(java.awt.Color)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getStroke()"><!-- --></A> <H3>
getStroke</H3>
<PRE>
public abstract <A HREF="../../java/awt/Stroke.html" title="java.awt 내의 인터페이스">Stroke</A>  <B>getStroke</B>()</PRE>
<DL>
<DD><code>Graphics2D</code> 컨텍스트
에서의 현재의 <code>Stroke</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>선의 스타일을 정의하는 현재의 <code>Graphics2D</code> <code>Stroke</code><DT><B>관련 항목:</B><DD><A HREF="../../java/awt/Graphics2D.html#setStroke(java.awt.Stroke)"><CODE>setStroke(java.awt.Stroke)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clip(java.awt.Shape)"><!-- --></A> <H3>
clip</H3>
<PRE>
public abstract void <B>clip</B>(<A HREF="../../java/awt/Shape.html" title="java.awt 안의 인터페이스">Shape</A> &nbsp;s)</PRE>
<DL>
<DD>현재의 <code>Clip</code> 가 지정된 <code>Shape</code>
 내부와 교차시켜, 결과적으로 생긴 공통 부분에 그 <code>Clip</code>를
 설정합니다. 지정된 <code>Shape</code>는

 현재의 <code>Clip</code> 와 교차하기 전에
 현재의 <code>Graphics2D</code> <code>Transform</code>를
 사용해 변환됩니다. 이 메서드를 사용하면, 현재의 <code>Clip</code>를
 작게 할 수 있습니다. <code>Clip</code>를
 크게 하려면,
<code>setClip</code> 메서드를 사용합니다. 이 메서드에
해 변경된 유저 클립은, 디바이스의 경계 및 가시성과 관련한 클리핑과는 무관계합니다. 지금까지 설정되어 있는 클립이 없는 경우, 또는 <A HREF="../../java/awt/Graphics.html#setClip(java.awt.Shape)"><CODE>setClip</CODE></A>  에 <code>null</code> 인수를 사용해 클립이 클리어 되고 있는 경우는
 지정된 <code>Shape</code> 가 새로운 유저 클립이 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 현재의 <code>Clip</code> 와 교차하는 <code>Shape</code>. <code>s</code> 가 <code>null</code>
 경우, 이 메서드는 현재의 <code>Clip</code>를
 클리어 한다</DL>
</DD>
</DL>
<HR>

<A NAME="getFontRenderContext()"><!-- --></A> <H3>
getFontRenderContext</H3>
<PRE>
public abstract <A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스">FontRenderContext</A>  <B>getFontRenderContext</B>()</PRE>
<DL>
<DD>이 <code>Graphics2D</code> 컨텍스트
에서의 <code>Font</code>
 렌더링 컨텍스트
을 돌려줍니다. <A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 안의 클래스"><CODE>FontRenderContext</CODE></A> 는

 에일리어징 제거나 부분 메트릭스등의 어플리케이션 힌트외, 타겟 디바이스에 특유의 해상도 (dpi)등의 정보를 캡슐화합니다. 이러한 정보는
<code>Font</code> 나 <code>TextLayout</code> 등의 문자 체재의 포맷을 실행하는 오브젝트의 사용시에 어플리케이션에
해 제공됩니다. 이 정보는 또, 각종 렌더링 힌트가 텍스트 렌더링에 적용되었을 때에
 그 자체의 레이아웃을 실행해, 유효폭이나 행의 높이 등, 그래프
의 각종 특성의 정확한 파악
을 필요로 하는 어플리케이션에
해 제공되지 않으면 안됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>FontRenderContext
 인스턴스에의 참조<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/awt/font/FontRenderContext.html" title="java.awt.font 내의 클래스"><CODE>FontRenderContext</CODE></A>,
 
<A HREF="../../java/awt/Font.html#createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)"><CODE>Font.createGlyphVector(java.awt.font.FontRenderContext, java.lang.String)</CODE></A>,
 
<A HREF="../../java/awt/font/TextLayout.html" title="java.awt.font 안의 클래스"><CODE>TextLayout</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Graphics2D.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/awt/Graphics.html" title="java.awt 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/awt/GraphicsConfigTemplate.html" title="java.awt 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/awt/Graphics2D.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Graphics2D.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:58:14 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
BreakIterator (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.text.BreakIterator class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="BreakIterator (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BreakIterator.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/text/Bidi.html" title="java.text 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/text/BreakIterator.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="BreakIterator.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.text</FONT>
<BR>
클래스 BreakIterator</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.text.BreakIterator</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>BreakIterator</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스">Cloneable</A> </DL>
</PRE>

<P>
<code>BreakIterator</code> 클래스는
 텍스트내의 경계의 위치를 찾아내는 메서드를 구현합니다. <code>BreakIterator</code>
 인스턴스는 현재의 위치를 유지해, 텍스트를 스캔 해 경계가 발생하는 문자의 인덱스를 돌려줍니다. 내부적으로는
<code>BreakIterator</code>는
 <code>CharacterIterator</code>를
 사용해 텍스트를 스캔 하기 위한, 이 프로토콜을 구현하는 임의의 오브젝트에
해 보관 유지되는 텍스트를 스캔 할 수 있습니다. <code>StringCharacterIterator</code>는

<code>setText</code> 에게 건네진 <code>String</code> 오브젝트의 스캔에 사용됩니다.

 <p>
이 클래스에
해 제공되는 팩토리 메서드를 사용해, 다양한 형태의 분할 반복자의 인스턴스를 생성합니다. 특히, 단어, 행, 문 및 문자의 경계 해석을 실행하는 <code>BreakIterator</code>를
 생성하려면,
 각각 <code>getWordIterator</code>,<code>getLineIterator</code>,<code>getSentenceIterator</code> 및 <code>getCharacterIterator</code>를
 사용합니다. 단일의 <code>BreakIterator</code>는

 1 개의 유니트 (단어, 행, 문장등)만을 처리하기 위해, 실행하는 유니트 경계 해석 마다 다른 반복자를 사용할 필요가 있습니다.

 <p>
행의 경계 해석에서는
 텍스트 캐릭터 라인을 행 즉시 로 분할하는 위치를 판정합니다. 구두점 및 하이픈 자동 삽입 된 단어도, 도구
에
해 올바르게 처리됩니다.

 <p>
문장의 경계 해석에서는
 숫자와 약어안의 피리어드, 인용부호나 괄호 등에 계속되는 구두점의 올바른 해석에 대해 선택이 가능합니다.

 <p>
단어의 경계 해석은, 검색 치환 기능으로 사용됩니다. 또, 텍스트 편집 어플리케이션내에서, 더블 클릭에
해 단어가 선택 가능하게 됩니다. 단어 선택에서는
 구두점과 함께, 기호나 구두점등과 같이 단어가 일부에서 없는 문자, 전후에 분할이 있는 문자도 올바르게 해석됩니다.

 <p>
문자의 경계 해석에서는
 예를 들어 커서를 텍스트 캐릭터 라인에 따라 움직이는 것 같은 경우에
 유저가 예측하는 대로의 조작을 하도록 합니다. 문자의 경계 해석에
해, 문자의 포함 방법으로
존하지 않고, 캐릭터 라인의 올바른 네비게이션이 가능하게 됩니다. 예를 들어, 엑센트 첨부의 문자는
 기준 문자와 발음 구별 부호로서 포함되고 있는 경우가 있습니다. 유저의 문자에 대한 인식은 언어간에 다릅니다.

 <p>
<code>BreakIterator</code>는
 자연 언어에서의 사용만을 상정하고 있습니다. 이 클래스는
 프로그램 언어를 토큰화하기 위해서는 사용할 수 없습니다.

<P>
 <strong>례</strong>:
<P>
 텍스트 경계를 작성해 사용합니다.  <blockquote>
 
 <pre>

 public static void main(String args[]) {
      if (args.length == 1) {
          String stringToExamine = args[0];
          //print each word in order
          BreakIterator boundary = BreakIterator.getWordInstance();
          boundary.setText(stringToExamine);
          printEachForward(boundary, stringToExamine);
          //print each sentence in reverse order
          boundary = BreakIterator.getSentenceInstance(Locale.US);
          boundary.setText(stringToExamine);
          printEachBackward(boundary, stringToExamine);
          printFirst(boundary, stringToExamine);
          printLast(boundary, stringToExamine);
      }
 }
 </pre>
 </blockquote>
각 요소를 순서에 출력합니다.  <blockquote>
 
 <pre>

 public static void printEachForward(BreakIterator boundary, String source) {
     int start = boundary.first();
     for (int end = boundary.next();
          end ! = BreakIterator.DONE;
          start = end, end = boundary.next()) {
          System.out.println(source.substring(start, end));
     }
 }
 </pre>
 </blockquote>
각 요소를 역순서에 출력합니다.  <blockquote>
 
 <pre>

 public static void printEachBackward(BreakIterator boundary, String source) {
     int end = boundary.last();
     for (int start = boundary.previous();
          start ! = BreakIterator.DONE;
          end = start, start = boundary.previous()) {
         System.out.println(source.substring(start, end));
     }
 }
 </pre>
 </blockquote>
최초의 요소를 출력합니다.  <blockquote>
 
 <pre>

 public static void printFirst(BreakIterator boundary, String source) {
     int start = boundary.first();
     int end = boundary.next();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>
마지막 요소를 출력합니다.  <blockquote>
 
 <pre>

 public static void printLast(BreakIterator boundary, String source) {
     int end = boundary.last();
     int start = boundary.previous();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>
지정된 위치에 있는 요소를 출력합니다.  <blockquote>
 
 <pre>

 public static void printAt(BreakIterator boundary, int pos, String source) {
     int end = boundary.following(pos);
     int start = boundary.previous();
     System.out.println(source.substring(start, end));
 }
 </pre>
 </blockquote>
다음의 단어를 검색합니다.  <blockquote>
 
 <pre>

 public static int nextWordStartAfter(int pos, String text) {
     BreakIterator wb = BreakIterator.getWordInstance();
     wb.setText(text);
     int last = wb.following(pos);
     int current = wb.next();
     while (current ! = BreakIterator.DONE) {
         for (int p = last; p < current; p++) {
             if (Character.isLetter(text.codePointAt(p))
                 return last;
         }
         last = current;
         current = wb.next();
     }
     return BreakIterator.DONE;
 }
 </pre>
(BreakIterator.getWordInstance()에
해 돌려주고지는 반복자는 일의이기 때문에
 돌려주고지는 분할 위치는 반복의 개시와 종료의 양쪽 모두를 나타내는 것은 아니다. 즉, 문장을 분할하는 반복자는
 각각이 1 개의 문장의 종료와 다음의 문장의 개시를 나타내는 분할을 돌려준다. 단어를 분할하는 반복자에서는
 2 개의 경계간의 문자가 단어, 구두점, 또는 2 개의 단어간의 공백 문자의 경우가 있다. 상기의 코드에서는
 단순한 휴리스틱을 사용해, 단어의 개시의 경계를 판정하고 있다. 어느 경계와 다음의 경계의 사이의 문자가, 적어도 1 개의 문자 (알파벳, CJK 통합 한자, 한글 문자, 가명등)를 포함한 경우는
 이 경계와 다음의 경계의 사이의 텍스트를 단어로 해, 그렇지 않은 경우는
 단어간의 데이터라고 본다) </blockquote>
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><CODE>CharacterIterator</CODE></A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#DONE">DONE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 유효한 경계가 돌려주고지고 나서, previous()와 next()에
해 DONE 가 돌려주고집니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#BreakIterator()">BreakIterator</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;생성자
입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;반복자의 카피를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#current()">current</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next(), previous(), first(), 또는 last()에
해 마지막에 돌려주고진 텍스트 경계의 문자 인덱스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#first()">first</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최초의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#following(int)">following</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 오프셋(offset)에 계속되는 최초의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getAvailableLocales()">getAvailableLocales</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 클래스의 <code>get*Instance</code> 메서드가 지역 대응의 인스턴스를 돌려줄 수 있는 로케일 모든 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getCharacterInstance()">getCharacterInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 로케일을 사용해, 문자 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getCharacterInstance(java.util.Locale)">getCharacterInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일을 사용해, 문자 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getInt(byte[], int)">getInt</A> </B>(byte[]&nbsp;buf,
       int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getLineInstance()">getLineInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 로케일을 사용해, 행 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getLineInstance(java.util.Locale)">getLineInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 로케일을 사용해, 행 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getLong(byte[], int)">getLong</A> </B>(byte[]&nbsp;buf,
        int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getSentenceInstance()">getSentenceInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 로케일을 사용해 문장 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getSentenceInstance(java.util.Locale)">getSentenceInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 로케일을 사용해, 문장 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getShort(byte[], int)">getShort</A> </B>(byte[]&nbsp;buf,
         int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스">CharacterIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getText()">getText</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 텍스트를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getWordInstance()">getWordInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 로케일을 사용해, 단어 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#getWordInstance(java.util.Locale)">getWordInstance</A> </B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 로케일을 사용해, 단어 분할을 위한 BreakIterator를
 생성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#isBoundary(int)">isBoundary</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 위치가 경계 위치의 경우에 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#last()">last</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;마지막 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#next()">next</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계에 계속되는 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#next(int)">next</A> </B>(int&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계로부터 n 번째의 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#preceding(int)">preceding</A> </B>(int&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 오프셋(offset)보다 전방에 있는 마지막 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#previous()">previous</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 경계에 선행하는 경계를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#setText(java.text.CharacterIterator)">setText</A> </B>(<A HREF="../../java/text/CharacterIterator.html" title="java.text 안의 인터페이스">CharacterIterator</A> &nbsp;newText)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 새로운 텍스트를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/text/BreakIterator.html#setText(java.lang.String)">setText</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;newText)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스캔 되는 새로운 텍스트 캐릭터 라인을 설정합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DONE"><!-- --></A> <H3>
DONE</H3>
<PRE>
public static final int <B>DONE</B></PRE>
<DL>
<DD>모든 유효한 경계가 돌려주고지고 나서, previous()와 next()에
해 DONE 가 돌려주고집니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.text.BreakIterator.DONE">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="BreakIterator()"><!-- --></A> <H3>
BreakIterator</H3>
<PRE>
protected <B>BreakIterator</B>()</PRE>
<DL>
<DD>생성자
입니다. BreakIterator 에는 상태가 없고, 디폴트의 동작이 없습니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()</PRE>
<DL>
<DD>반복자의 카피를 작성합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#clone()">clone</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 반복자의 카피<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="first()"><!-- --></A> <H3>
first</H3>
<PRE>
public abstract int <B>first</B>()</PRE>
<DL>
<DD>최초의 경계를 돌려줍니다. 반복자의 현재 위치는 최초의 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>최초의 텍스트 경계의 문자 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="last()"><!-- --></A> <H3>
last</H3>
<PRE>
public abstract int <B>last</B>()</PRE>
<DL>
<DD>마지막 경계를 돌려줍니다. 반복자의 현재 위치는 마지막 경계로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>마지막 텍스트 경계의 문자 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="next(int)"><!-- --></A> <H3>
next</H3>
<PRE>
public abstract int <B>next</B>(int&nbsp;n)</PRE>
<DL>
<DD>현재의 경계로부터 n 번째의 경계를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>n</CODE> - 돌려주고지는 경계. 값이 0
 경우, 아무것도 하지 않는다. 부의 값은 전방의 경계에 이동해, 정의 값은 후방의 경계에 이동한다
<DT><B>반환값:</B><DD>현재 위치로부터 n 번째의 경계의 인덱스</DL>
</DD>
</DL>
<HR>

<A NAME="next()"><!-- --></A> <H3>
next</H3>
<PRE>
public abstract int <B>next</B>()</PRE>
<DL>
<DD>현재의 경계에 계속되는 경계를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>모든 경계가 돌려주고지고 있는 경우는
 다음의 텍스트 경계의 문자 인덱스 또는 DONE. next(1)에 동일하다</DL>
</DD>
</DL>
<HR>

<A NAME="previous()"><!-- --></A> <H3>
previous</H3>
<PRE>
public abstract int <B>previous</B>()</PRE>
<DL>
<DD>현재의 경계에 선행하는 경계를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>전의 텍스트 경계의 문자 인덱스, 또는 모든 경계가 돌려주고지고 있는 경우는 DONE</DL>
</DD>
</DL>
<HR>

<A NAME="following(int)"><!-- --></A> <H3>
following</H3>
<PRE>
public abstract int <B>following</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 오프셋(offset)에 계속되는 최초의 경계를 돌려줍니다. 돌려주고지는 값은 항상 오프셋(offset)보다 큰지, 또는 값 BreakIterator.DONE 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 스캔 개시에의 오프셋(offset). 이 값은, setText()에게 건네진 CharacterIterator 에
해 판정되지 않으면 안 된다. 무효인 값을 지정하면, IllegalArgumentException 가 Throw 된다
<DT><B>반환값:</B><DD>지정된 오프셋(offset)의 뒤의 최초의 경계</DL>
</DD>
</DL>
<HR>

<A NAME="preceding(int)"><!-- --></A> <H3>
preceding</H3>
<PRE>
public int <B>preceding</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 오프셋(offset)보다 전방에 있는 마지막 경계를 돌려줍니다. 돌려주고지는 값은 항상, 오프셋(offset)보다 작은가 값 BreakIterator.DONE 입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 스캔 개시에의 오프셋(offset). 이 값은, setText()에게 건네진 CharacterIterator 에
해 판정되지 않으면 안 된다. 무효인 값을 지정하면, IllegalArgumentException 가 Throw 된다
<DT><B>반환값:</B><DD>지정된 오프셋(offset)의 전의 마지막 경계<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBoundary(int)"><!-- --></A> <H3>
isBoundary</H3>
<PRE>
public boolean <B>isBoundary</B>(int&nbsp;offset)</PRE>
<DL>
<DD>지정된 위치가 경계 위치의 경우에 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>offset</CODE> - 체크 대상의 오프셋(offset)
<DT><B>반환값:</B><DD>오프셋(offset)가 경계 위치의 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="current()"><!-- --></A> <H3>
current</H3>
<PRE>
public abstract int <B>current</B>()</PRE>
<DL>
<DD>next(), previous(), first(), 또는 last()에
해 마지막에 돌려주고진 텍스트 경계의 문자 인덱스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>마지막에 돌려주고진 경계</DL>
</DD>
</DL>
<HR>

<A NAME="getText()"><!-- --></A> <H3>
getText</H3>
<PRE>
public abstract <A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스">CharacterIterator</A>  <B>getText</B>()</PRE>
<DL>
<DD>스캔 되는 텍스트를 취득합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스캔 되는 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="setText(java.lang.String)"><!-- --></A> <H3>
setText</H3>
<PRE>
public void <B>setText</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;newText)</PRE>
<DL>
<DD>스캔 되는 새로운 텍스트 캐릭터 라인을 설정합니다. 현재의 스캔 위치는 first()에 리셋트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newText</CODE> - 스캔 대상의 새로운 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="setText(java.text.CharacterIterator)"><!-- --></A> <H3>
setText</H3>
<PRE>
public abstract void <B>setText</B>(<A HREF="../../java/text/CharacterIterator.html" title="java.text 안의 인터페이스">CharacterIterator</A> &nbsp;newText)</PRE>
<DL>
<DD>스캔 되는 새로운 텍스트를 설정합니다. 현재의 스캔 위치는 first()에 리셋트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newText</CODE> - 스캔 대상의 새로운 텍스트</DL>
</DD>
</DL>
<HR>

<A NAME="getWordInstance()"><!-- --></A> <H3>
getWordInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getWordInstance</B>()</PRE>
<DL>
<DD>디폴트의 로케일을 사용해, 단어 분할을 위한 BreakIterator를
 생성합니다. 단어 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. WordBreak는

 더블 클릭등의 단어 선택에 유용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>단어 분할을 위한 BreakIterator<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Locale.html#getDefault()"><CODE>Locale.getDefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getWordInstance(java.util.Locale)"><!-- --></A> <H3>
getWordInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getWordInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</PRE>
<DL>
<DD>지정한 로케일을 사용해, 단어 분할을 위한 BreakIterator를
 생성합니다. 단어 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. WordBreak는

 더블 클릭등의 단어 선택에 유용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>where</CODE> - 로케일. 지정한 로케일에 대해서 특정의 WordBreak 가 사용 불가의 경우는
 디폴트의 WordBreak 가 돌려주고진다
<DT><B>반환값:</B><DD>단어 분할을 위한 BreakIterator</DL>
</DD>
</DL>
<HR>

<A NAME="getLineInstance()"><!-- --></A> <H3>
getLineInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getLineInstance</B>()</PRE>
<DL>
<DD>디폴트의 로케일을 사용해, 행 분할을 위한 BreakIterator를
 생성합니다. 행 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. LineBreak는
 논리적으로 가능한 행 분할이며, 실제의 행 분할은 보통
, 표시폭에
해 정해집니다. LineBreak는

 단어 즉시 텍스트에 유용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행 분할을 위한 BreakIterator<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Locale.html#getDefault()"><CODE>Locale.getDefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLineInstance(java.util.Locale)"><!-- --></A> <H3>
getLineInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getLineInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</PRE>
<DL>
<DD>지정한 로케일을 사용해, 행 분할을 위한 BreakIterator를
 생성합니다. 행 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. LineBreak는
 논리적으로 가능한 행 분할이며, 실제의 행 분할은 보통
, 표시폭에
해 정해집니다. LineBreak는

 단어 즉시 텍스트에 유용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>where</CODE> - 로케일. 지정한 로케일에 대해서 특정의 LineBreak 가 사용 불가의 경우는
 디폴트의 LineBreak 가 돌려주고진다
<DT><B>반환값:</B><DD>행 분할을 위한 BreakIterator</DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterInstance()"><!-- --></A> <H3>
getCharacterInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getCharacterInstance</B>()</PRE>
<DL>
<DD>디폴트의 로케일을 사용해, 문자 분할을 위한 BreakIterator를
 생성합니다. 문자 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. 문자 분할은 결합 문자 순서의 경계입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>문자 분할을 위한 BreakIterator<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Locale.html#getDefault()"><CODE>Locale.getDefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCharacterInstance(java.util.Locale)"><!-- --></A> <H3>
getCharacterInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getCharacterInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</PRE>
<DL>
<DD>지정된 로케일을 사용해, 문자 분할을 위한 BreakIterator를
 생성합니다. 문자 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다. 문자 분할은 결합 문자 순서의 경계입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>where</CODE> - 로케일. 지정한 로케일에 대해서 특정의 문자 분할이 사용 불가의 경우는
 디폴트의 문자 분할이 돌려주고진다
<DT><B>반환값:</B><DD>문자 분할을 위한 BreakIterator</DL>
</DD>
</DL>
<HR>

<A NAME="getSentenceInstance()"><!-- --></A> <H3>
getSentenceInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getSentenceInstance</B>()</PRE>
<DL>
<DD>디폴트의 로케일을 사용해 문장 분할을 위한 BreakIterator를
 생성합니다. 문장 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>문 분할을 위한 BreakIterator<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Locale.html#getDefault()"><CODE>Locale.getDefault()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSentenceInstance(java.util.Locale)"><!-- --></A> <H3>
getSentenceInstance</H3>
<PRE>
public static <A HREF="../../java/text/BreakIterator.html" title="java.text 내의 클래스">BreakIterator</A>  <B>getSentenceInstance</B>(<A HREF="../../java/util/Locale.html" title="java.util 안의 클래스">Locale</A> &nbsp;where)</PRE>
<DL>
<DD>지정된 로케일을 사용해, 문장 분할을 위한 BreakIterator를
 생성합니다. 문장 분할을 구현하는 BreakIterator
 인스턴스를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>where</CODE> - 로케일. 지정한 로케일에 대해서 특정의 SentenceBreak 가 사용 불가의 경우는
 디폴트의 SentenceBreak 가 돌려주고진다
<DT><B>반환값:</B><DD>문 분할을 위한 BreakIterator</DL>
</DD>
</DL>
<HR>

<A NAME="getAvailableLocales()"><!-- --></A> <H3>
getAvailableLocales</H3>
<PRE>
public static <A HREF="../../java/util/Locale.html" title="java.util 내의 클래스">Locale</A> [] <B>getAvailableLocales</B>()</PRE>
<DL>
<DD>이 클래스의 <code>get*Instance</code> 메서드가 지역 대응의 인스턴스를 돌려줄 수 있는 로케일 모든 배열을 돌려줍니다. 돌려주고지는 배열은, 최저한 <A HREF="../../java/util/Locale.html#US"><CODE>Locale.US</CODE></A>  에 동일한 <code>Locale</code> 인스턴스를 포함하고 있을 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>지역 대응의 <code>BreakIterator</code> 인스턴스를 사용 가능한 로케일의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getLong(byte[], int)"><!-- --></A> <H3>
getLong</H3>
<PRE>
protected static long <B>getLong</B>(byte[]&nbsp;buf,
                              int&nbsp;offset)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInt(byte[], int)"><!-- --></A> <H3>
getInt</H3>
<PRE>
protected static int <B>getInt</B>(byte[]&nbsp;buf,
                            int&nbsp;offset)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getShort(byte[], int)"><!-- --></A> <H3>
getShort</H3>
<PRE>
protected static short <B>getShort</B>(byte[]&nbsp;buf,
                                int&nbsp;offset)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/BreakIterator.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/text/Bidi.html" title="java.text 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/text/CharacterIterator.html" title="java.text 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/text/BreakIterator.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="BreakIterator.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

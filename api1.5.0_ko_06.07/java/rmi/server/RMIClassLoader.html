<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:57:39 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
RMIClassLoader (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.rmi.server.RMIClassLoader class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="RMIClassLoader (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/RMIClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/rmi/server/RemoteStub.html" title="java.rmi.server 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/rmi/server/RMIClassLoader.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="RMIClassLoader.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.rmi.server</FONT>
<BR>
클래스 RMIClassLoader</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.rmi.server.RMIClassLoader</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>RMIClassLoader</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
<code>RMIClassLoader</code>는

 RMI를
 사용해 동적으로 클래스를 로드하기 위한 static 메서드로부터 구성됩니다. 이 클래스 로더에게는
 네트워크의 장소 (1 개 이상의 URL)에서 클래스를 로드하는 메서드나, 기존의 클래스가 포함되고 있는 장소를 얻는
 메서드가 삽입되어
 있습니다. 이러한 메서드는
 리모트 메서드 호출의 인수나 반환값에 포함되는 클래스를 정렬화 및 비정렬화할 때, RMI 런타임에
해 사용됩니다. 또, 이러한 메서드를 어플리케이션으로부터 직접 호출해, 클래스를 동적으로 로드할 수도 있습니다.

<p>다음의 static 메서드의 구현은, 서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> 
 인스턴스에
해 제공됩니다.

 <ul>
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)"><CODE>loadClass(URL, String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass(String, String, ClassLoader)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass(String, String[], ClassLoader)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)"><CODE>getClassLoader(String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation(Class)</CODE></A> 
 
</ul>

이 메서드중 한쪽이 불려 가면, 그 동작이 서비스 프로바이더 인스턴스의 대응하는 메서드에 위양 됩니다. 각 메서드가 프로바이더 인스턴스에 위양 하는 동작의 자세한 것은, 각 메서드의 메뉴얼을 참조하십시오.

<p>서비스 프로바이더 인스턴스는 다음과 같이 선택됩니다.

 <ul>
<li>시스템 프로퍼티 <code>java.rmi.server.RMIClassLoaderSpi</code> 가 정의되고 있는 경우, 그 값이 <code>"default"</code> 때는
<A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()"><CODE>getDefaultProviderInstance()</CODE></A>  메서드 호출의 반환값으로 지정되고 있는 프로바이더 인스턴스가 선택된다. 이 시스템 프로퍼티가 <code>"default"</code> 이외의 값 때는
 시스템 클래스 로더 (<A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A> 를
 참조)가 시스템 프로퍼티로 지정되고 있는 클래스를 로드 할 수 있어 그 클래스를 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  에 할당할 수가 있어 인수가 없는 public 생성자를 가지는 경우, 프로바이더 인스턴스 작성시에 그 생성자가 불려 간다. 이 시스템 프로퍼티가 정의되고 있는 경우에서도, 이러한 조건이 채워지지 않은 경우는
<code>RMIClassLoader</code>를
 사용을 시도하는 코드에 대해서, 프로바이더 인스턴스의 취득에 실패한 것을 나타내는
 지정되어 있지 않은 <code>Error</code> 가 Throw 된다
<li>시스템 클래스 로더에 <code>META-INF/services/java.rmi.server.RMIClassLoaderSpi</code> 라고 하는 자원이 삽입되어
 있는 경우, 이 자원의 내용은 프로바이더의 구성 파일로서 해석되어 이 파일의 최초로 지정되고 있는 클래스명이 프로바이더의 클래스명으로서 사용된다. 시스템 클래스 로더가 그 이름을 가지는 클래스를 로드 할 수 있어 그 클래스를 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A>  에 할당할 수가 있어 인수가 없는 public 생성자를 가지는 경우는
 프로바이더 인스턴스 작성시에 그 생성자가 불려 간다. 이 자원이 삽입되어
 있어도, 프로바이더를 인스턴스화할 수 없는 경우는
<code>RMIClassLoader</code>를
 사용을 시도하는 코드에 대해서, 프로바이더 인스턴스의 취득에 실패한 것을 나타내는
 지정되어 있지 않은 <code>Error</code> 가 Throw 된다
<li>상기 이외의 경우는
<A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()"><CODE>getDefaultProviderInstance()</CODE></A>  메서드 호출의 반환값으로 지정되고 있는 프로바이더 인스턴스가 선택된다
 
</ul>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> </DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)">getClassAnnotation</A> </B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스 정의의 위치를 나타내는 주석 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)">getClassLoader</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스">RMIClassLoaderSpi</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getDefaultProviderInstance()">getDefaultProviderInstance</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> 
 디폴트 프로바이더의 표준 인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#getSecurityContext(java.lang.ClassLoader)">getSecurityContext</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는
 클래스 로더의 시큐러티 컨텍스트
을 취득하기 위해서 이 메서드를 사용하지 않습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I><code>loadClass(String, String)</code> 메서드로 옮겨졌습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)">loadClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
          <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)">loadClass</A> </B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;codebase,
          <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 코드 베이스 URL 로부터 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)">loadProxyClass</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
               <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces,
               <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름을 가지는 인터페이스군을 구현한 동적 프록시 클래스 (<A HREF="../../../java/lang/reflect/Proxy.html" title="java.lang.reflect 안의 클래스"><CODE>Proxy</CODE></A> 를
 참조)를, 지정된 코드 베이스 URL 패스로부터 로드합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="loadClass(java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A>,

                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I><code>loadClass(String, String)</code> 메서드로 옮겨졌습니다. </I>
<P>
<DD>지정된 <code>name</code>를
 이름에 가지는 클래스를 로드합니다.

<p>이 메서드는 처리를 <A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메서드에 위양 합니다. 1 번째의 인수에는 <code>null</code> 가, 2 번째의 인수에는 <code>name</code> 가 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - 클래스 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 코드 베이스의 위치에 없었던 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.net.URL, java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/net/URL.html" title="java.net 안의 클래스">URL</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A>,

                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 로부터 클래스를 로드합니다.
<code>codebase</code> 가 <code>null</code> 인 경우, 이 메서드의 동작은, 메서드 <A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A> 
 인수에 <code>null</code> <code>codebase</code> 와 동일 클래스명을 지정했을 경우와 같게 됩니다.

<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메서드에 처리를 위양 합니다. 이 때, 지정한 URL 로 <A HREF="../../../java/net/URL.html#toString()"><CODE>URL.toString()</CODE></A> 를
 호출한 결과 (<code>codebase</code> 가 null
 경우는 <code>null</code>)가 최초의 인수로서<code>name</code> 가 2 번째의 인수로서<code>null</code> 가 3 번째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL, 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 URL 에 없었던 경우</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, java.lang.String)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A>,

                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다.

<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메서드에 처리를 위양 합니다. 이 때,<code>codebase</code> 가 최초의 인수로서<code>name</code> 가 2 번째의 인수로서<code>null</code> 가 3 번째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL
 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL를
 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 장소에 없었던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><!-- --></A> <H3>
loadClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                 <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
                                 <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)
                          throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A>,

                                 <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드합니다. 지정된 로더를 사용할 수도 있습니다.
프로바이더 구현의 호출원이, 상황에 따라 사용해야 할 추가 클래스 로더 (호출원의 스택상의 로더등)를 프로바이더 구현에 제공하는 경우에
 이 메서드를 사용합니다. 보통
, 프로바이더 구현은 지정된 <code>defaultLoader</code>를
 사용해 지정된 클래스의 해결을 시도하고 나서, 코드 베이스 URL 패스로부터의 클래스의 해결을 시도합니다.

<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadClass(String, String, ClassLoader)</CODE></A>  메서드에 처리를 위양 합니다. 이 때,<code>codebase</code> 가 최초의 인수로서<code>name</code> 가 2 번째의 인수로서<code>defaultLoader</code> 가 3 번째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL
 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>name</CODE> - 로드 대상 클래스의 이름<DD><CODE>defaultLoader</CODE> - 상황에 따라 사용하는 추가 클래스 로더, 또는 <code>null</code>
<DT><B>반환값:</B><DD>로드 된 클래스를 나타내는 <code>Class</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL를
 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스의 정의가 지정된 장소에 없었던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><!-- --></A> <H3>
loadProxyClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>loadProxyClass</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase,
                                      <A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces,
                                      <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;defaultLoader)
                               throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A>,

                                      <A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </PRE>
<DL>
<DD>지정된 이름을 가지는 인터페이스군을 구현한 동적 프록시 클래스 (<A HREF="../../../java/lang/reflect/Proxy.html" title="java.lang.reflect 안의 클래스"><CODE>Proxy</CODE></A> 를
 참조)를, 지정된 코드 베이스 URL 패스로부터 로드합니다.

<p>이러한 인터페이스의 해결은, 지정된 <code>codebase</code>를
 사용해 <A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메서드 경유로 로드 된 클래스와 같은 방법으로 행해집니다.

<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>RMIClassLoaderSpi.loadProxyClass(String, String[], ClassLoader)</CODE></A>  메서드에 처리를 위양 합니다. 이 때,<code>codebase</code> 가 최초의 인수로서<code>interfaces</code> 가 2 번째의 인수로서<code>defaultLoader</code> 가 3 번째의 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 클래스의 로드원의 URL
 리스트 (단락 문자는 스페이스), 또는 <code>null</code><DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 이름<DD><CODE>defaultLoader</CODE> - 상황에 따라 사용하는 추가 클래스 로더, 또는 <code>null</code>
<DT><B>반환값:</B><DD>지정된 인터페이스를 구현하는 동적 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL를
 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로드시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 지정된 인터페이스의 정의중 한쪽이 지정된 장소에 발견되지 않는 경우, 또는 동적 프록시 클래스의 작성에 실패했을 경우 (<A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass(ClassLoader, Class[])</CODE></A>  가, 지정된 인터페이스 리스트에 대해서 <code>IllegalArgumentException</code>를
 Throw 했을 때 등)<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClassLoader(java.lang.String)"><!-- --></A> <H3>
getClassLoader</H3>
<PRE>
public static <A HREF="../../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getClassLoader</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;codebase)
                                  throws <A HREF="../../../java/net/MalformedURLException.html" title="java.net 내의 클래스">MalformedURLException</A>,

                                         <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더를 돌려줍니다.

<p>돌려주고지는 클래스 로더는
<A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  메서드가 같은 <code>codebase</code> 인수를 지정해 클래스를 로드할 때 사용하는 클래스 로더와 같습니다.  
<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader(java.lang.String)"><CODE>RMIClassLoaderSpi.getClassLoader(String)</CODE></A>  메서드에 처리를 위양 합니다. 이 때,<code>codebase</code> 가 인수로서 건네받습니다.

<p>시큐러티 매니저가 존재하는 경우는
<code>RuntimePermission("getClassLoader")</code> 액세스권을 사용해 <code>checkPermission</code> 메서드가 불려 가<code>SecurityException</code> 가 체크됩니다. 이 메서드의 프로바이더 구현은, 호출측 컨텍스트
이 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권을 가지고 있을지 어떨지에 임해서, 시큐러티 체크를 실시하는 일도 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>codebase</CODE> - 돌려주고지는 클래스 로더가 로드하는 클래스가 포함되고 있는 URL
 리스트 (단락 문자는 스페이스), 또는 <code>null</code>
<DT><B>반환값:</B><DD>지정된 코드 베이스 URL 패스로부터 클래스를 로드하는 클래스 로더
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/net/MalformedURLException.html" title="java.net 안의 클래스">MalformedURLException</A> </CODE> - <code>codebase</code> 가 <code>null</code> 이외로 한편 무효인 URL를
 포함하고 있는 경우, 또는 <code>codebase</code> 가 <code>null</code> 로 한편 클래스 로더의 식별시에 사용된 프로바이더 고유 URL 가 무효인 경우
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재할 경우에
 그 <code>checkPermission</code> 메서드가 실패했을 경우. 또는
 호출측이 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권을 가지고 있지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getClassAnnotation(java.lang.Class)"><!-- --></A> <H3>
getClassAnnotation</H3>
<PRE>
public static <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getClassAnnotation</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</PRE>
<DL>
<DD>클래스 정의의 위치를 나타내는 주석 캐릭터 라인을 돌려줍니다. RMI는
 이것을 사용해, 지정된 클래스의 오브젝트의 정렬화를 실시할 때에
 클래스 기술자에게 주석을 더합니다.
<p>이 메서드는
 프로바이더 인스턴스의 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation(java.lang.Class)"><CODE>RMIClassLoaderSpi.getClassAnnotation(Class)</CODE></A>  메서드에 처리를 위양 합니다. 이 때,<code>cl</code> 가 인수로서 건네받습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 주석을 얻는
 대상의 클래스
<DT><B>반환값:</B><DD>정렬화시로 지정된 클래스에 주석을 더하기 위해서 사용되는 캐릭터 라인, 또는 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>cl</code> 가 <code>null</code>
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultProviderInstance()"><!-- --></A> <H3>
getDefaultProviderInstance</H3>
<PRE>
public static <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스">RMIClassLoaderSpi</A>  <B>getDefaultProviderInstance</B>()</PRE>
<DL>
<DD>서비스 프로바이더 인터페이스 <A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> 
 디폴트 프로바이더의 표준 인스턴스를 돌려줍니다. 시스템 프로퍼티 <code>java.rmi.server.RMIClassLoaderSpi</code> 가 정의되어 있지 않은 경우, 다음에 나타내는 <code>RMIClassLoader</code>
 static 메서드는
 서비스 프로바이더 인스턴스로서 디폴트 프로바이더의 표준 인스턴스를 사용합니다.
 <ul>
<li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.net.URL, java.lang.String)"><CODE>loadClass(URL, String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String)"><CODE>loadClass(String, String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass(String, String, ClassLoader)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass(String, String[], ClassLoader)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassLoader(java.lang.String)"><CODE>getClassLoader(String)</CODE></A>  <li><A HREF="../../../java/rmi/server/RMIClassLoader.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation(Class)</CODE></A> 
 
</ul>


<p>시큐러티 매니저가 존재하는 경우,<code>RuntimePermission("setFactory")</code> 액세스권을 사용해 <code>checkPermission</code> 메서드가 불려 가<code>SecurityException</code> 가 체크됩니다.

<p>디폴트의 서비스 프로바이더 인스턴스는
<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 안의 클래스"><CODE>RMIClassLoaderSpi</CODE></A> 를
 다음과 같이 구현합니다.
 <blockquote>

<p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassAnnotation(java.lang.Class)"><CODE>getClassAnnotation</CODE></A> </b> 메서드는
 지정된 클래스 정의의 다운로드에 리모트측이 사용하는 코드 베이스 URL 패스를 나타내는 <code>String</code>를
 돌려줍니다. 돌려주고지는 캐릭터 라인의 형식은, 스페이스에서 단락지어진 URL
 패스입니다.
돌려주고지는 코드 베이스의 캐릭터 라인은, 다음에 나타내도록(듯이), 지정된 클래스에 정의되고 있는 클래스 로더에 따라서 다릅니다.  
 <ul>

<p><li>정의되고 있는 클래스 로더가 시스템 클래스 로더 (<A HREF="../../../java/lang/ClassLoader.html#getSystemClassLoader()"><CODE>ClassLoader.getSystemClassLoader()</CODE></A> 를
 참조), 시스템 클래스 로더의 부모 (인스톨 끝난 확장 클래스에 사용되는 로더 등), 또는 bootstrap 클래스 로더 (<code>null</code> 로 나타내진다)의 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값 (또는 이전에 캐쉬된 값)이 돌려주고진다. 이 프로퍼티의 값이 설정되어 있지 않은 경우는
<code>null</code> 가 돌려주고진다

<p><li>정의되고 있는 클래스 로더가 <code>URLClassLoader</code>
 인스턴스의 경우는
 로더의 <code>getURLs</code> 메서드 호출로부터 돌려주고지는
 외부 형식의 URL
 리스트 (단락 문자는 스페이스)가 돌려주고진다. <code>URLClassLoader</code> 가 이 프로바이더에
해 작성되어 그 <code>loadClass</code> 또는 <code>loadProxyClass</code> 메서드가 사용되는 경우, 관련된 코드 베이스 캐릭터 라인을 취득하기 위한 액세스권은 필요없다. <code>URLClassLoader</code> 인스턴스가 이 프로바이더 이외에 작성되어 시큐러티 매니저가 존재하는 경우는
<code>getURLs</code> 메서드로부터 URL 가 돌려주고질 때마다,<code>openConnection(). getPermission()</code> 호출에
해 돌려주고진 액세스권을 사용해 시큐러티 매니저의 <code>checkPermission</code> 메서드가 불려 간다. 이러한 호출의 어느쪽이든으로 <code>SecurityException</code> 또는 <code>IOException</code> 가 Throw 되었을 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값이 돌려주고진다. 이 프로퍼티가 설정되어 있지 않은 경우는
<code>null</code> 가 돌려주고진다

<p><li>정의되고 있는 클래스 로더가 <code>URLClassLoader</code>
 인스턴스가 아닌 경우,<code>java.rmi.server.codebase</code> 프로퍼티의 값 (또는 이전에 캐쉬된 값)이 돌려주고진다. 이 프로퍼티가 설정되어 있지 않은 경우는
<code>null</code> 가 돌려주고진다
 
</ul>


<p><code>codebase</code> 라는 이름의 <code>String</code> 파라미터 (스페이스에서 단락지어진 URL
 리스트)를 취하는
 다음에 설명하는 각 메서드 구현에 대해, 메서드가 불려 갈 때마다 특정의 「코드 베이스 로더」를 관련지을 수 있습니다. 코드 베이스 로더는
<code>codebase</code> 인수와 현재의 thread의 컨텍스트
 클래스 로더 (<A HREF="../../../java/lang/Thread.html#getContextClassLoader()"><CODE>Thread.getContextClassLoader()</CODE></A> 를
 참조)를 조합해 검색됩니다. 시큐러티 매니저가 존재하는 경우, 이 프로바이더는
 클래스 로더 인스턴스의 내부 테이블 (적어도 <A HREF="../../../java/net/URLClassLoader.html" title="java.net 안의 클래스"><CODE>URLClassLoader</CODE></A> 
 인스턴스를 포함한다)을 보관 유지합니다. 이 테이블의 키는
 부모의 클래스 로더와 코드 베이스 URL 패스 (URL
 순서 첨부 리스트)의 페어입니다. <code>codebase</code> 인수가 <code>null</code>
 경우, 코드 베이스 URL 패스는
 시스템 프로퍼티 <code>java.rmi.server.codebase</code>
 값, 이전의 캐쉬된 값의 어느 쪽인가에 됩니다. 어느 코드 베이스 URL 패스가 있는 특정의 컨텍스트
내에서 이하의 몇개의 메서드의 호출의 <code>codebase</code> 인수로서 건네받았을 경우, 테이블내의 로더 가운데, 패스가 지정된 코드 베이스 URL 패스, 부모가 현재 thread의 컨텍스트
 클래스 로더인 것 같은 로더가, 코드 베이스 로더가 됩니다. 그러한 로더가 발견되지 않았던 경우, 그러한 로더가 새롭게 작성되어 테이블에 추가됩니다. 다만, 이 테이블은, 도달 불가능한 로더와 그 로더에 정의되고 있는 클래스가 가비지 컬렉트되도록, 로더에게로의 강참조를 보관 유지하지 않습니다. 시큐러티 매니저가 존재하지 않을 때에 신뢰되지 않는 코드가 가상 머신에 암묵적으로 로드 되지 않게 하기 위해서, 시큐러티 매니저가 설정되어 있지 않은 경우는
 코드 베이스 로더는 현재의 thread의 컨텍스트
 클래스 로더가 됩니다 (지정된 코드 베이스 URL 패스는 무시되어 리모트 클래스를 로드할 수 없게 된다).

<p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#getClassLoader(java.lang.String)"><CODE>getClassLoader</CODE></A> </b> 메서드는
 지정된 코드 베이스 URL 패스의 코드 베이스 로더를 돌려줍니다. 시큐러티 매니저가 존재하는 경우, 호출측 컨텍스트
에 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권이 없을 때는
<code>SecurityException</code> 가 Throw 됩니다.

<p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadClass(java.lang.String, java.lang.String, java.lang.ClassLoader)"><CODE>loadClass</CODE></A> </b> 메서드는
 지정된 이름의 클래스를 다음의 방법으로 로드를 시도합니다.
 <blockquote>
<code>defaultLoader</code> 인수가 <code>null</code> 가 아닌 경우는
 우선 <code>defaultLoader</code>를
 사용해, 지정된 <code>name</code>
 클래스의 로드를 시도합니다. 예를 들어, 다음과 같이 평가합니다.

 
 <pre>

     Class.forName(name, false, defaultLoader)
 </pre>

클래스를 <code>defaultLoader</code> 로부터 로드할 수 있었을 경우, 그 클래스가 돌려주고집니다. <code>ClassNotFoundException</code> 이외의 예외가 Throw 되었을 경우는
 그 예외가 호출해 측에 Throw 됩니다.

<p>다음에
<code>loadClass</code> 메서드가, 지정된 코드 베이스 URL 패스의 코드 베이스 로더를 사용해, 지정된 <code>name</code>
 클래스의 로드를 시도합니다. 시큐러티 매니저가 존재하는 경우, 호출측 컨텍스트
에는 코드 베이스 URL 패스내의 모든 URL 에 대한 액세스권이 필요합니다. 액세스권이 없는 경우는
 코드 베이스 로더 대신에
 현재의 thread의 컨텍스트
 클래스 로더가 사용됩니다.
 </blockquote>

<p><b><A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html#loadProxyClass(java.lang.String, java.lang.String[], java.lang.ClassLoader)"><CODE>loadProxyClass</CODE></A> </b> 메서드는
 다음의 방법으로 지정된 인터페이스의 동적 프록시 클래스를 돌려줍니다.
 <blockquote>

<p><code>defaultLoader</code> 인수가 <code>null</code> 이외로 그 로더를 사용해 지정된 인터페이스를 모두 해결할 수 있는 경우
 <ul>
<li>해결된 인터페이스가 모두 <code>public</code>
 경우는
 우선 <A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass</CODE></A> 를
 사용해, 코드 베이스 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다. <code>IllegalArgumentException</code> 가 Throw 되었을 경우는
<code>defaultLoader</code> 로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다. 어느 쪽의 경우도 <code>IllegalArgumentException</code> 가 Throw 되었을 때는
<code>ClassNotFoundException</code> 가 Throw 된다. 다른 예외가 Throw 되었을 경우, 그 예외는 호출해 측에 Throw 된다
<li>해결된 인터페이스가 <code>public</code> 이외의 경우, 그것들이 모두 같은 클래스 로더에 정의되고 있을 때는
 그 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다
<li>상기 이외의 경우는
<code>LinkageError</code> 가 Throw 된다 (지정된 인터페이스를 모두 구현하는 클래스는 어느 로더에도 정의할 수 없기 때문에)
 
</ul>


<p>지정된 모든 인터페이스를 코드 베이스 로더를 사용해 해결할 수 있는 경우
 <ul>
<li>해결된 인터페이스가 모두 <code>public</code>
 경우는
 그 인터페이스의 동적 프록시 클래스를 코드 베이스 로더로부터 취득하자 한다. <code>IllegalArgumentException</code> 가 Throw 되었을 경우는
<code>ClassNotFoundException</code> 가 Throw 된다
<li>해결된 인터페이스가 <code>public</code> 이외의 경우, 그것들이 모두 같은 클래스 로더에 정의되고 있을 때는
 그 로더로부터 그 인터페이스의 동적 프록시 클래스를 취득하려고 한다
<li>상기 이외의 경우는
<code>LinkageError</code> 가 Throw 된다 (지정된 인터페이스를 모두 구현하는 클래스는 어느 로더에도 정의할 수 없기 때문에)
 
</ul>


<p>상기 이외의 경우, 해결할 수 없었던 지정 인터페이스에 대해,<code>ClassNotFoundException</code> 가 Throw 됩니다.
 </blockquote>
 </blockquote>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>디폴트의 서비스 프로바이더의 정규의 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재하는 경우에
 그 <code>checkPermission</code> 메서드 호출해에 실패했을 때<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getSecurityContext(java.lang.ClassLoader)"><!-- --></A> <H3>
getSecurityContext</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public static <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>getSecurityContext</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>대체는 없습니다. Java 2 플랫폼 1.2 이후의 RMI 에서는
 클래스 로더의 시큐러티 컨텍스트
을 취득하기 위해서 이 메서드를 사용하지 않습니다. </I>
<P>
<DD>지정된 클래스 로더의 시큐러티 컨텍스트
을 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 시큐러티 컨텍스트
의 취득원의 클래스 로더
<DT><B>반환값:</B><DD>시큐러티 컨텍스트
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/SecurityManager.html#getSecurityContext()"><CODE>SecurityManager.getSecurityContext()</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/RMIClassLoader.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/rmi/server/RemoteStub.html" title="java.rmi.server 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/rmi/server/RMIClassLoaderSpi.html" title="java.rmi.server 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/rmi/server/RMIClassLoader.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="RMIClassLoader.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:58:23 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Arrays (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.Arrays class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Arrays (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 Arrays</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.Arrays</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Arrays</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스에는
 소트나 검색 등, 배열을 조작하기 위한 다양한 메서드가 있습니다. 또, 배열을 리스트로서 표시하기 위한 static 팩토리도 있습니다.

<p>지정된 배열 참조가 null
 경우, 그 이외의 처리가 명시되고 있는 경우를 제외해, 이 클래스의 메서드는 모두 <tt>NullPointerException</tt>를
 Throw 합니다.

<p>이 클래스에 있는 검색 메서드의 문서에는
 「구현」의 간단한 설명이 포함되어 있습니다. 이 설명은, 「사양」의 일부에서는 없고 「구현 정보」라고 생각해 주세요. 구현자는
 사양에 반하지 않는 한, 다른 알고리즘을 자유롭게 사용할 수 있습니다. 예를 들어,<tt>sort(Object[])</tt> 가 사용하는 알고리즘은 머지 소트일 필요는 없습니다만, 「고정 (stable)」의 알고리즘이 아니면 안됩니다.

<p>이 클래스는
<a href="../../../guide/collections/index.html">Java Collections Framework</a> 
 멤버입니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A>,
 
<A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스"><CODE>Comparator</CODE></A> </DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt;</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#asList(T...)">asList</A> </B>(T...&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열을 기본으로 하는 고정 사이즈의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(byte[], byte)">binarySearch</A> </B>(byte[]&nbsp;a,
             byte&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(char[], char)">binarySearch</A> </B>(char[]&nbsp;a,
             char&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 char 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(double[], double)">binarySearch</A> </B>(double[]&nbsp;a,
             double&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(float[], float)">binarySearch</A> </B>(float[]&nbsp;a,
             float&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(int[], int)">binarySearch</A> </B>(int[]&nbsp;a,
             int&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(long[], long)">binarySearch</A> </B>(long[]&nbsp;a,
             long&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(java.lang.Object[], java.lang.Object)">binarySearch</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 오브젝트를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(short[], short)">binarySearch</A> </B>(short[]&nbsp;a,
             short&nbsp;key)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값을 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; int</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#binarySearch(T[], T, java.util.Comparator)">binarySearch</A> </B>(T[]&nbsp;a,
             T&nbsp;key,
             <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 오브젝트를 검색합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepEquals(java.lang.Object[], java.lang.Object[])">deepEquals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a1,
           <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 개의 지정된 배열이 서로 「심층에서 등가」인 경우,<tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])">deepHashCode</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 「심층 내용」에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])">deepToString</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 「심층 내용」의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(boolean[], boolean[])">equals</A> </B>(boolean[]&nbsp;a,
       boolean[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 boolean 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(byte[], byte[])">equals</A> </B>(byte[]&nbsp;a,
       byte[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 byte 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(char[], char[])">equals</A> </B>(char[]&nbsp;a,
       char[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 char 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(double[], double[])">equals</A> </B>(double[]&nbsp;a,
       double[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 double 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(float[], float[])">equals</A> </B>(float[]&nbsp;a,
       float[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 float 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(int[], int[])">equals</A> </B>(int[]&nbsp;a,
       int[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 int 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(long[], long[])">equals</A> </B>(long[]&nbsp;a,
       long[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 long 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
       <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 Object
 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#equals(short[], short[])">equals</A> </B>(short[]&nbsp;a,
       short[]&nbsp;a2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 2 개의 short 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], boolean)">fill</A> </B>(boolean[]&nbsp;a,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 boolean 치의 배열의 각 요소에
 지정된 boolean 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(boolean[], int, int, boolean)">fill</A> </B>(boolean[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 boolean 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], byte)">fill</A> </B>(byte[]&nbsp;a,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열의 각 요소에
 지정된 byte 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(byte[], int, int, byte)">fill</A> </B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     byte&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 byte 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], char)">fill</A> </B>(char[]&nbsp;a,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 치의 배열의 각 요소에
 지정된 char 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(char[], int, int, char)">fill</A> </B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 char 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], double)">fill</A> </B>(double[]&nbsp;a,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열의 각 요소에
 지정된 double 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(double[], int, int, double)">fill</A> </B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 double 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], float)">fill</A> </B>(float[]&nbsp;a,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열의 각 요소에
 지정된 float 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(float[], int, int, float)">fill</A> </B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 float 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int)">fill</A> </B>(int[]&nbsp;a,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열의 각 요소에
 지정된 int 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(int[], int, int, int)">fill</A> </B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 int 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], int, int, long)">fill</A> </B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;long 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 long 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(long[], long)">fill</A> </B>(long[]&nbsp;a,
     long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열의 각 요소에
 지정된 long 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], int, int, java.lang.Object)">fill</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Object
 배열로 지정된 범위에 있는 각 요소에
 지정된 Object 참조를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(java.lang.Object[], java.lang.Object)">fill</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Object
 배열의 각 요소에
 지정된 Object 참조를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], int, int, short)">fill</A> </B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;short 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 short 치를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#fill(short[], short)">fill</A> </B>(short[]&nbsp;a,
     short&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열의 각 요소에
 지정된 short 치를 대입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(boolean[])">hashCode</A> </B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(byte[])">hashCode</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(char[])">hashCode</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(double[])">hashCode</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(float[])">hashCode</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(int[])">hashCode</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(long[])">hashCode</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])">hashCode</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#hashCode(short[])">hashCode</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[])">sort</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(byte[], int, int)">sort</A> </B>(byte[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[])">sort</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(char[], int, int)">sort</A> </B>(char[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 char 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[])">sort</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(double[], int, int)">sort</A> </B>(double[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 double 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[])">sort</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(float[], int, int)">sort</A> </B>(float[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 float 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[])">sort</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(int[], int, int)">sort</A> </B>(int[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 int 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[])">sort</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(long[], int, int)">sort</A> </B>(long[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 long 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])">sort</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 「자연 순서 붙이고」에 따라, 지정된 오브젝트의 배열을 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(java.lang.Object[], int, int)">sort</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;요소의 「자연 순서 붙이고」에 따라, 지정된 오브젝트의 배열의 지정된 범위를 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[])">sort</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(short[], int, int)">sort</A> </B>(short[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 short 치의 배열을 수치의 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)">sort</A> </B>(T[]&nbsp;a,
     <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 콤퍼레이터가 가리키는 순서에 따라, 지정된 오브젝트의 배열을 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" SUMMARY="">
<TR ALIGN="right" VALIGN="">
<TD NOWRAP><FONT SIZE="-1">
<CODE>&lt;T&gt; void</CODE></FONT></TD>
</TR>
</TABLE>
</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#sort(T[], int, int, java.util.Comparator)">sort</A> </B>(T[]&nbsp;a,
     int&nbsp;fromIndex,
     int&nbsp;toIndex,
     <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 콤퍼레이터의 차례에 따라서, 지정된 오브젝트의 배열의 지정 범위를 승순으로 소트 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(boolean[])">toString</A> </B>(boolean[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(byte[])">toString</A> </B>(byte[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(char[])">toString</A> </B>(char[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(double[])">toString</A> </B>(double[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(float[])">toString</A> </B>(float[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(int[])">toString</A> </B>(int[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(long[])">toString</A> </B>(long[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])">toString</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Arrays.html#toString(short[])">toString</A> </B>(short[]&nbsp;a)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="sort(long[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 long 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(long[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 long 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다. (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 하늘입니다. )

<p>소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 int 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(int[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 int 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다. (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 하늘입니다. )<p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 short 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 short 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다). <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 char 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(char[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 char 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다). <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. 소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(byte[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 byte 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다). <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 double 치의 배열을 수치의 승순으로 소트 합니다.
 <p>
<code>&lt;</code>
 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0 == 0.0</code> 은 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서, 이 메서드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에
<A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0</code> 이 <code>0.0</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보여지는 점으로써, 이 순서부는
<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서, 모든 NaN 치는 등가라고 보여집니다.
 <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(double[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 double 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다).
 <p>
<code>&lt;</code>
 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0 == 0.0</code> 은 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서, 이 메서드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에
<A HREF="../../java/lang/Double.html#compareTo(java.lang.Double)"><CODE>Double.compareTo(java.lang.Double)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0</code> 이 <code>0.0</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보여지는 점으로써, 이 순서부는
<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서, 모든 NaN 치는 등가라고 보여집니다.
 <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 float 치의 배열을 수치의 승순으로 소트 합니다.
 <p>
<code>&lt;</code>
 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0f == 0.0f</code>는
 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서, 이 메서드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에
<A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0f</code> 가 <code>0.0f</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보여지는 점으로써, 이 순서부는
<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서, 모든 NaN 치는 등가라고 보여집니다.
 <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열</DL>
</DD>
</DL>
<HR>

<A NAME="sort(float[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>지정된 float 치의 배열을 수치의 승순으로 소트 합니다. 소트 되는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다).
 <p>
<code>&lt;</code>
 릴레이션은, 모든 부동 소수점치에 관한 전체 순서부를 제공하지 않습니다. 이 부동 소수점치는 절대치가 다른 수치입니다만,<code>-0. 0f == 0.0f</code>는
 <code>true</code> 이며, NaN 치는 모든 부동 소수점치나 그 자체와 비교해도, 그것 이하에서도 이상에서도 등치이기도 하지 않습니다. 소트를 진행시키기 위해서, 이 메서드는 수치의 승순을 확정하는 <code>&lt;</code> 릴레이션을 사용하는 대신에
<A HREF="../../java/lang/Float.html#compareTo(java.lang.Float)"><CODE>Float.compareTo(java.lang.Float)</CODE></A>  가 실시하는 전체 순서부를 사용합니다. <code>-0. 0f</code> 가 <code>0.0f</code> 미만으로서 다루어져 NaN 가 다른 부동 소수점치보다 크다고 보여지는 점으로써, 이 순서부는
<code>&lt;</code> 릴레이션과는 다릅니다. 소트를 실시하기 위해서, 모든 NaN 치는 등가라고 보여집니다.
 <p>
소트 알고리즘은 조정된 퀵 소트로 「Software-Practice and Experience, Vol.  23(11)」(1993 년 11 월)의 1249 ~ 1265 페이지의 Jon L.  Bentley 와 M.  Douglas McIlroy 에
한 「Engineering a Sort Function」라고 하는 기사로부터 응용한 것입니다. 이 알고리즘은, 다른 퀵 소트 알고리즘에서는 n
 제곱의 퍼포먼스에 저하시키는 많은 데이터 세트에 대해, n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[])"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>요소의 「자연 순서 붙이고」에 따라, 지정된 오브젝트의 배열을 승순으로 소트 합니다. 배열의 모든 요소는
<tt>Comparable</tt> 인터페이스를 구현하고 있을 필요가 있습니다. 또, 배열의 모든 요소는
 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt>
 경우에
<tt>e1.compareTo(e2)</tt> 로 <tt>ClassCastException</tt>를
 Throw 해야 하지는 않습니다. <p>
이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>
소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는
 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 배열에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object[], int, int)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static void <B>sort</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex)</PRE>
<DL>
<DD>요소의 「자연 순서 붙이고」에 따라, 지정된 오브젝트의 배열의 지정된 범위를 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다). 이 범위의 모든 요소는
<tt>Comparable</tt> 인터페이스를 구현하고 있을 필요가 있습니다. 또, 범위의 모든 요소는
 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt>
 경우에
<tt>e1.compareTo(e2)</tt> 로 <tt>ClassCastException</tt>를
 Throw 해야 하지는 않습니다. <p>
이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>
소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는
 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 배열에 「서로 비교 가능」이 아닌 요소 (예를 들어, 캐릭터 라인과 정수)가 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object,java.util.Comparator)"><!-- --></A> <A NAME="sort(T[], java.util.Comparator)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 콤퍼레이터가 가리키는 순서에 따라, 지정된 오브젝트의 배열을 소트 합니다. 배열의 모든 요소는
 지정된 콤퍼레이터로 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt>
 경우,<tt>c.compare(e1, e2)</tt> 로 <tt>ClassCastException</tt>를
 Throw 해야 하지는 않습니다. <p>
이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>
소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는
 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>c</CODE> - 배열의 순서를 결정하는 콤퍼레이터. <tt>null</tt> 치는
 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 콤퍼레이터로 「서로 비교」할 수 없는 요소가 배열에 있는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스"><CODE>Comparator</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sort(java.lang.Object,int,int,java.util.Comparator)"><!-- --></A> <A NAME="sort(T[], int, int, java.util.Comparator)"><!-- --></A> <H3>
sort</H3>
<PRE>
public static &lt;T&gt; void <B>sort</B>(T[]&nbsp;a,
                            int&nbsp;fromIndex,
                            int&nbsp;toIndex,
                            <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>지정된 콤퍼레이터의 차례에 따라서, 지정된 오브젝트의 배열의 지정 범위를 승순으로 소트 합니다. 소트 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 인덱스 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 소트 범위는 비운다). 이 범위의 모든 요소는
 지정된 콤퍼레이터로 「서로 비교 가능」이 아니면 안됩니다. 즉, 배열의 요소가 <tt>e1</tt> 및 <tt>e2</tt>
 경우,<tt>c.compare(e1, e2)</tt> 로 <tt>ClassCastException</tt>를
 Throw 해야 하지는 않습니다. <p>
이 소트는 고정인 것이 보증되고 있습니다. 즉, 소트를 실행해도, 동등의 요소의 순서는 바뀌지 않습니다. <p>
소트 알고리즘은 수정 머지 소트입니다. 이 소트에서는
 하위의 사브리 파업에 있어서의 최고 레벨의 요소가 상위의 사브리 파업에 있어서의 최저 레벨의 요소보다 작은 경우, 머지는 생략 됩니다. 이 알고리즘은, 항상 n*log(n)의 퍼포먼스를 제공합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 소트 되는 배열<DD><CODE>fromIndex</CODE> - 소트 되는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 소트 되는 마지막 요소 (범위외)의 인덱스<DD><CODE>c</CODE> - 배열의 순서를 결정하는 콤퍼레이터. <tt>null</tt> 치는
 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 콤퍼레이터로 「서로 비교」할 수 없는 요소가 배열에 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Comparator.html" title="java.util 내의 인터페이스"><CODE>Comparator</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(long[], long)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(long[]&nbsp;a,
                               long&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 long 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(long[])"><CODE>sort(long[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(int[], int)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(int[]&nbsp;a,
                               int&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 int 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(int[])"><CODE>sort(int[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(short[], short)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(short[]&nbsp;a,
                               short&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 short 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(short[])"><CODE>sort(short[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(char[], char)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(char[]&nbsp;a,
                               char&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 char 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(char[])"><CODE>sort(char[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(byte[], byte)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(byte[]&nbsp;a,
                               byte&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 byte 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(byte[])"><CODE>sort(byte[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(double[], double)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(double[]&nbsp;a,
                               double&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 double 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메서드에서는 모든 NaN 치를 등가라고 봅니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(double[])"><CODE>sort(double[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(float[], float)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(float[]&nbsp;a,
                               float&nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 float 치의 배열로부터 지정된 값을 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>sort</tt> 메서드로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 값을 가지는 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다. 이 메서드에서는 모든 NaN 치를 등가라고 봅니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증되는<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#sort(float[])"><CODE>sort(float[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object[], java.lang.Object)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static int <B>binarySearch</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                               <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;key)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 오브젝트를 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>Sort(Object[])</tt> 로 요소의 「자연 순서 붙이고」에 따라 승순으로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 배열이 서로 비교 가능하지 않은 요소, 예를 들어 캐릭터 라인이나 정수등인 경우, 배열은 그 요소의 자연 순서부에 따라 소트 하지 못하고, 결과는 미정도리입니다. 지정된 오브젝트와 동일한 요소가 배열에 다수 있는 경우에는
 어느 요소가 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 검색 키가 배열의 요소와 동등하지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A>,
 
<A HREF="../../java/util/Arrays.html#sort(java.lang.Object[])"><CODE>sort(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="binarySearch(java.lang.Object,java.lang.Object,java.util.Comparator)"><!-- --></A> <A NAME="binarySearch(T[], T, java.util.Comparator)"><!-- --></A> <H3>
binarySearch</H3>
<PRE>
public static &lt;T&gt; int <B>binarySearch</B>(T[]&nbsp;a,
                                   T&nbsp;key,
                                   <A HREF="../../java/util/Comparator.html" title="java.util 안의 인터페이스">Comparator</A> &lt;?  super T&gt;&nbsp;c)</PRE>
<DL>
<DD>바이너리 서치 알고리즘을 사용해, 지정된 배열로부터 지정된 오브젝트를 검색합니다. 이 메서드를 호출하기 전에
 전술의 <tt>Sort(Object[], Comparator)</tt> 메서드로 지정된 콤퍼레이터에 따라 승순으로 배열을 소트 할 필요가 있습니다. 배열이 소트되어 있지 않은 경우에는
 결과는 미정도리입니다. 지정된 오브젝트와 동등의 요소가 배열에 다수 있는 경우에는
 어떤 것이 검색될까에 대한 보증은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 검색되는 배열<DD><CODE>key</CODE> - 검색되는 값<DD><CODE>c</CODE> - 배열이 순서 붙이고 되는 콤퍼레이터. <tt>null</tt> 치는
 요소의 「자연 순서 붙이고」를 사용하는 것을 나타낸다
<DT><B>반환값:</B><DD>리스트에 검색 키가 있는 경우는 검색 키의 인덱스. 검색 키가 리스트에 없는 경우는 <tt>(-(삽입 포인트) - 1)</tt>. 삽입 포인트란
 리스트로 키가 삽입되는 포인트이다. 즉, 키보다 큰 최초의 요소의 인덱스인가, 리스트의 모든 요소가 지정된 키보다 작은 경우는 <tt>list.size()</tt>. 이것에
해, 키가 발견되었을 경우에만 반환값이 &gt;= 0 이 되는 것이 보증된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassCastException.html" title="java.lang 안의 클래스">ClassCastException</A> </CODE> - 지정된 콤퍼레이터로 「서로 비교 가능」이 아닌 요소가 배열에 포함되어 있는 경우, 혹은 검색 키가 이 콤퍼레이터로 배열의 요소로 서로 비교할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Comparable.html" title="java.lang 내의 인터페이스"><CODE>Comparable</CODE></A>,
 
<A HREF="../../java/util/Arrays.html#sort(T[], java.util.Comparator)"><CODE>sort(Object[], Comparator)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(long[], long[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(long[]&nbsp;a,
                             long[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 long 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(int[], int[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(int[]&nbsp;a,
                             int[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 int 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(short[], short[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(short[]&nbsp;a,
                             short[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 short 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(char[], char[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(char[]&nbsp;a,
                             char[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 char 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(byte[], byte[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(byte[]&nbsp;a,
                             byte[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 byte 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(boolean[], boolean[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(boolean[]&nbsp;a,
                             boolean[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 boolean 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="equals(double[], double[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(double[]&nbsp;a,
                             double[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 double 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
2 개의 double 치 <tt>d1</tt> 와 <tt>d2</tt>는

 다음의 경우에 동등이라고 보여집니다.
 
 <pre>
    <tt>new Double(d1). equals(new Double(d2))</tt></pre>
<tt>==</tt> 연산자와 달리, 이 메서드는 <tt>NaN</tt>를
 그것 자신과 동등이라고 봐, 0.0d 로 -0. 0d는
 동등이라고 보지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Double.html#equals(java.lang.Object)"><CODE>Double.equals(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(float[], float[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(float[]&nbsp;a,
                             float[]&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 float 치의 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
다음의 경우에 대해, 2 개의 float 치 <tt>f1</tt> 및 <tt>f2</tt>는
 동등이 됩니다.
 
 <pre>
    <tt>new Float(f1). equals(new Float(f2))</tt></pre>
<tt>==</tt> 연산자와 달리, 이 메서드는 <tt>NaN</tt>를
 그것 자신과 동등이라고 봐, 0.0f 로 -0. 0f는
 동등이라고 보지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Float.html#equals(java.lang.Object)"><CODE>Float.equals(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object[], java.lang.Object[])"><!-- --></A> <H3>
equals</H3>
<PRE>
public static boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                             <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</PRE>
<DL>
<DD>지정된 2 개의 Object
 배열이 서로 동등한 경우에 <tt>true</tt>를
 돌려줍니다. 2 개의 배열이 동등이라고 보여지는 것은, 양쪽 모두의 배열에 같은 수의 요소가 있어, 대응하는 대의 요소가 모두 동등한 경우입니다. <tt>e1</tt> 와 <tt>e2</tt>
 2 개의 오브젝트는
<tt>(e1==null ?  e2==null : e1.equals(e2))</tt>
 경우에 동등이라고 보여집니다. 즉, 같은 순서로 같은 요소가 있는 2 개의 배열은 동등합니다. 또, 2 개의 배열 참조가 <tt>null</tt>
 경우에도 동등이라고 보여집니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], long)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        long&nbsp;val)</PRE>
<DL>
<DD>지정된 long 치의 배열의 각 요소에
 지정된 long 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(long[], int, int, long)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(long[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        long&nbsp;val)</PRE>
<DL>
<DD>long 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 long 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;val)</PRE>
<DL>
<DD>지정된 int 치의 배열의 각 요소에
 지정된 int 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(int[], int, int, int)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(int[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        int&nbsp;val)</PRE>
<DL>
<DD>int 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 int 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], short)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        short&nbsp;val)</PRE>
<DL>
<DD>지정된 short 치의 배열의 각 요소에
 지정된 short 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(short[], int, int, short)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(short[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        short&nbsp;val)</PRE>
<DL>
<DD>short 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 short 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], char)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        char&nbsp;val)</PRE>
<DL>
<DD>지정된 char 치의 배열의 각 요소에
 지정된 char 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(char[], int, int, char)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(char[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        char&nbsp;val)</PRE>
<DL>
<DD>char 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 char 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], byte)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        byte&nbsp;val)</PRE>
<DL>
<DD>지정된 byte 치의 배열의 각 요소에
 지정된 byte 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(byte[], int, int, byte)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(byte[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        byte&nbsp;val)</PRE>
<DL>
<DD>byte 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 byte 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], boolean)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>지정된 boolean 치의 배열의 각 요소에
 지정된 boolean 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(boolean[], int, int, boolean)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(boolean[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        boolean&nbsp;val)</PRE>
<DL>
<DD>boolean 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 boolean 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], double)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        double&nbsp;val)</PRE>
<DL>
<DD>지정된 double 치의 배열의 각 요소에
 지정된 double 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(double[], int, int, double)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(double[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        double&nbsp;val)</PRE>
<DL>
<DD>double 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 double 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], float)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        float&nbsp;val)</PRE>
<DL>
<DD>지정된 float 치의 배열의 각 요소에
 지정된 float 치를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(float[], int, int, float)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(float[]&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        float&nbsp;val)</PRE>
<DL>
<DD>float 치로 지정된 배열 안에서, 지정된 범위에 있는 각 요소에
 지정된 float 치를 할당합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], java.lang.Object)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</PRE>
<DL>
<DD>지정된 Object
 배열의 각 요소에
 지정된 Object 참조를 대입합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값</DL>
</DD>
</DL>
<HR>

<A NAME="fill(java.lang.Object[], int, int, java.lang.Object)"><!-- --></A> <H3>
fill</H3>
<PRE>
public static void <B>fill</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a,
                        int&nbsp;fromIndex,
                        int&nbsp;toIndex,
                        <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;val)</PRE>
<DL>
<DD>지정된 Object
 배열로 지정된 범위에 있는 각 요소에
 지정된 Object 참조를 대입합니다. 값을 대입하는 범위는 인덱스 <tt>fromIndex</tt> (범위내)로부터 <tt>toIndex</tt> (범위외)가 됩니다 (<tt>fromIndex==toIndex</tt>
 경우, 대입하는 범위는 비운다).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 치를 대입하는 배열<DD><CODE>fromIndex</CODE> - 지정된 값을 대입하는 최초의 요소 (범위내)의 인덱스<DD><CODE>toIndex</CODE> - 지정된 값을 대입하는 마지막 요소 (범위외)의 인덱스<DD><CODE>val</CODE> - 배열의 모든 요소에 포함하는 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>fromIndex &gt; toIndex</tt>
 경우
<DD><CODE><A HREF="../../java/lang/ArrayIndexOutOfBoundsException.html" title="java.lang 안의 클래스">ArrayIndexOutOfBoundsException</A> </CODE> - <tt>fromIndex &lt; 0</tt> 또는 <tt>toIndex &gt; a.length</tt>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="asList(java.lang.Object)"><!-- --></A> <A NAME="asList(T...)"><!-- --></A> <H3>
asList</H3>
<PRE>
public static &lt;T&gt; <A HREF="../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;T&gt; <B>asList</B>(T...&nbsp;a)</PRE>
<DL>
<DD>지정된 배열을 기본으로 하는 고정 사이즈의 리스트를 돌려줍니다. 돌려주고진 리스트에의 변경은, 그대로 배열에 기입해집니다. 이 메서드는
<tt>Collection.toArray</tt> 와 조합하는 것으로 배열 베이스의 API 와 컬렉션 베이스의 API
 중개역으로서 기능합니다. 또, 돌려주고지는 리스트는 직렬화 가능해,<A HREF="../../java/util/RandomAccess.html" title="java.util 안의 인터페이스"><CODE>RandomAccess</CODE></A> 를
 구현합니다.

<p>이 메서드는
 다음의 여러종류의 요소를 포함하도록 초기화하는 고정 사이즈의 리스트를 작성하기 위한 편리한 방법도 제공합니다.
 
 <pre>

     List<String> stooges = Arrays.asList("Larry", "Moe", "Curly");
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 리스트의 기가 되는 배열
<DT><B>반환값:</B><DD>지정된 배열의 리스트 표시<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Collection.html#toArray()"><CODE>Collection.toArray()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(long[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>long</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Long.html" title="java.lang 동안의 클래스"><CODE>Long</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(int[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 null 이외의 <tt>int</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Integer.html" title="java.lang 동안의 클래스"><CODE>Integer</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(short[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>short</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Short.html" title="java.lang 동안의 클래스"><CODE>Short</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(char[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>char</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Character.html" title="java.lang 동안의 클래스"><CODE>Character</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(byte[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>byte</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Byte.html" title="java.lang 동안의 클래스"><CODE>Byte</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(boolean[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>boolean</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Boolean.html" title="java.lang 동안의 클래스"><CODE>Boolean</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(float[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>float</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Float.html" title="java.lang 동안의 클래스"><CODE>Float</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(double[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 2 개의 <tt>double</tt> 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 와 같이 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드가 돌려주는 값은,<tt>a</tt>
 요소를 같은 순서로 표현하는 <A HREF="../../java/lang/Double.html" title="java.lang 동안의 클래스"><CODE>Double</CODE></A>  인스턴스의 순서를 포함한 <A HREF="../../java/util/List.html" title="java.util 동안의 인터페이스"><CODE>List</CODE></A>  에 대해,<A HREF="../../java/util/List.html#hashCode()"><CODE><tt>hashCode</tt></CODE></A>  메서드를 호출해 얻는
 값과 같습니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 해시치를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode(java.lang.Object[])"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public static int <B>hashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용에 근거하는 해시 코드를 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 해시 코드는 내용은 아니고 식별 정보에 근거한 것이 됩니다. 이것에
해, 자신을 요소로서 포함한 배열에 대해서, 이 메서드를 1 개 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 호출하는 것이 가능하게 됩니다.

<p>2 개의 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.equals(a, b)</tt> 라고 표현할 수 있는 경우, 이것을 <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드에
해 돌려주고지는 값은,<tt>a</tt> 가 <tt>null</tt> 인 경우를 제외해,<tt>Arrays.asList(a). hashCode()</tt> 에
해 돌려주고지는 값에 동일해집니다. <tt>a</tt> 가 <tt>null</tt> 인 경우는
<tt>0</tt> 이 돌려주고집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 내용 베이스의 해시 코드를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#deepHashCode(java.lang.Object[])"><CODE>deepHashCode(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepHashCode(java.lang.Object[])"><!-- --></A> <H3>
deepHashCode</H3>
<PRE>
public static int <B>deepHashCode</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 「심층 내용」에 근거하는 해시 코드를 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 해시 코드는 내용 및 그 외 모두에 근거한 것이 됩니다. 이 때문에
 자신을 요소로서 포함한 배열에 대해서, 이 메서드를 1 개 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 호출할 수 없습니다. 이런 종류의 호출 동작은, 정의되고 있지 않습니다.

<p>2 개의 배열 <tt>a</tt> 및 <tt>b</tt>를
 <tt>Arrays.deepEquals(a, b)</tt> 라고 표현할 수 있는 경우, 이것을 <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt> 라고도 표현할 수 있습니다.

<p>이 메서드에
해 돌려주고지는 값의 계산은,<tt>a</tt> 와 같은 요소를 같은 순서로 포함한 리스트에 대한 <A HREF="../../java/util/List.html#hashCode()"><CODE>List.hashCode()</CODE></A>  에
해 돌려주고지는 값의 계산 과 유사합니다. 다만,<tt>a</tt>
 요소 <tt>e</tt> 자신이 배열의 경우, 그 해시 코드의 계산은,<tt>e.hashCode()</tt>를
 호출하는 것이 아니라,<tt>Arrays.hashCode(e)</tt>
 적절한 overload를 호출하는지 (<tt>e</tt> 가 원시적형의 배열인 경우),<tt>Arrays.deepHashCode(e)</tt>를
 재귀적으로 호출하는 (<tt>e</tt> 가 참조형의 배열인 경우)  것에 따라 실행됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 이 메서드는 0을
 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 심층 내용 베이스의 해시 코드를 계산하는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 심층 내용 베이스의 해시 코드<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#hashCode(java.lang.Object[])"><CODE>hashCode(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepEquals(java.lang.Object[], java.lang.Object[])"><!-- --></A> <H3>
deepEquals</H3>
<PRE>
public static boolean <B>deepEquals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a1,
                                 <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a2)</PRE>
<DL>
<DD>2 개의 지정된 배열이 서로 「심층에서 등가」인 경우,<tt>true</tt>를
 돌려줍니다. <A HREF="../../java/util/Arrays.html#equals(long[], long[])"><CODE>(Object[], Object[])</CODE></A>  메서드와는 달라, 이 메서드는 임의의 깊이로 상자로 된 배열에서의 사용에 적절하고 있습니다.

<p>양쪽 모두가 <tt>null</tt> 인 경우, 2 개의 배열 참조는 심층에서 등가이다고 보여집니다. 또, 동수의 요소를 포함한 배열을 참조하는 경우, 2 개의 배열내의 대응하는 요소 페어는 심층에서 등가가 됩니다.

<p><tt>null</tt>
 가능성이 있는 2 개의 요소 <tt>e1</tt> 및 <tt>e2</tt>는

 다음의 조건의 어떤 것인가에 적합하는 경우, 심층에서 같습니다. <ul> <li> <tt>e1</tt> 와 <tt>e2</tt>
 양쪽 모두가 오브젝트 참조형의 배열이며,<tt>Arrays.deepEquals(e1, e2)</tt> 가 true를
 돌려준다<li> <tt>e1</tt> 와 <tt>e2</tt> 가 같은 원시적형의 배열이며,<tt>Arrays.equals(e1, e2)</tt>
 적절한 overload가 true를
 돌려준다<li> <tt>e1 == e2</tt> <li> <tt>e1.equals(e2)</tt> 가 true를
 돌려주는</ul> 이 정의에서는
 임의의 깊이의 <tt>null</tt> 요소가 허용 되는 점에 주의해 주세요.

<p>지정된 배열의 어느 쪽인지로 1 개 또는 복수의 배열 레벨을 개입시켜 직접 또는 간접적으로 자신이 요소로서 포함되는 경우, 이 메서드의 동작은 정의되고 있지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a1</CODE> - 동등한지 어떤지를 판정하는 1 번째의 배열<DD><CODE>a2</CODE> - 동등한지 어떤지를 판정하는 2 번째의 배열
<DT><B>반환값:</B><DD>2 개의 배열이 동등한 경우는 <tt>true</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#equals(java.lang.Object[], java.lang.Object[])"><CODE>equals(Object[], Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString(long[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(long[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(long)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(int[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(int[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(int)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(short[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(short[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(short)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(char[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(char)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(byte[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(byte[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(byte)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(boolean[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(boolean[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(boolean)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(float[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(float[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(float)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(double[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(double[]&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 내용의 캐릭터 라인 표현을 돌려줍니다. 캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
<tt>String.valueOf(double)</tt> 에
해 캐릭터 라인에 변환됩니다. <tt>a</tt> 가 <tt>null</tt>
 경우, 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString(java.lang.Object[])"><!-- --></A> <H3>
toString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 캐릭터 라인 표현을 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우,<tt>Object</tt> 로부터 확장된 <A HREF="../../java/lang/Object.html#toString()"><CODE>Object.toString()</CODE></A>  메서드에
해 배열이 캐릭터 라인에 변환됩니다. <tt>Object</tt> 에는
 내용은 아니고 식별 정보가 기술되고 있습니다.

<p>이 메서드에
해 돌려주고지는 값은,<tt>a</tt> 가 <tt>null</tt> 인 경우를 제외해,<tt>Arrays.asList(a). toString()</tt> 에
해 돌려주고지는 값과 동일해집니다. <tt>a</tt> 가 <tt>null</tt> 인 경우는
 「<tt>null</tt>」가 돌려주고집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#deepToString(java.lang.Object[])"><CODE>deepToString(Object[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="deepToString(java.lang.Object[])"><!-- --></A> <H3>
deepToString</H3>
<PRE>
public static <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>deepToString</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> []&nbsp;a)</PRE>
<DL>
<DD>지정된 배열의 「심층 내용」의 캐릭터 라인 표현을 돌려줍니다. 배열에 요소 이외의 배열이 포함되는 경우, 캐릭터 라인 표현에는 그 내용등이 포함됩니다. 이 메서드는
 다차원 배열의 캐릭터 라인에의 변환용으로 설계되고 있습니다.

<p>캐릭터 라인 표현은, 꺽쇄묶음 ( 「<tt>[]</tt>」)으로 둘러싸인 배열 요소의 리스트로 구성됩니다. 인접하는 요소는
 문자 「<tt>, </tt>」(콤마 및 공백 문자)로 단락지어집니다. 요소는
 그 자체가 배열이 아닌 한 <tt>String.valueOf(Object)</tt> 에
해 캐릭터 라인에 변환됩니다.

<p>요소 <tt>e</tt> 가 원시적형의 배열인 경우,<tt>Arrays.toString(e)</tt>
 적절한 overload를 호출하는 것으로 캐릭터 라인에 변환됩니다. 요소 <tt>e</tt> 가 참조형의 배열인 경우, 이 메서드를 재귀적으로 호출하는 것으로 캐릭터 라인에 변환됩니다.

<p>무한의 재귀를 피하기 때문에
 지정된 배열에 자신이 요소로서 포함되는지, 1 개 또는 복수의 배열 레벨을 포함한
 자신에게로의 간접 참조가 포함되는 경우, 자기 참조는 캐릭터 라인 「<tt>[...]</tt>」에 변환됩니다. 예를 들어, 자신에게로의 참조만을 포함한 배열은, 「<tt>[[...]]</tt>」로서 렌더링 됩니다.

<p>지정된 배열이 <tt>null</tt>
 경우, 이 메서드는 「<tt>null</tt>」를 돌려줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>a</CODE> - 캐릭터 라인 표현을 돌려주는 배열
<DT><B>반환값:</B><DD><tt>a</tt>
 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/Arrays.html#toString(java.lang.Object[])"><CODE>toString(Object[])</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Arrays.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/util/ArrayList.html" title="java.util 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/BitSet.html" title="java.util 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/util/Arrays.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Arrays.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:59:08 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Pattern (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.regex.Pattern class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Pattern (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Pattern.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="java.util.regex 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/regex/Pattern.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.regex</FONT>
<BR>
클래스 Pattern</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.regex.Pattern</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public final class <B>Pattern</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
컴파일 끝난 정규 표현입니다.

<p> 정규 표현은, 캐릭터 라인으로서 지정해, 이 클래스의 인스턴스에 컴파일 할 필요가 있습니다. 생성된 패턴은,<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  오브젝트를 작성하기 위해서 사용됩니다. 이 오브젝트는
 임의<A HREF="../../../java/lang/CharSequence.html" title="java.lang 중의 인터페이스"><CODE><code>문자 순서</code></CODE></A> 곳의 정규 표현을 성냥 할 수 있습니다. 성냥을 실행했을 때 상태는 모두 정규 표현 엔진에 포함됩니다. 이 때문에
 복수의 정규 표현 엔진이 같은 패턴을 공유할 수 있습니다.

<p> 표준적인 calling sequence는
 다음과 같이 됩니다.

 <blockquote>
 <pre>
 Pattern p = Pattern. <A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String)"><CODE>compile</CODE></A> ("a*b");
 Matcher m = p. <A HREF="../../../java/util/regex/Pattern.html#matcher(java.lang.CharSequence)"><CODE>matcher</CODE></A> ("aaaaab");
 boolean b = m. <A HREF="../../../java/util/regex/Matcher.html#matches()"><CODE>matches</CODE></A> ();</pre></blockquote>

<p> 이 클래스에 정의한 <A HREF="../../../java/util/regex/Pattern.html#matches(java.lang.String, java.lang.CharSequence)"><CODE>matches</CODE></A>  메서드를 사용하면, 정규 표현은 한 번 사용하는 것만으로 끝납니다. 이 메서드를 1 회 호출하는 것만으로 표현이 컴파일 되어 입력 순서와의 성냥을 합니다. 다음의 문장은, 전술의 3 개의 문장과 같습니다.
 <blockquote>
 <pre>
 boolean b = Pattern.matches("a*b", "aaaaab");</pre></blockquote>
다만, 성냥을 반복하는 경우는
 컴파일 끝난 패턴을 재이용할 수 없기 때문에
 효율이 저하합니다.

<p> 이 클래스의 인스턴스는 불변이기 때문에
 복수의 thread로 동시에 사용할 수 있습니다. <A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  클래스의 인스턴스는
 복수 thread에서의 동시 사용에 대응하고 있습니다.

<a name="sum"> <h4> 정규 표현 구문의 요약 </h4>
 <table border="0" cellpadding="1" cellspacing="0"  summary="Regular expression constructs, and what they match">
<tr align="left"> <th bgcolor="#CCCCFF" align="left" id="construct">구문</th> <th bgcolor="#CCCCFF" align="left" id="matches">매치 대상</th> </tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="characters">문자</th></tr>
<tr><td valign="top" headers="construct characters"><i>x</i></td> <td headers="matches">문자 <i>x</i></td></tr> <tr><td valign="top" headers="construct characters"><tt>\\</tt></td> <td headers="matches">backslash 문자</td></tr> <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td> <td headers="matches">8 진수 <tt>0</tt><i>n</i>를
 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td> <td headers="matches">8 진수 <tt>0</tt><i>nn</i>를
 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td> <td headers="matches">8 진수 <tt>0</tt><i>mnn</i>를
 가지는 문자 (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3, 0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td> <td headers="matches">16 진수 <tt>0x</tt><i>hh</i>를
 가지는 문자</td></tr> <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td> <td headers="matches">16 진수 <tt>0x</tt><i>hhhh</i>를
 가지는 문자</td></tr> <tr><td valign="top" headers="matches"><tt>\t</tt></td> <td headers="matches">탭 문자 (<tt>'&#92;u0009'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\n</tt></td> <td headers="matches">개행 문자 (<tt>'&#92;u000A'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\r</tt></td> <td headers="matches">왕복대 리턴 문자 (<tt>'&#92;u000D'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\f</tt></td> <td headers="matches">용지 보내 문자 (<tt>'&#92;u000C'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\a</tt></td> <td headers="matches">경고 (벨) 문자 (<tt>'&#92;u0007'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\e</tt></td> <td headers="matches">이스케이프 문자 (<tt>'&#92;u001B'</tt>)</td></tr> <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td> <td headers="matches"><i>x</i> 에 대응하는 제어 문자</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="classes">문자 클래스</th></tr>
<tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td> <td headers="matches"><tt>a</tt>,<tt>b</tt>, 또는 <tt>c</tt> (단순 클래스)</td></tr> <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td> <td headers="matches"><tt>a</tt>,<tt>b</tt>,<tt>c</tt> 이외의 문자 (부정)</td></tr> <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td> <td headers="matches"><tt>a</tt> ~ <tt>z</tt> 또는 <tt>A</tt> ~ <tt>Z</tt> (범위)</td></tr> <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td> <td headers="matches"><tt>a</tt> ~ <tt>d</tt>, 또는 <tt>m</tt> ~ <tt>p</tt>: <tt>[a-dm-p]</tt> (결합)</td></tr> <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td> <td headers="matches"><tt>d</tt>,<tt>e</tt>,<tt>f</tt> (교차)</tr> <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td> <td headers="matches"><tt>b</tt> 와 <tt>c</tt>를
 제외하는 <tt>a</tt> ~ <tt>z</tt>: <tt>[ad-z]</tt> (감산)</td></tr> <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td> <td headers="matches"><tt>m</tt> ~ <tt>p</tt>를
 제외하는 <tt>a</tt> ~ <tt>z</tt>: <tt>[a-lq-z]</tt> (감산)</td></tr> <tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="predef">정의 끝난 문자 클래스</th></tr>
<tr><td valign="top" headers="construct predef"><tt>. </tt></td> <td headers="matches">임의의 문자 (<a href="#lt">줄 끝 기호</a>와 성냥 하는 경우도 있다)</td></tr> <tr><td valign="top" headers="construct predef"><tt>\d</tt></td> <td headers="matches">숫자: <tt>[0-9]</tt></td></tr> <tr><td valign="top" headers="construct predef"><tt>\D</tt></td> <td headers="matches">숫자 이외: <tt>[^0-9]</tt></td></tr> <tr><td valign="top" headers="construct predef"><tt>\s</tt></td> <td headers="matches">공백 문자: <tt>[ \t\n\x0B\f\r]</tt></td></tr> <tr><td valign="top" headers="construct predef"><tt>\S</tt></td> <td headers="matches">비공백 문자: <tt>[^\s]</tt></td></tr> <tr><td valign="top" headers="construct predef"><tt>\w</tt></td> <td headers="matches">단어 구성 문자: <tt>[a-zA-Z_0-9]</tt></td></tr> <tr><td valign="top" headers="construct predef"><tt>\W</tt></td> <td headers="matches">비단어 문자: <tt>[^\w]</tt></td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="posix">POSIX 문자 클래스 (US-ASCII 마셔)<b></b></th></tr>
<tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td> <td headers="matches">소문자의 영문자: <tt>[a-z]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td> <td headers="matches">대문자의 영문자: <tt>[A-Z]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td> <td headers="matches">모든 ASCII 문자: <tt>[\x00-\x7F]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td> <td headers="matches">영문자: <tt>[\p{Lower}\p{Upper}]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td> <td headers="matches">10 진수자: <tt>[0-9]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td> <td headers="matches">영숫자: <tt>[\p{Alpha}\p{Digit}]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td> <td headers="matches">구두점 문자: <tt>! "#$%&'()*+,-. /:;<=>? @[\]^_`{|}~</tt>
 언젠가</td></tr> <!-- <tt>[\! "#\$%&'\(\)\*\+,\-\. /:;\<=\>\? @\[\\\]\^_`\{\|\}~]</tt> <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> --> <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td> <td headers="matches">표시할 수 있는 문자: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td> <td headers="matches">프린트 가능 문자: <tt>[\p{Graph}\x20]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td> <td headers="matches">공백 또는 탭: <tt>[ \t]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td> <td headers="matches">제어 문자: <tt>[\x00-\x1F\x7F]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td> <td headers="matches">16 진수자: <tt>[0-9a-fA-F]</tt></td></tr> <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td> <td headers="matches">공백 문자: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2">java.lang.Character 클래스 (단순한 <a href="#jcc">java 문자 타입</a>)</th></tr>
<tr><td valign="top"><tt>\p{javaLowerCase}</tt></td> <td>java.lang.Character.isLowerCase()와 등가</td></tr> <tr><td valign="top"><tt>\p{javaUpperCase}</tt></td> <td>java.lang.Character.isUpperCase()과 등가</td></tr> <tr><td valign="top"><tt>\p{javaWhitespace}</tt></td> <td>java.lang.Character.isWhitespace()와 등가</td></tr> <tr><td valign="top"><tt>\p{javaMirrored}</tt></td> <td>java.lang.Character.isMirrored()와 등가</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="unicode">Unicode 블록과 카테고리의 클래스</th></tr>
<tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td> <td headers="matches">희랍어 블록의 문자 (단순<a href="#ubc">블록</a>)</td></tr> <tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td> <td headers="matches">대문자 (단순<a href="#ubc">카테고리</a>)</td></tr> <tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td> <td headers="matches">통화 기호</td></tr> <tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td> <td headers="matches">희랍어 블록 이외의 문자 (부정)</td></tr> <tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td> <td headers="matches">대문자 이외의 문자 (감산)</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="bounds">경계 정규 표현 엔진</th></tr>
<tr><td valign="top" headers="construct bounds"><tt>^</tt></td> <td headers="matches">행의 선두</td></tr> <tr><td valign="top" headers="construct bounds"><tt>$</tt></td> <td headers="matches">행의 말미</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td> <td headers="matches">단어 경계</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td> <td headers="matches">비단어 경계</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td> <td headers="matches">입력의 선두</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td> <td headers="matches">전회의 성냥의 말미</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td> <td headers="matches">마지막<a href="#lt">줄 끝 기호</a>가 있는 경우는
 그것을 제외한 입력의 말미</td></tr> <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td> <td headers="matches">입력의 말미</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="greedy">최장 일치 수량자</th></tr>
<tr><td valign="top" headers="construct greedy"><i>X</i><tt>? </tt></td> <td headers="matches"><i>X</i>, 1 또는 0 회</td></tr> <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td> <td headers="matches"><i>X</i>, 0 회 이상</td></tr> <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td> <td headers="matches"><i>X</i>, 1 회 이상</td></tr> <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회</td></tr> <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr> <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="reluc">최단 일치 수량자</th></tr>
<tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td> <td headers="matches"><i>X</i>, 1 또는 0 회</td></tr> <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*? </tt></td> <td headers="matches"><i>X</i>, 0 회 이상</td></tr> <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+? </tt></td> <td headers="matches"><i>X</i>, 1 회 이상</td></tr> <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}? </tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회</td></tr> <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}? </tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr> <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}? </tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="poss">탐욕인 수량자</th></tr>
<tr><td valign="top" headers="construct poss"><i>X</i><tt>? +</tt></td> <td headers="matches"><i>X</i>, 1 또는 0 회</td></tr> <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td> <td headers="matches"><i>X</i>, 0 회 이상</td></tr> <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td> <td headers="matches"><i>X</i>, 1 회 이상</td></tr> <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회</td></tr> <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상</td></tr> <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td> <td headers="matches"><i>X</i>,<i>n</i> 회이상,<i>m</i> 회이하</td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="logical">논리 연산자</th></tr>
<tr><td valign="top" headers="construct logical"><i>XY</i></td> <td headers="matches"><i>X</i>
 직후에 <i>Y</i></td></tr> <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td> <td headers="matches"><i>X</i> 또는 <i>Y</i></td></tr> <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td> <td headers="matches">X,<a href="#cg">상대방 참조를 실시하는 정규 표현 그룹</a> </td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="backref">전방 참조</th></tr>
<tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td> <td valign="bottom" headers="matches">매치한 <i>n</i> 번째의<a href="#cg">상대방 참조를 실시하는 정규 표현 그룹</a> </td></tr>
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="quot">인용</th></tr>
<tr><td valign="top" headers="construct quot"><tt>\</tt></td> <td headers="matches">정규 표현은 아니지만, 다음의 문자를 이스케이프 하는</tt></td></tr> <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td> <td headers="matches">정규 표현은 아니지만,<tt>\E</tt> 까지의 모든 문자를 이스케이프 하는</td></tr> <tr><td valign="top" headers="construct quot"><tt>\E</tt></td> <td headers="matches">정규 표현은 아니지만,<tt>\Q</tt> 로 개시된 인용을 이스케이프 해</td></tr> <!-- Metachars: !$()*+.<>? [\]^{|} -->
<tr><th>&nbsp;</th></tr> <tr align="left"><th colspan="2" id="special">특수한 구문 (상대방 참조를 실시하지 않는다)</th></tr>
<tr><td valign="top" headers="construct special"><tt>(? :</tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>,<a href="#cg">상대방 참조를 실시하지 않는 정규 표현 그룹</a> </td></tr> <tr><td valign="top" headers="construct special"><tt>(? idmsux-idmsux) &nbsp;</tt></td> <td headers="matches">정규 표현은 아니지만, 매치 플래그의 온/오프를 바꾼다</td></tr> <tr><td valign="top" headers="construct special"><tt>(? idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td> <td headers="matches"><i>X</i>, 지정된 플래그를 온/오프로 한<a href="#cg">상대방 참조를 실시하지 않는 정규 표현 그룹</a> </td></tr> <tr><td valign="top" headers="construct special"><tt>(? =</tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>, 폭제로의 긍정 예측</td></tr> <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>, 폭제로의 부정 예측</td></tr> <tr><td valign="top" headers="construct special"><tt>(? &lt;=</tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>, 폭제로의 긍정 후 읽기</td></tr> <tr><td valign="top" headers="construct special"><tt>(? &lt;! </tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>, 폭제로의 부정 후 읽기</td></tr> <tr><td valign="top" headers="construct special"><tt>(? &gt;</tt><i>X</i><tt>)</tt></td> <td headers="matches"><i>X</i>, 독립한<a href="#cg">상대방 참조를 실시하지 않는 정규 표현 그룹</a> </td></tr>
 </table>
 <hr>

<a name="bs"> <h4> backslash, 이스케이프 및 인용 </h4>

<p> backslash 문자 (<tt>'\'</tt>)는
 전술의 겉(표)에 정의되고 있는 구문을 이스케이프 합니다. 또, 지정하지 않았던 경우는
 이스케이프되어 있지 않다고 해석되는 캐릭터 라인을 인용합니다. 예를 들어, 정규 표현 <tt>\\</tt> 은 1 개의 backslash와 성냥 해,<tt>\{</tt>는
 왼쪽 괄호와 성냥 합니다.

<p> 영문자의 전에 backslash를 사용했을 때에
 그 영문자가 이스케이프 구문이 아닌 경우는
 에러가 됩니다. 이러한 패턴은, 정규 표현 언어의 향후의 확장에 예약되고 있습니다. 영문자 이외의 문자의 경우는
 그 문자가 이스케이프 구문에 포함될지 어떨지에 관계없이, backslash를 지정할 수 있습니다.

<p> <a href="http://java.sun.com/docs/books/jls/second_edition/html/">Java 언어 사양</a>에서는
Java 원시 코드의 캐릭터 라인 리터럴에 포함되는 backslash는
<a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#100850">Unicode 이스케이프</a>등의<a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#101089">문자 이스케이프</a>로서 유효하다라고 해석됩니다. 이 때문에
 backslash가 Java 바이트 코드 컴파일러에
해 해석되지 않게 하려면,
 정규 표현을 나타내는 캐릭터 라인 리터럴내에서 backslash를 2 개 계속할 필요가 있습니다. 예를 들어, 캐릭터 라인 리터럴 <tt>"&#92;b"</tt>는

 정규 표현이라고 해석되면, 백 스페이스 1 문자와 성냥 됩니다. 그러나,<tt>"&#92;&#92;b"</tt>는
 단어 경계와 성냥 됩니다. 또, 캐릭터 라인 리터럴 <tt>"&#92;(hello&#92;)"</tt> 은 부당하게 되어, 컴파일시 에러가 발생합니다. 캐릭터 라인 <tt>(hello)</tt> 과 성냥 되려면,
 캐릭터 라인 리터럴 <tt>"&#92;&#92;(hello&#92;&#92;)"</tt>을
 사용할 필요가 있습니다.
<a name="cc"> <h4> 문자 클래스 </h4>
<p> 문자 클래스는
 다른 문자 클래스내로 지정하거나 결합 연산자 (암묵적)나 교차 연산자 (<tt>&amp;&amp;</tt>)를 사용해 작성할 수가 있습니다. 결합 연산자는
 1 개 이상의 오퍼랜드 클래스에 포함되는 모든 문자를 포함한 클래스를 나타냅니다. 교차 연산자는
 2 개의 오퍼랜드 클래스에 포함되는 모든 문자를 포함한 클래스를 나타냅니다.
<p> 문자 클래스 연산자는
 다음의 순서로 우선 순위가 높아집니다.
<blockquote><table border="0" cellpadding="1" cellspacing="0"  summary="Precedence of character class operators."> <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th>         <td>리터럴 이스케이프 &nbsp;&nbsp;&nbsp;&nbsp;</td>      <td><tt>\x</tt></td></tr> <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th>        <td>그룹화</td>          <td><tt>[...]</tt></td></tr> <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th>     <td>범위</td>     <td><tt>a-z</tt></td></tr> <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th>       <td>결합</td>     <td><tt>[a-e][i-u]<tt></td></tr> <tr><th>5&nbsp;&nbsp;&nbsp;&nbsp;</th>         <td>교차</td>     <td><tt>[a-z&&[aeiou]]</tt></td></tr> </table></blockquote>
<p> 실제로는
 다른 메타캐라크타세트는
 문자 클래스의 외부는 아니고 내부에 존재하는 것에 유의해 주세요. 예를 들어, 정규 표현 <tt>. </tt> (은)는
 문자 클래스 내부에서는 그 특수한
미를 잃습니다만, 표현 <tt>-</tt> 은 범위를 나타내는 메타캐라크타가 됩니다.
<a name="lt"> <h4> 줄 끝 기호 </h4>

<p> 「줄 끝 기호」란
 입력 문자 순서의 행의 말미를 지정할 경우에 사용하는
 1 문자 또는 2 문자의 문자 순서입니다. 다음의 문자가 줄 끝 기호로서 인식됩니다. <i></i>
 <ul>
<li> 개행 문자 (<tt>'\n'</tt>)
<li> 직후에 개행 문자가 붙은 왕복대 리턴 문자 (<tt>"\r\n"</tt>)
<li> 단독의 왕복대 리턴 문자 (<tt>'\r'</tt>)
<li> 다음 행 문자 (<tt>'&#92;u0085'</tt>)
<li> 행 단락 문자 (<tt>'&#92;u2028'</tt>)
<li> 단락 단락 문자 (<tt>'&#92;u2029</tt>)
 
</ul>

<p><A HREF="../../../java/util/regex/Pattern.html#UNIX_LINES"><CODE>UNIX_LINES</CODE></A>  모드가 유효한 경우는
 개행 문자만이 줄 끝 기호로서 인식됩니다.

<p> 정규 표현 <tt>. </tt> (은)는
<A HREF="../../../java/util/regex/Pattern.html#DOTALL"><CODE>DOTALL</CODE></A>  플래그가 지정되어 있지 않은 경우, 줄 끝 기호 이외의 모든 문자와 성냥 합니다.

<p> 디폴트에서는
 정규 표현 <tt>^</tt> 및 <tt>$</tt> 하행말 기호를 무시해, 입력 순서 전체의 각각 선두와 말미인 만큼 성냥 합니다. <A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A>  모드가 액티브하게 되면,<tt>^</tt>는
 입력의 선두 및 입력의 말미를 제외한 모든 줄 끝 기호의 후에 성냥 합니다. <A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A>  모드의 경우,<tt>$</tt> 하행말 기호의 직전, 또는 입력 순서의 말미에 성냥 합니다.
<a name="cg"> <h4> 정규 표현 그룹과 상대방 참조 </h4>

<p> 상대방 참조를 실시하는 정규 표현 그룹에는
 왼쪽에서 우측향에 왼쪽환괄호를 세는 것에
해, 번호를 붙일 수 있습니다. 예를 들어, 표현 <tt>((A)(B(C)))</tt>는

 다음의 4 개의 그룹으로 분류됩니다.  </p>

<blockquote><table cellpadding=1 cellspacing=0 summary="Capturing group numberings"> <tr><th>1&nbsp;&nbsp;&nbsp;&nbsp;</th> <td><tt>((A)(B(C)))</tt></td></tr> <tr><th>2&nbsp;&nbsp;&nbsp;&nbsp;</th> <td><tt>(A)</tt></td></tr> <tr><th>3&nbsp;&nbsp;&nbsp;&nbsp;</th> <td><tt>(B(C))</tt></td></tr> <tr><th>4&nbsp;&nbsp;&nbsp;&nbsp;</th> <td><tt>(C)</tt></td></tr> </table></blockquote>

<p> 그룹 0 은, 항상 표현 전체를 나타냅니다.


<p> 상대방 참조를 실시하는 정규 표현 그룹이 이와 같이 분류되고 나서, 입력 순서의 각 부분 순서가 이러한 그룹과 성냥 되어 성냥 할 때마다 부분 순서가 보존됩니다. 정규 표현 그룹의 부분 순서는
 전방 참조로서 표현내에서 나중에 사용할 수 있겠습니다. 또, 매치 조작이 완료하면, 정규 표현 엔진으로부터 꺼낼 수도 있습니다.

<p> 그룹과 입력 순서가 성냥 되면, 그 그룹과 마지막에 성냥 한 부분 순서가 항상 상대방 참조됩니다. 수량자를 지정했을 경우는
 그룹이 한번 더 평가됩니다. 2 번째의 평가가 실패했을 경우에서도, 그 전에 상대방 참조된 값이 있는 경우는
 그 값이 보관 유지됩니다. 예를 들어, 캐릭터 라인 <tt>"aba"</tt>를
 표현 <tt>(a(b)? )+</tt> (와)과 성냥 했을 경우는
 그룹 2 로 설정된 <tt>"b"</tt> 가 보관 유지됩니다. 상대방 참조된 모든 입력은, 각 매치가 시작되기 전에 파기됩니다.

<p> <tt>(? </tt> 그리고 시작되는 그룹은, 순수한 「상대방 참조되지 않는 정규 표현」그룹에서, 텍스트를 상대방 참조하지 않고, 그룹 전체에 카운트 되지 않습니다. <i></i>

<h4> Unicode 서포트 </h4>

<p> 이 클래스는
<a
 href="http://www.unicode.org/reports/tr18/">「Unicode Technical Standard #18: Unicode Regular Expression Guidelines」 (Unicode 테크니컬 스탠다드 No. 18: Unicode 정규 표현 가이드 라인)</a>  및, 릴리스 2.1 「Canonical Equivalents」 (표준 등가)을 참조하십시오.

<p> Java 원시 코드에서는
<tt>&#92;u2014</tt> 등의 Unicode escape sequence는
 「Java 언어 사양」의 <a href="http://java.sun.com/docs/books/jls/second_edition/html/lexical.doc.html#100850"> 3.3</a>  에 근거해 처리됩니다. 이러한 escape sequence는
 정규 표현 파서에
해 직접 구현되기 때문에
 파일 또는 키보드로부터 읽어들인 표현 안에서도 Unicode 이스케이프를 사용할 수 있습니다. 즉, 캐릭터 라인 <tt>"&#92;u2014"</tt> 와 <tt>"\\u2014"</tt>는
 등가가 아닙니다만, 같은 패턴에 컴파일 되어 16 진수 <tt>0x2014</tt>
 문자와 성냥 합니다.

<a name="ubc"> <p>Unicode 블록 및 카테고리는
 Perl 와 같게 <tt>\p</tt> 및 <tt>\P</tt> 구문으로 기술합니다. 입력에 프로퍼티 <i>prop</i> 가 포함되는 경우,<tt>\p{</tt><i>prop</i><tt>}</tt>는
 성냥 합니다만, \P{</tt><i>prop</i><tt>}</tt>는
 성냥 하지 않습니다. 블록에는
<tt>InMongolian</tt> 와 같이, 접두사 <tt>In</tt>를
 지정합니다. 카테고리에는
 접두사 <tt>Is</tt>를
 지정할 수도 있습니다. <tt>\p{L}</tt> 와 <tt>\p{IsL}</tt>는

 Unicode 문자의 카테고리를 나타냅니다. 블록과 카테고리는
 문자 클래스의 내부 및 외부의 어느 쪽에도 사용할 수 있습니다.

<p> 서포트되고 있는 카테고리는
<A HREF="../../../java/lang/Character.html" title="java.lang 안의 클래스"><CODE>Character</CODE></A>  클래스에서 지정된 버젼의 <a href="http://www.unicode.org/unicode/standard/standard.html">The Unicode Standard</a>  에 기재되어 있습니다. 카테고리명에 대해서는
 Unicode 표준에 규준과 정보가 정의되고 있습니다. <code>Pattern</code>
 지원하는
 블록명은,<A HREF="../../../java/lang/Character.UnicodeBlock.html#forName(java.lang.String)"><CODE>UnicodeBlock.forName</CODE></A>  에
해 받아들여져 정의되는 유효한 블록명입니다.

<a name="jcc"> <p><i>methodname</i> 메서드 (비추천의 메서드를 제외하다)인 java.lang.Character boolean 와 같게 기능하는 카테고리는
 지정된 프로퍼티가 이름 <tt>java<i>methodname</i></tt>를
 가지는
 동일한 <tt>\p{</tt><i>prop</i><tt>}</tt> 구문 전체로 사용 가능합니다.
<h4> Perl 5 라는 비교 </h4>

<p><code>Pattern</code> 엔진은, Perl 5 로 같이, 순서 붙이고 된 대체에 대한 종래의 NFA 베이스의 매칭을 실행합니다.

<p> 이 클래스에서 서포트되어 있지 않은 Perl 구문 </p>


 <ul>
<li><p> 조건부 구문 <tt>(? {</tt><i>X</i><tt>})</tt> 및 <tt>(? (</tt><i>조건</i><tt>)</tt><i>X</i><tt>|</tt><i>Y</i><tt>)</tt> </p></li>

<li><p> 매입 코드 구문 <tt>(? {</tt><i>코드</i><tt>})</tt> 및 <tt>(??{</tt><i>코드</i><tt>})</tt></p></li>

<li><p> 매입 코멘트 구문 <tt>(? #코멘트)</tt> </p></li>

<li><p> 프리프로세스 연산 <tt>\l</tt> <tt>&#92;u</tt>,<tt>\L</tt>,<tt>\U</tt>  </p></li>

 
</ul>


<p> 이 클래스에서 서포트되고 있지만, Perl 로 서포트되어 있지 않은 구문 </p>


 <ul>
<li><p> 탐욕인 수량자. 가능한 한 긴 캐릭터 라인과 성냥 한다. 퇴보 (백 트럭) 하면 정규 표현 전체의 성냥이 성공할 때에도, 퇴보 하지 않는다  </p></li>

<li><p> 문자 클래스의 결합과 교차 (<a href="#cc">전술</a>)</p></li>

 
</ul>


<p> Perl 와의 큰 차이점 </p>


 <ul>
<li><p> Perl 에서는
<tt>\1</tt> ~ <tt>\9</tt>는
 항상 전방 참조라고 해석된다. <tt>9</tt>를
 넘는 숫자가 backslash로 이스케이프 되고 있을 때는
 대응하는 수의 부분 패턴이 존재하는 경우, 전방 참조로 간주해진다. 존재하지 않는 경우는
 8 진수의 이스케이프 (가능한 경우)로 간주해진다. 이 클래스에서는
 8 진수의 이스케이프는 항상 제로로 시작된다. <tt>\1</tt> ~ <tt>\9</tt>는

 항상 전방 참조라고 해석된다. 그것보다 큰 숫자는
 정규 표현의 그 개소에 대응하는 수의 부분 패턴이 존재하는 경우는
 전방 참조로 간주해진다. 존재하지 않는 경우는
 그 숫자가 기존의 그룹 번호 이하가 되는지, 1 자리수의 숫자가 될 때까지, 자리수가 줄여진다 </p></li>

<li><p> Perl 에서는
 마지막 성냥이 종료한 장소로부터 성냥의 재개를 요구할 때는
<tt>g</tt> 플래그를 사용한다. 이 기능은,<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 안의 클래스"><CODE>Matcher</CODE></A>  클래스에
해 암묵적으로 제공된다. <A HREF="../../../java/util/regex/Matcher.html#find()"><CODE>find</CODE></A>  메서드를 반복해 호출하면, 정규 표현 엔진이 리셋트 되지 않는 한, 마지막 성냥이 종료한 장소로부터 매치 조작이 재개한다  </p></li>

<li><p> Perl 에서는
 표현의 최상정도에 파묻힌 플래그가 표현 전체에 적용된다. 이 클래스의 매입 플래그는
 파묻힌 장소에 관계없이, 그 개소에서만 유효하게 된다. 플래그가 그룹내에 파묻히고 있는 경우는
 Perl 와 같게 그룹의 최후로 복원된다  </p></li>

<li><p> Perl 에서는
 표현 <tt>*a</tt> 등이 부정한 매치 구문이나 표현 <tt>abc]</tt> 등의 매달려 괄호를 허용 하고 있어, 그것들을 리터럴로 간주한다. 이 클래스에서도 매달려 괄호는 받아들이지만,+,?,
* 등의 매달려 메타캐라크타는 허용 하지 않고, 그것들이 발견되었을 경우는 <A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스"><CODE>PatternSyntaxException</CODE></A> 를
 Throw 한다 </p></li>

 
</ul>



<p> 정규 표현 구문의 동작의 상세한 것에 대하여는
<a href="http://www.oreilly.com/catalog/regex2/">「Mastering Regular Expressions, 2nd Edition」 (Jeffrey E.  F.  Friedl 저, O'Reilly and Associates, 2002 년)</a> 을
 참조하십시오.  </p>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/String.html#split(java.lang.String, int)"><CODE>String.split(String, int)</CODE></A>,
 
<A HREF="../../../java/lang/String.html#split(java.lang.String)"><CODE>String.split(String)</CODE></A>,
 
<A HREF="../../../serialized-form.html#java.util.regex.Pattern">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#CANON_EQ">CANON_EQ</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;표준 등가를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE">CASE_INSENSITIVE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#COMMENTS">COMMENTS</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;패턴내에서 공백과 코멘트를 사용할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#DOTALL">DOTALL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DOTALL 모드를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#LITERAL">LITERAL</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;패턴의 리터럴 구문 분석을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#MULTILINE">MULTILINE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;복수행 모드를 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE">UNICODE_CASE</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#UNIX_LINES">UNIX_LINES</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unix 라인 모드를 유효하게 합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String)">compile</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 정규 표현을 패턴에 컴파일 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#compile(java.lang.String, int)">compile</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
        int&nbsp;flags)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 플래그를 사용해, 지정된 정규 표현을 패턴에 컴파일 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#flags()">flags</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 매치 플래그를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 내의 클래스">Matcher</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#matcher(java.lang.CharSequence)">matcher</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 입력과 이 패턴을 성냥 하는 정규 표현 엔진을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#matches(java.lang.String, java.lang.CharSequence)">matches</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
        <A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 정규 표현을 컴파일 해, 지정된 입력과 그 정규 표현을 성냥 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#pattern()">pattern</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 컴파일원의 정규 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#quote(java.lang.String)">quote</A> </B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 <code>String</code>
 리터럴 패턴 <code>String</code>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence)">split</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 성냥에 근거해, 지정된 입력 순서를 분할합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence, int)">split</A> </B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input,
      int&nbsp;limit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 성냥에 근거해, 지정된 입력 순서를 분할합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/regex/Pattern.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 패턴의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="UNIX_LINES"><!-- --></A> <H3>
UNIX_LINES</H3>
<PRE>
public static final int <B>UNIX_LINES</B></PRE>
<DL>
<DD>Unix 라인 모드를 유효하게 합니다.

<p> 이 모드에서는
<tt>'\n'</tt> 줄 끝 기호 이외는
<tt>. </tt>,<tt>^</tt>,<tt>$</tt>
 동작에서는 인식되지 않습니다.

<p> Unix 라인 모드는
 매입 플래그 표현 <tt>(? d)</tt>를
 사용해 유효하게 할 수도 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.UNIX_LINES">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="CASE_INSENSITIVE"><!-- --></A> <H3>
CASE_INSENSITIVE</H3>
<PRE>
public static final int <B>CASE_INSENSITIVE</B></PRE>
<DL>
<DD>대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다.

<p> 디폴트에서는
 대문자와 소문자를 구별하지 않는 매칭에서는
 US-ASCII 캐릭터셋의 문자만이 성냥 하는 것을 전제로 하고 있습니다. Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 하려면,
<A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE"><CODE>UNICODE_CASE</CODE></A>  플래그를 이 플래그와 조합해 지정합니다.

<p> 대문자와 소문자를 구별하지 않는 매칭은, 매입 플래그 표현 &nbsp;<tt>(? i)</tt>를
 사용해 유효하게 할 수도 있습니다.

<p> 이 플래그를 지정하면, 퍼포먼스가 조금 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.CASE_INSENSITIVE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="COMMENTS"><!-- --></A> <H3>
COMMENTS</H3>
<PRE>
public static final int <B>COMMENTS</B></PRE>
<DL>
<DD>패턴내에서 공백과 코멘트를 사용할 수 있도록 합니다.

<p> 이 모드에서는
 공백은 무시되어<tt>#</tt> 로 시작되는 매입 코멘트는 줄 끝까지 무시됩니다.

<p> 코멘트 모드는
 매입 플래그 표현 &nbsp;<tt>(? x)</tt>를
 사용해 유효하게 할 수도 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.COMMENTS">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="MULTILINE"><!-- --></A> <H3>
MULTILINE</H3>
<PRE>
public static final int <B>MULTILINE</B></PRE>
<DL>
<DD>복수행 모드를 유효하게 합니다.

<p> 복수행 모드에서는
 표현 <tt>^</tt> 과 <tt>$</tt>는

 각각 줄 끝 기호 또는 입력 순서의 말미의 직후 또는 직전에 성냥 합니다. 디폴트에서는
 이러한 표현은 입력 순서 전체의 선두와 말미에만 성냥 합니다.

<p> 복수행 모드는
 매입 플래그 표현 &nbsp;<tt>(? m)</tt>를
 사용해 유효하게 할 수도 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.MULTILINE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="LITERAL"><!-- --></A> <H3>
LITERAL</H3>
<PRE>
public static final int <B>LITERAL</B></PRE>
<DL>
<DD>패턴의 리터럴 구문 분석을 유효하게 합니다.

<p> 이 플래그가 지정되고 있는 경우, 패턴을 지정하는 입력 캐릭터 라인은, 리터럴 문자의 순서로서 처리됩니다. 입력 순서내의 메타캐라크타 또는 escape sequence에
 특별한
미는 부여되지 않습니다.

<p>CASE_INSENSITIVE 및 UNICODE_CASE 플래그를 이 플래그와 함께 사용하면, 매칭에 대한 영향이 유지됩니다. 다른 플래그는 불필요하게 됩니다.

<p> 리터럴 구문 분석을 유효하게하기 위한 매입 플래그 문자는 없습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.LITERAL">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="DOTALL"><!-- --></A> <H3>
DOTALL</H3>
<PRE>
public static final int <B>DOTALL</B></PRE>
<DL>
<DD>DOTALL 모드를 유효하게 합니다.

<p> DOTALL 모드에서는
 표현 <tt>. </tt> 하행말 기호를 포함한 임의의 문자에 성냥 합니다. 디폴트에서는
 이 표현은 줄 끝 기호에 성냥 하지 않습니다.

<p> DOTALL 모드는
 매입 플래그 표현 &nbsp;<tt>(? s)</tt>를
 사용해 유효하게 할 수도 있습니다 (<tt>s</tt>는

 「단일행」모드의 무릎 관절 모닛크에서, Perl 에서는 DOTALL 모드로 불린다).   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.DOTALL">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="UNICODE_CASE"><!-- --></A> <H3>
UNICODE_CASE</H3>
<PRE>
public static final int <B>UNICODE_CASE</B></PRE>
<DL>
<DD>Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭을 유효하게 합니다.

<p> 이 플래그와 <A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><CODE>CASE_INSENSITIVE</CODE></A>  플래그를 동시에 지정했을 경우는
 Unicode 표준에 준거한 대문자와 소문자를 구별하지 않는 매칭을 합니다. 디폴트의 대문자와 소문자를 구별하지 않는 매칭에서는
 US-ASCII 캐릭터셋의 문자만이 성냥 합니다.

<p> Unicode 에 준거한 대문자와 소문자를 구별하지 않는 매칭은, 매입 플래그 표현 &nbsp;<tt>(? u)</tt>를
 사용해 유효하게 할 수도 있습니다.

<p> 이 플래그를 지정하면, 퍼포먼스가 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.UNICODE_CASE">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="CANON_EQ"><!-- --></A> <H3>
CANON_EQ</H3>
<PRE>
public static final int <B>CANON_EQ</B></PRE>
<DL>
<DD>표준 등가를 유효하게 합니다.

<p> 이 플래그를 지정했을 때는
 2 개의 문자의 완전한 표준 분해가 성냥 했을 경우에 한정해, 그러한 문자가 성냥 한다고 보입니다. 예를 들어, 이 플래그를 지정하면, 표현 <tt>"a&#92;u030A"</tt>는
 캐릭터 라인 <tt>"? "</tt> 에 성냥 합니다. 디폴트의 매칭에서는
 표준 등가가 고려되지 않습니다.

<p> 표준 등가를 유효하게하기 위한 매입 플래그 문자는 없습니다.

<p> 이 플래그를 지정하면, 퍼포먼스가 저하하는 경우가 있습니다.   </p>
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#java.util.regex.Pattern.CANON_EQ">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="compile(java.lang.String)"><!-- --></A> <H3>
compile</H3>
<PRE>
public static <A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A>  <B>compile</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex)</PRE>
<DL>
<DD>지정된 정규 표현을 패턴에 컴파일 합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="compile(java.lang.String, int)"><!-- --></A> <H3>
compile</H3>
<PRE>
public static <A HREF="../../../java/util/regex/Pattern.html" title="java.util.regex 내의 클래스">Pattern</A>  <B>compile</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
                              int&nbsp;flags)</PRE>
<DL>
<DD>지정된 플래그를 사용해, 지정된 정규 표현을 패턴에 컴파일 합니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현<DD><CODE>flags</CODE> - 매치 플래그. <A HREF="../../../java/util/regex/Pattern.html#CASE_INSENSITIVE"><CODE>CASE_INSENSITIVE</CODE></A>,
<A HREF="../../../java/util/regex/Pattern.html#MULTILINE"><CODE>MULTILINE</CODE></A>,
<A HREF="../../../java/util/regex/Pattern.html#DOTALL"><CODE>DOTALL</CODE></A>,
<A HREF="../../../java/util/regex/Pattern.html#UNICODE_CASE"><CODE>UNICODE_CASE</CODE></A>,
<A HREF="../../../java/util/regex/Pattern.html#CANON_EQ"><CODE>CANON_EQ</CODE></A> 를
 포함한 비트 마스크
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 정의된 매치 플래그에 대응하지 않는 비트치가 <tt>flags</tt> 로 설정되었을 경우
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="pattern()"><!-- --></A> <H3>
pattern</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>pattern</B>()</PRE>
<DL>
<DD>이 패턴의 컴파일원의 정규 표현을 돌려줍니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴의 컴파일원</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD><p>이 패턴의 캐릭터 라인 표현을 돌려줍니다. 이것은, 이 패턴의 컴파일원의 정규 표현입니다. </p>
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴의 캐릭터 라인 표현<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="matcher(java.lang.CharSequence)"><!-- --></A> <H3>
matcher</H3>
<PRE>
public <A HREF="../../../java/util/regex/Matcher.html" title="java.util.regex 내의 클래스">Matcher</A>  <B>matcher</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>지정된 입력과 이 패턴을 성냥 하는 정규 표현 엔진을 작성합니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 매치되는 문자 순서
<DT><B>반환값:</B><DD>이 패턴의 새로운 정규 표현 엔진</DL>
</DD>
</DL>
<HR>

<A NAME="flags()"><!-- --></A> <H3>
flags</H3>
<PRE>
public int <B>flags</B>()</PRE>
<DL>
<DD>이 패턴의 매치 플래그를 돌려줍니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 패턴이 컴파일 되었을 때에 지정된 매치 플래그</DL>
</DD>
</DL>
<HR>

<A NAME="matches(java.lang.String, java.lang.CharSequence)"><!-- --></A> <H3>
matches</H3>
<PRE>
public static boolean <B>matches</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;regex,
                              <A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>지정된 정규 표현을 컴파일 해, 지정된 입력과 그 정규 표현을 성냥 합니다.

<p> 이 메서드를 다음의 형식에서 호출하면, 상기의 동작을 합니다.

 <blockquote>
 <pre>
 Pattern.matches(regex, input);</pre></blockquote>
상기의 메서드는
 다음의 표현과 같게 동작합니다.
 <blockquote>
 <pre>
 Pattern.compile(regex). matcher(input). matches()</pre></blockquote>

<p> 패턴을 반복해 사용하는 경우는
 그 패턴을 컴파일 해 재이용한 (분)편이, 매회 이 메서드를 호출하는 것보다도 효율적입니다.   </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>regex</CODE> - 컴파일 되는 표현<DD><CODE>input</CODE> - 매치되는 문자 순서
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 안의 클래스">PatternSyntaxException</A> </CODE> - 표현의 구문이 무효인 경우</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.CharSequence, int)"><!-- --></A> <H3>
split</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>split</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input,
                      int&nbsp;limit)</PRE>
<DL>
<DD>이 패턴의 성냥에 근거해, 지정된 입력 순서를 분할합니다.

<p> 이 메서드로부터 돌려주고지는 배열은, 입력 순서의 부분 캐릭터 라인으로 구성됩니다. 이러한 부분 캐릭터 라인은, 이 패턴과 성냥 하는 다른 부분 순서에
해 분할된 캐릭터 라인인가, 입력 순서의 종료에
해 분할된 캐릭터 라인입니다. 배열내의 부분 캐릭터 라인은, 입력 순서내에서 발생한 차례로 줄지어 있습니다. 이 패턴이 입력 순서의 부분 순서에 성냥 하지 않는 경우, 돌려주고지는 배열은 1 개의 요소, 즉 캐릭터 라인 형식의 입력 순서만으로 구성됩니다.

<p> <tt>limit</tt> 파라미터는
 이 패턴의 적용 회수, 즉, 돌려주고지는 배열의 길이를 제어합니다. 제한 <i>n</i> 가 제로보다 큰 경우, 이 패턴은 <i>n</i>&nbsp;-&nbsp;1 회이하의 회수가 적용되어 배열의 길이는 <i>n</i> 이하가 됩니다. 배열의 마지막 엔트리에는
 마지막에 성냥 한 단락 문자 이후의 입력 순서가 모두 포함됩니다. <i>n</i> 가 부의 값의 경우, 이 패턴의 적용 회수와 배열의 길이는 제한되지 않습니다. <i>n</i> 가 제로의 경우, 이 패턴의 적용 회수와 배열의 길이는 제한됩니다만, 후속의 하늘의 캐릭터 라인은 파기됩니다.

<p> 예를 들어, 입력 순서 <tt>"boo:and:foo"</tt>는

 이러한 파라미터에
해 다음과 같이 분할됩니다.
<blockquote><table cellpadding=1 cellspacing=0  summary="Split examples showing regex, limit, and result"> <tr><th><P align="left">정규 표현 &nbsp;&nbsp;&nbsp;&nbsp;<i></i></th> <th><P align="left">제한 &nbsp;&nbsp;&nbsp;&nbsp;<i></i></th> <th><P align="left">결과 &nbsp;&nbsp;&nbsp;&nbsp;<i></i></th></tr> <tr><td align=center>:</td> <td align=center>2</td> <td><tt>{ "boo", "and:foo" }</tt></td></tr> <tr><td align=center>:</td> <td align=center>5</td> <td><tt>{ "boo", "and", "foo" }</tt></td></tr> <tr><td align=center>:</td> <td align=center>-2</td> <td><tt>{ "boo", "and", "foo" }</tt></td></tr> <tr><td align=center>o</td> <td align=center>5</td> <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr> <tr><td align=center>o</td> <td align=center>-2</td> <td><tt>{ "b", "", ":and:f", "", "" }</tt></td></tr> <tr><td align=center>o</td> <td align=center>0</td> <td><tt>{ "b", "", ":and:f" }</tt></td></tr> </table></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 분할되는 문자 순서<DD><CODE>limit</CODE> - 결과의 해 귀의치 (전술대로)
<DT><B>반환값:</B><DD>캐릭터 라인의 배열. 이 패턴의 성냥에 근거해 분할된 입력 순서로부터 작성된다</DL>
</DD>
</DL>
<HR>

<A NAME="split(java.lang.CharSequence)"><!-- --></A> <H3>
split</H3>
<PRE>
public <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> [] <B>split</B>(<A HREF="../../../java/lang/CharSequence.html" title="java.lang 안의 인터페이스">CharSequence</A> &nbsp;input)</PRE>
<DL>
<DD>이 패턴의 성냥에 근거해, 지정된 입력 순서를 분할합니다.

<p> 이 메서드는
 limit 인수를 제로로 해 <A HREF="../../../java/util/regex/Pattern.html#split(java.lang.CharSequence, int)"><CODE>split</CODE></A>  메서드를 호출했을 경우와 같게 입력 순서를 분할합니다. 즉, 돌려주고지는 배열에는 후속의 하늘의 캐릭터 라인은 포함되지 않습니다.  </p>


<p> 예를 들어, 입력 순서 <tt>"boo:and:foo"</tt>는

 이러한 표현에
해 다음과 같이 분할됩니다.
<blockquote><table cellpadding=1 cellspacing=0  summary="Split examples showing regex and result"> <tr><th><P align="left">정규 표현 &nbsp;&nbsp;&nbsp;&nbsp;<i></i></th> <th><P align="left">결과<i></i></th></tr> <tr><td align=center>:</td> <td><tt>{ "boo", "and", "foo" }</tt></td></tr> <tr><td align=center>o</td> <td><tt>{ "b", "", ":and:f" }</tt></td></tr> </table></blockquote>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>input</CODE> - 분할되는 문자 순서
<DT><B>반환값:</B><DD>캐릭터 라인의 배열. 이 패턴의 성냥에 근거해 분할된 입력 순서로부터 작성된다</DL>
</DD>
</DL>
<HR>

<A NAME="quote(java.lang.String)"><!-- --></A> <H3>
quote</H3>
<PRE>
public static <A HREF="../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>quote</B>(<A HREF="../../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;s)</PRE>
<DL>
<DD>지정된 <code>String</code>
 리터럴 패턴 <code>String</code>를
 돌려줍니다.

<p>이 메서드는
 리터럴 패턴인것 같이 캐릭터 라인 <code>s</code> 에 성냥 하는 <code>Pattern</code>
 작성에 사용 가능한 <code>String</code>를
 생성합니다. </p>
 입력 순서내의 메타캐라크타 또는 escape sequence에
 특별한
미는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>s</CODE> - 리터럴화하는 캐릭터 라인
<DT><B>반환값:</B><DD>리터럴 캐릭터 라인 치환<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Pattern.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/regex/MatchResult.html" title="java.util.regex 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/regex/PatternSyntaxException.html" title="java.util.regex 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/regex/Pattern.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Pattern.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

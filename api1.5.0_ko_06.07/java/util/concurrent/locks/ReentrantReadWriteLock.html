<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:59:00 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ReentrantReadWriteLock (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.ReentrantReadWriteLock class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ReentrantReadWriteLock (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 ReentrantReadWriteLock</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.ReentrantReadWriteLock</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A>,
 <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스">ReadWriteLock</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ReentrantReadWriteLock</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A>,
 <A HREF="../../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A>  와 유사한 시멘틱스를 지원하는
 <A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>ReadWriteLock</CODE></A> 
 구현.
<p>이 클래스에는 다음의 프로퍼티가 있습니다.

<ul> <li><b>취득 순서</b>

<p> 이 클래스는
 락 액세스에 대한 리더 또는 라이터의 우선 순서를 규정하지 않습니다. 다만, 이것은 옵션의 「균등」폴리시를 서포트합니다. 균등으로서 구축되었을 경우, thread는 근사의 도착순서 폴리시를 사용해 엔트리로 경합 합니다. 기입 락이 해방되면, 대기 시간의 가장 긴 단일의 라이터에 기입해 락을 할당할 수 있는지, 어느 라이터보다 길게 대기하고 있는 리더가 존재하는 경우는
 리더세트에 읽어들여 락을 할당할 수 있습니다. 불균등으로서 구축되었을 경우는
 엔트리를 잠그는 순서를 도착순서로 할 필요는 없습니다. 어느 경우에도, 리더가 액티브해, 라이터가 락에 들어가는 경우, 그 라이터가 기입해 락을 취득해 해방할 때까지, 후속의 리더에게는 읽어들여 락은 허가되지 않습니다. <li><b>재입가능성</b>
<p>이 락은, 리더와 라이터의 양쪽 모두가,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A> 
 스타일로 읽어들여 또는 기입해 락을 재얻는
 것을 허가합니다. 기입하는 thread의 보관 유지하는 기입 락이 모두 해방될 때까지, 리더는 허가되지 않습니다.
<p>또, 라이터는 읽어들여 락을 취득할 수 있습니다만, 리더가 기입해 락을 취득할 수 없습니다. 다른 어플리케이션의 사이에서는
 read 락하에서 read를 실행하는 메서드에의 호출해 또는 콜백중에 기입해 락이 보관 유지되는 경우, 재입가능성은 유용합니다. 리더가 기입해 락을 취득하려고 해도, 성공하지 않습니다. <li><b>락의 격하</b>
<p>재입가능성을 이용하면, 기입 락을 취득하고 나서 read 락을 취득해, 그 후 기입해 락을 해방한다고 하는 방법으로 기입 락으로부터 읽어들여 락에의 격하가 가능하게 됩니다. 다만, read 락으로부터 기입해 락에의 승격은 할 수 없습니다.
<li><b>락 취득의 인터럽트</b>
<p>read 락과 기입해 락의 양쪽 모두가, 락 취득중의 인터럽트를 서포트합니다.
<li><b><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A> 
 서포트</b>
<p>기입 락의 제공하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  구현은, 기입 락에 관계되어,<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html#newCondition()"><CODE>ReentrantLock.newCondition()</CODE></A> 
 제공하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  구현이 <A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 안의 클래스"><CODE>ReentrantLock</CODE></A>  에 대해서 실행하는 것과 같이 동작합니다. 당연합니다만, 이 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A> 는
 기입해 락에서만 사용할 수 있습니다.
<p>read 락은 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A> 를
 서포트하지 않고,<tt>readLock(). newCondition()</tt> 가 <tt>UnsupportedOperationException</tt>를
 Throw 합니다.
<li><b>인스트르멘테이션</b> 
<P>
 이 클래스는
 락이 보관 유지되는지 경합 하는지를 판별하는 메서드를 서포트합니다. 이러한 메서드는
 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.  
</ul>


<p> 이 클래스의 직렬화는
 빌트인 락과 같게 동작합니다. 직렬화 해제된 락은, 직렬화시 상태에 관계없이, 락 해제 상태가 됩니다.

<p><b>사용례： </b>차의 코드예에서는
 재입가능성을 활용해, 캐쉬의 갱신 후에 락의 격하를 실행하는 방법을 나타냅니다 (간략화하기 위해서 예외 처리는 생략 되고 있다).
 
 <pre>

 class CachedData {
   Object data;
   volatile boolean cacheValid;
   ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

   void processCachedData() {
     rwl.readLock(). lock();
     if (! cacheValid) {
        // upgrade lock manually
        rwl.readLock(). unlock();   // must unlock first to obtain writelock
        rwl.writeLock(). lock();
        if (! cacheValid) { // recheck
          data = ...
          cacheValid = true;
        }
        // downgrade lock
        rwl.readLock(). lock();  // reacquire read without giving up write lock
        rwl.writeLock(). unlock(); // unlock write, still hold read
     }

     use(data);
     rwl.readLock(). unlock();
   }
 }
 </pre>

ReentrantReadWriteLocks를
 사용해, 어떤 종류의 Collections
 사용으로 병행성을 개선할 수 있습니다. 보통
, 이것이 가치가 있는 것은, 컬렉션이 대규모로 되는 것이 예상되어 라이터 thread보다 다수의 리더 thread에
해 액세스 되어 동기에
한 오버헤드를 웃도는 오버헤드를 가지는 조작이 포함되는 경우입니다. 예로서 대규모여, 동시 액세스가 예상되는 TreeMap를
 사용하는 클래스를 이하에 나타냅니다.

 
 <pre>

 class RWDictionary {
    private final Map&lt;String, Data&gt;  m = new TreeMap&lt;String, Data&gt;();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public Data get(String key) {
        r.lock(); try { return m.get(key); } finally { r.unlock(); }
    }
    public String[] allKeys() {
        r.lock(); try { return m.keySet(). toArray(); } finally { r.unlock(); }
    }
    public Data put(String key, Data value) {
        w.lock(); try { return m.put(key, value); } finally { w.unlock(); }
    }
    public void clear() {
        w.lock(); try { m.clear(); } finally { w.unlock(); }
    }
 }
 </pre>
 
<h3>구현상의 주의:</h3>


<p>재입 가능한 기입 락은, 소유자를 본래 정의해서,
 락을 해방할 수 있는 것은 취득한 thread만입니다. 대조적으로 이 구현에서는
 read 락에 소유권이라고 하는 개념은 존재하지 않기 때문에
 read 락을 해방하는 thread가 그것을 얻는
 thread와 같지 않으면 안 된다고 하는 것은 없습니다. 다만, 이 프로퍼티는
 이 클래스의 장래의 구현으로 보관 유지되는 것은 보증되고 있지 않습니다.

<p> 이 락은, 최대 65536
 재귀적 기입 락 및 65536
 read 락을 서포트합니다. 이러한 제한을 넘으려고 하면, 잠그는 메서드로부터 <A HREF="../../../../java/lang/Error.html" title="java.lang 안의 클래스"><CODE>Error</CODE></A>  가 Throw 됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantReadWriteLock">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.ReadLock</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock()"><CODE>readLock()</CODE></A>  메서드에
해 돌려주고지는 락</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.WriteLock</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()"><CODE>writeLock()</CODE></A>  메서드에
해 돌려주고지는 락</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock()">ReentrantReadWriteLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;디폴트의 순서 프로퍼티로 새로운 <tt>ReentrantReadWriteLock</tt>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#ReentrantReadWriteLock(boolean)">ReentrantReadWriteLock</A> </B>(boolean&nbsp;fair)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 균등성 폴리시를 사용해, 새로운 <tt>ReentrantReadWriteLock</tt>를
 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getOwner()">getOwner</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 기입 락을 소유하고 있는 thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedReaderThreads()">getQueuedReaderThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 몇개의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueuedWriterThreads()">getQueuedWriterThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getReadLockCount()">getReadLockCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락용으로 보관 유지되고 있는 read 락의 수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitingThreads(java.util.concurrent.locks.Condition)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWaitQueueLength(java.util.concurrent.locks.Condition)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#getWriteHoldCount()">getWriteHoldCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread에
한, 이 락상의 재입 가능한 기입 보관 유지수를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThread(java.lang.Thread)">hasQueuedThread</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 지정의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;read 락 또는 기입해 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#hasWaiters(java.util.concurrent.locks.Condition)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 기입 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isFair()">isFair</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락으로 균등성이 true 로 설정되어 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLocked()">isWriteLocked</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락이 thread에 보관 유지되고 있는지 어떤지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#isWriteLockedByCurrentThread()">isWriteLockedByCurrentThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 이 기입 락을 보관 유지하고 있는 제발을 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.ReadLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#readLock()">readLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;읽어들여에 사용하는 락을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.WriteLock</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()">writeLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입해에 사용하는 락을 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ReentrantReadWriteLock()"><!-- --></A> <H3>
ReentrantReadWriteLock</H3>
<PRE>
public <B>ReentrantReadWriteLock</B>()</PRE>
<DL>
<DD>디폴트의 순서 프로퍼티로 새로운 <tt>ReentrantReadWriteLock</tt>를
 작성합니다.
<P>
</DL>
<HR>

<A NAME="ReentrantReadWriteLock(boolean)"><!-- --></A> <H3>
ReentrantReadWriteLock</H3>
<PRE>
public <B>ReentrantReadWriteLock</B>(boolean&nbsp;fair)</PRE>
<DL>
<DD>지정된 균등성 폴리시를 사용해, 새로운 <tt>ReentrantReadWriteLock</tt>를
 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>fair</CODE> - 이 락이 균등 순서부 폴리시를 사용하는 경우는 true</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="writeLock()"><!-- --></A> <H3>
writeLock</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.WriteLock</A>  <B>writeLock</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock()">ReadWriteLock</A> </CODE>
 기술: </B></DD>
<DD>기입해에 사용하는 락을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#writeLock()">writeLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>기입해에 사용하는 락</DL>
</DD>
</DL>
<HR>

<A NAME="readLock()"><!-- --></A> <H3>
readLock</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock.ReadLock</A>  <B>readLock</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock()">ReadWriteLock</A> </CODE>
 기술: </B></DD>
<DD>읽어들여에 사용하는 락을 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 내의 인터페이스">ReadWriteLock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html#readLock()">readLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽어들여에 사용하는 락</DL>
</DD>
</DL>
<HR>

<A NAME="isFair()"><!-- --></A> <H3>
isFair</H3>
<PRE>
public final boolean <B>isFair</B>()</PRE>
<DL>
<DD>이 락으로 균등성이 true 로 설정되어 있는 경우는 true를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락으로 균등성이 true 로 설정되어 있는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="getOwner()"><!-- --></A> <H3>
getOwner</H3>
<PRE>
protected <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getOwner</B>()</PRE>
<DL>
<DD>현재 기입 락을 소유하고 있는 thread를 돌려줍니다. 락이 소유되어 있지 않은 경우는 <tt>null</tt>를
 돌려줍니다. 락의 취득을 시도하고 있어 아직 취득하고 있지 않는 thread가 존재하는 경우도, 소유자는 일시적으로 <tt>null</tt> 가 되는 경우가 있습니다. 이 메서드는
 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>소유자. 소유되어 있지 않은 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getReadLockCount()"><!-- --></A> <H3>
getReadLockCount</H3>
<PRE>
public int <B>getReadLockCount</B>()</PRE>
<DL>
<DD>이 락용으로 보관 유지되고 있는 read 락의 수를 조회합니다. 이 메서드는
 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>보관 유지하는 read 락의 수</DL>
</DD>
</DL>
<HR>

<A NAME="isWriteLocked()"><!-- --></A> <H3>
isWriteLocked</H3>
<PRE>
public boolean <B>isWriteLocked</B>()</PRE>
<DL>
<DD>기입 락이 thread에 보관 유지되고 있는지 어떤지를 조회합니다. 이 메서드는
 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>몇개의 thread가 기입해 락을 보관 유지하는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isWriteLockedByCurrentThread()"><!-- --></A> <H3>
isWriteLockedByCurrentThread</H3>
<PRE>
public boolean <B>isWriteLockedByCurrentThread</B>()</PRE>
<DL>
<DD>현재의 thread가 이 기입 락을 보관 유지하고 있는 제발을 조회합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread가 기입해 락을 보관 유지하는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt></DL>
</DD>
</DL>
<HR>

<A NAME="getWriteHoldCount()"><!-- --></A> <H3>
getWriteHoldCount</H3>
<PRE>
public int <B>getWriteHoldCount</B>()</PRE>
<DL>
<DD>현재의 thread에
한, 이 락상의 재입 가능한 기입 보관 유지수를 조회합니다. 라이터 thread는
 락 해제 액션과 일치하지 않는 각 락 액션용의 락을 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread의, 기입 락에 대한 보관 유지수. 현재의 thread가 이 락을 보관 유지하고 있지 않는 경우는 제로</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedWriterThreads()"><!-- --></A> <H3>
getQueuedWriterThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedWriterThreads</B>()</PRE>
<DL>
<DD>기입 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에도 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 결과는 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다. 이 메서드는
 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedReaderThreads()"><!-- --></A> <H3>
getQueuedReaderThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedReaderThreads</B>()</PRE>
<DL>
<DD>read 락의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에도 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 결과는 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다. 이 메서드는
 보다 포괄적인 락 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 때문에
<tt>true</tt> 가 돌려주고져도, 다른 몇개의 thread가 락을 얻는
 것은 보증되고 있지 않습니다. 이 메서드는
 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락의 취득을 대기중의 다른 thread가 존재할 가능성이 있는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThread(java.lang.Thread)"><!-- --></A> <H3>
hasQueuedThread</H3>
<PRE>
public final boolean <B>hasQueuedThread</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 지정의 thread가 존재할지 어떨지를 조회합니다. 취소는 언제라도 발생할 가능성이 있기 때문에
<tt>true</tt> 가 돌려주고져도, 이 thread가 락을 얻는
 것은 보증되고 있지 않습니다. 이 메서드는
 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 넣어지고 있어 이 락을 대기중인 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 취득을 대기중의 thread의 추정수를 돌려줍니다. 이 메서드가 내부의 데이터 구조를 암벽 횡단 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 때문에
 이 값은 추정에 지나지 않습니다. 이 메서드는
 동기의 제어용은 아니고, 시스템 상태를 감시하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>read 락 또는 기입해 락의 몇개의 취득을 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에도 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 결과는 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다. 이 메서드는
 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>이 기입 락에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트는 언제라도 발생할 가능성이 있기 때문에
<tt>true</tt> 가 돌려주고져도, 장래 <tt>signal</tt> 가 thread를 시작시키는 것은 보증되고 있지 않습니다. 이 메서드는
 주로 시스템 상태의 감시에 사용하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>기입 락에 관련지을 수 있었던 지정 상태로 대기중의 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해, 추정수는
 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메서드는
 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.Condition)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
protected <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A> &nbsp;condition)</PRE>
<DL>
<DD>기입 락에 관련지을 수 있었던 지정 상태를 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에도 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다. 이 메서드는
 보다 포괄적인 상태 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 이 락을 보관 유지하고 있지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 락과 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 락 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 「Write locks =」에 이어 재입가능성을 보관 유지하는 기입 락의 수 및 캐릭터 라인 「Read locks =」에 이어 보관 유지되는 read 락의 수가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

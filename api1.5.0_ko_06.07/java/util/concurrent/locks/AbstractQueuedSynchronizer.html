<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:58:59 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
AbstractQueuedSynchronizer (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.AbstractQueuedSynchronizer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AbstractQueuedSynchronizer (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedSynchronizer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 AbstractQueuedSynchronizer</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.AbstractQueuedSynchronizer</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>AbstractQueuedSynchronizer</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
블록 락 및 선입처 방편 (FIFO) 대기 큐에
존하는 관련 동기화 장치 (semaphore, 이벤트등)를 구현하는 체제를 제공합니다. 이 클래스는
 상태 표현을 단일의 원자 <tt>int</tt> 치에
존하는 대부분의 종류의 동기화 장치의 유용한 기반으로서 설계되고 있습니다. 서브 클래스는
 이 상태를 변경하는 protected 메서드를 정의할 필요가 있어, 그 메서드는 취득 또는 해방중의 오브젝트를 사용해 상태의
미를 정의합니다. 이것들이 지정되면, 이 클래스내의 다른 메서드는 모든 큐 및 블록 도구
를 가동시킵니다. 서브 클래스는
 다른 상태 필드를 유지할 수 있습니다만, 동기에 관한 추적을 실시할 수 있는 것은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A>,
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)"><CODE>setState(int)</CODE></A>  및 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)"><CODE>compareAndSetState(int, int)</CODE></A>  메서드를 사용해 조작되어 원자적으로 갱신된 <tt>int</tt> 치 뿐입니다.

<p>서브 클래스는
 public 가 아닌 내부 헬퍼 클래스로서 정의할 필요가 있습니다. 이것은, 그것을 둘러싸는 클래스의 동기 프로퍼티의 구현에 사용됩니다. <tt>AbstractQueuedSynchronizer</tt> 클래스는
 동기 인터페이스를 일절 구현하지 않습니다. 그 대신해, 구상 락 및 관련된 동기화 장치에
해 적당 호출해 public 메서드를 구현할 수 있는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireInterruptibly(int)"><CODE>acquireInterruptibly(int)</CODE></A>  등의 메서드를 정의합니다.  

<p>이 클래스는
 디폴트의 「배타」모드 및 「공유」모드의 언젠가 또는 양쪽 모두를 서포트합니다. 배타 모드로 취득되면, 다른 thread가 취득을 시도해도 성공하지 않습니다. 공유 모드에서는
 복수의 thread에
한 취득이 가능합니다 (다만, 반드시 취득이 성공할 필요가 있는 것은 아니다). 이 클래스는
 공유 모드의 취득이 성공했을 경우, 대기중의 다음의 thread (존재하는 경우)도 취득 가능한가 어떤가를 판별할 필요가 있다고 하는 도구
적인
미를 제외해, 이러한 차이를 「인식」하지 않습니다. 다른 모드로 대기중의 thread는
 같은 FIFO 큐를 공유합니다. 보통
, 구현 서브 클래스는 이러한 모드의 1 개만을 서포트합니다만,<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A>  등에서는 양쪽 모두가 기능하는 것이 가능합니다. 배타 모드 또는 공유 모드만을 지원하는
 서브 클래스는
 사용하지 않는 모드를 지원하는
 메서드를 정의할 필요는 없습니다.

<p>이 클래스는
 배타 모드를 지원하는
 서브 클래스에
해 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  구현으로서 사용 가능한, 상자로 된 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 동안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  클래스를 정의합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()"><CODE>isHeldExclusively()</CODE></A> 는

 이 클래스에 관계되어, 동기가 현재의 thread에 관해서 배타적으로 보관 유지되는지, 현재의 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A>  치를 사용해 불려 간 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)"><CODE>release(int)</CODE></A>  메서드가 이 오브젝트를 완전하게 해방하는지, 이 보존이 끝난 상태치가 지정되면 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquire(int)"><CODE>acquire(int)</CODE></A>  가 최종적으로 이 오브젝트를 이전에 취득된 상태에 복원하는지를 리포트합니다. 그 이외에서는
<tt>AbstractQueuedSynchronizer</tt> 메서드는 이 상태를 작성하지 않기 때문에
 이 제한을 채울 수가 없는 경우는 사용하지 말아 주세요. 당연한 일입니다만,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A> 
 동작은 동기화 장치 구현의 시멘틱스에
존합니다.  
<p> 이 클래스는
 내부 큐의 검증, 파악
 및 감시용 메서드 및 상태 오브젝트용의 유사 메서드를 제공합니다. 이것들은, 필요하게 응해  동기도구
의 <tt>AbstractQueuedSynchronizer</tt>를
 사용해 클래스내에 export 할 수 있습니다.

<p> 이 클래스를 직렬화하면, 기본으로 되는 원자 정수의 보수 상태만이 포함되기 때문에
 직렬화 복원된 오브젝트는 하늘의 thread 큐를 보관 유지합니다. 직렬화 기능을 필요로 하는 보통
의 서브 클래스는
 직렬화 복원시에 이것을 기존의 초기 상태에 복원하는 <tt>readObject</tt> 메서드를 정의합니다.
<h3>사용법</h3>


<p> 이 클래스를 동기화 장치의 베이스로서 사용하려면,
 적용 가능하면 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A>,
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)"><CODE>setState(int)</CODE></A>,
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)"><CODE>compareAndSetState(int, int)</CODE></A> 를
 사용해 동기 상태의 검증이나 변경을 실시하는 것으로 다음의 메서드를 재정의합니다.
<ul> <li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  <li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  <li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  <li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  <li> <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()"><CODE>isHeldExclusively()</CODE></A> 
</ul>

이러한 각 메서드는
 디폴트로 <A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다. 이러한 메서드의 구현은, 내부가 thread 세이프가 아니면 안되어, 또, 일반적으로 짧고 한편 블로킹없이 없으면 안됩니다. 이러한 메서드의 정의는
 이 클래스의 서포트되는 유일한 사용 방법입니다. 다른 메서드는 모두, 개별적으로 변경할 수 없기 때문에
<tt>final</tt> 라고 선언됩니다.

<p> 이 클래스는 내부의 FIFO 큐에 근거한다고는 해도, 자동적으로 FIFO 취득 폴리시가 적용되는 것은 아닙니다. 배타적인 동기의 코어는
 다음의 형식이 됩니다.

<space num=" ">
 <pre>

<space num=" ">Acquire:
<space num="     ">while (! tryAcquire(arg)) {
<space num="        "><em>enqueue thread if it is not already queued</em>;
<space num="        "><em>possibly block current thread</em>;
<space num="     ">}

<space num=" ">Release:
<space num="     ">if (tryRelease(arg))
<space num="        "><em>unblock the first queued thread</em>;
<space num=" "></pre>

(공유 모드도 비슷하지만, cascade 신호가 관계하는 경우가 있다)

<p> 취득의 체크는 큐에 넣어지기 전에 불려 가므로 새롭게 취득되는 thread는
 블록 및 큐에 넣어지는 다른 thread보다 먼저 「화물 운반선 한다」일이 가능합니다. 다만, 필요하면,<tt>tryAcquire</tt> 이나 <tt>tryAcquireShared</tt>를
 정의해, 1 개 이상의 검증 메서드를 내부에서 호출하는 것으로 화물 운반선을 무효로 할 수 있습니다. 특히, 엄밀한 FIFO 락은 <tt>tryAcquire</tt>를
 정의해,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getFirstQueuedThread()"><CODE>getFirstQueuedThread()</CODE></A>  가 현재의 thread를 돌려주지 않는 경우에 즉시 <tt>false</tt>를
 돌려주는 것이 가능합니다. 보통
 바람직한 비엄밀해 편향이 없는 버젼은,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()"><CODE>hasQueuedThreads()</CODE></A>  가 <tt>true</tt>를
 돌려주고,<tt>getFirstQueuedThread</tt> 가 현재의 thread가 아닌 (즉 <tt>getFirstQueuedThread</tt> 가 null 에서도 현재의 thread도 아니다) 경우에게만, 즉시 <tt>false</tt>를
 돌려줄 수가 있습니다. 새로운 바리에이션이 가능합니다.

<p> 보통
, throughput와 스케이라비리티는
 디폴트의 화물 운반선 ( 「탐욕」, 「방폐」, 「호송 회피」라고도 불린다) 스트래터지의 최상정도에 위치합니다. 이것이 편향이 없고, 고갈하지 않는 것은 보증됩니다만, 먼저 큐에 넣어진 thread는
 나중에 큐에 넣어지는 thread보다 전에 재경합이 허가되어 각 재경합은 착신하는 thread에 대해서 성공하는 공평한 기회를 보관 유지합니다. 또, 취득은, 보통
적인
미에서는 「스핀」하지 않습니다만, 블로킹전에 다른 계산에 삽입된 <tt>tryAcquire</tt>
 복수의 호출을 실행 가능합니다. 이것에
해, 배타적인 동기가 단기적으로 보관 유지될 뿐의 경우, 스핀의 혜택의 대부분을 향수할 수 있습니다. 게다가 배타적인 동기가 보관 유지되지 않는 경우에는 거의 부담없이, 그 혜택을 향수할 수 있습니다. 필요하게 응해 「지름길」체크를 가지는 메서드를 얻는
 호출을 앞두고 배치하는 것으로 이 값을 늘릴 수가 있습니다. 이것은, 동기화 장치가 경합 할 가능성이 적은 경우,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasContended()"><CODE>hasContended()</CODE></A>  나 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()"><CODE>hasQueuedThreads()</CODE></A> 를
 사전에 체크하는 등 방법으로 실행할 수 있습니다.

<p> 이 클래스는
 사용 범위를 <tt>int</tt> 상태, 파라미터의 취득과 해방 및 내부 FIFO 대기 큐에
존 가능한 동기화 장치로 한정하는 것으로 효율적으로 확장성의 높은 동기 기반의 일부를 제공합니다. 이것이라도 충분하지 않는 경우,<A HREF="../../../../java/util/concurrent/atomic/package-summary.html"><CODE>atomic</CODE></A>  클래스, 독자적인 커스텀 <A HREF="../../../../java/util/Queue.html" title="java.util 내의 인터페이스"><CODE>Queue</CODE></A>  클래스 및 <A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 안의 클래스"><CODE>LockSupport</CODE></A>  블록 서포트를 사용해, 동기화 장치를 저레벨로부터 구축할 수 있습니다. <h3>사용예</h3>

<p>이하에
 값제로를 사용해 락 해제 상태 및 락 상태를 나타내는 재입 불가능한 상호 배타 락 클래스를 나타냅니다. 이것은, 상태의 서포트 및 몇개의 파악
 메서드의 공개도 실시합니다.

<space num=" ">
 <pre>

<space num=" ">class Mutex implements Lock, java.io.Serializable {

<space num="    ">// Our internal helper class
<space num="    ">private static class Sync extends AbstractQueuedSynchronizer {
<space num="      ">// Report whether in locked state
<space num="      ">    protected boolean isHeldExclusively() { 
<space num="        ">return getState() == 1; 
<space num="      ">}

<space num="      ">// Acquire the lock if state is zero
<space num="      ">public boolean tryAcquire(int acquires) {
<space num="        ">assert acquires == 1; // Otherwise unused
<space num="        ">return compareAndSetState(0, 1);
<space num="      ">}

<space num="      ">// Release the lock by setting state to zero
<space num="      ">protected boolean tryRelease(int releases) {
<space num="        ">assert releases == 1; // Otherwise unused
<space num="        ">if (getState() == 0) throw new IllegalMonitorStateException();
<space num="        ">setState(0);
<space num="        ">return true;
<space num="      ">}
<space num="       ">
<space num="      ">// Provide a Condition
<space num="      ">Condition newCondition() { return new ConditionObject(); }

<space num="      ">// Deserialize properly
<space num="      ">private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
<space num="        ">s.defaultReadObject();
<space num="        ">setState(0); // reset to unlocked state
<space num="      ">}
<space num="    ">}

<space num="    ">// The sync object does all the hard work.  We just forward to it.
<space num="    ">private final Sync sync = new Sync();

<space num="    ">public void lock()                { sync.acquire(1); }
<space num="    ">public boolean tryLock()          { return sync.tryAcquire(1); }
<space num="    ">public void unlock()              { sync.release(1); }
<space num="    ">public Condition newCondition()   { return sync.newCondition(); }
<space num="    ">public boolean isLocked()         { return sync.isHeldExclusively(); }
<space num="    ">public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }
<space num="    ">public void lockInterruptibly() throws InterruptedException { 
<space num="      ">sync.acquireInterruptibly(1);
<space num="    ">}
<space num="    ">public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException {
<space num="      ">return sync.tryAcquireNanos(1, unit.toNanos(timeout));
<space num="    ">}
<space num=" ">}
<space num=" "></pre>


<p> 이하에
 시작에 단일의 <tt>signal</tt>를
 필요로 하는 것을 제외해,<A HREF="../../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A>  클래스에 유사한 빗장 클래스를 나타냅니다. 빗장은 비배타적이기 때문에
<tt>shared</tt> 취득 및 해방 메서드를 사용합니다.

<space num=" ">
 <pre>

<space num=" ">class BooleanLatch {

<space num="    ">private static class Sync extends AbstractQueuedSynchronizer {
<space num="      ">boolean isSignalled() { return getState() ! = 0; }

<space num="      ">protected int tryAcquireShared(int ignore) {
<space num="        ">return isSignalled()?  1 : -1;
<space num="      ">}
<space num="        ">
<space num="      ">protected boolean tryReleaseShared(int ignore) {
<space num="        ">setState(1);
<space num="        ">return true;
<space num="      ">}
<space num="    ">}

<space num="    ">private final Sync sync = new Sync();
<space num="    ">public boolean isSignalled() { return sync.isSignalled(); }
<space num="    ">public void signal()         { sync.releaseShared(1); }
<space num="    ">public void await() throws InterruptedException {
<space num="      ">sync.acquireSharedInterruptibly(1);
<space num="    ">}
<space num=" ">}

<space num=" "></pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.AbstractQueuedSynchronizer">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Lock</CODE></A>  구현의 기반으로서 기능하는
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer</CODE></A>  상태 구현

 이 클래스의 메서드 문서에는
 Lock 및 Condition 유저로부터 본 동작 사양은 아니고, 내부 도구
가 기재되어 있습니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#AbstractQueuedSynchronizer()">AbstractQueuedSynchronizer</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제로의 초기 동기 상태를 사용해, 새로운 <tt>AbstractQueuedSynchronizer</tt> 인스턴스를 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquire(int)">acquire</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 배타 모드로 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireInterruptibly(int)">acquireInterruptibly</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireShared(int)">acquireShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인터럽트를 무시해, 공유 모드로 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#acquireSharedInterruptibly(int)">acquireSharedInterruptibly</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#compareAndSetState(int, int)">compareAndSetState</A> </B>(int&nbsp;expect,
                   int&nbsp;update)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getExclusiveQueuedThreads()">getExclusiveQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getFirstQueuedThread()">getFirstQueuedThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()">getQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueueLength()">getQueueLength</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getSharedQueuedThreads()">getSharedQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()">getState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 현재가를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">getWaitingThreads</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">getWaitQueueLength</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasContended()">hasContended</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 동기화 장치의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메서드가 블록 되었는지 어떠했는지)를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasQueuedThreads()">hasQueuedThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">hasWaiters</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isHeldExclusively()">isHeldExclusively</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#isQueued(java.lang.Thread)">isQueued</A> </B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread가, 현재, 큐에 넣어지고 있는 경우는 true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)">owns</A> </B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 ConditionObject 가 이 동기화 장치를 락으로서 사용할지 어떨지를 조회합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)">release</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 해방합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#releaseShared(int)">releaseShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 해방합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#setState(int)">setState</A> </B>(int&nbsp;newState)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기 상태의 값을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;동기화 장치 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)">tryAcquire</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireNanos(int, long)">tryAcquireNanos</A> </B>(int&nbsp;arg,
                long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)">tryAcquireShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireSharedNanos(int, long)">tryAcquireSharedNanos</A> </B>(int&nbsp;arg,
                      long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드로 취득을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)">tryRelease</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;배타 모드에서의 해방을 반영하도록, 상태의 설정을 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)">tryReleaseShared</A> </B>(int&nbsp;arg)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;공유 모드에서의 해방을 반영하도록, 상태의 설정을 시도합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="AbstractQueuedSynchronizer()"><!-- --></A> <H3>
AbstractQueuedSynchronizer</H3>
<PRE>
protected <B>AbstractQueuedSynchronizer</B>()</PRE>
<DL>
<DD>제로의 초기 동기 상태를 사용해, 새로운 <tt>AbstractQueuedSynchronizer</tt> 인스턴스를 작성합니다.
<P>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getState()"><!-- --></A> <H3>
getState</H3>
<PRE>
protected final int <B>getState</B>()</PRE>
<DL>
<DD>동기 상태의 현재가를 돌려줍니다. 이 조작은,<tt>volatile</tt> 읽을 메모리세만티크스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="setState(int)"><!-- --></A> <H3>
setState</H3>
<PRE>
protected final void <B>setState</B>(int&nbsp;newState)</PRE>
<DL>
<DD>동기 상태의 값을 설정합니다. 이 조작은,<tt>volatile</tt> 기입의 메모리세만티크스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newState</CODE> - 새로운 상태치</DL>
</DD>
</DL>
<HR>

<A NAME="compareAndSetState(int, int)"><!-- --></A> <H3>
compareAndSetState</H3>
<PRE>
protected final boolean <B>compareAndSetState</B>(int&nbsp;expect,
                                           int&nbsp;update)</PRE>
<DL>
<DD>현재 상태치가 예상되는 값에 동일한 경우, 동기 상태가 지정된 갱신치에 원자적으로 설정합니다. 이 조작은,<tt>volatile</tt> read 및 기입의 메모리세만티크스를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>expect</CODE> - 예상되는 값<DD><CODE>update</CODE> - 새로운 값
<DT><B>반환값:</B><DD>성공하는 경우는 true. false는

 실제의 값이 예상되는 값과 등가가 아닌 것을 나타낸다</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquire(int)"><!-- --></A> <H3>
tryAcquire</H3>
<PRE>
protected boolean <B>tryAcquire</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 취득을 시도합니다. 이 메서드는
 오브젝트가 배타 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 취득합니다.

<p>이 메서드는 항상 취득을 실행하는 thread에
해 불려 갑니다. 이 메서드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메서드는
 다른 thread로부터의 해방에
해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()"><CODE>Lock.tryLock()</CODE></A>  메서드의 구현에 사용할 수 있습니다.

<p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은, 항상 acquire 메서드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다. 그 외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>성공하는 경우는 true. 성공시에는
 이 오브젝트는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에
해, 이 동기화 장치가 부정한 상태에 놓여지는 경우. 동기가 올바르게 기능하기 위해서는
 이 예외를 일관한 방식에서 Throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 서포트되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryRelease(int)"><!-- --></A> <H3>
tryRelease</H3>
<PRE>
protected boolean <B>tryRelease</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드에서의 해방을 반영하도록, 상태의 설정을 시도합니다. <p>이 메서드는
 해방을 실행하는 thread에
해 항상 불려 갑니다.

<p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release
 인수. 이 값은, 항상 release 메서드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다. 그 외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>대기중의 임의의 thread가 취득을 시도할 수가 있도록, 이 오브젝트가 완전하게 해방된 상태에 있는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해방에
해, 이 동기화 장치가 부정한 상태에 놓여지는 경우. 동기가 올바르게 기능하기 위해서는
 이 예외를 일관한 방식에서 Throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 배타 모드가 서포트되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireShared(int)"><!-- --></A> <H3>
tryAcquireShared</H3>
<PRE>
protected int <B>tryAcquireShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 취득을 시도합니다. 이 메서드는
 오브젝트가 공유 모드에서의 취득을 허가하는 상태에 있을지 어떨지를 조회해, 허가하는 상태에 있으면 취득합니다.

<p>이 메서드는 항상 취득을 실행하는 thread에
해 불려 갑니다. 이 메서드가 실패를 리포트해, 한편 thread가 큐에 넣어지지 않은 경우, 취득 메서드는
 다른 thread로부터의 해방에
해 신호가 송신될 때까지 그 thread를 큐에 넣을 수가 있습니다.

<p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은, 항상 acquire 메서드에게 건네지는 값, 또는 상태 대기에의 엔트리로 보존되는 값이 된다. 그 외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>실패했을 경우는 부의 값, 배타적으로 성공했을 경우는 제로 비배타적으로 성공했을 경우는 정의 값. 어느 경우에서도, 후속의 대기 thread는 가용성을 체크할 필요가 있다 (3 개이 다른 반환값의 서포트에
해, 취득만이 때때로 배타적으로 동작하는 컨텍스트
내에서 이 메서드를 사용하는 것이 가능하게 된다). 성공시에는
 이 오브젝트는 취득이 끝난 상태이다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 취득에
해, 이 동기화 장치가 부정한 상태에 놓여지는 경우. 동기가 올바르게 기능하기 위해서는
 이 예외를 일관한 방식에서 Throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 서포트되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryReleaseShared(int)"><!-- --></A> <H3>
tryReleaseShared</H3>
<PRE>
protected boolean <B>tryReleaseShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드에서의 해방을 반영하도록, 상태의 설정을 시도합니다.
<p>이 메서드는
 해방을 실행하는 thread에
해 항상 불려 갑니다.

<p> 디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release
 인수. 이 값은, 항상 release 메서드에게 건네지는 값, 또는 상태 대기에의 엔트리에서의 현재 상태치가 된다. 그 외의 경우, 이 값은 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD>대기중의 임의의 thread가 취득을 시도할 수가 있도록, 이 오브젝트가 완전하게 해방된 상태에 있는 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 해방에
해, 이 동기화 장치가 부정한 상태에 놓여지는 경우. 동기가 올바르게 기능하기 위해서는
 이 예외를 일관한 방식에서 Throw 할 필요가 있다
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 공유 모드가 서포트되어 있지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isHeldExclusively()"><!-- --></A> <H3>
isHeldExclusively</H3>
<PRE>
protected boolean <B>isHeldExclusively</B>()</PRE>
<DL>
<DD>현재의 (호출측의) thread에 관해서, 동기가 배타적으로 행해지는 경우는 true를
 돌려줍니다. 비대기 상태 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 중의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  메서드가 불려 갈 때 마다, 이 메서드가 불려 갑니다 (대기 상태의 메서드에서는 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#release(int)"><CODE>release(int)</CODE></A>  가 불려 간다).
<p>디폴트 구현은,<A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스"><CODE>UnsupportedOperationException</CODE></A> 를
 Throw 합니다. 이 메서드는
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스"><CODE>AbstractQueuedSynchronizer.ConditionObject</CODE></A>  메서드로 내부적에게만 불려 가기 때문에
 상태가 사용되지 않는 경우는 정의할 필요가 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>동기가 배타적으로 행해지는 경우는 true, 그렇지 않은 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 상태가 서포트되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="acquire(int)"><!-- --></A> <H3>
acquire</H3>
<PRE>
public final void <B>acquire</B>(int&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 배타 모드로 취득합니다. 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출합니다. 이 메서드는
<A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()"><CODE>Lock.lock()</CODE></A>  메서드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireInterruptibly(int)"><!-- --></A> <H3>
acquireInterruptibly</H3>
<PRE>
public final void <B>acquireInterruptibly</B>(int&nbsp;arg)
                                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 취득합니다. 인터럽트가 발생했을 경우는
 중지합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출합니다. 이 메서드는
<A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()"><CODE>Lock.lockInterruptibly()</CODE></A>  메서드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireNanos(int, long)"><!-- --></A> <H3>
tryAcquireNanos</H3>
<PRE>
public final boolean <B>tryAcquireNanos</B>(int&nbsp;arg,
                                     long&nbsp;nanosTimeout)
                              throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>배타 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A> 를
 호출합니다. 이 메서드는
<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>Lock.tryLock(long, TimeUnit)</CODE></A>  메서드의 구현에 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquire(int)"><CODE>tryAcquire(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 true, 타임 아웃 했을 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="release(int)"><!-- --></A> <H3>
release</H3>
<PRE>
public final boolean <B>release</B>(int&nbsp;arg)</PRE>
<DL>
<DD>배타 모드로 해방합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  가 true를
 돌려주는 경우, 1 개 이상의 thread를 블록 해제하는 것으로 구현됩니다. 이 메서드는
<A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()"><CODE>Lock.unlock()</CODE></A>  메서드의 구현으로 사용할 수 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryRelease(int)"><CODE>tryRelease(int)</CODE></A>  로부터 돌려주고지는 값</DL>
</DD>
</DL>
<HR>

<A NAME="acquireShared(int)"><!-- --></A> <H3>
acquireShared</H3>
<PRE>
public final void <B>acquireShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>인터럽트를 무시해, 공유 모드로 취득합니다. 최초로 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다</DL>
</DD>
</DL>
<HR>

<A NAME="acquireSharedInterruptibly(int)"><!-- --></A> <H3>
acquireSharedInterruptibly</H3>
<PRE>
public final void <B>acquireSharedInterruptibly</B>(int&nbsp;arg)
                                      throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 취득합니다. 인터럽트가 발생했을 경우에는 중지합니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공할까 thread로 인터럽트가 발생할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="tryAcquireSharedNanos(int, long)"><!-- --></A> <H3>
tryAcquireSharedNanos</H3>
<PRE>
public final boolean <B>tryAcquireSharedNanos</B>(int&nbsp;arg,
                                           long&nbsp;nanosTimeout)
                                    throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>공유 모드로 취득을 시도합니다. 인터럽트가 발생했을 경우는 중지해, 지정된 타임 아웃 시간이 경과했을 경우는 실패합니다. 최초로 끼어들어 상태를 체크하고 나서, 한 번 이상 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출하는 것으로 구현되어 성공시에 복귀합니다. 그 외의 경우, thread는 큐에 넣어져 대체로의 경우 블록 및 블록 해제를 몇번이나 반복해, 성공하는지, thread로 인터럽트가 발생하는지, 타임 아웃 시간이 경과할 때까지 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A> 를
 호출합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - acquire
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryAcquireShared(int)"><CODE>tryAcquireShared(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있는<DD><CODE>nanosTimeout</CODE> - 대기하는 최대 나노초수
<DT><B>반환값:</B><DD>취득했을 경우는 true, 타임 아웃 했을 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="releaseShared(int)"><!-- --></A> <H3>
releaseShared</H3>
<PRE>
public final boolean <B>releaseShared</B>(int&nbsp;arg)</PRE>
<DL>
<DD>공유 모드로 해방합니다. <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  가 true를
 돌려주는 경우, 1 개 이상의 thread를 블록 해제하는 것으로 구현됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>arg</CODE> - release
 인수. 이 값은 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  에 송신되지만, 그 외의 경우는 미해석이 되어, 임의의 값을 나타낼 수가 있다
<DT><B>반환값:</B><DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#tryReleaseShared(int)"><CODE>tryReleaseShared(int)</CODE></A>  로부터 돌려주고지는 값</DL>
</DD>
</DL>
<HR>

<A NAME="hasQueuedThreads()"><!-- --></A> <H3>
hasQueuedThreads</H3>
<PRE>
public final boolean <B>hasQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기중의 thread가 존재할지 어떨지를 조회합니다. 언젠가는 끼어들어 및 타임 아웃에
한 취소가 발생했을 경우,<tt>true</tt> 가 돌려주고져도 다른 thread가 취득을 실행하는 것은 보증되지 않습니다.

<p> 이 구현에서는
 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락의 취득을 대기중의 다른 thread가 존재할 가능성이 있는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="hasContended()"><!-- --></A> <H3>
hasContended</H3>
<PRE>
public final boolean <B>hasContended</B>()</PRE>
<DL>
<DD>이 동기화 장치의 취득으로 경합 하고 있는 thread가 존재할지 어떨지 (즉, acquire 메서드가 블록 되었는지 어떠했는지)를 조회합니다.

<p> 이 구현에서는
 이 조작은 일정한 시간에 복귀합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>경합이 존재하는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="getFirstQueuedThread()"><!-- --></A> <H3>
getFirstQueuedThread</H3>
<PRE>
public final <A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>getFirstQueuedThread</B>()</PRE>
<DL>
<DD>큐내의 최초의 (대기 시간의 가장 길다) thread를 돌려줍니다. 현재 큐에 넣어지고 있는 thread가 존재하지 않는 경우는 <tt>null</tt>를
 돌려줍니다.

<p> 보통
, 이 구현에서는
 이 조작은 일정시간으로 복귀합니다. 다만, 다른 thread가 큐의 변경을 동시에 실행하고 있는 경우는
 경합에
해 처리를 반복하는 경우가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>큐내의 최초의 (대기 시간의 가장 길다) thread. 현재 큐에 넣어지고 있는 thread가 존재하지 않는 경우는 <tt>null</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isQueued(java.lang.Thread)"><!-- --></A> <H3>
isQueued</H3>
<PRE>
public final boolean <B>isQueued</B>(<A HREF="../../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;thread)</PRE>
<DL>
<DD>지정된 thread가, 현재, 큐에 넣어지고 있는 경우는 true를
 돌려줍니다.

<p> 이 구현은, 큐를 암벽 횡단 해 지정된 thread의 존재를 판별합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>thread</CODE> - thread
<DT><B>반환값:</B><DD>지정된 thread가 큐에 존재하는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - thread가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getQueueLength()"><!-- --></A> <H3>
getQueueLength</H3>
<PRE>
public final int <B>getQueueLength</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread의 추정수를 돌려줍니다. 이 메서드가 내부의 데이터 구조를 암벽 횡단 하고 있는 동안에도, thread수가 동적으로 변화하는 경우가 있기 때문에
 이 값은 추정에 지나지 않습니다. 이 메서드는
 동기의 제어용은 아니고, 시스템 상태를 감시하기 위한의 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락을 대기하고 있는 thread의 추정수</DL>
</DD>
</DL>
<HR>

<A NAME="getQueuedThreads()"><!-- --></A> <H3>
getQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getQueuedThreads</B>()</PRE>
<DL>
<DD>취득을 대기하고 있는 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에도 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다. 이 메서드는
 보다 포괄적인 감시 기능을 제공하는 서브 클래스의 구축을 용이하게 하는 목적으로 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getExclusiveQueuedThreads()"><!-- --></A> <H3>
getExclusiveQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getExclusiveQueuedThreads</B>()</PRE>
<DL>
<DD>배타 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 배타적 취득을 위해서 대기중의 thread만을 돌려주는 것을 제외해서는
<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="getSharedQueuedThreads()"><!-- --></A> <H3>
getSharedQueuedThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getSharedQueuedThreads</B>()</PRE>
<DL>
<DD>공유 모드로 취득하기 위해서 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 이것은, 공유적 취득을 위해서 대기중의 thread만을 돌려주는 것을 제외해,<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getQueuedThreads()"><CODE>getQueuedThreads()</CODE></A>  와 같은 프로퍼티를 보관 유지합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 컬렉션</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>동기화 장치 및 그 상태를 식별하는 캐릭터 라인을 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 「State =」에 이어 <A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.html#getState()"><CODE>getState()</CODE></A> 
 현재가 및 큐가 하늘인가 어떤가에 응해 「nonempty」또는 「empty」가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 동기화 장치 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<HR>

<A NAME="owns(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
owns</H3>
<PRE>
public final boolean <B>owns</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>지정된 ConditionObject 가 이 동기화 장치를 락으로서 사용할지 어떨지를 조회합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>소유되는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="hasWaiters(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
hasWaiters</H3>
<PRE>
public final boolean <B>hasWaiters</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread가 존재할지 어떨지를 조회합니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해,<tt>true</tt>는

 장래의 <tt>signal</tt> 가 thread를 시작시키는 것을 보증하지 않습니다. 이 메서드는
 주로 시스템 상태의 감시에 사용하기 위한의 것입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread가 존재하는 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 동기화 장치와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitQueueLength(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitQueueLength</H3>
<PRE>
public final int <B>getWaitQueueLength</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기하고 있는 thread의 추정수를 돌려줍니다. 타임 아웃 및 인터럽트의 발생할 가능성은 언제라도 존재하기 위해, 추정수는
 실제의 대기자수에 관한 상한을 나타내는에 지나지 않습니다. 이 메서드는
 동기의 제어용으로서가 아니고, 시스템 상태의 감시용으로서 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>대기중의 thread의 추정수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 동기화 장치와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getWaitingThreads(java.util.concurrent.locks.AbstractQueuedSynchronizer.ConditionObject)"><!-- --></A> <H3>
getWaitingThreads</H3>
<PRE>
public final <A HREF="../../../../java/util/Collection.html" title="java.util 내의 인터페이스">Collection</A> &lt;<A HREF="../../../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> &gt; <B>getWaitingThreads</B>(<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 안의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> &nbsp;condition)</PRE>
<DL>
<DD>이 동기화 장치에 관련지을 수 있었던 지정 상태로 대기중의 thread를 포함한 컬렉션을 돌려줍니다. 실제의 thread 세트는
 결과의 구축중에 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 컬렉션은 최선이 노력한 다음의 추정에 지나지 않습니다. 돌려주고지는 컬렉션의 요소에는
 특정의 순서는 존재하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>condition</CODE> - 상태
<DT><B>반환값:</B><DD>thread의 컬렉션
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 배타적 동기가 보관 유지되지 않는 경우
<DD><CODE><A HREF="../../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지정된 상태가 이 동기화 장치와 관련지을 수 있지 않은 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 상태가 null
 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AbstractQueuedSynchronizer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;전의 클래스 &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/AbstractQueuedSynchronizer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="AbstractQueuedSynchronizer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

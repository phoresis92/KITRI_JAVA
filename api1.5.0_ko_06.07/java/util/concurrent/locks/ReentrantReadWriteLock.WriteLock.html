<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:59:01 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ReentrantReadWriteLock.WriteLock (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ReentrantReadWriteLock.WriteLock (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.WriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;다음의 클래스</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.WriteLock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
클래스 ReentrantReadWriteLock.WriteLock</H2>
<PRE>
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A>,
 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스">Lock</A> </DD>
</DL>
<DL>
<DT><B>포함되어 있는 클래스:</B><DD><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantReadWriteLock</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public static class <B>ReentrantReadWriteLock.WriteLock</B><DT>extends <A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A>,
 <A HREF="../../../../java/io/Serializable.html" title="java.io 안의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html#writeLock()"><CODE>ReentrantReadWriteLock.writeLock()</CODE></A>  메서드에
해 돌려주고지는 락
<P>

<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../../serialized-form.html#java.util.concurrent.locks.ReentrantReadWriteLock.WriteLock">직렬화 된 형식</A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#ReentrantReadWriteLock.WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock)">ReentrantReadWriteLock.WriteLock</A> </B>(<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock</A> &nbsp;lock)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에
해 사용되는 생성자
입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#lock()">lock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;기입 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#lockInterruptibly()">lockInterruptibly</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>  가 아닌 한, 기입 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#newCondition()">newCondition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Lock</CODE></A>  인스턴스로 사용하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락을 식별하는 캐릭터 라인 및 락 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock()">tryLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호출시에 다른 thread에
해 보관 유지되어 있지 않은 경우에만, 기입 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </B>(long&nbsp;timeout,
        <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 대기 시간내에 다른 thread가 락을 보관 유지하지 않고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하고 있지 않는 경우에
 기입 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#unlock()">unlock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락의 해방을 시도합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ReentrantReadWriteLock.WriteLock(java.util.concurrent.locks.ReentrantReadWriteLock)"><!-- --></A> <H3>
ReentrantReadWriteLock.WriteLock</H3>
<PRE>
protected <B>ReentrantReadWriteLock.WriteLock</B>(<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock</A> &nbsp;lock)</PRE>
<DL>
<DD>서브 클래스에
해 사용되는 생성자
입니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>lock</CODE> - 외부의 락 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 락이 null
 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="lock()"><!-- --></A> <H3>
lock</H3>
<PRE>
public void <B>lock</B>()</PRE>
<DL>
<DD>기입 락을 취득합니다.

<p>read 락 또는 기입해 락의 모두 다른 thread에 보관 유지되어 있지 않은 경우, 기입 락을 취득해 즉시 복귀해, 기입 락의 보관 유지 카운트를 1 으로 설정합니다.

<p>현재의 thread가 기입해 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해, 메서드를 즉시 복귀합니다.

<p>락이 다른 thread에
해 보관 유지되고 있는 경우, 현재의 thread가 thread 스케줄링에 관해서 무효가 되어, 기입 락이 취득될 때까지 대기합니다. 락이 취득되면, 기입 락 보관 유지 카운트가 1 으로 설정됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()">lock</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockInterruptibly()"><!-- --></A> <H3>
lockInterruptibly</H3>
<PRE>
public void <B>lockInterruptibly</B>()
                       throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>  가 아닌 한, 기입 락을 취득합니다.

<p>read 락 또는 기입해 락의 모두 다른 thread에 보관 유지되어 있지 않은 경우, 기입 락을 취득해 즉시 복귀해, 기입 락의 보관 유지 카운트를 1 으로 설정합니다.

<p>현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값을 1 증분 해, 메서드를 즉시 복귀합니다.

<p>락이 다른 thread에
해 보관 유지되고 있는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 2 개중 한쪽이 일어날 때까지 대기합니다.
 <ul>
<li>현재의 thread에
해 기입 락이 취득된다
<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시한다
 
</ul>


<p>기입 락이 현재의 thread에
해 취득되었을 경우, 락 보관 유지 카운트가 1 으로 설정됩니다.

<p>현재의 thread로

 <ul>
<li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,
<li>기입 락의 취득중에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생했을 경우,
 
</ul>

<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 스테이터스가 클리어 됩니다.

<p>이 메서드는 명시적인 끼어들어 포인트이기 때문에
 이 구현에서는
 보통
 또는 재입 가능한 락 취득에의 인터럽트에의 응답에 높은 우선도가 주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()">lockInterruptibly</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="tryLock()"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public boolean <B>tryLock</B>()</PRE>
<DL>
<DD>호출시에 다른 thread에
해 보관 유지되어 있지 않은 경우에만, 기입 락을 취득합니다.

<p>다른 thread에
해 기입 락과 읽어들여 락의 모두 보관 유지되어 있지 않은 경우에 기입해 락을 취득해, 값 <tt>true</tt> 로 즉시 복귀해 락의 보관 유지 카운트를 1 으로 설정합니다. 이 락이 균등 순서부 폴리시를 사용하도록 설정되어 있는 경우에서도, 락이 사용 가능하면, 다른 thread가 현재 기입 락을 대기하고 있을지 어떨지에 관계없이,<tt>tryLock()</tt>
 호출로 곧바로 락이 취득됩니다. 이 「화물 운반선」동작에
해 균등성이 없어진다고는 말할 수 있어 이것은 특정의 상황하로 유용합니다. 이 락의 균등 설정을 존중하는 경우는
 거의 등가인 <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>tryLock(0, TimeUnit.SECONDS)</CODE></A> 를
 사용합니다 (이것도 인터럽트를 검출한다).

<p> 현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값이 1 증분 되어 메서드는 <tt>true</tt>를
 돌려줍니다.

<p>락이 다른 thread에
해 보관 유지되고 있는 경우, 이 메서드는
 값 <tt>false</tt> 로 즉시 복귀합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()">tryLock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>락이 프리로 현재의 thread에
해 취득되었는지, 기입 락이 현재의 thread에
해 취득이 끝난 상태인 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt></DL>
</DD>
</DL>
<HR>

<A NAME="tryLock(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
tryLock</H3>
<PRE>
public boolean <B>tryLock</B>(long&nbsp;timeout,
                       <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>지정된 대기 시간내에 다른 thread가 락을 보관 유지하지 않고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하고 있지 않는 경우에
 기입 락을 취득합니다.

<p>다른 thread가 기입해 락과 읽어들여 락의 모두 보관 유지하고 있지 않는 경우에 기입해 락을 취득해, 값 <tt>true</tt> 로 즉시 복귀해, 락 보관 유지 카운트를 1 으로 설정합니다. 이 락이 균등 순서부 폴리시를 사용하도록 설정되어 있어도, 다른 thread가 기입해 락을 대기하고 있는 경우는
 사용 가능한 락은 취득되지 않습니다. 이것은,<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html#tryLock()"><CODE>tryLock()</CODE></A>  메서드와는 대조적입니다. 균등 락에 대한 화물 운반선을 허가하지 않는
 시간 설정된 <tt>tryLock</tt>를
 사용하는 경우는
 시간 설정과 비시간 설정의 양형식을 조합해 사용합니다.

 
 <pre>
if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }
 </pre>


<p>현재의 thread가 락을 벌써 보관 유지하고 있는 경우, 보관 유지 카운트의 값이 1 증분 되어 메서드는 <tt>true</tt>를
 돌려줍니다.

<p>락이 다른 thread에
해 보관 유지되고 있는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 3 개중 한쪽이 일어날 때까지 대기합니다.
 <ul>
<li>현재의 thread에
해 기입 락이 취득된다
<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시한다     
<li>지정된 대기 시간이 경과한다
 
</ul>


<p>기입 락이 취득되었을 경우, 값 <tt>true</tt> 가 돌려주고져 락 보관 유지 카운트가 1 으로 설정됩니다.

<p>현재의 thread로

 <ul>
<li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,
<li>기입 락의 취득중에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생했을 경우,
 
</ul>
 
<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 스테이터스가 클리어 됩니다.

<p>지정된 대기 시간이 경과하면, 값 <tt>false</tt> 가 돌려주고집니다. 시간이 제로 또는 그것보다 작은 경우, 메서드는 대기하지 않습니다.

<p>이 메서드는 명시적인 끼어들어 포인트이기 때문에
 이 구현에서는
 보통
 또는 재입 가능한 락 취득 및 대기 시간 경과 리포트에의 인터럽트에 대한 응답에 높은 우선도가 주어집니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 기입 락을 대기하는 시간<DD><CODE>unit</CODE> - timeout 인수의 시간 단위
<DT><B>반환값:</B><DD>락이 프리로 현재의 thread에
해 소득되었는지, 기입 락이 현재의 thread에
해 취득이 끝난 상태인 경우는 <tt>true</tt>, 락을 취득하기 전에 대기 시간이 경과했을 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생했을 경우
<DD><CODE><A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 단위가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unlock()"><!-- --></A> <H3>
unlock</H3>
<PRE>
public void <B>unlock</B>()</PRE>
<DL>
<DD>이 락의 해방을 시도합니다.

<p>현재의 thread가 이 락의 홀더인 경우, 보관 유지 카운트의 값이 줄여집니다. 보관 유지 카운트가 제로가 되면, 락이 해방됩니다. 현재의 thread가 이 락의 홀더가 아닌 경우,<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  가 Throw 됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()">unlock</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 락을 보관 유지하지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newCondition()"><!-- --></A> <H3>
newCondition</H3>
<PRE>
public <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A>  <B>newCondition</B>()</PRE>
<DL>
<DD>이 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Lock</CODE></A>  인스턴스로 사용하는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스를 돌려줍니다.
<p>돌려주고지는 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스는
<A HREF="../../../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  감시 메서드 (<A HREF="../../../../java/lang/Object.html#wait()"><CODE>wait</CODE></A>,
<A HREF="../../../../java/lang/Object.html#notify()"><CODE>notify</CODE></A>  및 <A HREF="../../../../java/lang/Object.html#notifyAll()"><CODE>notifyAll</CODE></A> )를 빌트인 감시 락으로 사용하는 경우와 같은 사용 방법을 서포트합니다.
 <ul>
<li><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  메서드의 호출시에 이 기입 락을 보관 유지하고 있지 않는 경우,<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  가 Throw 된다 (read 락은 기입해 락과는 독립해 보관 유지되기 때문에
 체크되거나 영향을 받을 것은 없다. 다만, 현재의 thread가 읽어들여 락도 취득하고 있는 경우에 상태 대기 메서드를 호출하는 것은, 그것을 블록 해제 가능한 다른 thread로 기입해 락을 취득할 수 없게 되어 버리기 때문에
 항상 근본적인 잘못이다).
<li>상태<A HREF="../../../../java/util/concurrent/locks/Condition.html#await()"><CODE>대기</CODE></A> 메서드가 불려 가면, 기입 락이 해방된다. 그 후, 기입 락이 재취득되어 락 보관 유지 카운트가 메서드의 호출시 상태에 복원되고 나서, 메서드가 복귀한다.
<li>대기중에 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하면, 대기는 종료해,<A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 thread의 인터럽트 상태가 클리어 된다.
<li> 대기중의 thread는
 FIFO
 순서로 신호가 송신된다.
<li>대기중의 메서드로부터 복귀하는 thread가 락을 재얻는
 순서는
 thread가 락을 최초로 취득했을 때의 순서와 같게 된다. 이것은, 디폴트에서는 지정되어 있지 않지만, 「균등」락에서는 가장 길게 대기하고 있던 thread가 우선된다.   
</ul>
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스">Lock</A> </CODE> 내의 <CODE><A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()">newCondition</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>Condition 오브젝트</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 락을 식별하는 캐릭터 라인 및 락 상태를 돌려줍니다. 상태는 괄호로 둘러싸여 캐릭터 라인 「Unlocked」또는 캐릭터 라인 「Locked by」에 이어, 소유하는 thread의 <A HREF="../../../../java/lang/Thread.html#getName()"><CODE>Thread.getName()</CODE></A>  가 포함됩니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 락 및 그 상태를 식별하는 캐릭터 라인</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ReentrantReadWriteLock.WriteLock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;다음의 클래스</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ReentrantReadWriteLock.WriteLock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

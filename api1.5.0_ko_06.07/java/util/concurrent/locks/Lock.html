<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:59:00 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Lock (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.Lock interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Lock (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Lock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Lock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
인터페이스 Lock</H2>
<DL>
<DT><B>기존의 구현 클래스의 일람: </B> <DD><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스">ReentrantLock</A>,
 <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.ReadLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.ReadLock</A>,
 <A HREF="../../../../java/util/concurrent/locks/ReentrantReadWriteLock.WriteLock.html" title="java.util.concurrent.locks 안의 클래스">ReentrantReadWriteLock.WriteLock</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Lock</B></DL>
</PRE>

<P>
<tt>Lock</tt> 구현은,<tt>synchronized</tt>
 메서드나 문장을 사용하는 것으로 취득 가능한 락 조작보다 광범위한 락 조작을 제공합니다. 이 구현을 사용하면, 보다 유연한 구조나 완전히 다른 프로퍼티를 보관 유지하거나 관련된 복수 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 중의 인터페이스"><CODE>Condition</CODE></A>  오브젝트를 서포트할 수 있게 됩니다.

<p>락은, 복수의 thread에
한 공유 자원에의 액세스를 제어하기 위한 툴입니다. 보통
, 락은 공유 자원에의 배타적인 액세스를 제공합니다. 락을 취득할 수 있는 것은 한 번에 1 개의 thread 뿐이어서, 모든 공유 자원에 액세스 하려면  락을 최초로 취득할 필요가 있습니다. 다만,<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A> 
 read 락등의 일부의 락에서는
 공유 자원에의 동시 액세스가 허가되는 경우가 있습니다.

<p><tt>synchronized</tt> 메서드나 문장의 사용에
해, 각 오브젝트에 관련지을 수 있었던 암묵의 감시 락에의 액세스를 제공할 수 있습니다만, 락의 취득 및 해방은 모두 블록 구조에 따라 실시하는 것이 요구됩니다. 이 때문에
 복수의 락이 취득되었을 경우, 그 해방은 취득과는 반대의 순서로 실시할 필요가 있습니다. 또, 모든 락의 해방은, 그것들이 취득된 범위내에서 실시할 필요가 있습니다.

<p><tt>synchronized</tt> 메서드 및 문장의 범위 도구
는
 감시 락의 프로그래밍을 큰폭으로 용이하게함과 함께, 락에 관련한 일반적인 프로그래밍 에러의 대부분을 피하는데 도움이 됩니다만, 락의 조작을 보다 유연하게 실시할 필요가 있는 상황이 존재합니다. 예를 들어, 데이터 구조에 동시에 액세스 하는 일부의 호랑이 용기 알고리즘에서는
 「hand-over-hand」또는 「chain locking」를 사용할 필요가 있습니다. 이 경우, 노드 A
 락을 취득해, 다음에 노드 B
 락을 취득해, 다음에 A를
 해방해 C를
 취득해, 다음에 B를
 해방해 D를
 취득한다, 라고 하는 상태에 처리를 진행시킵니다. <tt>Lock</tt> 인터페이스를 구현하면, 다른 스코프내에서 락을 취득 및 해방하거나 복수의 락을 임의의 순서로 취득 및 해방하는 것이 가능하게 되기 때문에
 이런 종류의 테크닉을 이용할 수 있게 됩니다.

<p>이와 같이 유연성이 높아지면, 새로운 책임도 발생합니다. 블록 구조 락이 존재하지 않게 되는 것으로<tt>synchronized</tt> 메서드 및 문장으로 실행되는 락의 자동 해방이 기능하지 않게 됩니다. 대체로의 경우, 다음의 코드를 사용할 필요가 있습니다.

<space num=" ">
 <pre>
<tt><space num="     ">Lock l = ...;
 
<space num="     ">l.lock();
<space num="     ">try {
<space num="         ">// access the resource protected by this lock
<space num="     ">} finally {
<space num="         ">l.unlock();
<space num="     ">}
<space num=" "></tt></pre>

락 및 락 해제가 다른 스코프내에서 행해지는 경우, 락의 보관 유지중에 실행되는 모든 코드가 try-finally 또는 try-catch 에
해 보호되어 필요에 따라서 락이 확실히 해방되도록 주위를 기울일 필요가 있습니다.

<p><tt>Lock</tt> 구현은, 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()"><CODE>tryLock()</CODE></A> )를 취득하기 위한 비블록 시행, 끼어들어 가능한 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()"><CODE>lockInterruptibly()</CODE></A>  나 타임 아웃 가능한 락 (<A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)"><CODE>tryLock(long, TimeUnit)</CODE></A> )를 얻는
 시행을 제공하는 것으로써,<tt>synchronized</tt> 메서드 및 문장에의 추가 기능을 제공합니다.

<p><tt>Lock</tt> 클래스는
 보증된 순서 붙여 재입 불가능한 사용, 데드 록의 검출 등, 암묵의 감시 락과는 완전히 다른 동작이나 시멘틱스를 제공할 수 있습니다. 구현이 이러한 특수 시멘틱스를 제공하는 경우, 구현은 이러한 시멘틱스를 문서화할 필요가 있습니다.

<p><tt>Lock</tt> 인스턴스는 보통
의 오브젝트에 지나지 않고, 그 자체를 <tt>synchronized</tt> 문의 타겟으로서 사용할 수 있는 것에 유의해 주세요. <tt>Lock</tt> 인스턴스의 감시 락을 얻는
 것으로 그 인스턴스의 몇개의 <A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()"><CODE>lock()</CODE></A>  메서드를 호출하는 것으로는
 특히 관계가 없습니다. 혼란을 피하기 때문에
 독자적인 구현 이외에서는
 이러한 방법으로 <tt>Lock</tt> 인스턴스를 결코 사용하지 않는 것을 추천합니다.

<p>특히 명기되어 있지 않은 한, 몇개의 파라미터에 대해 <tt>null</tt> 치를 건네주면,<A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스"><CODE>NullPointerException</CODE></A>  가 Throw 됩니다.
<h3>메모리의 동기화</h3>

<p>모든 <tt>Lock</tt> 구현은, 빌트인 감시 락이 제공하는 것과 같은 메모리 동기 시멘틱스를 시행할 필요가 있습니다. 이하에 그 내용을 나타냅니다. <ul> <li>성공하는 lock 조작은, 성공하는 <tt>monitorEnter</tt> 액션과 같게 동작한다<li>성공하는 <tt>unlock</tt> 조작은, 성공하는 <tt>monitorExit</tt> 액션과 같게 동작한다</ul>
성공하지 않는 락 및 락 해제 조작 및 재입 가능한 락/락 해제 조작은, 메모리 동기 효과를 일절 필요로 하지 않습니다.
<h3>구현상의 고려사항</h3>


<p> 락 취득의 3 개의 형식 (인터럽트가능, 인터럽트 불가 및 시각 지정)에서는
 퍼포먼스 특성, 순서부의 보증, 다른 구현 품질이 다릅니다. 또, 「진행중의」락 취득에의 끼어들어 기능도, 지정된 <tt>Lock</tt> 클래스에서는 사용할 수 없습니다. 이 때문에
 3 개의 락 취득 형식 모두로 구현이 엄밀하게 같은 보증이나 시멘틱스를 정의할 필요는 없습니다. 또, 진행중의 락 취득의 인터럽트를 서포트할 필요도 없습니다. 구현은, 각 락 메서드의 제공하는 시멘틱스 및 보증을 명확하게 문서화할 필요가 있습니다. 또, 락 취득의 인터럽트가 서포트되는 범위내 (전체 또는 메서드 엔트리만)에서, 이 인터페이스로 정의된 인터럽트 시멘틱스에 따를 필요도 있습니다.

<p>보통
, 인터럽트는 취소를
미해, 인터럽트의 체크는 빈번하게 행해지는 것은 아니기 때문에
 구현은 보통
의 메서드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 이것은, 다른 액션이 thread를 블록 해제한 뒤에
 인터럽트가 발생했던 것(적)이 나타나는 경우에도 들어맞읍니다. 구현은, 이 동작을 문서화할 필요가 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../../java/util/concurrent/locks/ReentrantLock.html" title="java.util.concurrent.locks 내의 클래스"><CODE>ReentrantLock</CODE></A>,
 
<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>,
 
<A HREF="../../../../java/util/concurrent/locks/ReadWriteLock.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>ReadWriteLock</CODE></A> </DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#lock()">lock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#lockInterruptibly()">lockInterruptibly</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>  가 아닌 한, 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스">Condition</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()">newCondition</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Lock</tt> 인스턴스에 바인드 된 새로운 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A> 를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock()">tryLock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;호출시에 락되어 있지 않은 경우에게만, 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#tryLock(long, java.util.concurrent.TimeUnit)">tryLock</A> </B>(long&nbsp;time,
        <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 대기 시간내에 락이 이용 가능하고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하고 있지 않는 경우에
 락을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Lock.html#unlock()">unlock</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 락을 해제합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="lock()"><!-- --></A> <H3>
lock</H3>
<PRE>
void <B>lock</B>()</PRE>
<DL>
<DD>락을 취득합니다.
<p>락을 사용할 수 없는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 락이 취득될 때까지 대기합니다.
<p><b>구현상의 고려사항</b>

<p><tt>Lock</tt> 구현은, 데드 록을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 Throw 할 수 있습니다. <tt>Lock</tt> 구현에
해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lockInterruptibly()"><!-- --></A> <H3>
lockInterruptibly</H3>
<PRE>
void <B>lockInterruptibly</B>()
                       throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재의 thread가 <A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>interrupted</CODE></A>  가 아닌 한, 락을 취득합니다.
<p>이용 가능한 경우에 락을 취득해, 곧바로 복귀합니다.

<p>락을 사용할 수 없는 경우, 현재의 thread는 thread의 스케줄링에 관해서 무효가 되어, 다음의 2 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>현재의 thread에
해 락이 취득된다<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시해, 락 취득의 인터럽트가 서포트된다</ul>
<p>현재의 thread로
<ul> <li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,<li>락의 취득 및 락 취득의 중단이 서포트되고 있는 상황으로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우,
</ul>
 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 스테이터스가 클리어 됩니다.

<p><b>구현상의 고려사항</b>


<p>어느 상황하에서는 락 취득에 끼어들지 못하고, 경우에 따라서는 부하의 큰 조작이 되는 경우가 있습니다. 프로그래머는
 이러한 경우가 있는 것을
식해 둘 필요가 있습니다. 구현은, 해당하는 상황을 문서화할 필요가 있습니다.

<p>구현은, 보통
의 메서드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다.

<p><tt>Lock</tt> 구현은, 데드 록을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 Throw 할 수 있습니다. <tt>Lock</tt> 구현에
해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 락의 취득중 ( 및 락 취득의 중단이 서포트되고 있는 상황)에
 현재의 thread로 인터럽트가 발생하는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="tryLock()"><!-- --></A> <H3>
tryLock</H3>
<PRE>
boolean <B>tryLock</B>()</PRE>
<DL>
<DD>호출시에 락되어 있지 않은 경우에게만, 락을 취득합니다.
<p>가능한 경우에 락을 취득해, 값 <tt>true</tt> 로 곧바로 복귀합니다. 락이 이용 가능하지 않은 경우, 이 메서드는 값 <tt>false</tt> 로 곧바로 복귀합니다.
<p>이 메서드의 보통
의 사용 방법을 다음에 나타냅니다.

<space num=" ">
 <pre>

<space num="      ">Lock lock = ...;
<space num="      ">if (lock.tryLock()) {
<space num="          ">try {
<space num="              ">// manipulate protected state
<space num="          ">} finally {
<space num="              ">lock.unlock();
<space num="          ">}
<space num="      ">} else {
<space num="          ">// perform alternative actions
<space num="      ">}
<space num=" "></pre>
이 사용에
해, 락이 취득되었을 경우에 락이 해제되는 것 및 락이 취득되지 않았던 경우에 락 해제를 시도하지 않는 것이 보증됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>락이 취득되었을 경우는 <tt>true</tt>, 그렇지 않은 경우는 <tt>false</tt></DL>
</DD>
</DL>
<HR>

<A NAME="tryLock(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
tryLock</H3>
<PRE>
boolean <B>tryLock</B>(long&nbsp;time,
                <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>지정된 대기 시간내에 락이 이용 가능하고, 현재의 thread로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하고 있지 않는 경우에
 락을 취득합니다.

<p>락이 이용 가능한 경우, 이 메서드는 즉시 값 <tt>true</tt> 로 복귀합니다. 락을 이용할 수 없는 경우, 현재의 thread가 thread 스케줄링에 관해서 무효가 되어, 다음의 3 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>현재의 thread에
해 락이 취득된다<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시해, 락 취득의 인터럽트가 서포트된다<li>지정된 대기 시간이 경과한다</ul>
<p>락이 취득되면,<tt>true</tt> 가 돌려주고집니다.

<p>현재의 thread로
<ul> <li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,<li>락의 취득 및 락 취득의 중단이 서포트되고 있는 상황으로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우,
</ul>
 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 스테이터스가 클리어 됩니다.
<p>지정된 대기 시간이 경과하면, 값 <tt>false</tt> 가 돌려주고집니다. 시간이 제로 또는 그것보다 작은 경우, 메서드는 대기하지 않습니다.

<p><b>구현상의 고려사항</b>

<p>어느 상황하에서는 락 취득에 끼어들지 못하고, 경우에 따라서는 부하의 큰 조작이 되는 경우가 있습니다. 프로그래머는
 이러한 경우가 있는 것을
식해 둘 필요가 있습니다. 구현은, 해당하는 상황을 문서화할 필요가 있습니다.
<p>구현은, 보통
의 메서드 복귀에 대한 인터럽트, 또는 타임 아웃의 리포트에 긍정적으로 응답할 수 있습니다.
<p><tt>Lock</tt> 구현은, 데드 록을 일으키는 호출등의 락의 부정사용을 검출해, 그러한 상황으로 (체크되지 않는다) 예외를 Throw 할 수 있습니다. <tt>Lock</tt> 구현에
해, 해당하는 상황 및 예외의 형태를 문서화할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>time</CODE> - 락의 최장 대기 시간<DD><CODE>unit</CODE> - <tt>time</tt> 인수의 시간 단위
<DT><B>반환값:</B><DD>락이 취득되었을 경우는 <tt>true</tt>, 락이 취득되기 전에 대기 시간이 경과했을 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 락의 취득중 ( 및 락 취득의 중단이 서포트되고 있는 상황)에
 현재의 thread로 인터럽트가 발생하는 경우<DT><B>관련 항목:</B><DD><A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="unlock()"><!-- --></A> <H3>
unlock</H3>
<PRE>
void <B>unlock</B>()</PRE>
<DL>
<DD>이 락을 해제합니다.
<p><b>구현상의 고려사항</b>

<p>보통
,<tt>Lock</tt> 구현은, 락을 해방 가능한 thread에 관해서 제한을 부과해 (일반적으로 락의 홀더만을 해방할 수 있다), 제한이 침범되었을 경우에는 (체크되지 않는다) 예외를 Throw 할 수 있습니다. 제한 및 예외의 형태는 모두,<tt>Lock</tt> 구현에
해 문서화할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="newCondition()"><!-- --></A> <H3>
newCondition</H3>
<PRE>
<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스">Condition</A>  <B>newCondition</B>()</PRE>
<DL>
<DD>이 <tt>Lock</tt> 인스턴스에 바인드 된 새로운 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A> 를
 돌려줍니다.
<p>상태의 대기를 실행하기 전에
 현재의 thread가 락을 보관 유지할 필요가 있습니다. <A HREF="../../../../java/util/concurrent/locks/Condition.html#await()"><CODE>Condition.await()</CODE></A>  에의 호출에
해, 대기가 복귀하기 전에 락을 대기 및 재취득하기 전에
 락이 원자적으로 해방됩니다.
<p><b>구현상의 고려사항</b>

<p><A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 안의 인터페이스"><CODE>Condition</CODE></A>  인스턴스의 엄밀한 조작은 <tt>Lock</tt> 구현에
존하기 위해, 구현에
해 문서화할 필요가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Lock</tt> 인스턴스용의 새로운 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><CODE>Condition</CODE></A> 
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - 이 <tt>Lock</tt> 구현이 상태를 서포트하지 않는 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Lock.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/LockSupport.html" title="java.util.concurrent.locks 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Lock.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Lock.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

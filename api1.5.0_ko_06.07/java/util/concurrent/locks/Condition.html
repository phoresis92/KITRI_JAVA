<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:59:00 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Condition (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.locks.Condition interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Condition (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Condition.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Condition.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Condition.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent.locks</FONT>
<BR>
인터페이스 Condition</H2>
<DL>
<DT><B>기존의 구현 클래스의 일람: </B> <DD><A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스">AbstractQueuedSynchronizer.ConditionObject</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public interface <B>Condition</B></DL>
</PRE>

<P>
<tt>Condition</tt>는

<tt>Object</tt> 감시 메서드 (<A HREF="../../../../java/lang/Object.html#wait()"><CODE>wait</CODE></A>,
<A HREF="../../../../java/lang/Object.html#notify()"><CODE>notify</CODE></A>  및 <A HREF="../../../../java/lang/Object.html#notifyAll()"><CODE>notifyAll</CODE></A> )를 별개의 오브젝트 로 분해해, 그것들에 임의 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 중의 인터페이스"><CODE>Lock</CODE></A>  구현의 사용을 조합해, 오브젝트 마다 복수의 대기 세트를 보관 유지하는 효과를 부여합니다. 여기서,<tt>Lock</tt>는
 <tt>synchronized</tt> 메서드 및 문장의 사용을 옮겨놓아<tt>Condition</tt>는
 Object 감시 메서드의 사용을 옮겨놓습니다.

<p>상태 ( 「상태 큐」나 「상태 변수」라고도 불린다)는
 어느 상태가 true 가 되었던 것(적)이 다른 thread에
해 통지될 때까지, thread가 실행을 정지 (대기)하는 수단을 제공합니다. 이 공유 상태 정보에의 액세스는 다른 thread내에서 행해지기 때문에
 이 액세스를 보호할 필요가 있습니다. 이 때문에
 어떠한 형식의 락이 이 상태와 관련지을 수 있고 있습니다. 상태 대기의 제공하는 주요 프로퍼티는
<tt>Object.wait</tt> 와 같이, 관련된 락을 「원자적으로」해방해, 현재의 thread를 정지시키는 것입니다.

<p><tt>Condition</tt> 인스턴스는
 내재적으로 락에 바인드 되고 있습니다. 특정 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 중의 인터페이스"><CODE>Lock</CODE></A>  용의 <tt>Condition</tt> 인스턴스를 취득하기 위해서, 인스턴스는 <A HREF="../../../../java/util/concurrent/locks/Lock.html#newCondition()"><CODE>newCondition()</CODE></A>  메서드를 사용합니다.

<p>예로서<tt>put</tt> 및 <tt>take</tt> 메서드를 지원하는
 바운드 버퍼를 보관 유지하는 경우를 생각합시다. 하늘의 버퍼에 대해서 <tt>take</tt> 가 시도되면, 항목이 이용 가능하게 될 때까지 thread가 블록 합니다. 가득한 상태의 버퍼에 대해서 <tt>put</tt> 가 시도되면, 공간이 이용 가능하게 될 때까지 thread가 블록 합니다. 버퍼내에서 항목 또는 공간이 이용 가능하게 된 시점에서 단일 thread 통지만의 최적화를 사용할 수 있도록,<tt>put</tt> thread와 <tt>take</tt> thread를 별개의 대기 세트내에서 대기시키기로 하겠습니다. 이것은, 2 개 <A HREF="../../../../java/util/concurrent/locks/Condition.html" title="java.util.concurrent.locks 중의 인터페이스"><CODE>Condition</CODE></A>  인스턴스를 사용해 달성할 수 있습니다.
 
 <pre>

 class BoundedBuffer {
   <b>final Lock lock = new ReentrantLock();</b>
   final Condition notFull  = <b>lock.newCondition(); </b>
   final Condition notEmpty = <b>lock.newCondition(); </b>

   final Object[] items = new Object[100];
   int putptr, takeptr, count;

   public void put(Object x) throws InterruptedException {
     <b>lock.lock();
     try {</b>
       while (count == items.length) 
         <b>notFull.await();</b>
       items[putptr] = x; 
       if (++putptr == items.length) putptr = 0;
       ++count;
       <b>notEmpty.signal();</b>
     <b>} finally {
       lock.unlock();
     }</b>
   }

   public Object take() throws InterruptedException {
     <b>lock.lock();
     try {</b>
       while (count == 0) 
         <b>notEmpty.await();</b>
       Object x = items[takeptr]; 
       if (++takeptr == items.length) takeptr = 0;
       --count;
       <b>notFull.signal();</b>
       return x;
     <b>} finally {
       lock.unlock();
     }</b>
   } 
 }
 </pre>

(이 기능은 <A HREF="../../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>ArrayBlockingQueue</CODE></A>  클래스에
해 제공되기 때문에
 이 사용 예의 클래스를 구현할 필요는 없다)

<p><tt>Condition</tt> 구현은, 통지 순서부가 보증되는 것이나, 통지의 실행시에 락을 보관 유지할 필요가 없는 것 등,<tt>Object</tt> 감시 메서드의 동작이나 시멘틱스와는 다른 동작이나 시멘틱스를 제공할 수 있습니다. 이런 종류의 특수 시멘틱스가 구현에
해 제공되는 경우는
 구현은 이러한 시멘틱스를 문서화할 필요가 있습니다.

<p><tt>Condition</tt> 인스턴스는 보통
의 오브젝트이며, 그 자체를 <tt>synchronized</tt> 문의 타겟으로 사용할 수 있는 것 및 독자적인 감시의<A HREF="../../../../java/lang/Object.html#wait(long)"><CODE>대기</CODE></A> 및<A HREF="../../../../java/lang/Object.html#notify()"><CODE>통지</CODE></A> 메서드를 호출할 수 있는 것에 유의해 주세요. <tt>Condition</tt> 인스턴스의 감시 락의 취득, 또는 그 감시 메서드의 사용은,<tt>Condition</tt> 에 관련지을 수 있었던 <A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 동안의 인터페이스"><CODE>Lock</CODE></A> 
 취득 또는<A HREF="../../../../java/util/concurrent/locks/Condition.html#await()"><CODE>대기</CODE></A> 및<A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>신호 송신</CODE></A> 메서드의 사용과는 특히 관계가 없습니다. 혼란을 피하기 때문에
 독자 구현의 내부를 제외해,<tt>Condition</tt> 인스턴스를 이러한 방법에서는 결코 사용하지 않게 해 주세요.

<p>특히 명기되어 있지 않은 한, 몇개의 파라미터에 대해 <tt>null</tt> 치를 건네주면,<A HREF="../../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스"><CODE>NullPointerException</CODE></A>  가 Throw 됩니다.
<h3>구현상의 고려사항</h3>


<p><tt>Condition</tt>
 대기중에
 보통
, 기본으로 되는 플랫폼 시멘틱스에의 양보로서 「외관의 시작」이 허가됩니다. <tt>Condition</tt>는
 루프상에서 항상 대기해, 대기 대상 상태 예측을 테스트할 필요가 있기 때문에
 이것은 대체로의 응용 프로그램에서는 실질적인 효과는 거의 없습니다. 구현은 외관의 시작의 가능성을 자유롭게 삭제할 수 있습니다만, 어플리케이션 프로그래머는 그것이 발생해, 루프상에서 항상 대기하는 것과 상정하는 것을 추천합니다.

<p>상태 대기의 3 개의 형식 (인터럽트가능, 인터럽트 불가 및 시각 지정)에서는
 플랫폼에서의 구현의 용이성 및 퍼포먼스 특성이 다릅니다. 특히, 이러한 기능을 제공하면서, 순서부 보증등의 특정의 시멘틱스를 유지하는 것이 곤란한 경우가 있습니다. 게다가 실제의 thread 중단에 끼어드는 기능을 모든 플랫폼에서 구현하는 것은, 항상 실행 가능하다라고는 한정하지 않습니다.
<p>따라서, 구현이, 3 개의 대기 형식 모두로 동일한 보증이나 시멘틱스를 정의하는 것은 요구되고 있지 않습니다. 또, 실제의 thread 중단에 대한 인터럽트를 서포트할 필요도 없습니다.
<p>구현은, 대기중의 각 메서드로 제공되는 시멘틱스나 보증 및 구현이 thread 중단의 인터럽트를 서포트해, 이 인터페이스로 정의된 인터럽트 시멘틱스에 따를 필요가 있는 경우를 명확하게 문서화할 필요가 있습니다.
<p>보통
, 인터럽트는 취소를
미해, 인터럽트의 체크는 빈번하게 행해지는 것은 아니기 때문에
 구현은 보통
의 메서드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 이것은, 다른 액션이 thread를 블록 해제한 뒤에
 인터럽트가 발생했던 것(적)이 나타나는 경우에도 들어맞읍니다. 구현은, 이 동작을 문서화할 필요가 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#await()">await</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;신호가 송신되는지,<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트가 발생하는</CODE></A> 까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#await(long, java.util.concurrent.TimeUnit)">await</A> </B>(long&nbsp;time,
      <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 대기 시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitNanos(long)">awaitNanos</A> </B>(long&nbsp;nanosTimeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 대기 시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUninterruptibly()">awaitUninterruptibly</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread를, 신호가 보내질 때까지 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#awaitUntil(java.util.Date)">awaitUntil</A> </B>(<A HREF="../../../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;deadline)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 기한이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()">signal</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대기중의 thread를 1 개 시작합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()">signalAll</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;대기중의 모든 thread를 시작합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="await()"><!-- --></A> <H3>
await</H3>
<PRE>
void <B>await</B>()
           throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>신호가 송신되는지,<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트가 발생하는</CODE></A> 까지, 현재의 thread를 대기시킵니다.

<p>이 <tt>Condition</tt> 에 관련지을 수 있고 있는 락은 원자적으로 해방됩니다. 또, 현재의 thread는 thread의 스케줄링으로서는 무효가 되어, 다음의 4 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A>  메서드를 호출해, 현재의 thread가 시작 thread로서 선택된다<li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A>  메서드를 호출한다<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시해, thread 중단의 인터럽트가 서포트된다<li>「외관의 시작」이 발생한다 </ul>

<p>어느 경우에서도, 이 메서드가 현재의 thread를 돌려주기 전에
 이 상태에 관련지을 수 있었던 락을 재취득할 필요가 있습니다. thread의 복귀시에
 이 락을 보관 유지하는 것이 보증됩니다.

<p>현재의 thread로
<ul> <li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,<li>thread의 대기 및 중단이 서포트되고 있는 상황으로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우,
</ul>
 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다. 첫회시에는
 락이 해방되기 전에 인터럽트의 테스트가 실행될지 어떨지는 지정되지 않습니다.
<p><b>구현상의 고려사항</b>

<p>이 메서드의 호출시에
 현재의 thread는
 이 <tt>Condition</tt> 에 관련지을 수 있고 있는 락을 보관 유지하는 것이라고 보여집니다. 이것이 응답 방법을 결정하는 요인이 될지 어떨지는
 구현에 따라서 다릅니다. 보통
, (<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  등의) 예외가 Throw 되어 구현은 그것을 문서화할 필요가 있습니다.

<p>구현은, 신호에 응답해 실행되는 보통
의 메서드 복귀에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 이 경우, 구현은, 다른 대기 thread가 존재하는 경우에
 신호가 그 thread에 확실히 리디렉트 되도록 할 필요가 있습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생하는 ( 및 thread 중단의 인터럽트가 서포트된다) 경우</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUninterruptibly()"><!-- --></A> <H3>
awaitUninterruptibly</H3>
<PRE>
void <B>awaitUninterruptibly</B>()</PRE>
<DL>
<DD>현재의 thread를, 신호가 보내질 때까지 대기시킵니다.

<p>이 상태에 관련지을 수 있고 있는 락은 원자적으로 해방됩니다. 또, 현재의 thread는 thread의 스케줄링으로서는 무효가 되어, 다음의 3 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A>  메서드를 호출해, 현재의 thread가 시작 thread로서 선택된다<li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A>  메서드를 호출한다<li>「외관의 시작」이 발생한다 </ul>

<p>어느 경우에서도, 이 메서드가 현재의 thread를 돌려주기 전에
 이 상태에 관련지을 수 있었던 락을 재취득할 필요가 있습니다. thread의 복귀시에
 이 락을 보관 유지하는 것이 보증됩니다.

<p>현재의 thread가 이 메서드에 들어갈 때 인터럽트 상태가 설정되는지, 대기중에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우, 신호가 송신될 때까지 대기가 계속됩니다. 이 메서드로부터의 최종 복귀시에도, 「인터럽트 상태」는 계속 설정됩니다.
<p><b>구현상의 고려사항</b>

<p>이 메서드의 호출시에
 현재의 thread는
 이 <tt>Condition</tt> 에 관련지을 수 있고 있는 락을 보관 유지하는 것이라고 보여집니다. 이것이 응답 방법을 결정하는 요인이 될지 어떨지는
 구현에 따라서 다릅니다. 보통
, (<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  등의) 예외가 Throw 되어 구현은 그것을 문서화할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="awaitNanos(long)"><!-- --></A> <H3>
awaitNanos</H3>
<PRE>
long <B>awaitNanos</B>(long&nbsp;nanosTimeout)
                throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 대기 시간이 경과할 때까지, 현재의 thread를 대기시킵니다.

<p>이 상태에 관련지을 수 있고 있는 락은 원자적으로 해방됩니다. 또, 현재의 thread는 thread의 스케줄링으로서는 무효가 되어, 다음의 5 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A>  메서드를 호출해, 현재의 thread가 시작 thread로서 선택된다<li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A>  메서드를 호출한다<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시해, thread 중단의 인터럽트가 서포트된다<li>지정된 대기 시간이 경과한다<li>「외관의 시작」이 발생한다 </ul>

<p>어느 경우에서도, 이 메서드가 현재의 thread를 돌려주기 전에
 이 상태에 관련지을 수 있었던 락을 재취득할 필요가 있습니다. thread의 복귀시에
 이 락을 보관 유지하는 것이 보증됩니다.

<p>현재의 thread로
<ul> <li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,<li>thread의 대기 및 중단이 서포트되고 있는 상황으로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우,
</ul>
 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다. 첫회시에는
 락이 해방되기 전에 인터럽트의 테스트가 실행될지 어떨지는 지정되지 않습니다.

<p>이 메서드는
 복귀시에
 지정된 대기 시간을 나타내는 <tt>nanosTimeout</tt> 치에 대한 나머지의 추정 나노초수를 돌려줍니다. 타임 아웃 시간이 경과하고 있는 경우는
 제로 또는 제로 미만의 값을 돌려줍니다. 대기가 복귀해도 대기 상태가 여전히 보관 유지되지 않는 경우에
 이 값을 사용해, 재차 대기할지 어떨지 및 그 기간을 결정할 수 있습니다. 보통
, 이 메서드는 다음의 형식이 됩니다.

 
 <pre>

 synchronized boolean aMethod(long timeout, TimeUnit unit) {
   long nanosTimeout = unit.toNanos(timeout);
   while (! conditionBeingWaitedFor) {
     if (nanosTimeout &gt; 0)
         nanosTimeout = theCondition.awaitNanos(nanosTimeout);
      else
        return false;
   }
   // ... 
 }
 </pre>


<p> 설계상의 주의: 이 메서드는
 남은 시간을 리포트할 때에 잘라서 버림 에러의 발생을 피하기 위해서 나노초의 인수를 지정할 필요가 있습니다. 이 정밀도가 저하하면, 대기 시간의 합계가, 지정된 재대기의 발생시보다 시스템적으로 짧지 않은 것을 프로그래머가 보증하는 것이 어려워집니다.

<p><b>구현상의 고려사항</b>

<p>이 메서드의 호출시에
 현재의 thread는
 이 <tt>Condition</tt> 에 관련지을 수 있고 있는 락을 보관 유지하는 것이라고 보여집니다. 이것이 응답 방법을 결정하는 요인이 될지 어떨지는
 구현에 따라서 다릅니다. 보통
, (<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  등의) 예외가 Throw 되어 구현은 그것을 문서화할 필요가 있습니다.

<p>구현은, 신호에 응답해 실행되는 보통
의 메서드 복귀에 대한 인터럽트, 또는 지정된 대기 시간의 경과 지시에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 어느 쪽의 경우도, 구현은, 다른 대기 thread가 존재하는 경우에
 신호가 그 thread에 확실히 리디렉트 되도록 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>nanosTimeout</CODE> - 나노초단위의 대기 시간
<DT><B>반환값:</B><DD>대기가 타임 아웃 했을 경우는 제로 이하의 값. 그렇지 않은 경우는
 이 메서드의 복귀시의 추정 남은 시간 (<tt>nanosTimeout</tt> 인수보다 항상 작은 값이 된다)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생하는 ( 및 thread 중단의 인터럽트가 서포트된다) 경우</DL>
</DD>
</DL>
<HR>

<A NAME="await(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
await</H3>
<PRE>
boolean <B>await</B>(long&nbsp;time,
              <A HREF="../../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
              throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 대기 시간이 경과할 때까지, 현재의 thread를 대기시킵니다. 이 메서드의 동작은, 이하에 동일해집니다. <br>
 
 <pre>

   awaitNanos(unit.toNanos(time)) &gt; 0
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>time</CODE> - 대기하는 최장 시간<DD><CODE>unit</CODE> - <tt>time</tt> 인수의 시간 단위
<DT><B>반환값:</B><DD>메서드로부터의 복귀전에 대기 시간이 경과했던 것이 검출되었을 경우는 <tt>false</tt>, 그렇지 않은 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생하는 ( 및 thread 중단의 인터럽트가 서포트된다) 경우</DL>
</DD>
</DL>
<HR>

<A NAME="awaitUntil(java.util.Date)"><!-- --></A> <H3>
awaitUntil</H3>
<PRE>
boolean <B>awaitUntil</B>(<A HREF="../../../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;deadline)
                   throws <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>신호가 송신되는
 인터럽트가 발생한다, 또는 지정된 기한이 경과할 때까지, 현재의 thread를 대기시킵니다.

<p>이 상태에 관련지을 수 있고 있는 락은 원자적으로 해방됩니다. 또, 현재의 thread는 thread의 스케줄링으로서는 무효가 되어, 다음의 5 개중 한쪽이 일어날 때까지 대기합니다. <ul> <li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signal()"><CODE>signal()</CODE></A>  메서드를 호출해, 현재의 thread가 시작 thread로서 선택된다<li>다른 thread가 이 <tt>Condition</tt> 에 대해서 <A HREF="../../../../java/util/concurrent/locks/Condition.html#signalAll()"><CODE>signalAll()</CODE></A>  메서드를 호출한다<li>다른 thread가 현재의 thread에<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A>를
 실시해, thread 중단의 인터럽트가 서포트된다<li>지정된 기한이 경과한다<li>「외관의 시작」이 발생한다 </ul>

<p>어느 경우에서도, 이 메서드가 현재의 thread를 돌려주기 전에
 이 상태에 관련지을 수 있었던 락을 재취득할 필요가 있습니다. thread의 복귀시에
 이 락을 보관 유지하는 것이 보증됩니다.


<p>현재의 thread로
<ul> <li>이 메서드에의 엔트리상에서 설정된 인터럽트 스테이터스가 보관 유지되는지,<li>thread의 대기 및 중단이 서포트되고 있는 상황으로<A HREF="../../../../java/lang/Thread.html#interrupt()"><CODE>인터럽트</CODE></A> 가 발생하는 경우,
</ul>
 <A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스"><CODE>InterruptedException</CODE></A>  가 Throw 되어 현재의 thread의 인터럽트 상태가 클리어 됩니다. 첫회시에는
 락이 해방되기 전에 인터럽트의 테스트가 실행될지 어떨지는 지정되지 않습니다.


<p>반환값은, 기한이 경과했는지 어떠했는지를 나타냅니다. 이 값은 다음과 같이 사용할 수 있습니다.
 
 <pre>

 synchronized boolean aMethod(Date deadline) {
   boolean stillWaiting = true;
   while (! conditionBeingWaitedFor) {
     if (stillwaiting)
         stillWaiting = theCondition.awaitUntil(deadline);
      else
        return false;
   }
   // ... 
 }
 </pre>


<p><b>구현상의 고려사항</b>

<p>이 메서드의 호출시에
 현재의 thread는
 이 <tt>Condition</tt> 에 관련지을 수 있고 있는 락을 보관 유지하는 것이라고 보여집니다. 이것이 응답 방법을 결정하는 요인이 될지 어떨지는
 구현에 따라서 다릅니다. 보통
, (<A HREF="../../../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스"><CODE>IllegalMonitorStateException</CODE></A>  등의) 예외가 Throw 되어 구현은 그것을 문서화할 필요가 있습니다.

<p>구현은, 신호에 응답해 실행되는 보통
의 메서드 복귀에 대한 인터럽트, 또는 지정된 기한의 경과 지시에 대한 인터럽트에 긍정적으로 응답할 수 있습니다. 어느 쪽의 경우도, 구현은, 다른 대기 thread가 존재하는 경우에
 신호가 그 thread에 확실히 리디렉트 되도록 할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>deadline</CODE> - 대기하는 절대 시간
<DT><B>반환값:</B><DD>복귀시에 기한이 경과하고 있는 경우는 <tt>false</tt>, 그렇지 않은 경우는 <tt>true</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread로 인터럽트가 발생하는 ( 및 thread 중단의 인터럽트가 서포트된다) 경우</DL>
</DD>
</DL>
<HR>

<A NAME="signal()"><!-- --></A> <H3>
signal</H3>
<PRE>
void <B>signal</B>()</PRE>
<DL>
<DD>대기중의 thread를 1 개 시작합니다.

<p>이 상태로 대기중의 thread가 존재하는 경우, 1 개의 thread가 시작용으로 선택됩니다. 이 thread는
<tt>await</tt> 로부터 복귀하기 전에 락을 재취득할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="signalAll()"><!-- --></A> <H3>
signalAll</H3>
<PRE>
void <B>signalAll</B>()</PRE>
<DL>
<DD>대기중의 모든 thread를 시작합니다.

<p>이 상태로 대기중의 thread가 존재하는 경우, 모든 thread가 시작됩니다. 각 thread는
<tt>await</tt> 로부터 복귀하기 전에 락을 재취득할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Condition.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/locks/AbstractQueuedSynchronizer.ConditionObject.html" title="java.util.concurrent.locks 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/Lock.html" title="java.util.concurrent.locks 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/locks/Condition.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Condition.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:23:01 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
java.util.concurrent (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="java.util.concurrent (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 java.util.concurrent
</H2>
 보통
, 유틸리티 클래스는 병행 프로그래밍으로 유용합니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>인터페이스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue&lt;E&gt;</A> </B></TD>
<TD>요소의 취득시에 큐가 하늘이 아니게 될 때까지 대기하거나 요소의 포함시에 큐내의 공간이 이용 가능하게 될 때까지 대기하는 조작을 추가 지원하는
 <A HREF="../../../java/util/Queue.html" title="java.util 동안의 인터페이스"><CODE>Queue</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스">Callable&lt;V&gt;</A> </B></TD>
<TD>결과를 돌려주는 태스크. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 안의 인터페이스">CompletionService&lt;V&gt;</A> </B></TD>
<TD>새로운 비동기 태스크의 생성을, 완료필 태스크의 결과의 소비로부터 분리하는 서비스. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentMap.html" title="java.util.concurrent 안의 인터페이스">ConcurrentMap&lt;K, V&gt;</A> </B></TD>
<TD>추가의 원자적 <tt>putIfAbsent</tt>,<tt>remove</tt>,<tt>replace</tt> 메서드를 제공하는 <A HREF="../../../java/util/Map.html" title="java.util 동안의 인터페이스"><CODE>Map</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Delayed.html" title="java.util.concurrent 안의 인터페이스">Delayed</A> </B></TD>
<TD>지정된 지연 후에 동작하는 오브젝트를 마크하기 위한,
 혼합 스타일의 인터페이스

이 인터페이스의 구현은,<tt>getDelay</tt> 메서드와 정합성이 있는 순서를 제공하는 <tt>compareTo</tt> 메서드를 정의할 필요가 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 안의 인터페이스">Executor</A> </B></TD>
<TD>송신된 <A HREF="../../../java/lang/Runnable.html" title="java.lang 동안의 인터페이스"><CODE>Runnable</CODE></A>  태스크를 실행하는 오브젝트. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스">ExecutorService</A> </B></TD>
<TD>종료를 관리하는 메서드 및 1 개 이상의 비동기 태스크의 진행 상황을 추적하는 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Future</CODE></A> 를
 생성 가능한 메서드를 제공하는 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스">Future&lt;V&gt;</A> </B></TD>
<TD><tt>Future</tt>는

 비동기 계산의 결과를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor</CODE></A>  로 실행 불가능한 태스크의 핸들러</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스">ScheduledExecutorService</A> </B></TD>
<TD>지정된 지연 시간 후, 또는 주기적으로 커멘드의 실행을 스케줄 가능한 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledFuture.html" title="java.util.concurrent 안의 인터페이스">ScheduledFuture&lt;V&gt;</A> </B></TD>
<TD>취소해 가능한, 지연 된 결과 생성 액션. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> </B></TD>
<TD>요구에 응해 새로운 thread를 작성하는 오브젝트. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 안의 클래스">AbstractExecutorService</A> </B></TD>
<TD><A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A>  실행 메서드의 디폴트 구현을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스">ArrayBlockingQueue&lt;E&gt;</A> </B></TD>
<TD>배열에 근거하는 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블록 큐</A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 안의 클래스">ConcurrentHashMap&lt;K, V&gt;</A> </B></TD>
<TD>취득의 완전한 동시성 및 예상되는 조정 가능한 갱신 동시성을 지원하는
 해시 테이블. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 안의 클래스">ConcurrentLinkedQueue&lt;E&gt;</A> </B></TD>
<TD>안 바운드 형식의 thread 세이프인 <A HREF="../../../java/util/Queue.html" title="java.util 안의 인터페이스">큐 </a>베이스의 링크 노드. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 안의 클래스">CopyOnWriteArrayList&lt;E&gt;</A> </B></TD>
<TD>기본으로 되는 배열의 새로운 카피를 작성하는 것으로써, 모든 변경 조작 (추가, 설정등)이 구현되는 <A HREF="../../../java/util/ArrayList.html" title="java.util 동안의 클래스"><CODE>ArrayList</CODE></A> 
 thread 세이프인 변수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 안의 클래스">CopyOnWriteArraySet&lt;E&gt;</A> </B></TD>
<TD>모든 조작으로 <A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 안의 클래스"><CODE>CopyOnWriteArrayList</CODE></A> 를
 사용하는 <A HREF="../../../java/util/Set.html" title="java.util 동안의 인터페이스"><CODE>Set</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스">CountDownLatch</A> </B></TD>
<TD>다른 thread로 실행중의 조작 세트가 완료할 때까지, 1 개 이상의 thread를 대기 가능하게 하는 동기 지원. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 안의 클래스">CyclicBarrier</A> </B></TD>
<TD>thread 세트의 각각이 공통의 바리어 포인트에 이를 때까지 대기하는 것을 가능하게 하는 동기화 지원 기능. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 안의 클래스">DelayQueue&lt;E extends Delayed&gt;</A> </B></TD>
<TD><tt>Delayed</tt> 요소의 안 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블록 큐</A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 안의 클래스">Exchanger&lt;V&gt;</A> </B></TD>
<TD>2 개의 thread가 오브젝트를 교환 가능한 동기 포인트. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 안의 클래스">ExecutorCompletionService&lt;V&gt;</A> </B></TD>
<TD>태스크의 실행으로 지정된 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A> 를
 사용하는 <A HREF="../../../java/util/concurrent/CompletionService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>CompletionService</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스">Executors</A> </B></TD>
<TD>이 패키지로 정의된 <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Executor</CODE></A>,
<A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A>,
<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ScheduledExecutorService</CODE></A>,
<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스"><CODE>ThreadFactory</CODE></A>  및 <A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스"><CODE>Callable</CODE></A>  클래스용의 팩토리 및 유틸리티 메서드. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 안의 클래스">FutureTask&lt;V&gt;</A> </B></TD>
<TD>취소해 가능한 비동기 계산. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 안의 클래스">LinkedBlockingQueue&lt;E&gt;</A> </B></TD>
<TD>링크 노드에 근거하는
 옵션의 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스">블록 큐</A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 안의 클래스">PriorityBlockingQueue&lt;E&gt;</A> </B></TD>
<TD><A HREF="../../../java/util/PriorityQueue.html" title="java.util 안의 클래스"><CODE>PriorityQueue</CODE></A>  클래스와 같은 순서부 규칙을 사용해, 블록 취득 조작을 제공하는
 안 바운드 형식<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스">블록 큐</A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스">ScheduledThreadPoolExecutor</A> </B></TD>
<TD>지정된 지연 후 또는 주기적으로 실행하기 위한 커멘드를 추가 스케줄 가능한 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 안의 클래스">Semaphore</A> </B></TD>
<TD>카운트에 사용되는 semaphore. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 안의 클래스">SynchronousQueue&lt;E&gt;</A> </B></TD>
<TD>각 <tt>put</tt> 가 <tt>take</tt>를
 대기해, 그 역도 실행할 필요가 있는<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 동안의 인터페이스">블록 큐</A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor</A> </B></TD>
<TD>많은 경우, 풀 된 복수의 thread의 어느쪽이든을 사용해, 송신된 각 태스크를 실행하는 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ExecutorService</CODE></A> . </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.AbortPolicy</A> </B></TD>
<TD><tt>RejectedExecutionException</tt>를
 Throw 한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.CallerRunsPolicy</A> </B></TD>
<TD>executor 가 슛다운 하고 있지 않는 경우에
<tt>execute</tt> 메서드의 thread 호출로 거부된 태스크를 직접 실행한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardOldestPolicy</A> </B></TD>
<TD>executor 가 슛다운 하고 있지 않는 경우에
 가장 낡은 미처리의 요구를 파기해 <tt>execute</tt>를
 재시행한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardPolicy</A> </B></TD>
<TD>거부된 태스크를 예고 없이 파기한다, 거부된 태스크의 핸들러. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>열거형의 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> </B></TD>
<TD><tt>TimeUnit</tt>는

 기간이 지정된 입도 단위로 나타냅니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>예외 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/BrokenBarrierException.html" title="java.util.concurrent 안의 클래스">BrokenBarrierException</A> </B></TD>
<TD>고장 상태에 있는지, thread의 대기중에 고장 상태에 들어가는 바리어를, thread가 대기하려고 하고 있을 때 Throw 되는 예외입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/CancellationException.html" title="java.util.concurrent 안의 클래스">CancellationException</A> </B></TD>
<TD>태스크가 삭제되었기 때문에
<A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 안의 클래스"><CODE>FutureTask</CODE></A>  등의 값을 생성하는 태스크의 결과를 취득할 수 없는 것을 나타내는 예외. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/ExecutionException.html" title="java.util.concurrent 안의 클래스">ExecutionException</A> </B></TD>
<TD>예외의 Throw에
해 중단된 태스크의 결과를 취득하려고 했을 때에
 Throw 되는 예외. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 안의 클래스">RejectedExecutionException</A> </B></TD>
<TD>태스크를 받아들여 실행할 수 없는 경우에
<A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 안의 인터페이스"><CODE>Executor</CODE></A>  에
해 Throw 되는 예외</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../java/util/concurrent/TimeoutException.html" title="java.util.concurrent 안의 클래스">TimeoutException</A> </B></TD>
<TD>블록 조작이 타임 아웃 했을 때에 Throw 되는 예외. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 java.util.concurrent
 설명
</H2>

<P>
<p> 보통
, 유틸리티 클래스는 병행 프로그래밍으로 유용합니다. 이 패키지에는
 몇개의 소규모의 표준화 된 확장 가능 체제 및 편리성이 높고, 다른 점에서는 단조로워 구현의 곤란한 기능을 제공하는 클래스가 포함됩니다. 이하에
 주요 컴퍼넌트에 대해 간결하게 설명합니다. <tt>locks</tt> 및 <tt>atomic</tt> 패키지도 참조하십시오.
<h2>Executor</h2>

<b>인터페이스. </b> <A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 안의 인터페이스"><CODE>Executor</CODE></A> 는

 thread 풀, 비동기 입출력 및 경량 태스크 체제를 포함한, thread를 닮은 커스텀 하부조직을 정의하기 위한 표준화 된 단순한 인터페이스입니다. 사용중의 구상 Executor 클래스에 응해, 새로운 작성된 thread, 기존의 태스크 실행 thread, 또는 <tt>execute()</tt>를
 호출하는 thread내에서 태스크를 차례차례 또는 동시에 실행할 수 있습니다. <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ExecutorService</CODE></A> 는

 보다 완성도의 높은 동기 태스크 실행 체제를 제공합니다. ExecutorService는

 태스크의 큐잉 및 스케줄링을 관리해, 제어된 슛다운을 가능하게 합니다.
<A HREF="../../../java/util/concurrent/ScheduledExecutorService.html" title="java.util.concurrent 안의 인터페이스"><CODE>ScheduledExecutorService</CODE></A>  서브 인터페이스는
 지연 및 주기적인 태스크 실행 서포트를 추가합니다. ExecutorServices는

<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스"><CODE>Runnable</CODE></A>  와 유사한 결과를 얻을 수 있는
<A HREF="../../../java/util/concurrent/Callable.html" title="java.util.concurrent 안의 인터페이스"><CODE>Callable</CODE></A>  로 표현되는 임의의 함수의 비동기 실행을 결정하는 메서드를 제공합니다. <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 안의 인터페이스"><CODE>Future</CODE></A> 는

 함수의 결과를 돌려주고, 실행이 완료했는지 어떠했는지를 판별 가능하게 해, 실행을 취소하는 수단을 제공합니다.
<b>구현. </b><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor</CODE></A>  및 <A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 안의 클래스"><CODE>ScheduledThreadPoolExecutor</CODE></A>  클래스는
 튜닝 가능해 유연성의 높은 thread 풀을 제공합니다. <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  클래스는
 Executor
 가장 일반적인 종류 및 구성의 팩토리 메서드 및 이것들에 특히 대응하고 싶은 구두인가의 유틸리티 메서드를 제공합니다. Executor 에 근거하는 다른 유틸리티에는
 Future
 일반적인 확장 가능 구현을 제공하는 구상 클래스 <A HREF="../../../java/util/concurrent/FutureTask.html" title="java.util.concurrent 내의 클래스"><CODE>FutureTask</CODE></A>  및 비동기 태스크 그룹의 처리 조정을 지원하는 <A HREF="../../../java/util/concurrent/ExecutorCompletionService.html" title="java.util.concurrent 동안의 클래스"><CODE>ExecutorCompletionService</CODE></A>  가 포함됩니다.
<h2>큐</h2>

java.util.concurrent <A HREF="../../../java/util/concurrent/ConcurrentLinkedQueue.html" title="java.util.concurrent 내의 클래스"><CODE>ConcurrentLinkedQueue</CODE></A>  클래스는
 효율 및 확장성이 높고, thread 세이프인 비블로킹 FIFO 큐를 제공합니다. java.util.concurrent
 5 개의 구현 <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 내의 클래스"><CODE>LinkedBlockingQueue</CODE></A>,
<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>ArrayBlockingQueue</CODE></A>,
<A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 안의 클래스"><CODE>SynchronousQueue</CODE></A>,
<A HREF="../../../java/util/concurrent/PriorityBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>PriorityBlockingQueue</CODE></A>  및 <A HREF="../../../java/util/concurrent/DelayQueue.html" title="java.util.concurrent 안의 클래스"><CODE>DelayQueue</CODE></A> 는

 put 및 take
 블로킹 버젼을 정의하는
 확장된 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 동안의 인터페이스"><CODE>BlockingQueue</CODE></A>  인터페이스를 서포트합니다. 프로듀서 컨슈머(consumer), 메세지 처리, 병행 태스크 실행 및 관련된 병행 설계용의 가장 일반적인 사용 컨텍스트
은, 다른 클래스의 대상이 됩니다.

<h2>타이밍</h2>

<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형"><CODE>TimeUnit</CODE></A>  클래스는
 타임 아웃에 근거하는 조작을 지정 및 제어하기 위한 복수의 상세 (나노초를 포함한다)를 제공합니다. 패키지내의 대부분의 클래스에는
 무제한의 대기에 가세해 타임 아웃에 근거하는 조작이 포함됩니다. 타임 아웃을 사용하는 경우는 항상, 메서드가 타임 아웃을 나타내기 전에 대기할 필요가 있는 최소 시간이, 타임 아웃에
해 지정됩니다. 구현은, 타임 아웃의 발생 다음에 올 뿐 빨리 그것을 검출하도록 최선이 노력합니다만, 타임 아웃의 검출로부터 타임 아웃 후에 thread가 실제로 재실행되어까지의 사이에 무제한의 시간이 경과할 가능성이 있습니다.
<h2>동기화 장치</h2>

일반적으로 사용되는 특수용도의 동기를 지원하기 위해서, 4 개의 클래스가 사용됩니다
<A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 안의 클래스"><CODE>Semaphore</CODE></A>  is a classic concurrency tool.
<A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A>  is a very simple yet very<A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 내의 클래스"><CODE>Semaphore</CODE></A> 는

 표준적인 concurrent processing 툴입니다. <p><A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A> 는

 매우 단순합니다만, 지정된 수의 신호, 이벤트, 또는 상태에 이를 때까지 블록하기 위한,
 일반적인 유틸리티입니다. <A HREF="../../../java/util/concurrent/CyclicBarrier.html" title="java.util.concurrent 안의 클래스"><CODE>CyclicBarrier</CODE></A> 는

 일부의 병행 프로그래밍으로 도움이 되는
 설정 가능한 다중 동기 포인트입니다. <A HREF="../../../java/util/concurrent/Exchanger.html" title="java.util.concurrent 안의 클래스"><CODE>Exchanger</CODE></A> 를
 사용하면, 2 개의 thread가 만났을 때에 오브젝트를 교환할 수가 있습니다. 이것은, 몇개의 파이프라인 설계로 유용합니다. (★코멘트 : 이 문장의 전2개의 문장은, 번역 대상이라고 생각합니다만, 번역 대상외로서 태그화 되고 있습니다. 번역문을 추가했습니다. 추가 부분：「<A HREF="../../../java/util/concurrent/Semaphore.html" title="java.util.concurrent 안의 클래스"><CODE>Semaphore</CODE></A> 는

 표준적인 concurrent processing 툴입니다. <A HREF="../../../java/util/concurrent/CountDownLatch.html" title="java.util.concurrent 안의 클래스"><CODE>CountDownLatch</CODE></A> 는

 매우 단순합니다만,」★)
<h2>동시 컬렉션</h2>

이 패키지는
 Queues 에 가세해 multi-thread 컨텍스트
에서의 사용을 목적으로 설계되어 따분한가의 Collection 구현 (<A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentHashMap</CODE></A>,
<A HREF="../../../java/util/concurrent/CopyOnWriteArrayList.html" title="java.util.concurrent 안의 클래스"><CODE>CopyOnWriteArrayList</CODE></A>  및 <A HREF="../../../java/util/concurrent/CopyOnWriteArraySet.html" title="java.util.concurrent 안의 클래스"><CODE>CopyOnWriteArraySet</CODE></A> )을 제공합니다.
<p>이 패키지의 일부의 클래스에서 사용되는 접두사 「Concurrent」는
 유사한 「synchronized」클래스 물어 구두인가의 점으로써 차이가 있는 것을 나타냅니다. 예를 들어,<tt>java.util.Hashtable</tt> 및 <tt>Collections.synchronizedMap(new HashMap())</tt>는

 동기화 됩니다. 다만,<A HREF="../../../java/util/concurrent/ConcurrentHashMap.html" title="java.util.concurrent 안의 클래스"><CODE>ConcurrentHashMap</CODE></A> 는
 「동시」입니다. 동시 컬렉션은, thread 세이프입니다만, 단일의 배타 락에
해 제어되지 않습니다. ConcurrentHashMap
 특정의 케이스에서는
 동시 컬렉션은 임의수의 동시 read 및 조절 가능한 수의 동시 write를
 안전하게 허가합니다. 「동기화 되었다」클래스는
 단일의 락을 포함한
 컬렉션에의 액세스 모든 것을, 스케이라비리티를 희생해도 막을 필요가 있는 경우에 유용합니다. 복수의 thread가 공통의 컬렉션에 액세스 하는 것이 예상되는 다른 경우에는
 일반적으로 「동시」버젼이 우수합니다. 동기화되어 있지 않은 컬렉션은, 컬렉션이 공유되어 있지 않은지, 다른 락을 보관 유지하고 있는 경우에게만 액세스 가능한 경우가 뛰어납니다.
<p> 대부분의 동시 Collection 구현 (대부분의 Queue를
 포함한다)에서는
 Iterator 에
해 파스트페이르트라바살은 아니고 「약한 일관성」이 제공되는 점도 java.util
 보통
의 규약과는 다릅니다. 약한 일관성을 가지는 반복자는 thread 세이프입니다만, 반드시 반복중에 컬렉션을 다운 당할 필요는 없기 때문에
 반복자의 작성 이후의 갱신을 반영하는 일도 반영하지 않는 것도 가능합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/atomic/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/concurrent/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:23:01 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
java.util.concurrent.atomic (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.atomic package">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="java.util.concurrent.atomic (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/atomic/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<H2>
패키지 java.util.concurrent.atomic
</H2>
단일의 변수에 대한 락 프리로 thread 세이프인 프로그래밍을 지원하는
 클래스의 소규모의 툴 킷입니다.
<P>
<B>참조처:</B>
<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="#package_description"><B>설명</B></A> 
<P>

<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicBoolean.html" title="java.util.concurrent.atomic 안의 클래스">AtomicBoolean</A> </B></TD>
<TD>원자적인 갱신이 가능한 <tt>boolean</tt> 치. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicInteger.html" title="java.util.concurrent.atomic 안의 클래스">AtomicInteger</A> </B></TD>
<TD>원자적으로 갱신 가능한 <tt>int</tt> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicIntegerArray</A> </B></TD>
<TD>요소의 원자적인 갱신이 가능한 <tt>int</tt> 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicIntegerFieldUpdater&lt;T&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <tt>volatile int</tt> 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLong.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLong</A> </B></TD>
<TD>원자적인 갱신이 가능한 <tt>long</tt> 치입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLongArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLongArray</A> </B></TD>
<TD>요소의 원자적인 갱신이 가능한 <tt>long</tt> 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicLongFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicLongFieldUpdater&lt;T&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <tt>volatile long</tt> 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicMarkableReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicMarkableReference&lt;V&gt;</A> </B></TD>
<TD><tt>AtomicMarkableReference</tt>는

 원자적으로 갱신 가능한 마크 비트와 함께, 오브젝트 참조를 관리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReference&lt;V&gt;</A> </B></TD>
<TD>원자적인 갱신이 가능한 오브젝트 참조입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceArray.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReferenceArray&lt;E&gt;</A> </B></TD>
<TD>요소를 원자적으로 갱신 가능한 오브젝트 참조의 배열입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스">AtomicReferenceFieldUpdater&lt;T, V&gt;</A> </B></TD>
<TD>지정된 클래스의 지정된 <tt>volatile</tt> 참조 필드의 원자 갱신이 가능한, 리플렉션 베이스의 유틸리티입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD WIDTH="15%"><B><A HREF="../../../../java/util/concurrent/atomic/AtomicStampedReference.html" title="java.util.concurrent.atomic 안의 클래스">AtomicStampedReference&lt;V&gt;</A> </B></TD>
<TD><tt>AtomicStampedReference</tt>는

 원자적으로 갱신 가능한 정수 「스탬프」와(과) 함께, 오브젝트 참조를 관리합니다. </TD>
</TR>
</TABLE>
&nbsp;

<P>
<A NAME="package_description"><!-- --></A> <H2>
패키지 java.util.concurrent.atomic
 설명
</H2>

<P>
단일의 변수에 대한 락 프리로 thread 세이프인 프로그래밍을 지원하는
 클래스의 소규모의 툴 킷입니다. 기본적으로 이 패키지내의 클래스는 <tt>volatile</tt> 치, 필드 및 배열 요소의 개념을, 원자적인 조건부 갱신 조작도 제공하는 클래스에까지 확장합니다. 서식은 다음과 같습니다.

 <pre>
<space num=" ">boolean compareAndSet(expectedValue, updateValue);</pre>
<p> 이 메서드 (클래스가 다르면 인수의 형태도 다르다)가 <tt>expectedValue</tt>를
 현재 보관 유지하고 있는 경우, 변수를 <tt>updateValue</tt> 에 원자적으로 설정해, 성공하면 <tt>true</tt>를
 돌려줍니다. 이 패키지내의 클래스에는
 값을 취득하거나 무조건으로 설정하는 메서드 및 약한 조건부 원자 갱신 조작 <tt> weakCompareAndSet</tt> 도 포함됩니다. 보통
의 사용에서는
 약한 버젼이 효과적인 경우가 있습니다만, 지정된 <tt>weakCompareAndSet</tt> 메서드 호출이 외관상에서도 (즉, 명확한 이유없이) 실패하는 일이 있는 점이 다릅니다. <tt>false</tt> 가
미하는 것은, 필요에 따라서 조작을 재시행할 수 있는 것 뿐입니다. 이것은, 변수가 <tt>expectedValue</tt>를
 보관 유지해, 이 변수의 설정을 시도하는 다른 thread가 존재하지 않는 경우에
 호출을 반복해 실행하는 것으로 최종적인 성공이 보증되는 것에 기초를 두고 있습니다.
<p> 이러한 메서드 사양에 근거하는 구현에
해, 최신의 프로세서로 사용 가능한 고효율의 머신 레벨 원자 명령을 사용하는 것이 가능하게 됩니다. 다만, 일부의 플랫폼에서는
 이것을 지원하는
 것으로 어떠한 내부 락이 수반할 가능성이 있습니다. 이 때문에
 메서드로 비블로킹이 엄밀하게 보증되는 것은 아닙니다. thread는
 조작을 실행하기 전에 일시적으로 블록을 실행하는 일이 있습니다.
<p> <A HREF="../../../../java/util/concurrent/atomic/AtomicBoolean.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicBoolean</CODE></A>,
<A HREF="../../../../java/util/concurrent/atomic/AtomicInteger.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicInteger</CODE></A>,
<A HREF="../../../../java/util/concurrent/atomic/AtomicLong.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLong</CODE></A>  및 <A HREF="../../../../java/util/concurrent/atomic/AtomicReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReference</CODE></A>  클래스의 인스턴스는
 각각 대응하는 형태의 단일의 변수에 액세스 및 갱신을 제공합니다. 각 클래스는
 그 형태에 대응한 유틸리티 메서드도 제공합니다. 예를 들어,<tt>AtomicLong</tt> 및 <tt>AtomicInteger</tt> 클래스는
 원자 증분 메서드를 제공합니다. 어느 어플리케이션이, 다음과 같이 일련 번호를 생성한다고 합니다.

 <pre>
class Sequencer { private AtomicLong sequenceNumber = new AtomicLong(0);
 public long next() { return sequenceNumber.getAndIncrement();
 }}</pre>
<p>보통
, 액세스 및 갱신의 memory effect는
 다음의 휘발성 규칙에 따릅니다.
<ul>
<li> <tt>get</tt>는

<tt>volatile</tt> 변수의 독해로 memory effect를 보관 유지한다
<li> <tt>set</tt>는

<tt>volatile</tt> 변수의 기입 (할당하고)으로 memory effect를 보관 유지한다
<li><tt>weakCompareAndSet</tt>는

 변수를 원자적으로 읽어들여, 조건부로 기입한다. 순서는
 그 변수에 대한 다른 메모리 조작과의 관련으로 결정된다. 다만, 그 외의 경우는
 보통
의 비휘발성 메모리 조작으로서 동작한다
<li> <tt>compareAndSet</tt> 및 다른 모든 독해 및 갱신 조작 (<tt>getAndIncrement</tt> 등)은,<tt>volatile</tt> 변수의 독해와 기입의 양쪽 모두로 memory effect를 보관 유지한다
</ul>
 
<p>이 패키지에는
 단일의 값을 나타내는 클래스에 가세해 선택한 클래스내의 선택한 <tt>volatile</tt> 필드에 대한 <tt>compareAndSet</tt> 조작의 취득에 사용 가능한 <em>Updater</em> 클래스가 포함됩니다. <A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReferenceFieldUpdater</CODE></A>,
<A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicIntegerFieldUpdater</CODE></A>  및 <A HREF="../../../../java/util/concurrent/atomic/AtomicLongFieldUpdater.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLongFieldUpdater</CODE></A> 는

 관련된 필드형에의 액세스를 제공하는 리플렉션 베이스의 유틸리티입니다. 이것들은 주로 동일 노드의 복수의 <tt>volatile</tt> 필드 (트리 노드의 링크등)가 독립해 원자 갱신의 대상이 되는 원자 데이터 구조로 사용됩니다. 이러한 클래스를 사용하면, 원자 갱신의 사용 방법 및 사용하는 타이밍에 관한 유연성이 높아집니다. 다만, 리플렉션 베이스의 설정이 취급하기 어려운, 사용하기 어려운, 보증이 약해지는 등의 희생을 지불할 필요가 있습니다.
<p><A HREF="../../../../java/util/concurrent/atomic/AtomicIntegerArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicIntegerArray</CODE></A>,
<A HREF="../../../../java/util/concurrent/atomic/AtomicLongArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicLongArray</CODE></A>  및 <A HREF="../../../../java/util/concurrent/atomic/AtomicReferenceArray.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicReferenceArray</CODE></A>  클래스는
 이러한 형태의 배열에 대한 원자 조작 서포트를 한층 더 확장합니다. 이러한 클래스는
 일반의 배열에서는 서포트되지 않는
 배열 요소에 대한 <tt>volatile</tt> 액세스 시멘틱스를 제공하는 점에서도 주목할 만합니다.
<p> <A HREF="../../../../java/util/concurrent/atomic/AtomicMarkableReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicMarkableReference</CODE></A>  클래스는
 단일의 불리언 값을 참조와 관련짓습니다. 예를 들어, 데이터 구조의 내부에서 이 비트를 사용해, 참조중의 오브젝트가 논리적으로 삭제가 끝난 상태인 것을 나타낼 수 있습니다. <A HREF="../../../../java/util/concurrent/atomic/AtomicStampedReference.html" title="java.util.concurrent.atomic 안의 클래스"><CODE>AtomicStampedReference</CODE></A>  클래스는
 정수치를 참조에 관련짓습니다. 이것은, 일련의 갱신에 대응하는 버젼 번호를 나타내는 경우 등에 사용할 수 있습니다.
<p> 원자 클래스는
 비블록 데이터 구조 및 관련된 기반 클래스를 구현하기 위한 기본 단위로서 주로 설계되고 있습니다. 보통
,<tt>compareAndSet</tt> 메서드는 락의 대체가 아닙니다. 이것은, 오브젝트의 위기인 갱신이 「단일의」변수로 한정되는 경우에만 적용됩니다.
<p> 원자 클래스는
<tt>java.lang.Integer</tt> 및 관련 클래스에 대한 범용의 대체 클래스가 아닙니다. 이 클래스는
<tt>hashCode</tt> 나 <tt>compareTo</tt> 등의 메서드를 정의하지 않습니다 (원자 변수에서는 변경이 상정되고 있기 때문에
 해시 테이블 키로서는 바람직한 선택사항은 아니기 때문에). 또, 보통
, 클래스는 목적의 어플리케이션으로 유용한 형태에 대해서 제공됩니다. 예를 들어,<tt>byte</tt>를
 나타내는 원자 클래스는 존재하지 않습니다. 이러한 사용 빈도의 적은 케이스에서는
<tt>AtomicInteger</tt>를
 사용해 <tt>byte</tt> 치를 보관 유지해, 필요에 따라서 캐스트 할 수 있습니다. 또,<tt>Float.floatToIntBits</tt> 나 <tt>Float.intBitstoFloat</tt> 변환을 사용해 float를
 보관 유지하거나<tt>Double.doubleToLongBits</tt> 나 <tt>Double.longBitsToDouble</tt> 변환을 사용해 double를
 보관 유지할 수 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>패키지</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <FONT CLASS="NavBarFont1">클래스</FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-use.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../../java/util/concurrent/package-summary.html"><B>전의 패키지</B></A> &nbsp;
&nbsp;<A HREF="../../../../java/util/concurrent/locks/package-summary.html"><B>다음의 패키지</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../../index.html?java/util/concurrent/atomic/package-summary.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="package-summary.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

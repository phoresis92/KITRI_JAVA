<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:58:56 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ThreadPoolExecutor (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.concurrent.ThreadPoolExecutor class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ThreadPoolExecutor (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util.concurrent</FONT>
<BR>
클래스 ThreadPoolExecutor</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 내의 클래스">java.util.concurrent.AbstractExecutorService</A> 
      <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.concurrent.ThreadPoolExecutor</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/util/concurrent/Executor.html" title="java.util.concurrent 내의 인터페이스">Executor</A>,
 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 안의 인터페이스">ExecutorService</A> </DD>
</DL>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../../java/util/concurrent/ScheduledThreadPoolExecutor.html" title="java.util.concurrent 내의 클래스">ScheduledThreadPoolExecutor</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ThreadPoolExecutor</B><DT>extends <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 내의 클래스">AbstractExecutorService</A> </DL>
</PRE>

<P>
많은 경우, 풀 된 복수의 thread의 어느쪽이든을 사용해, 송신된 각 태스크를 실행하는 <A HREF="../../../java/util/concurrent/ExecutorService.html" title="java.util.concurrent 동안의 인터페이스"><CODE>ExecutorService</CODE></A> . 일반적으로<A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  팩토리 메서드를 사용해 구성됩니다.

<p>thread 풀은, 태스크마다의 호출의 오버헤드를 감소시키는 것으로 대량의 비동기 태스크를 실행할 때의 퍼포먼스를 개선해, 태스크의 컬렉션을 실행할 때에 소비되는 thread등의 자원을 제한 및 관리하는 수단을 제공하는 것으로 다른 2 개의 문제에 대응합니다. 각 <tt>ThreadPoolExecutor</tt> 도, 완료 태스크의 수등의 몇개의 기본적인 통계를 관리합니다.

<p>광범위한 컨텍스트
으로 유용하기 때문에,
 이 클래스는 조정 가능한 다수의 파라미터 및 확장 기능 훅을 제공합니다. 다만, 프로그래머는
 보다 편리성의 높은 <A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 동안의 클래스"><CODE>Executors</CODE></A>  팩토리 메서드인 <A HREF="../../../java/util/concurrent/Executors.html#newCachedThreadPool()"><CODE>Executors.newCachedThreadPool()</CODE></A>  (안 바운드 형식의 thread 풀, 자동 thread 재생을 포함한다),<A HREF="../../../java/util/concurrent/Executors.html#newFixedThreadPool(int)"><CODE>Executors.newFixedThreadPool(int)</CODE></A>  (고정 사이즈의 thread 풀) 및 <A HREF="../../../java/util/concurrent/Executors.html#newSingleThreadExecutor()"><CODE>Executors.newSingleThreadExecutor()</CODE></A>  (단독의 백그라운드 thread)를 사용하는 것이 추천 되고 있습니다. 이러한 메서드는
 일반적으로 사용되는 대부분의 시나리오에 맞추어 미리 설정되어 있습니다. 그렇지 않은 경우는
 다음에 나타내는 가이드에 따라 이 클래스를 수동으로 구성 및 튜닝 해 주세요.
<!-- BEGIN DATA -->
<dt>코어 및 최대 풀 사이즈</dt>
<dd><tt>ThreadPoolExecutor</tt>는

 corePoolSize (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A> 를
 참조) 및 maximumPoolSize (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A> 를
 참조)가 부과하는 제한에 따라, 풀 사이즈 (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()"><CODE>getPoolSize()</CODE></A> 를
 참조)를 자동조정 합니다. 새로운 태스크가 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A>  메서드내에서 송신되어 corePoolSize thread보다 실행중의 수가 적은 경우, 다른 워카스렛드가 아이돌 상태의 경우에서도, 요구를 처리하기 위해서 새로운 thread가 작성됩니다. 실행중의 수가 corePoolSize thread보다 많아, maximumPoolSize thread보다 적은 경우, 큐가 가득 되어 있는 경우에게만 새로운 thread가 작성됩니다. corePoolSize 및 maximumPoolSize를
 같게 설정하는 것으로 고정 사이즈의 thread 풀을 작성합니다. maximumPoolSize을
 <tt>Integer.MAX_VALUE</tt> 등의 원칙적으로 무제한한 값으로 설정하는 것으로 풀이 임의의 수의 동시 태스크를 받아들이는 것이 가능하게 됩니다. 보통
, 코어 및 최대 풀 사이즈는 구축시에게만 설정됩니다만,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A>  및 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A> 를
 사용해 동적으로 변경하는 일도 가능합니다.  <dd>
<dt> 요구에 응한 구축
<dd> 디폴트에서는
 코어 thread가 최초로 작성되어 필요한 때만 새로운 태스크에
해 시작되는 경우에서도,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()"><CODE>prestartCoreThread()</CODE></A>  나 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()"><CODE>prestartAllCoreThreads()</CODE></A>  메서드를 사용해 동적으로 오버라이드(override) 되는 경우가 있습니다.   </dd>
<dt>새로운 thread의 작성</dt>
<dd>새로운 thread는
<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스"><CODE>ThreadFactory</CODE></A> 를
 사용해 작성됩니다. 지정되어 있지 않은 경우는
<A HREF="../../../java/util/concurrent/Executors.html#defaultThreadFactory()"><CODE>Executors.defaultThreadFactory()</CODE></A> 를
 사용해, 작성하는 thread 모든 것이 같은 <A HREF="../../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스"><CODE>ThreadGroup</CODE></A>,
<tt>NORM_PRIORITY</tt> 우선도 및 비demon 상태를 보관 유지하도록 합니다. 다른 ThreadFactory를
 지정하는 것으로 thread의 이름, thread 그룹, 우선 순위, demon 상태등을 변경할 수 있습니다. <tt>newThread</tt> 로부터 null 가 돌려주고졌을 때에 요구된 <tt>ThreadFactory</tt> 로 thread의 작성에 실패했을 경우, executor는
 속행합니다만, 태스크를 실행할 수 없을 가능성이 있습니다. </dd>
<dt>킵얼라이브 시간</dt>
<dd>풀이 현재 corePoolSize를
 넘는 thread를 보관 유지하고 있는 경우, 아이돌 상태의 시간이 keepAliveTime (<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A> 를
 참조)를 초과하면, 초과한 thread는 종료합니다. 이것에
해, 풀이 액티브하게 사용되어 있지 않은 경우에
 자원의 소비를 억제할 수가 있습니다. 풀이 나중에보다 액티브하게 되면, 새로운 thread가 작성됩니다. 이 파라미터는
<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A>  메서드를 사용해 동적으로 변경하는 일도 가능합니다. <tt>Long.MAX_VALUE</tt> <A HREF="../../../java/util/concurrent/TimeUnit.html#NANOSECONDS"><CODE>TimeUnit.NANOSECONDS</CODE></A>  치를 사용하면, 아이돌 상태의 thread가 슛다운전에 종료하지 않게 할 수 있습니다.  </dd>
<dt>큐잉</dt>
<dd>임의 <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 중의 인터페이스"><CODE>BlockingQueue</CODE></A> 를
 사용해, 송신 끝난 태스크를 전송 및 보관 유지할 수 있습니다. 이 큐를 사용하면, 풀의 사이즈 변경이 대화적으로 처리됩니다.
 <ul>
<li> 실행중의 thread가 corePoolSize 보다 적은 경우, Executor는
 큐잉보다 새로운 thread의 추가를 항상 우선한다</li>

<li> corePoolSize 이상의 thread가 실행중의 경우, Executor는
 새로운 thread의 추가보다 요구의 큐잉을 항상 우선한다</li>
  <li> 요구를 큐에 넣을 수가 없는 경우, maximumPoolSize를
 초과하지 않는 한, 새로운 thread가 작성된다. maximumPoolSize를
 초과하는 경우, 태스크가 거부된다</li>

 
</ul>

큐잉에는
 다음의 3 개의 스트래터지가 있습니다.  <ol>
<li> 직접 핸드 오프. 작업 큐용이 뛰어난 디폴트 선택인 <A HREF="../../../java/util/concurrent/SynchronousQueue.html" title="java.util.concurrent 동안의 클래스"><CODE>SynchronousQueue</CODE></A> 는

 thread를 따로 보관 유지하는 일 없이 thread에 건네준다. 여기서, 곧바로 실행 가능한 thread가 존재하지 않는 경우, 태스크를 큐에 넣으려고 하는 시도는 실패하기 위해, 새로운 thread가 작성된다. 이 폴리시는
 내부
존성을 보관 유지할 가능성이 있는 요구 세트를 처리할 때, 록 업을 회피한다. 보통
, 직접 핸드 오프에서는
 새롭게 송신되는 태스크가 거부되는 것을 회피하기 위해서 안 바운드 형식의 maximumPoolSizes 가 필요하게 된다. 한편, 이 경우, 전체적으로 처리 능력을 넘는 속도로 커멘드가 차례차례로 도착하면, 안 바운드 형식의 thread가 커질 가능성이 있다  </li>

<li>안 바운드 형식의 큐. 안 바운드 형식의 큐 (정의 끝난 용량을 가지지 않는 <A HREF="../../../java/util/concurrent/LinkedBlockingQueue.html" title="java.util.concurrent 동안의 클래스"><CODE>LinkedBlockingQueue</CODE></A>  등)를 사용하면, 모든 corePoolSize thread가 Busy 상태에 있는 경우에 새로운 태스크가 큐에 넣어진다. 이 때문에
 corePoolSize를
 넘는 thread는 작성되지 않는다 (따라서, maximumPoolSize
 값은 영향을 미치지 않는다). 이것이 적절한 것은, Web 페이지 서버내 등, 각 태스크가 다른 태스크로부터 완전하게 독립하고 있기 위해서, 태스크가 다른 태스크의 실행에 영향을 미치는 것이 없는 경우이다. 이 큐 스타일은, 일시적으로 급증한 요구를 처리하는 경우 등에 유용하지만, 전체적으로 처리 능력을 넘는 속도로 커멘드가 차례차례로 도착하면, 안 바운드 형식의 작업 큐가 커질 가능성이 있다  </li>

<li>바운드 형식의 큐. 바운드 형식의 큐 (<A HREF="../../../java/util/concurrent/ArrayBlockingQueue.html" title="java.util.concurrent 안의 클래스"><CODE>ArrayBlockingQueue</CODE></A>  등)는
 한정된 maximumPoolSizes 와 함께 사용하면 자원의 고갈을 막는 경우에 도움이 되지만, 튜닝이나 제어가 곤란하게 될 가능성이 있다. 큐 사이즈와 최대 풀 사이즈는
 트레이드 오프의 관계에 있다. 대규모 큐와 소규모의 풀을 사용하면, CPU
 사용, OS
 자원 및 컨텍스트
 변환의 오버헤드를 가능한 한 줄일 수가 있지만, 그 때문에(위해) throughput가 저하할 가능성이 있다. 태스크가 빈번하게 블록 하는 (예를 들어, 입출력이 제한된다) 경우, 다른 방법으로 허가하는 것보다도 많은 thread에 대해서 시스템이 시간을 스케줄 할 수 있다. 보통
, 소규모의 큐를 사용하면, 대량의 풀 사이즈가 필요하게 된다. 이것에
해, CPU
 Busy 상태가 많아지지만, 수락 불가의 스케줄링 오버헤드에 조우할 가능성이 있기 때문에
 역시 throughput가 저하한다  </li>

 </ol>
 </dd>
<dt>거부된 태스크</dt>
<dd> Executor 가 슛다운 하고 있는 경우 및 Executor 가 최대 thread와 작업 큐 용량의 양쪽 모두를 제한해, 그것이 포화 상태에 있는 경우,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)"><CODE>execute(java.lang.Runnable)</CODE></A>  메서드내에 송신된 새로운 태스크는 「거부」됩니다. 어느 쪽의 경우도,<tt>execute</tt> 메서드는 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스"><CODE>RejectedExecutionHandler</CODE></A> 
 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html#rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)"><CODE>RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor)</CODE></A>  메서드를 호출합니다. 다음의 4 개의 정의가 끝난 핸들러 폴리시가 제공됩니다.
 <ol>
<li> 디폴트 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 중의 클래스"><CODE>ThreadPoolExecutor.AbortPolicy</CODE></A>  에서는
 거부되면, 핸들러는 실행시 <A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 중의 클래스"><CODE>RejectedExecutionException</CODE></A> 를
 Throw 한다</li>
  <li> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.CallerRunsPolicy</CODE></A>  에서는
<tt>execute</tt> 자체를 호출하는 thread가 태스크를 실행한다. 이것에
해, 단순한 피드백 제어 메카니즘이 제공되어 결과적으로 새로운 태스크의 송신 레이트가 저하한다 </li>

<li> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.DiscardPolicy</CODE></A>  에서는
 실행 불가능한 태스크는 단지 삭제된다  </li>

<li><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스"><CODE>ThreadPoolExecutor.DiscardOldestPolicy</CODE></A>  에서는
 executor 가 슛다운 하고 있지 않는 경우, 작업 큐의 선두에 있는 태스크가 삭제되어 실행이 재차 시도된다 (재차 실패할 가능성도 있어, 그 경우는 이것이 반복해진다) </li>

 </ol>
다른 종류 <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 중의 인터페이스"><CODE>RejectedExecutionHandler</CODE></A>  클래스를 정의 및 사용하는 일도 가능합니다. 이 경우, 특히 폴리시가 특정의 용량 또는 큐잉 폴리시에서만 동작하도록 설계되고 있는 경우는
 주의가 필요합니다.  </dd>
<dt>훅 메서드</dt>
<dd>이 클래스는
<tt>protected</tt>를
 오버라이드(override) 가능한 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)"><CODE>beforeExecute(java.lang.Thread, java.lang.Runnable)</CODE></A>  및 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)"><CODE>afterExecute(java.lang.Runnable, java.lang.Throwable)</CODE></A>  메서드를 제공합니다. 이것은, 각 태스크의 실행 전후에 불려 갑니다. 이것들은, ThreadLocals
 재초기화, 통계의 수집, 로그 엔트리의 추가등의, 실행 환경의 조작에 사용할 수 있습니다. 또,<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()"><CODE>terminated()</CODE></A>  메서드를 오버라이드(override) 해, Executor 가 완전하게 종료한 후에 실행할 필요가 있는 특수한 처리를 실행할 수 있습니다.  

<p>훅 메서드 또는 콜백 메서드가 예외를 Throw 하면, 내부의 워카스렛드가 실패해 즉시 종료합니다. </dd> 
<dt>큐의 보수</dt>
<dd> <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()"><CODE>getQueue()</CODE></A>  메서드를 사용하면, 감시 및 디버그 목적으로 작업 큐에 액세스 할 수 있습니다. 다른 목적으로 이 메서드를 사용하는 것은, 가능한 한 피해 주세요. 큐에 넣어진 대량의 태스크가 삭제되었을 경우, 제공되는 2 개의 메서드 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)"><CODE>remove(java.lang.Runnable)</CODE></A>  및 <A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A> 를
 기억 영역의 재생의 지원에 사용할 수 있습니다. </dd> </dl>

<p> 확장 기능의 예. 이 클래스의 확장 기능의 대부분은, 1 개 이상의 protected 훅 메서드를 오버라이드(override) 합니다. 다음의 예는
 단순한 일시정지/재개 기능을 추가하는 서브 클래스입니다. <b></b>

 
 <pre>

 class PausableThreadPoolExecutor extends ThreadPoolExecutor {
   private boolean isPaused;
   private ReentrantLock pauseLock = new ReentrantLock();
   private Condition unpaused = pauseLock.newCondition();

   public PausableThreadPoolExecutor(...) { super(...); }
 
   protected void beforeExecute(Thread t, Runnable r) {
     super.beforeExecute(t, r);
     pauseLock.lock();
     try {
       while (isPaused) unpaused.await();
     } catch(InterruptedException ie) {
       t.interrupt();
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void pause() {
     pauseLock.lock();
     try {
       isPaused = true;
     } finally {
       pauseLock.unlock();
     }
   }
 
   public void resume() {
     pauseLock.lock();
     try {
       isPaused = false;
       unpaused.signalAll();
     } finally {
       pauseLock.unlock();
     }
   }
 }
 </pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.AbortPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>RejectedExecutionException</tt>를
 Throw 한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.CallerRunsPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.CallerRunsPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 가 슛다운 하고 있지 않는 경우에
<tt>execute</tt> 메서드의 thread 호출로 거부된 태스크를 직접 실행한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardOldestPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardOldestPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;executor 가 슛다운 하고 있지 않는 경우에
 가장 낡은 미처리의 요구를 파기해 <tt>execute</tt>를
 재시행한다, 거부된 태스크의 핸들러. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.DiscardPolicy.html" title="java.util.concurrent 안의 클래스">ThreadPoolExecutor.DiscardPolicy</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;거부된 태스크를 예고 없이 파기한다, 거부된 태스크의 핸들러. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터 및 디폴트의 thread 팩토리 및 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)">ThreadPoolExecutor</A> </B>(int&nbsp;corePoolSize,
                   int&nbsp;maximumPoolSize,
                   long&nbsp;keepAliveTime,
                   <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                   <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                   <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory,
                   <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#afterExecute(java.lang.Runnable, java.lang.Throwable)">afterExecute</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r,
             <A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;t)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 Runnable
 실행 완료시에 불려 가는 메서드. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#awaitTermination(long, java.util.concurrent.TimeUnit)">awaitTermination</A> </B>(long&nbsp;timeout,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;슛다운 요구 후에 모든 태스크가 실행을 완료하는
 타임 아웃이 발생하는
 현재의 thread로 인터럽트가 발생하는

 어떤 것인가가 최초로 일어날 때까지 블록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#beforeExecute(java.lang.Thread, java.lang.Runnable)">beforeExecute</A> </B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;t,
              <A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 thread내에서, 지정된 Runnable
 실행에 앞서 불려 가는 메서드. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#execute(java.lang.Runnable)">execute</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 태스크를 장래의 언젠가 실행합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor 가 참조되는 것이 없어졌을 경우에
<tt>shutdown</tt>를
 호출합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getActiveCount()">getActiveCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;태스크를 액티브하게 실행중의 thread의 개수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCompletedTaskCount()">getCompletedTaskCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행이 완료한 태스크의 대체로의 총수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()">getCorePoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 코어수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)">getKeepAliveTime</A> </B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 킵얼라이브 시간을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getLargestPoolSize()">getLargestPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지금까지 동시에 풀에 존재한 thread의 최대수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()">getMaximumPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;허가되는 thread의 최대수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getPoolSize()">getPoolSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;풀내의 현재의 thread수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getQueue()">getQueue</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor 가 사용하는 태스크 큐를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 내의 인터페이스">RejectedExecutionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()">getRejectedExecutionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 불가능한 태스크용의 현재의 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getTaskCount()">getTaskCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행이 스케줄 된 태스크의 대체로의 총수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스">ThreadFactory</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()">getThreadFactory</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 thread의 작성에 사용하는 thread 팩토리를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isShutdown()">isShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 executor가 슛다운 했을 경우,<tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminated()">isTerminated</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;슛다운에 이어 모든 태스크가 완료했을 경우에
<tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#isTerminating()">isTerminating</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 후에 이 executor 가 종료 처리를 실행중이지만, 완전하게 종료하고 있지 않는 경우, true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartAllCoreThreads()">prestartAllCoreThreads</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 코어 thread를 개시해, 아이돌 상태로 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#prestartCoreThread()">prestartCoreThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;코어 thread를 개시해, 아이돌 상태로 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()">purge</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;작업 큐로부터 삭제된 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Future</CODE></A>  태스크 모든 삭제를 시도합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#remove(java.lang.Runnable)">remove</A> </B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;task)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 태스크가 존재하는 경우, executor
 내부 큐로부터 삭제해, 아직 시작하고 있지 않으면 실행되지 않게 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)">setCorePoolSize</A> </B>(int&nbsp;corePoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 코어수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)">setKeepAliveTime</A> </B>(long&nbsp;time,
                 <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread가 종료하기 전에 아이돌 상태에 머무르는 제한 시간을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)">setMaximumPoolSize</A> </B>(int&nbsp;maximumPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;허가되는 thread의 최대수를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)">setRejectedExecutionHandler</A> </B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행 불가능한 태스크용의 새로운 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)">setThreadFactory</A> </B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 thread의 작성에 사용하는 thread 팩토리를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdown()">shutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;순서에 따라 실행되는 슛다운을 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#shutdownNow()">shutdownNow</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;실행중의 액티브한 태스크 모든 정지를 시도해 대기중의 태스크의 처리를 정지해, 실행을 대기하고 있던 태스크의 리스트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#terminated()">terminated</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Executor 가 종료되었을 때에 불려 가는 메서드. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.util.concurrent.AbstractExecutorService"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.util.concurrent. <A HREF="../../../java/util/concurrent/AbstractExecutorService.html" title="java.util.concurrent 안의 클래스">AbstractExecutorService</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection)">invokeAll</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAll(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAll</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection)">invokeAny</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#invokeAny(java.util.Collection, long, java.util.concurrent.TimeUnit)">invokeAny</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.util.concurrent.Callable)">submit</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable)">submit</A>,
 <A HREF="../../../java/util/concurrent/AbstractExecutorService.html#submit(java.lang.Runnable, T)">submit</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue)</PRE>
<DL>
<DD>지정된 초기 파라미터 및 디폴트의 thread 팩토리 및 핸들러를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다. 이 범용 생성자를 사용하는 것보다도,<A HREF="../../../java/util/concurrent/Executors.html" title="java.util.concurrent 안의 클래스"><CODE>Executors</CODE></A>  팩토리 메서드의 1 개를 사용하는 것이 편리한 경우가 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (아이돌 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀에서 허가되는 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은, 초과한 아이돌 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간이 되는<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크를 실행하기 전에
 태스크 보관 유지에 사용하는 큐. 이 큐는
<tt>execute</tt> 메서드에
해 송신된 <tt>Runnable</tt> 태스크만을 보관 유지한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로 미만의 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 가 null
 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</PRE>
<DL>
<DD>지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (아이돌 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀에서 허가되는 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은, 초과한 아이돌 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간이 되는<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크를 실행하기 전에
 태스크 보관 유지에 사용하는 큐. 이 큐는
<tt>execute</tt> 메서드에
해 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>threadFactory</CODE> - executor 가 새로운 thread를 작성할 때에 사용하는 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로 미만의 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 또는 <tt>threadFactory</tt> 가 null
 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (아이돌 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀에서 허가되는 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은, 초과한 아이돌 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간이 되는<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크를 실행하기 전에
 태스크 보관 유지에 사용하는 큐. 이 큐는
<tt>execute</tt> 메서드에
해 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>handler</CODE> - thread가 제한에 이르는지, 큐가 용량에 이르렀기 때문에 실행이 블록 되었을 경우에 사용하는 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로 미만의 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt> 또는 <tt>handler</tt> 가 null
 경우</DL>
</DL>
<HR>

<A NAME="ThreadPoolExecutor(int, int, long, java.util.concurrent.TimeUnit, java.util.concurrent.BlockingQueue, java.util.concurrent.ThreadFactory, java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
ThreadPoolExecutor</H3>
<PRE>
public <B>ThreadPoolExecutor</B>(int&nbsp;corePoolSize,
                          int&nbsp;maximumPoolSize,
                          long&nbsp;keepAliveTime,
                          <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit,
                          <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 안의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt;&nbsp;workQueue,
                          <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory,
                          <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>지정된 초기 파라미터를 사용해, 새로운 <tt>ThreadPoolExecutor</tt>를
 작성합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 풀내 로 유지하는 thread의 수 (아이돌 상태의 thread도 포함한다)<DD><CODE>maximumPoolSize</CODE> - 풀에서 허가되는 thread의 최대수<DD><CODE>keepAliveTime</CODE> - thread의 수가 코어보다 많은 경우, 이것은, 초과한 아이돌 상태의 thread가 종료전에 새로운 태스크를 대기하는 최대 시간이 되는<DD><CODE>unit</CODE> - keepAliveTime 인수의 시간 단위<DD><CODE>workQueue</CODE> - 태스크를 실행하기 전에
 태스크 보관 유지에 사용하는 큐. 이 큐는
<tt>execute</tt> 메서드에
해 송신된 <tt>Runnable</tt> 태스크만을 보관 유지하는<DD><CODE>threadFactory</CODE> - executor 가 새로운 thread를 작성할 때에 사용하는 팩토리<DD><CODE>handler</CODE> - thread가 제한에 이르는지, 큐가 용량에 이르렀기 때문에 실행이 블록 되었을 경우에 사용하는 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - corePoolSize 또는 keepAliveTime 가 제로 미만의 경우, maximumPoolSize 가 제로 이하의 경우, 또는 corePoolSize 가 maximumPoolSize 보다 큰 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <tt>workQueue</tt>,<tt>threadFactory</tt>, 또는 <tt>handler</tt> 가 null
 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="execute(java.lang.Runnable)"><!-- --></A> <H3>
execute</H3>
<PRE>
public void <B>execute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;command)</PRE>
<DL>
<DD>지정된 태스크를 장래의 언젠가 실행합니다. 이 태스크는
 새로운 thread로 실행되는 일도, 풀 된 기존의 thread로 실행되는 일도 있습니다.
이 executor 가 슛다운 하고 있는지, 용량이 가득 되었기 때문에 태스크를 실행용으로 송신할 수 없는 경우, 태스크는 현재의 <tt>RejectedExecutionHandler</tt> 에
해 처리됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>command</CODE> - 실행하는 태스크
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/util/concurrent/RejectedExecutionException.html" title="java.util.concurrent 안의 클래스">RejectedExecutionException</A> </CODE> - 태스크를 실행용으로 받아들일 수가 없는 경우,<tt>RejectedExecutionHandler</tt>
 판단으로 Throw 된다
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 커멘드가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="shutdown()"><!-- --></A> <H3>
shutdown</H3>
<PRE>
public void <B>shutdown</B>()</PRE>
<DL>
<DD>순서에 따라 실행되는 슛다운을 개시합니다. 이전에 송신된 태스크가 실행됩니다만, 새로운 태스크는 받아들여지지 않습니다. 슛다운 후에 호출을 실행해도, 효과는 없습니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재하는 상황으로 슛다운을 실행하면, 이 ExecutorService 이 호출해 측에는 변경이 허가되지 않는 thread를 조작할 수 있는 경우. 이것은,<A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> <tt>("modifyThread")</tt>를
 보관 유지하지 않는지, 시큐러티 매니저의 <tt>checkAccess</tt> 메서드가 액세스를 거부하기 위해이다</DL>
</DD>
</DL>
<HR>

<A NAME="shutdownNow()"><!-- --></A> <H3>
shutdownNow</H3>
<PRE>
public <A HREF="../../../java/util/List.html" title="java.util 내의 인터페이스">List</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt; <B>shutdownNow</B>()</PRE>
<DL>
<DD>실행중의 액티브한 태스크 모든 정지를 시도해 대기중의 태스크의 처리를 정지해, 실행을 대기하고 있던 태스크의 리스트를 돌려줍니다.
<p>이 구현은 <A HREF="../../../java/lang/Thread.html#interrupt()"><CODE>Thread.interrupt()</CODE></A> 를
 개입시켜 태스크를 취소합니다. 이 때문에
 몇개의 태스크가 마스크를 실행하는지, 인터럽트에의 응답에 실패하면, 그 태스크가 결코 종료하지 않게 될 가능성이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>실행이 개시되지 않았던 태스크의 리스트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재하는 상황으로 슛다운을 실행하면, 이 ExecutorService 이 호출해 측에는 변경이 허가되지 않는 thread를 조작할 수 있는 경우. 이것은,<A HREF="../../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> <tt>("modifyThread")</tt>를
 보관 유지하지 않는지, 시큐러티 매니저의 <tt>checkAccess</tt> 메서드가 액세스를 거부하기 위해이다</DL>
</DD>
</DL>
<HR>

<A NAME="isShutdown()"><!-- --></A> <H3>
isShutdown</H3>
<PRE>
public boolean <B>isShutdown</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isShutdown()">ExecutorService</A> </CODE>
 기술: </B></DD>
<DD>이 executor가 슛다운 했을 경우,<tt>true</tt>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 executor가 슛다운 했을 경우는 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="isTerminating()"><!-- --></A> <H3>
isTerminating</H3>
<PRE>
public boolean <B>isTerminating</B>()</PRE>
<DL>
<DD><tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 후에 이 executor 가 종료 처리를 실행중이지만, 완전하게 종료하고 있지 않는 경우, true를
 돌려줍니다. 이 메서드는
 디버그로 유용한 경우가 있습니다. 슛다운 후, 충분한 시간이 경과하고 나서 <tt>true</tt> 가 돌려주고졌을 경우, 송신된 태스크가 인터럽트를 무시했는지 억제했기 때문에
 이 executor 가 적정하게 종료하고 있지 않을 가능성이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>종료중이지만, 완료하고 있지 않는 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="isTerminated()"><!-- --></A> <H3>
isTerminated</H3>
<PRE>
public boolean <B>isTerminated</B>()</PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#isTerminated()">ExecutorService</A> </CODE>
 기술: </B></DD>
<DD>슛다운에 이어 모든 태스크가 완료했을 경우에
<tt>true</tt>를
 돌려줍니다. <tt>shutdown</tt> 또는 <tt>shutdownNow</tt> 가 최초로 불려 가지 않는 한,<tt>isTerminated</tt>는
 결코 <tt>true</tt> 로는 되지 않습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>슛다운에 이어 모든 태스크가 완료했을 경우에 <tt>true</tt></DL>
</DD>
</DL>
<HR>

<A NAME="awaitTermination(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
awaitTermination</H3>
<PRE>
public boolean <B>awaitTermination</B>(long&nbsp;timeout,
                                <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)
                         throws <A HREF="../../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD><B>인터페이스 <CODE><A HREF="../../../java/util/concurrent/ExecutorService.html#awaitTermination(long, java.util.concurrent.TimeUnit)">ExecutorService</A> </CODE>
 기술: </B></DD>
<DD>슛다운 요구 후에 모든 태스크가 실행을 완료하는
 타임 아웃이 발생하는
 현재의 thread로 인터럽트가 발생하는

 어떤 것인가가 최초로 일어날 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 대기하는 최장 시간<DD><CODE>unit</CODE> - timeout 인수의 시간 단위
<DT><B>반환값:</B><DD>이 executor 가 종료되는 경우는 <tt>true</tt>, 종료전에 타임 아웃이 경과했을 경우는 <tt>false</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 대기중에 인터럽트가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()</PRE>
<DL>
<DD>이 executor 가 참조되는 것이 없어졌을 경우에
<tt>shutdown</tt>를
 호출합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../../java/lang/Object.html#finalize()">finalize</A> </CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setThreadFactory(java.util.concurrent.ThreadFactory)"><!-- --></A> <H3>
setThreadFactory</H3>
<PRE>
public void <B>setThreadFactory</B>(<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 안의 인터페이스">ThreadFactory</A> &nbsp;threadFactory)</PRE>
<DL>
<DD>새로운 thread의 작성에 사용하는 thread 팩토리를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>threadFactory</CODE> - 새로운 thread 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - threadFactory 가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getThreadFactory()"><CODE>getThreadFactory()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getThreadFactory()"><!-- --></A> <H3>
getThreadFactory</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스">ThreadFactory</A>  <B>getThreadFactory</B>()</PRE>
<DL>
<DD>새로운 thread의 작성에 사용하는 thread 팩토리를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread 팩토리<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setThreadFactory(java.util.concurrent.ThreadFactory)"><CODE>setThreadFactory(java.util.concurrent.ThreadFactory)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><!-- --></A> <H3>
setRejectedExecutionHandler</H3>
<PRE>
public void <B>setRejectedExecutionHandler</B>(<A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 안의 인터페이스">RejectedExecutionHandler</A> &nbsp;handler)</PRE>
<DL>
<DD>실행 불가능한 태스크용의 새로운 핸들러를 설정합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>handler</CODE> - 새로운 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 핸들러가 null
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getRejectedExecutionHandler()"><CODE>getRejectedExecutionHandler()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getRejectedExecutionHandler()"><!-- --></A> <H3>
getRejectedExecutionHandler</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/RejectedExecutionHandler.html" title="java.util.concurrent 내의 인터페이스">RejectedExecutionHandler</A>  <B>getRejectedExecutionHandler</B>()</PRE>
<DL>
<DD>실행 불가능한 태스크용의 현재의 핸들러를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 핸들러<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)"><CODE>setRejectedExecutionHandler(java.util.concurrent.RejectedExecutionHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getQueue()"><!-- --></A> <H3>
getQueue</H3>
<PRE>
public <A HREF="../../../java/util/concurrent/BlockingQueue.html" title="java.util.concurrent 내의 인터페이스">BlockingQueue</A> &lt;<A HREF="../../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> &gt; <B>getQueue</B>()</PRE>
<DL>
<DD>이 executor 가 사용하는 태스크 큐를 돌려줍니다. 태스크 큐에의 액세스는
 주로 디버그 및 감시로 사용합니다. 이 큐는 액티브하게 사용되고 있을 가능성이 있습니다. 태스크 큐의 취득에
해, 큐에 넣어진 태스크의 실행을 방해할 수 있을 것은 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크 큐</DL>
</DD>
</DL>
<HR>

<A NAME="remove(java.lang.Runnable)"><!-- --></A> <H3>
remove</H3>
<PRE>
public boolean <B>remove</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;task)</PRE>
<DL>
<DD>이 태스크가 존재하는 경우, executor
 내부 큐로부터 삭제해, 아직 시작하고 있지 않으면 실행되지 않게 합니다.
<p> 이 메서드는
 취소 schema의 일부로서 유효하게 사용할 수 있습니다. 내부 큐에 배치되기 전에 다른 형식에 변환된 태스크는
 삭제에 실패하는 경우가 있습니다. 예를 들어,<tt>submit</tt>를
 사용해 입력된 태스크는
<tt>Future</tt> 상태를 유지하는 형식에 변환될 가능성이 있습니다. 다만, 이 경우는
<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#purge()"><CODE>purge()</CODE></A>  메서드를 사용해 이러한 삭제된 Future를
 삭제할 수 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 삭제하는 태스크
<DT><B>반환값:</B><DD>태스크가 삭제되었을 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="purge()"><!-- --></A> <H3>
purge</H3>
<PRE>
public void <B>purge</B>()</PRE>
<DL>
<DD>작업 큐로부터 삭제된 <A HREF="../../../java/util/concurrent/Future.html" title="java.util.concurrent 동안의 인터페이스"><CODE>Future</CODE></A>  태스크 모든 삭제를 시도합니다. 이 메서드는
 기능에 다른 영향을 미칠리가 없는 기억 영역의 재생 조작에 도움이 됩니다. 삭제된 태스크는 결코 실행됩니다만, 워카스렛드가 이것들을 액티브하게 삭제할 수 있게 될 때까지 작업 큐에 축적됩니다. 이 메서드를 호출하면, 그러한 삭제를 즉시 시도합니다. 다만, 다른 thread로부터의 간섭이 존재하는 경우, 이 메서드는 태스크의 삭제에 실패할 가능성이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setCorePoolSize(int)"><!-- --></A> <H3>
setCorePoolSize</H3>
<PRE>
public void <B>setCorePoolSize</B>(int&nbsp;corePoolSize)</PRE>
<DL>
<DD>thread의 코어수를 설정합니다. 이것은, 생성자
으로 설정된 값을 모두 오버라이드(override) 합니다. 새로운 값이 현재의 값보다 작은 경우, 초과하고 있는 기존의 thread는 아이돌 상태가 되면 종료합니다. 새로운 값이 현재의 값보다 큰 경우, 필요에 따라서 새로운 thread가 개시되어 큐에 넣어진 모든 태스크가 실행됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>corePoolSize</CODE> - 새로운 코어 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>corePoolSize</tt> 가 제로 미만의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>getCorePoolSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getCorePoolSize()"><!-- --></A> <H3>
getCorePoolSize</H3>
<PRE>
public int <B>getCorePoolSize</B>()</PRE>
<DL>
<DD>thread의 코어수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 코어수<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setCorePoolSize(int)"><CODE>setCorePoolSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="prestartCoreThread()"><!-- --></A> <H3>
prestartCoreThread</H3>
<PRE>
public boolean <B>prestartCoreThread</B>()</PRE>
<DL>
<DD>코어 thread를 개시해, 아이돌 상태로 대기시킵니다. 이것은, 새로운 태스크가 실행되는 경우에게만, 코어 thread 개시의 디폴트 폴리시를 오버라이드(override) 합니다. 모든 코어 thread가 벌써 개시되고 있는 경우, 이 메서드는
<tt>false</tt>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread가 개시되고 있었을 경우는 true</DL>
</DD>
</DL>
<HR>

<A NAME="prestartAllCoreThreads()"><!-- --></A> <H3>
prestartAllCoreThreads</H3>
<PRE>
public int <B>prestartAllCoreThreads</B>()</PRE>
<DL>
<DD>모든 코어 thread를 개시해, 아이돌 상태로 대기시킵니다. 이것은, 새로운 태스크의 실행시에게만, 코어 thread 개시의 디폴트 폴리시를 오버라이드(override) 합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>개시된 thread의 수</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"><!-- --></A> <H3>
setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;maximumPoolSize)</PRE>
<DL>
<DD>허가되는 thread의 최대수를 설정합니다. 이것은, 생성자내에서 설정된 모든 값을 오버라이드(override) 합니다. 새로운 값이 현재의 값보다 작은 경우, 초과한 기존의 thread는
 다음에 아이돌 상태가 되면 종료합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>maximumPoolSize</CODE> - 새로운 최대치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - maximumPoolSize 가 제로 미만 또는<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getCorePoolSize()"><CODE>코어 풀 사이즈</CODE></A>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getMaximumPoolSize()"><CODE>getMaximumPoolSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"><!-- --></A> <H3>
getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL>
<DD>허가되는 thread의 최대수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>허가되는 thread의 최대수<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setMaximumPoolSize(int)"><CODE>setMaximumPoolSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;time,
                             <A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</PRE>
<DL>
<DD>thread가 종료하기 전에 아이돌 상태에 머무르는 제한 시간을 설정합니다. 현재 풀내에 있는 thread의 코어수보다 thread가 많은 경우, 이 기간만 태스크를 처리하지 않고 대기한 후에
 초과한 thread가 종료합니다. 이것은, 생성자
으로 설정된 모든 값을 오버라이드(override) 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>time</CODE> - 대기 시간. 시간치가 제로의 경우, 초과한 thread는 태스크의 실행 후 즉시 종료하는<DD><CODE>unit</CODE> - time 인수의 시간 단위
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 시간이 제로 미만의 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#getKeepAliveTime(java.util.concurrent.TimeUnit)"><CODE>getKeepAliveTime(java.util.concurrent.TimeUnit)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime(java.util.concurrent.TimeUnit)"><!-- --></A> <H3>
getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>(<A HREF="../../../java/util/concurrent/TimeUnit.html" title="java.util.concurrent 안의 열거형">TimeUnit</A> &nbsp;unit)</PRE>
<DL>
<DD>thread의 킵얼라이브 시간을 돌려줍니다. 이것은, 코어 풀 사이즈를 초과한 thread가 종료하기 전에 아이돌 상태에 머무르는 기간입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>unit</CODE> - 기대되는 결과의 시간 단위
<DT><B>반환값:</B><DD>제한 시간<DT><B>관련 항목:</B><DD><A HREF="../../../java/util/concurrent/ThreadPoolExecutor.html#setKeepAliveTime(long, java.util.concurrent.TimeUnit)"><CODE>setKeepAliveTime(long, java.util.concurrent.TimeUnit)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPoolSize()"><!-- --></A> <H3>
getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL>
<DD>풀내의 현재의 thread수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 수</DL>
</DD>
</DL>
<HR>

<A NAME="getActiveCount()"><!-- --></A> <H3>
getActiveCount</H3>
<PRE>
public int <B>getActiveCount</B>()</PRE>
<DL>
<DD>태스크를 액티브하게 실행중의 thread의 개수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 수</DL>
</DD>
</DL>
<HR>

<A NAME="getLargestPoolSize()"><!-- --></A> <H3>
getLargestPoolSize</H3>
<PRE>
public int <B>getLargestPoolSize</B>()</PRE>
<DL>
<DD>지금까지 동시에 풀에 존재한 thread의 최대수를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>thread의 수</DL>
</DD>
</DL>
<HR>

<A NAME="getTaskCount()"><!-- --></A> <H3>
getTaskCount</H3>
<PRE>
public long <B>getTaskCount</B>()</PRE>
<DL>
<DD>실행이 스케줄 된 태스크의 대체로의 총수를 돌려줍니다. 태스크 및 thread 상태는 계산중에 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 값은 개산에 지나지 않습니다만, 일련의 호출을 통해서 감소할 것은 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크의 수</DL>
</DD>
</DL>
<HR>

<A NAME="getCompletedTaskCount()"><!-- --></A> <H3>
getCompletedTaskCount</H3>
<PRE>
public long <B>getCompletedTaskCount</B>()</PRE>
<DL>
<DD>실행이 완료한 태스크의 대체로의 총수를 돌려줍니다. 태스크 및 thread 상태는 계산중에 동적으로 변화할 가능성이 있기 때문에
 돌려주고지는 값은 개산에 지나지 않습니다만, 일련의 호출을 통해서 감소할 것은 없습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>태스크의 수</DL>
</DD>
</DL>
<HR>

<A NAME="beforeExecute(java.lang.Thread, java.lang.Runnable)"><!-- --></A> <H3>
beforeExecute</H3>
<PRE>
protected void <B>beforeExecute</B>(<A HREF="../../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> &nbsp;t,
                             <A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r)</PRE>
<DL>
<DD>지정된 thread내에서, 지정된 Runnable
 실행에 앞서 불려 가는 메서드. 이 메서드는
 태스크 <tt>r</tt>를
 실행하는 thread <tt>t</tt> 에
해 불려 가 ThreadLocals
 재초기화나 로그의 실행에 사용할 수 있습니다. 주: 복수의 오버라이드(override)를 적정하게 상자로 하기 때문에
 보통
, 서브 클래스는 이 메서드의 마지막에 <tt>super.beforeExecute</tt>를
 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>t</CODE> - 태스크 r를
 실행하는 thread<DD><CODE>r</CODE> - 실행되는 태스크</DL>
</DD>
</DL>
<HR>

<A NAME="afterExecute(java.lang.Runnable, java.lang.Throwable)"><!-- --></A> <H3>
afterExecute</H3>
<PRE>
protected void <B>afterExecute</B>(<A HREF="../../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;r,
                            <A HREF="../../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;t)</PRE>
<DL>
<DD>지정된 Runnable
 실행 완료시에 불려 가는 메서드. 이 메서드는
 태스크를 실행한 thread에
해 불려 갑니다. null 이외의 경우, Throwable는
 실행을 돌연에 종료시킨 캐치 되지 않는 예외입니다. 주: 복수의 오버라이드(override)를 적절히 상자로 하기 때문에
 보통
, 서브 클래스는 이 메서드의 최초로 <tt>super.afterExecute</tt>를
 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>r</CODE> - 완료한 runnable<DD><CODE>t</CODE> - 종료의 원인이 된 예외. 실행이 정상적으로 완료했을 경우는 null</DL>
</DD>
</DL>
<HR>

<A NAME="terminated()"><!-- --></A> <H3>
terminated</H3>
<PRE>
protected void <B>terminated</B>()</PRE>
<DL>
<DD>Executor 가 종료되었을 때에 불려 가는 메서드. 디폴트 구현은, 아무것도 실행하지 않습니다. 주: 복수의 오버라이드(override)를 적정하게 상자로 하기 때문에
 보통
, 서브 클래스는 이 메서드내에서 <tt>super.terminated</tt>를
 호출할 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ThreadPoolExecutor.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/util/concurrent/ThreadFactory.html" title="java.util.concurrent 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/util/concurrent/ThreadPoolExecutor.AbortPolicy.html" title="java.util.concurrent 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/util/concurrent/ThreadPoolExecutor.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ThreadPoolExecutor.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

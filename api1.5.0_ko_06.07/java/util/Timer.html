<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:58:43 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Timer (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.util.Timer class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Timer (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Timer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/util/StringTokenizer.html" title="java.util 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/TimerTask.html" title="java.util 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/util/Timer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Timer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.util</FONT>
<BR>
클래스 Timer</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.util.Timer</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Timer</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
백그라운드 thread로 장래 실행되는 태스크를 스케줄 하는
 thread를 위한 기능입니다. 태스크는
 1 회만, 또는 정기적으로 반복해 실행되도록 스케줄 됩니다.

<p>각 <tt>Timer</tt> 오브젝트와 대응하는 것은, 타이머의 태스크를 모두 연속해 실행하기 위해서 사용되는
 단일의 백그라운드 thread입니다. 타이머 태스크는 신속히 실행될 필요가 있습니다. 타이머 태스크의 완료에 시간이 너무 걸리면, 타이머의 태스크 실행 thread가 「점유」됩니다. 이것에
해 후속의 태스크의 실행이 늦어 위반한 태스크의 완료시 (완료했을 경우)에
 연달아 「정리하며」실행되게 됩니다.

<p><tt>Timer</tt> 오브젝트의 마지막 라이브 참조가 종료해, 미처리의 태스크가 모두 실행되면, 타이머의 태스크 실행 thread도 동시에 완료해, 가비지 컬렉트됩니다. 다만, 이것에는 한없고 긴 시간이 걸리는 경우가 있습니다. 디폴트에서는
 태스크의 실행 thread는 「demon thread」로서는 실행되지 않기 때문에
 어플리케이션이 종료하지 않게 할 수 있습니다. 타이머의 태스크 실행 thread를 즉시 완료시키는 경우, 호출측은 타이머의 <tt>cancel</tt> 메서드를 호출할 필요가 있습니다.

<p><tt>stop</tt> 메서드의 호출등에
해 타이머의 태스크 실행 thread가 예상외의 시간에 종료했을 경우, 타이머의 태스크를 스케줄 하려고 하면, 타이머의 <tt>cancel</tt> 메서드가 불려 갔을 경우와 같게,<tt>IllegalStateException</tt> 가 발생합니다.

<p>이 클래스는 thread 세이프입니다. 외부의 동기화를 실시하지 않아도, 복수의 thread로 단일의 <tt>Timer</tt> 오브젝트를 공유할 수 있습니다.

<p>이 클래스에서는
 리얼타임은 보증되지 않습니다. <tt>Object.wait(long)</tt> 메서드를 사용해, 태스크가 스케줄 됩니다.

<p>구현상의 주의: 이 클래스는
 동시에 스케줄 된 다수의 태스크를 슬캘링 합니다 (수천에서도 문제는 없다). 태스크 큐를 나타내기 위해서 바이너리 heap가 내부적으로 사용되기 때문에
 태스크를 스케줄 하는 코스트는 O(log n)가 됩니다. n는

 동시에 스케줄 된 태스크의 수입니다.

<p>구현상의 주의: 모든 생성자는 타이머 thread를 개시합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/util/TimerTask.html" title="java.util 내의 클래스"><CODE>TimerTask</CODE></A>,
 
<A HREF="../../java/lang/Object.html#wait(long)"><CODE>Object.wait(long)</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/Timer.html#Timer()">Timer</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 타이머를 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/Timer.html#Timer(boolean)">Timer</A> </B>(boolean&nbsp;isDaemon)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;demon로서 실행되도록 지정할 수 있는 관련 thread를 가지는
 새로운 타이머가 작성됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/Timer.html#Timer(java.lang.String)">Timer</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름의 관련된 thread를 가지는 새로운 타이머가 작성됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/util/Timer.html#Timer(java.lang.String, boolean)">Timer</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
      boolean&nbsp;isDaemon)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 이름의 관련된 thread를 가지는 새로운 타이머가 작성됩니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#cancel()">cancel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 스케줄 되고 있는 태스크를 파기해, 이 타이머를 종료합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#purge()">purge</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;삭제된 모든 태스크를, 이 타이머의 태스크 큐로부터 삭제합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#schedule(java.util.TimerTask, java.util.Date)">schedule</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
         <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;time)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 시간으로 지정한 태스크가 실행되도록 스케줄 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#schedule(java.util.TimerTask, java.util.Date, long)">schedule</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
         <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;firstTime,
         long&nbsp;period)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 태스크가, 지정한 시간에 개시되어 「고정 지연 실행」을 반복하도록 스케줄 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#schedule(java.util.TimerTask, long)">schedule</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
         long&nbsp;delay)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 지연의 후에
 지정한 태스크가 실행되도록 스케줄 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#schedule(java.util.TimerTask, long, long)">schedule</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
         long&nbsp;delay,
         long&nbsp;period)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 태스크가, 지정한 지연의 후에 개시되어 「고정 지연 실행」을 반복하도록 스케줄 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)">scheduleAtFixedRate</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                    <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;firstTime,
                    long&nbsp;period)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 태스크가, 지정한 시간에 개시되어 「고정 빈도 실행」을 반복하도록 스케줄 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/util/Timer.html#scheduleAtFixedRate(java.util.TimerTask, long, long)">scheduleAtFixedRate</A> </B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                    long&nbsp;delay,
                    long&nbsp;period)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정한 태스크가, 지정한 지연의 후에 개시되어 「고정 빈도 실행」을 반복하도록 스케줄 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Timer()"><!-- --></A> <H3>
Timer</H3>
<PRE>
public <B>Timer</B>()</PRE>
<DL>
<DD>새로운 타이머를 작성합니다. 관련된 thread는
 demon로서는 실행되지 않습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스"><CODE>Thread</CODE></A>,
 
<A HREF="../../java/util/Timer.html#cancel()"><CODE>cancel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="Timer(boolean)"><!-- --></A> <H3>
Timer</H3>
<PRE>
public <B>Timer</B>(boolean&nbsp;isDaemon)</PRE>
<DL>
<DD>demon로서 실행되도록 지정할 수 있는 관련 thread를 가지는
 새로운 타이머가 작성됩니다. demon thread는
 타이머가 「보수 작업」의 반복을 스케줄 하기 위해서 사용되는 경우에 불려 갑니다. 이것은, 어플리케이션이 실행되고 있는 동안 실행될 필요가 있습니다만, 어플리케이션의 수명을 지연시킬 수 없습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>isDaemon</CODE> - 관련된 thread가 demon로서 실행되는 경우는 true<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스"><CODE>Thread</CODE></A>,
 
<A HREF="../../java/util/Timer.html#cancel()"><CODE>cancel()</CODE></A> </DL>
</DL>
<HR>

<A NAME="Timer(java.lang.String)"><!-- --></A> <H3>
Timer</H3>
<PRE>
public <B>Timer</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>지정된 이름의 관련된 thread를 가지는 새로운 타이머가 작성됩니다. 관련된 thread는
 demon로서는 실행되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 관련된 thread의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 이름이 null
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getName()"><CODE>Thread.getName()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#isDaemon()"><CODE>Thread.isDaemon()</CODE></A> </DL>
</DL>
<HR>

<A NAME="Timer(java.lang.String, boolean)"><!-- --></A> <H3>
Timer</H3>
<PRE>
public <B>Timer</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
             boolean&nbsp;isDaemon)</PRE>
<DL>
<DD>지정된 이름의 관련된 thread를 가지는 새로운 타이머가 작성됩니다. 관련된 thread는
 demon로서의 실행이 지정되는 경우가 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 관련된 thread의 이름<DD><CODE>isDaemon</CODE> - 관련된 thread가 demon로서 실행되는 경우는 true
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 이름이 null
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getName()"><CODE>Thread.getName()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#isDaemon()"><CODE>Thread.isDaemon()</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="schedule(java.util.TimerTask, long)"><!-- --></A> <H3>
schedule</H3>
<PRE>
public void <B>schedule</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                     long&nbsp;delay)</PRE>
<DL>
<DD>지정한 지연의 후에
 지정한 태스크가 실행되도록 스케줄 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>delay</CODE> - 태스크가 실행되기 전의 밀리 세컨드 단위의 지연
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>delay</tt> 가 부의 값의 경우, 또는 <tt>delay + System.currentTimeMillis()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 또는 타이머가 삭제되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="schedule(java.util.TimerTask, java.util.Date)"><!-- --></A> <H3>
schedule</H3>
<PRE>
public void <B>schedule</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                     <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;time)</PRE>
<DL>
<DD>지정한 시간으로 지정한 태스크가 실행되도록 스케줄 합니다. 과거의 시간을 지정하면, 태스크는 즉시 실행되도록 스케줄 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>time</CODE> - 태스크가 실행되는 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>time.getTime()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 타이머가 삭제되었을 경우, 또는 타이머 thread가 종료했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="schedule(java.util.TimerTask, long, long)"><!-- --></A> <H3>
schedule</H3>
<PRE>
public void <B>schedule</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                     long&nbsp;delay,
                     long&nbsp;period)</PRE>
<DL>
<DD>지정한 태스크가, 지정한 지연의 후에 개시되어 「고정 지연 실행」을 반복하도록 스케줄 합니다. 그 후는
 지정한 기간과는 별도로 거의 일정한 간격으로 실행됩니다.

<p>고정 지연 실행에서는
 전의 실행의 실제의 실행 시간을 기준으로 해 각각의 실행이 스케줄 됩니다. 어떠한 이유로써 실행이 지연 했을 경우 (가비지 컬렉션, 그 외의 백그라운드 작업 등), 그 후의 실행도 지연 됩니다. 최종적으로 실행의 빈도는 보통
, 지정한 기간의 대응하는 빈도보다 약간 늦어집니다 (기본이 되는 <tt>Object.wait(long)</tt>를
 지지하고 있는 시스템 클록이 정확이라고 하는 전제로).

<p>고정 지연 실행은, 「원활함」을 필요로 하는 작업의 반복에 적절하고 있습니다. 즉, 장시간의 실행보다 단시간의 실행으로 빈도의 정확함을 유지할 필요가 있는 작업에 적절하고 있습니다. 이것에는
 일정한 간격으로 커서를 점멸시키는 등, 대부분의 애니메이션 태스크가 포함됩니다. 또, 키가 밀리고 있는 동안은 문자를 자동적으로 반복하는 등, 유저의 입력에 응해 일정한 활동이 실행되는 태스크도 포함됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>delay</CODE> - 태스크가 실행되기 전의 밀리 세컨드 단위의 지연<DD><CODE>period</CODE> - 연속하는 태스크 실행의 밀리 세컨드 단위의 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>delay</tt> 가 부의 값의 경우, 또는 <tt>delay + System.currentTimeMillis()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 타이머가 삭제되었을 경우, 또는 타이머 thread가 종료했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="schedule(java.util.TimerTask, java.util.Date, long)"><!-- --></A> <H3>
schedule</H3>
<PRE>
public void <B>schedule</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                     <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;firstTime,
                     long&nbsp;period)</PRE>
<DL>
<DD>지정한 태스크가, 지정한 시간에 개시되어 「고정 지연 실행」을 반복하도록 스케줄 합니다. 그 후는
 지정한 기간과는 별도로 거의 일정한 간격으로 실행됩니다.

<p>고정 지연 실행에서는
 전의 실행의 실제의 실행 시간을 기준으로 해 각각의 실행이 스케줄 됩니다. 어떠한 이유로써 실행이 지연 했을 경우 (가비지 컬렉션, 그 외의 백그라운드 작업 등), 그 후의 실행도 지연 됩니다. 최종적으로 실행의 빈도는 보통
, 지정한 기간의 대응하는 빈도보다 약간 늦어집니다 (기본이 되는 <tt>Object.wait(long)</tt>를
 지지하고 있는 시스템 클록이 정확이라고 하는 전제로).

<p>고정 지연 실행은, 「원활함」을 필요로 하는 작업의 반복에 적절하고 있습니다. 즉, 장시간의 실행보다 단시간의 실행으로 빈도의 정확함을 유지할 필요가 있는 작업에 적절하고 있습니다. 이것에는
 일정한 간격으로 커서를 점멸시키는 등, 대부분의 애니메이션 태스크가 포함됩니다. 또, 키가 밀리고 있는 동안은 문자를 자동적으로 반복하는 등, 유저의 입력에 응해 일정한 활동이 실행되는 태스크도 포함됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>firstTime</CODE> - 태스크가 실행되는 최초의 시간<DD><CODE>period</CODE> - 연속하는 태스크 실행의 밀리 세컨드 단위의 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>time.getTime()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 타이머가 삭제되었을 경우, 또는 타이머 thread가 종료했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleAtFixedRate(java.util.TimerTask, long, long)"><!-- --></A> <H3>
scheduleAtFixedRate</H3>
<PRE>
public void <B>scheduleAtFixedRate</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                                long&nbsp;delay,
                                long&nbsp;period)</PRE>
<DL>
<DD>지정한 태스크가, 지정한 지연의 후에 개시되어 「고정 빈도 실행」을 반복하도록 스케줄 합니다. 그 후는
 지정한 기간과는 별도로 거의 일정한 간격으로 실행됩니다.

<p>고정 빈도 실행에서는
 최초의 실행의 스케줄 된 실행 시간을 기준으로 해 각각의 실행이 스케줄 됩니다. 어떠한 이유로써 실행이 지연 했을 경우 (가비지 컬렉션 또는 그 외의 백그라운드 작업 등), 「지연을 되찾는다」위해 2 개 이상의 실행이 연속해 행해집니다. 최종적으로 실행의 빈도는
 지정한 기간의 대응하는 빈도와 같게 됩니다 (기본이 되는 <tt>Object.wait(long)</tt>를
 지지하고 있는 시스템 클록이 정확이라고 하는 전제로).

<p>고정 빈도 실행은, 1 시간 마다에 차임을 울리거나 특정의 시간에 매일 스케줄 된 보수를 실행하는 등, 「절대」시간을 반영하는 작업을 반복하는데 적합합니다. 또, 10 초 마다 새겨지는 카운트다운 타이머 등, 정해진 수의 실행의 합계 시간이 중요한 작업을 반복하는데도 적합합니다. 게다가 고정 빈도 실행은, 서로 동기화를 보관 유지할 필요가 있는 복수의 반복 타이머 태스크를 스케줄 하는데도 적합합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>delay</CODE> - 태스크가 실행되기 전의 밀리 세컨드 단위의 지연<DD><CODE>period</CODE> - 연속하는 태스크 실행의 밀리 세컨드 단위의 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>delay</tt> 가 부의 값의 경우, 또는 <tt>delay + System.currentTimeMillis()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 타이머가 삭제되었을 경우, 또는 타이머 thread가 종료했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="scheduleAtFixedRate(java.util.TimerTask, java.util.Date, long)"><!-- --></A> <H3>
scheduleAtFixedRate</H3>
<PRE>
public void <B>scheduleAtFixedRate</B>(<A HREF="../../java/util/TimerTask.html" title="java.util 안의 클래스">TimerTask</A> &nbsp;task,
                                <A HREF="../../java/util/Date.html" title="java.util 안의 클래스">Date</A> &nbsp;firstTime,
                                long&nbsp;period)</PRE>
<DL>
<DD>지정한 태스크가, 지정한 시간에 개시되어 「고정 빈도 실행」을 반복하도록 스케줄 합니다. 그 후는
 지정한 기간과는 별도로 거의 일정한 간격으로 실행됩니다.

<p>고정 빈도 실행에서는
 최초의 실행의 스케줄 된 실행 시간을 기준으로 해 각각의 실행이 스케줄 됩니다. 어떠한 이유로써 실행이 지연 했을 경우 (가비지 컬렉션 또는 그 외의 백그라운드 작업 등), 「지연을 되찾는다」위해 2 개 이상의 실행이 연속해 행해집니다. 최종적으로 실행의 빈도는
 지정한 기간의 대응하는 빈도와 같게 됩니다 (기본이 되는 <tt>Object.wait(long)</tt>를
 지지하고 있는 시스템 클록이 정확이라고 하는 전제로).

<p>고정 빈도 실행은, 1 시간 마다에 차임을 울리거나 특정의 시간에 매일 스케줄 된 보수를 실행하는 등, 「절대」시간을 반영하는 작업을 반복하는데 적합합니다. 또, 10 초 마다 새겨지는 카운트다운 타이머 등, 정해진 수의 실행의 합계 시간이 중요한 작업을 반복하는데도 적합합니다. 게다가 고정 빈도 실행은, 서로 동기화를 보관 유지할 필요가 있는 복수의 반복 타이머 태스크를 스케줄 하는데도 적합합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>task</CODE> - 스케줄 되는 태스크<DD><CODE>firstTime</CODE> - 태스크가 실행되는 최초의 시간<DD><CODE>period</CODE> - 연속하는 태스크 실행의 밀리 세컨드 단위의 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <tt>time.getTime()</tt> 가 부의 값의 경우
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 태스크가 벌써 스케줄 되었는지 삭제되었을 경우, 타이머가 삭제되었을 경우, 또는 타이머 thread가 종료했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="cancel()"><!-- --></A> <H3>
cancel</H3>
<PRE>
public void <B>cancel</B>()</PRE>
<DL>
<DD>현재 스케줄 되고 있는 태스크를 파기해, 이 타이머를 종료합니다. 현재 실행중의 태스크 (있는 경우)에는 간섭하지 않습니다. 타이머가 종료하면, 실행 thread도 동시에 종료해, 태스크는 스케줄 되지 않게 됩니다.

<p>이 타이머에
해 불려 간 타이머 태스크의 실행 메서드로부터 이 메서드를 호출하면, 진행중의 태스크 실행은, 이 타이머에 실행되는 마지막 태스크 실행이 됩니다.

<p>이 메서드는
 반복해 불려 갑니다. 2 번째 이후의 호출에는
 효과는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="purge()"><!-- --></A> <H3>
purge</H3>
<PRE>
public int <B>purge</B>()</PRE>
<DL>
<DD>삭제된 모든 태스크를, 이 타이머의 태스크 큐로부터 삭제합니다. 이 메서드를 호출해도 타이머의 동작은 영향을 받지 않습니다만, 삭제된 태스크에의 참조를 큐로부터 배제합니다. 이러한 태스크에의 외부 참조가 존재하지 않는 경우, 태스크는 가비지 컬렉션의 대상이 됩니다.

<p>대부분의 프로그램은, 이 메서드를 호출할 필요는 없습니다. 이 메서드를 사용하는 것은, 다수의 태스크를 취소할 필요가 있는 어플리케이션이며, 그러한 어플리케이션은 좀처럼 존재하지 않습니다. 이 메서드를 호출하면, 처리 시간부터 메모리 효율이 우선되기 때문에
 메서드의 런타임이 n + c log n 에 비례하는 경우가 있습니다. 여기서, n는
 큐내의 태스크의 수, c는
 삭제된 태스크의 수를 나타냅니다.

<p>이 타이머에 스케줄 된 태스크내로부터, 이 메서드를 호출할 수가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>큐로부터 삭제된 태스크의 수<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Timer.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/util/StringTokenizer.html" title="java.util 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/util/TimerTask.html" title="java.util 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/util/Timer.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Timer.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

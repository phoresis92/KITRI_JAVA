<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:57:16 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Socket (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.net.Socket class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Socket (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Socket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/net/ServerSocket.html" title="java.net 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/net/Socket.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Socket.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.net</FONT>
<BR>
클래스 Socket</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.net.Socket</B>
</PRE>
<DL>
<DT><B>직계의 기존의 서브 클래스: </B> <DD><A HREF="../../javax/net/ssl/SSLSocket.html" title="javax.net.ssl 내의 클래스">SSLSocket</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Socket</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </DL>
</PRE>

<P>
이 클래스는
 클라이언트 소켓 (단지 「소켓」이라고도 부른다)을 구현합니다. 소켓과는 2 개의 머신간의 통신의 양단에 위치하는 것입니다.
 <p>
소켓의 실제의 처리는 <code>SocketImpl</code> 클래스의 인스턴스가 실시합니다. 어플리케이션은, 소켓을 작성하는 소켓 팩토리를 변경하는 것에
해, 로컬의 방화벽(fire wall)에 적절한 소켓을 작성하도록, 어플리케이션 자신을 구성할 수 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A>,
 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>,
 
<A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 안의 클래스"><CODE>SocketChannel</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket()">Socket</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시스템으로 디폴트가 되어 있는 타입의 SocketImpl를
 사용해, 접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
       int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림 소켓을 작성해, 지정된 IP 주소의 지정된 포트 번호에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int, boolean)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;host,
       int&nbsp;port,
       boolean&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.InetAddress, int, java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
       int&nbsp;port,
       <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
       int&nbsp;localPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 작성해, 지정된 리모트 포트상의 지정된 리모트 주소에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.Proxy)">Socket</A> </B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(존재하는 경우는) 다른 설정에 관계없이 사용하는 프록시의 타입을 지정해, 접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.net.SocketImpl)">Socket</A> </B>(<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스">SocketImpl</A> &nbsp;impl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;유저가 지정한 SocketImpl를
 사용해, 접속되어 있지 않은 소켓을 작성합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int, boolean)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port,
       boolean&nbsp;stream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#Socket(java.lang.String, int, java.net.InetAddress, int)">Socket</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
       int&nbsp;port,
       <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
       int&nbsp;localPort)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 작성해, 지정된 리모트 포트상의 지정된 리모트 호스트에게 접속합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)">bind</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;bindpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓을 로컬 주소에 바인드 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress)">connect</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 서버에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress, int)">connect</A> </B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint,
        int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 타임 아웃치를 사용해 이 소켓을 서버에 접속합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getChannel()">getChannel</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓에 관련된 고유 <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 중의 클래스"><CODE>SocketChannel</CODE></A>  오브젝트를 돌려줍니다 (존재하는 경우). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getInetAddress()">getInetAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 접속처의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getInputStream()">getInputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 입력 스트림을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getKeepAlive()">getKeepAlive</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_KEEPALIVE 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalAddress()">getLocalAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 바인드처의 로컬 주소를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalPort()">getLocalPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 바인드처의 로컬 포트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getLocalSocketAddress()">getLocalSocketAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 바인드 되고 있는 단 점의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getOOBInline()">getOOBInline</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OOBINLINE 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getOutputStream()">getOutputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 출력 스트림을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getPort()">getPort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 접속처의 리모트 포트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getReceiveBufferSize()">getReceiveBufferSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 로 사용되는 SO_RCVBUF 옵션의 값을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getRemoteSocketAddress()">getRemoteSocketAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓이 접속되고 있는 단 점의 주소를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getReuseAddress()">getReuseAddress</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_REUSEADDR 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSendBufferSize()">getSendBufferSize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 <tt>Socket</tt> 로 사용되는 SO_SNDBUF 옵션의 값을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSoLinger()">getSoLinger</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_LINGER
 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getSoTimeout()">getSoTimeout</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_TIMEOUT
 설정을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getTcpNoDelay()">getTcpNoDelay</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP_NODELAY 가 유효한가 어떤가를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#getTrafficClass()">getTrafficClass</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스형을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isBound()">isBound</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 바인딩 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isClosed()">isClosed</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓이 닫은 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isConnected()">isConnected</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓의 접속 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isInputShutdown()">isInputShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 접속의 독해측의 반이 닫고 있는지 어떤지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#isOutputShutdown()">isOutputShutdown</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓 접속의 기입측의 반이 닫고 있는지 어떤지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#sendUrgentData(int)">sendUrgentData</A> </B>(int&nbsp;data)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;소켓상의 1 바이트의 긴급 데이터를 송신합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setKeepAlive(boolean)">setKeepAlive</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_KEEPALIVE를
 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setOOBInline(boolean)">setOOBInline</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OOBINLINE (TCP 긴급 데이터의 수신)를 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setPerformancePreferences(int, int, int)">setPerformancePreferences</A> </B>(int&nbsp;connectionTime,
                          int&nbsp;latency,
                          int&nbsp;bandwidth)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 퍼포먼스 설정을 실시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setReceiveBufferSize(int)">setReceiveBufferSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_RCVBUF 옵션을, 이 <tt>Socket</tt> 로 지정된 값으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setReuseAddress(boolean)">setReuseAddress</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_REUSEADDR 소켓 옵션을 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSendBufferSize(int)">setSendBufferSize</A> </B>(int&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SO_SNDBUF 옵션을, 이 <tt>Socket</tt> 로 지정된 값으로 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)">setSocketImplFactory</A> </B>(<A HREF="../../java/net/SocketImplFactory.html" title="java.net 안의 인터페이스">SocketImplFactory</A> &nbsp;fac)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;어플리케이션의 클라이언트 소켓 구현 팩토리를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)">setSoLinger</A> </B>(boolean&nbsp;on,
            int&nbsp;linger)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 지연 시간 (초단위)으로 SO_LINGER를
 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setSoTimeout(int)">setSoTimeout</A> </B>(int&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 타임 아웃 (밀리 세컨드 단위)을 사용해, SO_TIMEOUT를
 유효 또는 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setTcpNoDelay(boolean)">setTcpNoDelay</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TCP_NODELAY를
 유효 또는 무효로 합니다 (Nagle
 알고리즘의 유효, 무효의 변환). </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#setTrafficClass(int)">setTrafficClass</A> </B>(int&nbsp;tc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Socket 로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스형 8중창을 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#shutdownInput()">shutdownInput</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 입력 스트림을 「스트림의 최후」에 배치합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#shutdownOutput()">shutdownOutput</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓의 출력 스트림을 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/net/Socket.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 소켓을 <code>String</code> 로 변환합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Socket()"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>()</PRE>
<DL>
<DD>시스템으로 디폴트가 되어 있는 타입의 SocketImpl를
 사용해, 접속되어 있지 않은 소켓을 작성합니다.
<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DL>
<HR>

<A NAME="Socket(java.net.Proxy)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스">Proxy</A> &nbsp;proxy)</PRE>
<DL>
<DD>(존재하는 경우는) 다른 설정에 관계없이 사용하는 프록시의 타입을 지정해, 접속되어 있지 않은 소켓을 작성합니다.
<P>
 시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 프록시 호스트 주소와 포트 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
 례:
<UL> 
 <LI><code>Socket s = new Socket(Proxy.NO_PROXY);</code> 에서는
 다른 프록시 구성을 무시해, 프레인인 소켓이 작성된다</LI> 
 <LI><code>Socket s = new Socket(new Proxy(Proxy.Type.SOCKS, new InetSocketAddress("socks.mydom.com", 1080)));</code> 에서는
 지정된 SOCKS 프록시 서버를 개입시켜 접속하는 소켓이 작성된다</LI> 
</UL>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>proxy</CODE> - 사용하는 프록시의 종류를 지정하는 <A HREF="../../java/net/Proxy.html" title="java.net 동안의 클래스"><CODE>Proxy</CODE></A>  오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 프록시의 형태가 무효 또는 <code>null</code> 인 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 프록시에의 접속의 액세스권이 거부되었을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/ProxySelector.html" title="java.net 내의 클래스"><CODE>ProxySelector</CODE></A>,
 
<A HREF="../../java/net/Proxy.html" title="java.net 안의 클래스"><CODE>Proxy</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.SocketImpl)"><!-- --></A> <H3>
Socket</H3>
<PRE>
protected <B>Socket</B>(<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스">SocketImpl</A> &nbsp;impl)
          throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>유저가 지정한 SocketImpl를
 사용해, 접속되어 있지 않은 소켓을 작성합니다.  
<P>
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>impl</CODE> - 서브 클래스가 Socket 상에서 사용하는 <B>SocketImpl</B>
 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
              int&nbsp;port)
       throws <A HREF="../../java/net/UnknownHostException.html" title="java.net 내의 클래스">UnknownHostException</A>,

              <A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다.
 <p>
지정된 호스트가 <tt>null</tt>
 경우, 이것은 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 로서 주소를 지정하는 것과 같습니다. 즉, 루프백 인터페이스의 주소를 지정하는 것으로 같습니다. </p>
 <p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는
 그 팩토리의 <code>createSocketImpl</code> 메서드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.
 <p>
시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 호스트 주소와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 호스트명. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/UnknownHostException.html" title="java.net 안의 클래스">UnknownHostException</A> </CODE> - 호스트의 IP 주소를 판정할 수 없었던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A>,
 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>,
 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
              int&nbsp;port)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림 소켓을 작성해, 지정된 IP 주소의 지정된 포트 번호에 접속합니다.
 <p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는
 그 팩토리의 <code>createSocketImpl</code> 메서드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.
 <p>
시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 호스트 주소와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - IP 주소<DD><CODE>port</CODE> - 포트 번호
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A>,
 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>,
 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
              int&nbsp;port,
              <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
              int&nbsp;localPort)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 작성해, 지정된 리모트 포트상의 지정된 리모트 호스트에게 접속합니다. 소켓은, 지정된 로컬 주소와 포트에 바인드 됩니다.
 <p>
지정된 호스트가 <tt>null</tt> 인 경우, 이것은 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 로서 주소를 지정하는 것과 같습니다. 즉, 루프백 인터페이스의 주소를 지정하는 것으로 같습니다. </p>
 <p>
시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 호스트 주소와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 리모트 호스트명. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 리모트 포트<DD><CODE>localAddr</CODE> - 소켓의 바인드처의 로컬 주소<DD><CODE>localPort</CODE> - 소켓의 바인드처의 로컬 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, java.net.InetAddress, int)"><!-- --></A> <H3>
Socket</H3>
<PRE>
public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;address,
              int&nbsp;port,
              <A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;localAddr,
              int&nbsp;localPort)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 작성해, 지정된 리모트 포트상의 지정된 리모트 주소에 접속합니다. 소켓은, 지정된 로컬 주소와 포트에 바인드 됩니다.
 <p>
시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 호스트 주소와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>address</CODE> - 리모트 주소<DD><CODE>port</CODE> - 리모트 포트<DD><CODE>localAddr</CODE> - 소켓의 바인드처의 로컬 주소<DD><CODE>localPort</CODE> - 소켓의 바인드처의 로컬 포트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.lang.String, int, boolean)"><!-- --></A> <H3>
Socket</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <B>Socket</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;host,
                         int&nbsp;port,
                         boolean&nbsp;stream)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I>
<P>
<DD>스트림 소켓을 작성해, 지정된 호스트상의 지정된 포트 번호에 접속합니다.
 <p>
지정된 호스트가 <tt>null</tt> 인 경우, 이것은 <tt><A HREF="../../java/net/InetAddress.html#getByName(java.lang.String)"><CODE>InetAddress.getByName</CODE></A> (null)</tt> 로서 주소를 지정하는 것과 같습니다. 즉, 루프백 인터페이스의 주소를 지정하는 것으로 같습니다. </p>
 <p>
stream 인수에 <code>true</code>를
 지정하면, 스트림 소켓이 작성됩니다. stream 인수에 <code>false</code>를
 지정하면, 데이터 그램 소켓이 작성됩니다.
 <p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는
 그 팩토리의 <code>createSocketImpl</code> 메서드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.
 <p>
시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 가, 인수로서 호스트 주소와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
 <p>
UDP 소켓을 사용하는 경우, TCP/IP 에 관련된 소켓 옵션은 적용되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - 호스트명. 루프백 주소의 경우는 <code>null</code><DD><CODE>port</CODE> - 포트 번호<DD><CODE>stream</CODE> - 스트림 소켓이나 데이터 그램 소켓인지를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A>,
 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>,
 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Socket(java.net.InetAddress, int, boolean)"><!-- --></A> <H3>
Socket</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <B>Socket</B>(<A HREF="../../java/net/InetAddress.html" title="java.net 안의 클래스">InetAddress</A> &nbsp;host,
                         int&nbsp;port,
                         boolean&nbsp;stream)
       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>UDP 전송은 아니고 DatagramSocket를
 사용해 주세요. </I>
<P>
<DD>소켓을 작성해, 지정된 IP 주소에 있는 지정된 포트 번호에 접속합니다.
 <p>
stream 인수에 <code>true</code>를
 지정하면, 스트림 소켓이 작성됩니다. stream 인수에 <code>false</code>를
 지정하면, 데이터 그램 소켓이 작성됩니다.
 <p>
어플리케이션으로 서버 소켓 팩토리를 지정하고 있는 경우는
 그 팩토리의 <code>createSocketImpl</code> 메서드가 불려 가 실제의 소켓이 작성됩니다. 그렇지 않은 경우는 「프레인인」소켓이 작성됩니다.  
<p>시큐러티 매니저가 존재하는 경우, 시큐러티 매니저의 <code>checkConnect</code> 메서드가, 인수로서 <code>host.getHostAddress()</code> 와 <code>port</code> 번호를 지정해 불려 갑니다. 이 결과, SecurityException 가 되는 일이 있습니다.
 <p>
UDP 소켓을 사용하는 경우, TCP/IP 에 관련된 소켓 옵션은 적용되지 않습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>host</CODE> - IP 주소<DD><CODE>port</CODE> - 포트 번호<DD><CODE>stream</CODE> - <code>true</code>를
 지정했을 경우는 스트림 소켓이 작성되어 그렇지 않은 경우는 데이터 그램 소켓이 작성된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓의 작성중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkConnect</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSocketImplFactory(java.net.SocketImplFactory)"><CODE>setSocketImplFactory(java.net.SocketImplFactory)</CODE></A>,
 
<A HREF="../../java/net/SocketImpl.html" title="java.net 안의 클래스"><CODE>SocketImpl</CODE></A>,
 
<A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkConnect(java.lang.String, int)"><CODE>SecurityManager.checkConnect(java.lang.String, int)</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="connect(java.net.SocketAddress)"><!-- --></A> <H3>
connect</H3>
<PRE>
public void <B>connect</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint)
             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓을 서버에 접속합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>endpoint</CODE> - <code>SocketAddress</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 접속시에 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스">IllegalBlockingModeException</A> </CODE> - 이 소켓에 관련된 채널이 존재해, 그 채널이 비블로킹 모드의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 단 점이 null 인 경우, 또는 단 점이 이 소켓으로 서포트되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="connect(java.net.SocketAddress, int)"><!-- --></A> <H3>
connect</H3>
<PRE>
public void <B>connect</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;endpoint,
                    int&nbsp;timeout)
             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 타임 아웃치를 사용해 이 소켓을 서버에 접속합니다. 타임 아웃에 0을
 지정하면, 타임 아웃은 무한이라고 해석됩니다. 그 경우, 접속이 확립될까 에러가 발생할 때까지, 접속은 블록 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>endpoint</CODE> - <code>SocketAddress</code><DD><CODE>timeout</CODE> - 사용하는 타임 아웃치 (밀리 세컨드)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 접속시에 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/net/SocketTimeoutException.html" title="java.net 안의 클래스">SocketTimeoutException</A> </CODE> - 접속하기 전에 타임 아웃이 지났을 경우
<DD><CODE><A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스">IllegalBlockingModeException</A> </CODE> - 이 소켓에 관련된 채널이 존재해, 그 채널이 비블로킹 모드의 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 단 점이 null 인 경우, 또는 단 점이 이 소켓으로 서포트되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="bind(java.net.SocketAddress)"><!-- --></A> <H3>
bind</H3>
<PRE>
public void <B>bind</B>(<A HREF="../../java/net/SocketAddress.html" title="java.net 안의 클래스">SocketAddress</A> &nbsp;bindpoint)
          throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓을 로컬 주소에 바인드 합니다.
<P>
 주소가 <code>null</code>
 경우는
 시스템에
해 일시적인 포트와 유효한 로컬 주소가 선택되어 소켓이 바인드 됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>bindpoint</CODE> - 바인드처의 <code>SocketAddress</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 바인드 조작에 실패했을 경우, 혹은 소켓이 벌써 바인드 되고 있는 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - bindpoint 가 이 소켓으로 서포트되어 있지 않은 SocketAddress 서브 클래스인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getInetAddress()"><!-- --></A> <H3>
getInetAddress</H3>
<PRE>
public <A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A>  <B>getInetAddress</B>()</PRE>
<DL>
<DD>소켓의 접속처의 주소를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 접속처의 리모트 IP 주소. 소켓이 접속되어 있지 않은 경우는 <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="getLocalAddress()"><!-- --></A> <H3>
getLocalAddress</H3>
<PRE>
public <A HREF="../../java/net/InetAddress.html" title="java.net 내의 클래스">InetAddress</A>  <B>getLocalAddress</B>()</PRE>
<DL>
<DD>소켓의 바인드처의 로컬 주소를 취득합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 바인드처의 로컬 주소. 소켓이 아직 바인드되어 있지 않은 경우는 <code>InetAddress.anyLocalAddress()</code><DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPort()"><!-- --></A> <H3>
getPort</H3>
<PRE>
public int <B>getPort</B>()</PRE>
<DL>
<DD>이 소켓의 접속처의 리모트 포트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 접속처의 리모트 포트 번호. 소켓이 아직 접속되어 있지 않은 경우는 0</DL>
</DD>
</DL>
<HR>

<A NAME="getLocalPort()"><!-- --></A> <H3>
getLocalPort</H3>
<PRE>
public int <B>getLocalPort</B>()</PRE>
<DL>
<DD>이 소켓의 바인드처의 로컬 포트를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 바인드처의 로컬 포트 번호. 소켓이 아직 바인드되어 있지 않은 경우는 -1</DL>
</DD>
</DL>
<HR>

<A NAME="getRemoteSocketAddress()"><!-- --></A> <H3>
getRemoteSocketAddress</H3>
<PRE>
public <A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A>  <B>getRemoteSocketAddress</B>()</PRE>
<DL>
<DD>이 소켓이 접속되고 있는 단 점의 주소를 돌려줍니다. 소켓이 접속되어 있지 않은 경우는 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 리모트단점을 나타내는 <code>SocketAddress</code>. 소켓이 아직 접속되어 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getInetAddress()"><CODE>getInetAddress()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#getPort()"><CODE>getPort()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress, int)"><CODE>connect(SocketAddress, int)</CODE></A>,
 
<A HREF="../../java/net/Socket.html#connect(java.net.SocketAddress)"><CODE>connect(SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLocalSocketAddress()"><!-- --></A> <H3>
getLocalSocketAddress</H3>
<PRE>
public <A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스">SocketAddress</A>  <B>getLocalSocketAddress</B>()</PRE>
<DL>
<DD>이 소켓이 바인드 되고 있는 단 점의 주소를 돌려줍니다. 소켓이 바인드되어 있지 않은 경우는 <code>null</code>를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 로컬단점을 나타내는 <code>SocketAddress</code>. 소켓이 아직 바인드되어 있지 않은 경우는 <code>null</code><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getLocalAddress()"><CODE>getLocalAddress()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#getLocalPort()"><CODE>getLocalPort()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getChannel()"><!-- --></A> <H3>
getChannel</H3>
<PRE>
public <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 내의 클래스">SocketChannel</A>  <B>getChannel</B>()</PRE>
<DL>
<DD>이 소켓에 관련된 고유 <A HREF="../../java/nio/channels/SocketChannel.html" title="java.nio.channels 중의 클래스"><CODE>SocketChannel</CODE></A>  오브젝트를 돌려줍니다 (존재하는 경우).

<p> 채널 자체가 <A HREF="../../java/nio/channels/SocketChannel.html#open()"><CODE>SocketChannel.open</CODE></A>  메서드 또는 <A HREF="../../java/nio/channels/ServerSocketChannel.html#accept()"><CODE>ServerSocketChannel.accept</CODE></A>  메서드를 사용해 작성되었을 경우에만, 소켓에 채널이 존재합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓에 관련된 소켓 채널. 이 소켓이 채널용으로 작성되지 않았던 경우는 <tt>null</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getInputStream()"><!-- --></A> <H3>
getInputStream</H3>
<PRE>
public <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A>  <B>getInputStream</B>()
                           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 입력 스트림을 돌려줍니다.

<p> 이 소켓에 관련된 채널이 존재하는 경우는
 결과의 입력 스트림은 그 조작을 모두 채널에 위양 합니다. 그 채널이 비블록 모드의 경우, 입력 스트림의 <tt>read</tt> 조작으로 <A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스"><CODE>IllegalBlockingModeException</CODE></A>  가 Throw 됩니다.

<p>이상한 상황에서는
 기본이 되는 접속이 리모트 호스트 또는 네트워크 소프트웨어에
해 절단 되는 일이 있습니다 (예: TCP 접속의 경우, 접속의 리셋트). 네트워크 소프트웨어에
해 절단 된 접속이 검출되었을 경우, 돌려주고지는 입력 스트림에 이하가 적용됩니다.
 <ul>
<li><p>네트워크 소프트웨어는
 소켓에
해 버퍼 된 바이트를 파기할 수가 있다. 네트워크 소프트웨어에
해 파기되지 않는 바이트는
<A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A> 를
 사용해 읽어낼 수가 있다
<li><p>소켓에 버퍼 된 바이트가 없는 경우, 또는 모든 버퍼 된 바이트가 <A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A>  에
해 소비되었을 경우,<A HREF="../../java/io/InputStream.html#read()"><CODE>read</CODE></A>  에의 그 후의 호출은 모두,<A HREF="../../java/io/IOException.html" title="java.io 안의 클래스"><CODE>IOException</CODE></A> 를
 Throw 한다
<li><p>소켓에 버퍼 된 바이트가 없고,<A HREF="../../java/net/Socket.html#close()"><CODE>close</CODE></A> 를
 사용해 소켓이 닫혀지지 않은 경우,<A HREF="../../java/io/InputStream.html#available()"><CODE>available</CODE></A> 는
 <code>0</code>을
 돌려준다
 
</ul>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓으로부터 바이트를 읽어내기 위한 입력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입력 스트림의 작성시에 입출력 에러가 발생했을 경우, 소켓이 닫혀지고 있는 경우, 소켓이 접속되어 있지 않은 경우, 또는 소켓 입력이 <A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A> 를
 사용해 정지되었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getOutputStream()"><!-- --></A> <H3>
getOutputStream</H3>
<PRE>
public <A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A>  <B>getOutputStream</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 출력 스트림을 돌려줍니다.

<p> 이 소켓에 관련된 채널이 존재하는 경우는
 결과의 출력 스트림은 그 조작을 모두 채널에 위양 합니다. 채널이 비블록 모드의 경우, 출력 스트림의 <tt>write</tt> 조작으로 <A HREF="../../java/nio/channels/IllegalBlockingModeException.html" title="java.nio.channels 안의 클래스"><CODE>IllegalBlockingModeException</CODE></A>  가 Throw 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓에 바이트를 기입하기 위한 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 출력 스트림의 작성중에 입출력 에러가 발생했을 경우, 혹은 소켓이 접속되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="setTcpNoDelay(boolean)"><!-- --></A> <H3>
setTcpNoDelay</H3>
<PRE>
public void <B>setTcpNoDelay</B>(boolean&nbsp;on)
                   throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>TCP_NODELAY를
 유효 또는 무효로 합니다 (Nagle
 알고리즘의 유효, 무효의 변환).
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - TCP_NODELAY를
 유효하게 하는 경우는 <code>true</code>, 무효로 하는 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getTcpNoDelay()"><CODE>getTcpNoDelay()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTcpNoDelay()"><!-- --></A> <H3>
getTcpNoDelay</H3>
<PRE>
public boolean <B>getTcpNoDelay</B>()
                      throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>TCP_NODELAY 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>TCP_NODELAY 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setTcpNoDelay(boolean)"><CODE>setTcpNoDelay(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSoLinger(boolean, int)"><!-- --></A> <H3>
setSoLinger</H3>
<PRE>
public void <B>setSoLinger</B>(boolean&nbsp;on,
                        int&nbsp;linger)
                 throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>지정된 지연 시간 (초단위)으로 SO_LINGER를
 유효 또는 무효로 합니다. 최대 타임 아웃의 값은 플랫폼에 고유합니다.
설정은 소켓을 닫는 경우에만 영향을 줍니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 지연 시간을 유효하게 할지 어떨지를 지정<DD><CODE>linger</CODE> - on 가 true
 경우는
 지연 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 지연 시간의 값이 부의 수치인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSoLinger()"><CODE>getSoLinger()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSoLinger()"><!-- --></A> <H3>
getSoLinger</H3>
<PRE>
public int <B>getSoLinger</B>()
                throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_LINGER
 설정을 돌려줍니다. 반환값이 -1
 경우는
 이 옵션이 무효라는 점을 나타냅니다.
설정은 소켓을 닫는 경우에만 영향을 줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_LINGER
 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sendUrgentData(int)"><!-- --></A> <H3>
sendUrgentData</H3>
<PRE>
public void <B>sendUrgentData</B>(int&nbsp;data)
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>소켓상의 1 바이트의 긴급 데이터를 송신합니다. 송신되는 바이트는 데이터 파라미터의 최하정도 8 비트입니다. 긴급 데이터는
 소켓의 OutputStream 에의 모든 선행하는 기입뒤 및 OutputStream 에의 향후의 기입전에 송신됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>data</CODE> - 송신하는 데이터의 바이트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 데이터를 송신할 경우에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setOOBInline(boolean)"><!-- --></A> <H3>
setOOBInline</H3>
<PRE>
public void <B>setOOBInline</B>(boolean&nbsp;on)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>OOBINLINE (TCP 긴급 데이터의 수신)를 유효 또는 무효로 합니다.
디폴트에서는
 이 옵션은 무효로 소켓으로 수신한 TCP 긴급 데이터는 그대로 파기됩니다. 긴급 데이터를 수신하는 경우는
 이 옵션을 유효하게 할 필요가 있습니다. 유효하게 했을 경우, 긴급 데이터는 보통
 데이터와 함께 인 라인으로 수신됩니다.
 <p>
수신하는 긴급 데이터의 처리에는 한정한 서포트 밖에 제공되지 않는 것에 주의해 주세요. 특히, 고위 레벨의 프로토콜이 제공되어 있지 않은 경우, 수신하는 긴급 데이터의 통지는 제공되지 않고, 보통
 데이터와 긴급 데이터를 구별하는 기능은 없습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - OOBINLINE를
 유효하게 하는 경우는 <code>true</code>, 무효로 하는 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getOOBInline()"><CODE>getOOBInline()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getOOBInline()"><!-- --></A> <H3>
getOOBInline</H3>
<PRE>
public boolean <B>getOOBInline</B>()
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>OOBINLINE 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>OOBINLINE 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setOOBInline(boolean)"><CODE>setOOBInline(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSoTimeout(int)"><!-- --></A> <H3>
setSoTimeout</H3>
<PRE>
public void <B>setSoTimeout</B>(int&nbsp;timeout)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>지정된 타임 아웃 (밀리 세컨드 단위)을 사용해, SO_TIMEOUT를
 유효 또는 무효로 합니다. 이 옵션에 0 이외의 타임 아웃을 설정해, 이 Socket 에 관련한 InputStream 에 대해서 read()를 호출하면, 설정한 시간만 블록 됩니다. 타임 아웃이 지나면, Socket는
 유효한 그대로 <B>java.net.SocketTimeoutException</B> 가 발생합니다. 이 옵션은, 블록 조작에 들어가기 전에 유효하게 해 둘<B>필요가 있습니다</B>. 타임 아웃에는 0 보다 큰 값을 지정합니다. 타임 아웃에 0을
 지정하면, 타임 아웃은 무한이라고 해석됩니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드로 나타내지는
 지정된 타임 아웃
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK 1.1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSoTimeout()"><CODE>getSoTimeout()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSoTimeout()"><!-- --></A> <H3>
getSoTimeout</H3>
<PRE>
public int <B>getSoTimeout</B>()
                 throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_TIMEOUT
 설정을 돌려줍니다. 이 옵션이 무효 (타임 아웃이 무한)의 경우는 0을
 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_TIMEOUT
 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSoTimeout(int)"><CODE>setSoTimeout(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSendBufferSize(int)"><!-- --></A> <H3>
setSendBufferSize</H3>
<PRE>
public void <B>setSendBufferSize</B>(int&nbsp;size)
                       throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_SNDBUF 옵션을, 이 <tt>Socket</tt> 로 지정된 값으로 설정합니다. SO_SNDBUF 옵션은, 사용하는 네트워크 입출력 버퍼로 설정하는 사이즈의 힌트로서 플랫폼의 네트워크 코드가 사용합니다.

<p>SO_SNDBUF는
 힌트이므로 어플리케이션으로 버퍼의 사이즈 설정을 조사할 필요가 있는 경우는
<A HREF="../../java/net/Socket.html#getSendBufferSize()"><CODE>getSendBufferSize()</CODE></A> 를
 호출해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 송신 버퍼용으로서 설정하는 사이즈. 0 보다 큰 값을 지정할 필요가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 치가 0 또는 부의 값인 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getSendBufferSize()"><CODE>getSendBufferSize()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSendBufferSize()"><!-- --></A> <H3>
getSendBufferSize</H3>
<PRE>
public int <B>getSendBufferSize</B>()
                      throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 로 사용되는 SO_SNDBUF 옵션의 값을 취득합니다. 이것은, 이 <tt>Socket</tt> 로 출력용으로서 플랫폼이 사용하는 버퍼의 사이즈입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Socket</tt>
 SO_SNDBUF 옵션의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setSendBufferSize(int)"><CODE>setSendBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setReceiveBufferSize(int)"><!-- --></A> <H3>
setReceiveBufferSize</H3>
<PRE>
public void <B>setReceiveBufferSize</B>(int&nbsp;size)
                          throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_RCVBUF 옵션을, 이 <tt>Socket</tt> 로 지정된 값으로 설정합니다. SO_RCVBUF 옵션은, 사용하는 네트워크 입출력 버퍼로 설정하는 사이즈의 힌트로서 플랫폼의 네트워크 코드가 사용합니다.

<p>수신 버퍼의 사이즈를 늘리면, 대규모 접속에서의 네트워크 입출력의 퍼포먼스를 올릴 수가 있습니다. 한편, 사이즈를 줄이면, 수신 데이터의 백 로그를 줄일 수가 있습니다.

<p>SO_RCVBUF는
 힌트이므로 어플리케이션으로 버퍼의 사이즈 설정을 조사할 필요가 있는 경우는
<A HREF="../../java/net/Socket.html#getReceiveBufferSize()"><CODE>getReceiveBufferSize()</CODE></A> 를
 호출해 주세요.

<p>SO_RCVBUF
 값은, 리모트 피어에 통지되는 TCP 수신 윈도우의 설정에도 사용됩니다. 일반적으로 윈도우 사이즈는 소켓의 접속시에 언제라도 변경할 수 있습니다. 다만, 64K 보다 큰 수신 윈도우가 필요한 경우는
 소켓을 리모트 피어에 접속하기<B>전</B>으로 변경을 요구할 필요가 있습니다. 다음의 2 개의 점에 유의해 주세요. <p> <ol> <li>ServerSocket 로부터 받아들인 소켓의 경우, ServerSocket를
 로컬 주소에 바인드 하기 전에
<A HREF="../../java/net/ServerSocket.html#setReceiveBufferSize(int)"><CODE>ServerSocket.setReceiveBufferSize(int)</CODE></A> 를
 호출해 이것을 실행할 필요가 있다<p></li> <li>클라이언트 소켓의 경우, 소켓을 그 리모트 피어에 접속하기 전에
 setReceiveBufferSize()를 호출할 필요가 있다<p></li></ol>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>size</CODE> - 수신 버퍼용으로서 설정하는 사이즈. 0 보다 큰 값을 지정할 필요가 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 치가 0 또는 부의 값인 경우
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getReceiveBufferSize()"><CODE>getReceiveBufferSize()</CODE></A>,
 
<A HREF="../../java/net/ServerSocket.html#setReceiveBufferSize(int)"><CODE>ServerSocket.setReceiveBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReceiveBufferSize()"><!-- --></A> <H3>
getReceiveBufferSize</H3>
<PRE>
public int <B>getReceiveBufferSize</B>()
                         throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 <tt>Socket</tt> 로 사용되는 SO_RCVBUF 옵션의 값을 취득합니다. 이것은, 이 <tt>Socket</tt> 로 입력용으로서 플랫폼이 사용하는 버퍼의 사이즈입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 <tt>Socket</tt>
 SO_RCVBUF 옵션의 값
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setReceiveBufferSize(int)"><CODE>setReceiveBufferSize(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAlive(boolean)"><!-- --></A> <H3>
setKeepAlive</H3>
<PRE>
public void <B>setKeepAlive</B>(boolean&nbsp;on)
                  throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_KEEPALIVE를
 유효 또는 무효로 합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 소켓을 온대로 해 둘지 어떨지를 지정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getKeepAlive()"><CODE>getKeepAlive()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAlive()"><!-- --></A> <H3>
getKeepAlive</H3>
<PRE>
public boolean <B>getKeepAlive</B>()
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_KEEPALIVE 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_KEEPALIVE 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setKeepAlive(boolean)"><CODE>setKeepAlive(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setTrafficClass(int)"><!-- --></A> <H3>
setTrafficClass</H3>
<PRE>
public void <B>setTrafficClass</B>(int&nbsp;tc)
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 Socket 로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스형 8중창을 설정합니다. 사용하는 네트워크 구현이 이 값을 무시하는 일이 있으므로 어플리케이션에서는 이 값을 힌트라고 생각해 주세요.

<P>
 tc
 범위는 <code>0 <= tc <= 255</code> 가<B>아니면 안됩니다</B>. 그렇지 않은 경우는
 IllegalArgumentException 이 Throw 됩니다.
<p>주:

<p> IP (Internet Protocol) 버젼 4
 경우, RFC 1349 로 설명되고 있도록, 이 값은 우선 순위의 높은 8중창과 TOS 필드로 구성됩니다. TOS 필드는
 다음과 같이 비트 단위의 논리합에
해 작성되는 비트 세트입니다.
 <p>

<UL> 
 <LI><CODE>IPTOS_LOWCOST (0x02)</CODE></LI> 
 <LI><CODE>IPTOS_RELIABILITY (0x04)</CODE></LI> 
 <LI><CODE>IPTOS_THROUGHPUT (0x08)</CODE></LI> 
 <LI><CODE>IPTOS_LOWDELAY (0x10)</CODE></LI> 
</UL> 최하정도 비트는
 MBZ (0 이 아니면 안된다) 비트에 대응하므로 항상 무시됩니다.
 <p>
우선 필드에 비트를 설정하면, 조작이 허가되지 않는 것을 나타내는 SocketException 가 되는 일이 있습니다.
 <p>
IP (Internet Protocol) 버젼 6
 경우,<code>tc</code>는
 IP 헤더의 sin6_flowinfo 필드에 포함되는 값입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tc</CODE> - 비트 세트의 <code>int</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 트래픽 클래스 또는 서비스형을 설정할 경우에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getTrafficClass()"><CODE>getTrafficClass()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTrafficClass()"><!-- --></A> <H3>
getTrafficClass</H3>
<PRE>
public int <B>getTrafficClass</B>()
                    throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>이 소켓으로부터 송신되는 패킷의 IP 헤더의 트래픽 클래스 또는 서비스형을 취득합니다.
 <p>
배후의 네트워크 구현이,<A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A> 를
 사용해 설정된 트래픽 클래스 또는 서비스형을 무시하는 일이 있으므로 이 Socket 로 <A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A>  메서드를 사용해 이전으로 설정된 값과는 다른 값이 이 메서드로부터 돌려주고지는 일이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>벌써 설정되어 있는 트래픽 클래스 또는 서비스형
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 트래픽 클래스 또는 서비스형의 값을 취득할 경우에 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setTrafficClass(int)"><CODE>setTrafficClass(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setReuseAddress(boolean)"><!-- --></A> <H3>
setReuseAddress</H3>
<PRE>
public void <B>setReuseAddress</B>(boolean&nbsp;on)
                     throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_REUSEADDR 소켓 옵션을 유효 또는 무효로 합니다.
 <p>
TCP 접속을 닫으면, 접속이 닫은 뒤, 접속이 일정한 시간 타임 아웃 상태대로 되는 일이 있습니다 (보통
,<tt>TIME_WAIT</tt> 상태 또는 <tt>2MSL</tt> 대기 상태로 불린다). 주지의 소켓 주소 또는 포트를 사용하는 어플리케이션의 경우, 소켓 주소 또는 포트에 관련된 접속이 타임 아웃 상태에 있으면, 소켓을 필요한 <tt>SocketAddress</tt> 에 바인드 할 수 없는 것이 있습니다.
 <p>
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A> 를
 사용해 소켓을 바인드 하기 전에 <tt>SO_REUSEADDR</tt>를
 유효하게 하면, 이전의 접속이 타임 아웃 상태에서도 소켓을 바인드 할 수가 있습니다.
 <p>
<tt>Socket</tt> 가 작성되면,<tt>SO_REUSEADDR</tt>
 초기설정은 무효가 됩니다.
 <p>
소켓이 바인드 되었다 (<A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A> 를
 참조) 나중에 <tt>SO_REUSEADDR</tt>를
 유효 또는 무효로 하는 경우의 동작은, 정의되고 있지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - 소켓 옵션을 유효하게 할까 무효로 하는지를 지정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - <tt>SO_RESUEADDR</tt> 소켓 옵션을 유효 또는 무효로 할 경우에 에러가 발생하는 경우, 혹은 소켓이 닫고 있는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#getReuseAddress()"><CODE>getReuseAddress()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(SocketAddress)</CODE></A>,
 
<A HREF="../../java/net/Socket.html#isClosed()"><CODE>isClosed()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#isBound()"><CODE>isBound()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReuseAddress()"><!-- --></A> <H3>
getReuseAddress</H3>
<PRE>
public boolean <B>getReuseAddress</B>()
                        throws <A HREF="../../java/net/SocketException.html" title="java.net 내의 클래스">SocketException</A> </PRE>
<DL>
<DD>SO_REUSEADDR 가 유효한가 어떤가를 조사합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>SO_REUSEADDR 가 유효한가 어떤가를 나타내는 <code>boolean</code> 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 기본이 되는 프로토콜로 TCP 에러등의 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#setReuseAddress(boolean)"><CODE>setReuseAddress(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓을 닫습니다.
 <p>
현재 이 소켓의 입출력 조작으로 블록 떠날 수 있어 모든 thread가 <A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스"><CODE>SocketException</CODE></A> 를
 Throw 합니다.
 <p>
소켓이 닫혀지면, 그 후의 네트워크에 그 소켓을 사용할 수 없습니다 (즉, 재접속 또는 재바인드는 할 수 없다). 새로운 소켓을 작성할 필요가 있습니다.

<p> 이 소켓에 관련된 채널이 존재하는 경우는
 그 채널도 닫혀집니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 닫을 때 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#isClosed()"><CODE>isClosed()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="shutdownInput()"><!-- --></A> <H3>
shutdownInput</H3>
<PRE>
public void <B>shutdownInput</B>()
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 입력 스트림을 「스트림의 최후」에 배치합니다. 소켓의 입력 스트림 측에 송신된 데이터는 확인되어 그대로 파기됩니다.
 <p>
소켓으로 shutdownInput()를 호출한 뒤에 소켓의 입력 스트림로부터 읽어내면, 스트림은 EOF를
 돌려줍니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 정지할 경우에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownOutput()"><CODE>shutdownOutput()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A>,
 
<A HREF="../../java/net/Socket.html#isInputShutdown()"><CODE>isInputShutdown()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="shutdownOutput()"><!-- --></A> <H3>
shutdownOutput</H3>
<PRE>
public void <B>shutdownOutput</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 소켓의 출력 스트림을 무효로 합니다. TCP 소켓의 경우, 벌써 기입해지고 있는 데이터가 송신되어 그 후에 TCP
 보통
의 접속 종료 처리가 계속됩니다.
소켓으로 shutdownOutput()를 호출한 뒤에 소켓의 출력 스트림에 기입하면, 스트림은 IOException를
 Throw 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 이 소켓을 정지할 경우에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A>,
 
<A HREF="../../java/net/Socket.html#setSoLinger(boolean, int)"><CODE>setSoLinger(boolean, int)</CODE></A>,
 
<A HREF="../../java/net/Socket.html#isOutputShutdown()"><CODE>isOutputShutdown()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>이 소켓을 <code>String</code> 로 변환합니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 소켓의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="isConnected()"><!-- --></A> <H3>
isConnected</H3>
<PRE>
public boolean <B>isConnected</B>()</PRE>
<DL>
<DD>소켓의 접속 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 서버에 정상적으로 접속되고 있는 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="isBound()"><!-- --></A> <H3>
isBound</H3>
<PRE>
public boolean <B>isBound</B>()</PRE>
<DL>
<DD>소켓의 바인딩 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 정상적으로 주소에 바인드 되고 있는 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#bind(java.net.SocketAddress)"><CODE>bind(java.net.SocketAddress)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isClosed()"><!-- --></A> <H3>
isClosed</H3>
<PRE>
public boolean <B>isClosed</B>()</PRE>
<DL>
<DD>소켓이 닫은 상태를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓이 닫았을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#close()"><CODE>close()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInputShutdown()"><!-- --></A> <H3>
isInputShutdown</H3>
<PRE>
public boolean <B>isInputShutdown</B>()</PRE>
<DL>
<DD>소켓 접속의 독해측의 반이 닫고 있는지 어떤지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 입력이 정지했을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownInput()"><CODE>shutdownInput()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isOutputShutdown()"><!-- --></A> <H3>
isOutputShutdown</H3>
<PRE>
public boolean <B>isOutputShutdown</B>()</PRE>
<DL>
<DD>소켓 접속의 기입측의 반이 닫고 있는지 어떤지를 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>소켓의 출력이 정지했을 경우는 true<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/net/Socket.html#shutdownOutput()"><CODE>shutdownOutput()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setSocketImplFactory(java.net.SocketImplFactory)"><!-- --></A> <H3>
setSocketImplFactory</H3>
<PRE>
public static void <B>setSocketImplFactory</B>(<A HREF="../../java/net/SocketImplFactory.html" title="java.net 안의 인터페이스">SocketImplFactory</A> &nbsp;fac)
                                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>어플리케이션의 클라이언트 소켓 구현 팩토리를 설정합니다. 팩토리를 설정할 수 있는 것은 1 회 뿐입니다.
 <p>
어플리케이션으로 새로운 클라이언트 소켓을 작성하면, 소켓 구현 팩토리의 <code>createSocketImpl</code> 메서드가 불려 가 실제의 소켓이 작성됩니다.
 <p>
팩토리가 벌써 설정되어 있지 않은 한, 메서드에 <code>null</code>를
 건네주어도 아무것도 행해지지 않습니다.
<p>시큐러티 매니저가 존재하는 경우, 이 메서드는 최초로 시큐러티 매니저의 <code>checkSetFactory</code> 메서드를 호출하는 것으로 이 조작이 허가되고 있는 것을 확인합니다. 이 결과, SecurityException 가 되는 일이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>fac</CODE> - 목적의 팩토리
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 소켓 팩토리의 설정중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/net/SocketException.html" title="java.net 안의 클래스">SocketException</A> </CODE> - 팩토리가 벌써 정의되고 있는 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkSetFactory</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/net/SocketImplFactory.html#createSocketImpl()"><CODE>SocketImplFactory.createSocketImpl()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkSetFactory()"><CODE>SecurityManager.checkSetFactory()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPerformancePreferences(int, int, int)"><!-- --></A> <H3>
setPerformancePreferences</H3>
<PRE>
public void <B>setPerformancePreferences</B>(int&nbsp;connectionTime,
                                      int&nbsp;latency,
                                      int&nbsp;bandwidth)</PRE>
<DL>
<DD>이 소켓의 퍼포먼스 설정을 실시합니다.

<p> 소켓은 디폴트로 TCP/IP 프로토콜을 사용합니다. 구현에 따라서는
 TCP/IP 와는 다른 퍼포먼스 특성을 가지는 대체 프로토콜이 제공되는 일도 있습니다. 어플리케이션은, 이 메서드를 사용하는 것으로 구현으로 이용 가능한 프로토콜의 선택시에
 이러한 균형의 취하는 방법을 나타내는 독자적인 설정을 표현할 수 있습니다.

<p> 퍼포먼스 설정은, 접속 시간의 짧음, 응답 시간의 속도, 대역폭의 넓이의 상대적인 중요도를 나타내는 3 개의 정수치에
해 기술됩니다. 정수의 절대치에 관계성은 없고, 프로토콜을 선택하기 위해서 값을 단지 비교합니다. 값이 크면보다 강한 설정을 나타냅니다. 부의 값은, 정의 값보다 우선 순위가 낮은 일을 나타냅니다. 어플리케이션이 응답 시간의 속도와 대역폭의 넓이보다 접속 시간의 짧음을 우선하는 경우, 이 메서드를 <tt>(1, 0, 0)</tt> 이라고 하는 값으로 호출할 수가 있습니다. 어플리케이션이 응답 시간의 속도보다 대역폭의 넓이를, 또 접속 시간의 짧음보다 응답 시간의 속도를 우선하는 경우, 이 메서드를 <tt>(0, 1, 2)</tt> 이라고 하는 값으로 호출할 수가 있습니다.

<p> 이 소켓이 접속된 뒤에 이 메서드를 호출해도, 아무것도 행해지지 않습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>connectionTime</CODE> - 접속 시간의 짧음의 상대적인 중요도를 나타내는 <tt>int</tt><DD><CODE>latency</CODE> - 응답 시간의 속도의 상대적인 중요도를 나타내는 <tt>int</tt><DD><CODE>bandwidth</CODE> - 대역폭의 넓이의 상대적인 중요도를 나타내는 <tt>int</tt><DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Socket.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/net/ServerSocket.html" title="java.net 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/net/SocketAddress.html" title="java.net 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/net/Socket.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Socket.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

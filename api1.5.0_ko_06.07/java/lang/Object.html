<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:56:50 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Object (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.lang.Object class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Object (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/lang/NumberFormatException.html" title="java.lang 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/lang/Object.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Object.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Object</H2>
<PRE>
<B>java.lang.Object</B>
</PRE>
<HR>
<DL>
<DT><PRE>public class <B>Object</B></DL>
</PRE>

<P>
<code>Object</code> 클래스는
 클래스 계층 루트입니다. 모든 클래스는
 슈퍼 클래스로서 <code>Object</code>를
 가집니다. 배열을 포함한 모든 오브젝트는
 이 클래스의 메서드를 구현합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스"><CODE>Class</CODE></A> </DL>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Object.html#Object()">Object</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#clone()">clone</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 오브젝트의 카피를 작성해 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 오브젝트와 다른 오브젝트가 동일한지 어떤지를 나타냅니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#finalize()">finalize</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 오브젝트에의 참조는 이제 없으면 가비지 컬렉션에
해 판단되었을 때에
 가비지 컬렉터에
해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;?  extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#getClass()">getClass</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트의 실행시 클래스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#hashCode()">hashCode</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트의 해시 코드치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#notify()">notify</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 오브젝트의 모니터로 대기중의 thread를 1 개 재개합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 오브젝트의 모니터로 대기중의 모든 thread를 재개합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait()">wait</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait(long)">wait</A> </B>(long&nbsp;timeout)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출하는지, 지정된 시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </B>(long&nbsp;timeout,
     int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출하는지, 다른 thread가 현재의 thread에 인터럽트를 걸거나 지정된 양의 실시간이 경과할 때까지, 현재의 thread를 대기시킵니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Object()"><!-- --></A> <H3>
Object</H3>
<PRE>
public <B>Object</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getClass()"><!-- --></A> <H3>
getClass</H3>
<PRE>
public final <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;?  extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> &gt; <B>getClass</B>()</PRE>
<DL>
<DD>오브젝트의 실행시 클래스를 돌려줍니다. 이 <tt>Class</tt> 오브젝트는
 나타내진 클래스의 <tt>static synchronized</tt> 메서드에
해 락 되는 오브젝트입니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>오브젝트의 실행시 클래스를 나타내는 <code>java.lang.Class</code> 오브젝트. 결과는
<code>Class&lt;?  extends X&gt;</code> 형이 된다. 여기서, X는
 <code>getClass</code> 가 불려 가는 static 형의 이레이쟈</DL>
</DD>
</DL>
<HR>

<A NAME="hashCode()"><!-- --></A> <H3>
hashCode</H3>
<PRE>
public int <B>hashCode</B>()</PRE>
<DL>
<DD>오브젝트의 해시 코드치를 돌려줍니다. 이 메서드는
<code>java.util.Hashtable</code> 에
해 제공되는 것 같은 해시 테이블로 사용하기 위해서 준비되어 있습니다.  
 <p>
<code>hashCode</code> 메서드의 일반적인 규칙을 다음에 나타냅니다. <ul> <li>Java 어플리케이션의 실행중에 같은 오브젝트상에서 여러 차례 불려 가는 경우는 반드시, 이 오브젝트에 대한 <tt>equals</tt> 에
한 비교로 사용된 정보가 변경되어 있지 않으면,<tt>hashCode</tt> 메서드는 같은 정수를 일관해 돌려주지 않으면 안 된다. 어플리케이션을 한 번 종료하고 나서 한번 더 같은 어플리케이션을 실행했을 경우, 이 메서드로부터 돌려주고지는 정수는 전회의 실행시에 돌려주고진 정수와 같다라고는 한정되지 않는다<li><tt>equals(Object)</tt> 메서드로 2 개의 오브젝트가 등가로 여겨졌을 경우, 어느 쪽의 오브젝트로 <code>hashCode</code> 메서드를 호출해도 결과는 같은 정수치가 되어야 하다<li><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>equals(java.lang.Object)</CODE></A>  메서드로 2 개의 오브젝트가 등가가 아니다고 여겨졌을 경우는
 이러한 오브젝트에 대해서 <tt>hashCode</tt> 메서드를 호출했을 때에
 결과가 다른 정수치가 되지 않아도 상관없다. 그러나, 동일하지 않은 오브젝트에 대해서는 다른 정수치가 생성되도록 하면, 해시 테이블의 퍼포먼스를 올릴 수가 있다
</ul>

 <p>
할 수 있는 한,<tt>Object</tt> 클래스에서 정의되는 hashCode 메서드는
 다른 오브젝트에 대해서는 다른 정수치를 돌려줍니다. 보통
, 이것은 오브젝트의 내부 주소를 정수치로 변환하는 형태로 구현됩니다만, 그러한 구현 테크닉은 Java<font size="-2"><sup>TM</sup></font> 프로그램 언어에서는 불필요합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 오브젝트의 해시 코드치<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#equals(java.lang.Object)"><CODE>equals(java.lang.Object)</CODE></A>,
 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="equals(java.lang.Object)"><!-- --></A> <H3>
equals</H3>
<PRE>
public boolean <B>equals</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>이 오브젝트와 다른 오브젝트가 동일한지 어떤지를 나타냅니다.
 <p>
<code>equals</code> 메서드는
 null 이외의 오브젝트 참조에서의 동치 관계를 구현합니다. <ul> <li>반사성 (<i>reflexive</i>): null 이외의 참조치 <code>x</code> 에 대해,<code>x.equals(x)</code>는
 <code>true</code>를
 돌려준다<li>대칭성 (<i>symmetric</i>): null 이외의 참조치 <code>x</code> 와 <code>y</code> 에 대해,<code>x.equals(y)</code>는

<code>y.equals(x)</code> 가 <code>true</code>를
 돌려주는 경우만 <code>true</code>를
 돌려준다<li>추이성 (<i>transitive</i>): null 이외의 참조치 <code>x</code>,<code>y</code>,<code>z</code> 에 대해,<code>x.equals(y)</code> 가 <code>true</code>를
 돌려주고, 한편 <code>y.equals(z)</code> 가 <code>true</code>를
 돌려주는 경우에
<code>x.equals(z)</code>는
 <code>true</code>를
 돌려준다<li>정합성 (<i>consistent</i>): null 이외의 참조치 <code>x</code> 및 <code>y</code> 에 대해,<tt>x.equals(y)</tt>를
 복수 호출하면 항상 <code>true</code>를
 돌려주는지, 항상 <code>false</code>를
 돌려준다. 이것은, 오브젝트에 대한 <code>equals</code> 에
한 비교로 사용된 정보가 변경되어 있지 않은 것이 조건이다<li>null 이외의 참조치 <code>x</code> 에 대해,<code>x.equals(null)</code>는
 <code>false</code>를
 돌려준다 
</ul>

 <p>
<code>Object</code> 클래스의 <tt>equals</tt> 메서드는
 가장 비교하기 쉬운 오브젝트의 동치 관계를 구현합니다. 즉, null 이외의 참조치 <code>x</code> 와 <code>y</code> 에 대해, 이 메서드는 <code>x</code> 와 <code>y</code> 가 같은 오브젝트를 참조하는 (<code>x == y</code> 가 <code>true</code>) 경우에만 <code>true</code>를
 돌려줍니다.
 <p>
보통
, 이 메서드를 오버라이드(override) 하는 경우는
<tt>hashCode</tt> 메서드를 항상 오버라이드(override) 해, 「등가인 오브젝트는 등가인 해시 코드를 보관 유지할 필요가 있다」라고 하는 <tt>hashCode</tt> 메서드의 범용 규약에 따를 필요가 있는 것에 유의해 주세요.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 비교 대상의 참조 오브젝트
<DT><B>반환값:</B><DD>obj 인수로 지정된 오브젝트와 이 오브젝트가 동일한 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#hashCode()"><CODE>hashCode()</CODE></A>,
 
<A HREF="../../java/util/Hashtable.html" title="java.util 안의 클래스"><CODE>Hashtable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A> <H3>
clone</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>clone</B>()
                throws <A HREF="../../java/lang/CloneNotSupportedException.html" title="java.lang 내의 클래스">CloneNotSupportedException</A> </PRE>
<DL>
<DD>이 오브젝트의 카피를 작성해 돌려줍니다. 「카피」의 정확한 이유는
 오브젝트의 클래스에
해 다릅니다. 일반적으로는
 임의의 오브젝트 <tt>x</tt> 에 대해, 다음의 식 <blockquote>
 
 <pre>

 x.clone() ! = x</pre></blockquote>
하지만 true 이며, 다음의 식 <blockquote>
 
 <pre>

 x.clone(). getClass() == x.getClass()</pre></blockquote>
도 <tt>true</tt> 인 것입니다만, 이것들도 절대적인 요건이 아닙니다. 또 다음의 식 <blockquote>
 
 <pre>

 x.clone(). equals(x)</pre></blockquote>
도 보통
 <tt>true</tt> 가 됩니다만, 이것도 절대적인 요건이 아닙니다.  
 <p>
보통
,<tt>super.clone</tt>를
 호출하는 것으로 돌려주고지는 오브젝트를 취득할 수 있습니다. 클래스 및 그 슈퍼 클래스 모든 것 (<tt>Object</tt>를
 제외한다)이 이 규칙에 따르는 경우,<tt>x.clone(). getClass() == x.getClass()</tt> 가 성립합니다.
 <p>
보통
, 이 메서드에
해 돌려주고지는 오브젝트는
 이 오브젝트 (복제되고 있다)로부터 독립하고 있을 필요가 있습니다. 이 독립성을 달성하기 위해,<tt>super.clone</tt> 가 돌려주는 오브젝트의 필드를 1 개 이상 (오브젝트가 돌려주기 전에) 변경하는 것이 필요하게 되는 경우가 있습니다. 이것은, 보통
, 복제하는 오브젝트의 내부 「심층 구조」를 구성하는 가변 오브젝트의 카피 및 이러한 오브젝트에의 참조를 카피에의 참조에 옮겨놓는 것을
미합니다. 클래스에 원시적 필드 또는 불변 오브젝트에의 참조만이 포함되는 경우, 보통
,<tt>super.clone</tt> 에
해 돌려주고지는 오브젝트내의 필드를 변경할 필요는 없습니다.
 <p>
<tt>Object</tt> 클래스의 <tt>clone</tt> 메서드는
 특정의 복제 처리를 실행합니다. 우선, 이 오브젝트의 클래스가 <tt>Cloneable</tt> 인터페이스를 구현하고 있지 않는 경우는
<tt>CloneNotSupportedException</tt> 가 Throw 됩니다. 배열은 모두, 인터페이스 <tt>Cloneable</tt>를
 구현하고 있는 것이라고 보여지는 것에 주의해 주세요. 구현하고 있지 않는 경우, 이 메서드는 이 오브젝트의 클래스의 새로운 인스턴스를 생성해, 그 필드를 모두, 이 오브젝트의 대응하는 각 필드의 내용으로 초기화합니다. 이것은 대입과 같아, 필드의 내용 자신이 복제되는 것은 아닙니다. 즉 이 메서드는
 오브젝트의 「샤로코피」를 생성합니다만, 「딥 카피」는 생성하지 않습니다.
 <p>
클래스 <tt>Object</tt> 자체는
<tt>Cloneable</tt> 인터페이스를 구현하지 않기 때문에
 클래스가 <tt>Object</tt> 인 <tt>clone</tt> 메서드를 호출하면, 실행시에 예외가 Throw 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 인스턴스의 복제
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/CloneNotSupportedException.html" title="java.lang 안의 클래스">CloneNotSupportedException</A> </CODE> - 오브젝트의 클래스가 <code>Cloneable</code> 인터페이스를 서포트하고 있지 않는 경우. <code>clone</code> 메서드를 오버라이드(override) 한 서브 클래스도, 인스턴스를 복제할 수 없는 것을 나타내기 위해서 이 예외를 Throw 하는 일이 있는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Cloneable.html" title="java.lang 내의 인터페이스"><CODE>Cloneable</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>오브젝트의 캐릭터 라인 표현을 돌려줍니다. 보통
,<code>toString</code> 메서드는 이 오브젝트를 「텍스트로 표현한다」캐릭터 라인을 돌려줍니다. 이 결과는
 인간이 읽을 수 있는 간결하고 유익한 정보여야 합니다. 모든 서브 클래스에서, 이 메서드를 오버라이드(override) 하는 것을 추천합니다.
 <p>
<code>Object</code> 클래스의 <code>toString</code> 메서드는
 오브젝트의 파생원의 클래스명, @ 부호 (<code>@</code>) 및 오브젝트의 해시 코드의 부호 없음 16 진표현으로부터 구성되는 캐릭터 라인을 돌려줍니다. 즉, 이 메서드는 다음의 값과 동일한 캐릭터 라인을 돌려줍니다.  <blockquote>
 
 <pre>

 getClass(). getName() + '@' + Integer.toHexString(hashCode())
 </pre></blockquote>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 오브젝트의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="notify()"><!-- --></A> <H3>
notify</H3>
<PRE>
public final void <B>notify</B>()</PRE>
<DL>
<DD>이 오브젝트의 모니터로 대기중의 thread를 1 개 재개합니다. 이 오브젝트로 복수의 thread가 대기중의 경우는
 그 중의 1 개를 재개합니다. 이 선택은 임의로 구현에 따라서 다릅니다. thread는
<code>wait</code> 메서드를 1 개 호출해, 오브젝트의 모니터로 대기합니다.
 <p>
재개된 thread의 처리는
 현재의 thread가 이 오브젝트의 락을 해제할 때까지는 진행될 수가 없습니다. 재개된 thread는
 다른 thread와 같이, 이 오브젝트와 동기 하도록 적극적으로 겨룹니다. 예를 들어, 이 오브젝트를 잠그는 다음의 thread가 되려고 하는 경우에서도, 재개된 thread의 취급은 다른 thread보다 우세하지도 열세하지도 않습니다.
 <p>
이 메서드를 호출하는 것은, 이 오브젝트의 모니터를 소유하는 thread가 아니면 안됩니다. thread가 오브젝트의 모니터의 오너가 되는 방법은, 다음의 3 방법이 있습니다. <ul> <li>오브젝트의 synchronized 인스턴스 메서드를 실행한다<li>오브젝트를 동기화하는 <code>synchronized</code> 문의 본체를 실행한다<li><code>Class</code> 형의 오브젝트의 경우는
 그 클래스의 syncronized static 메서드를 실행한다  
</ul>

 <p>
오브젝트의 모니터를 소유할 수 있는 thread는 1 회에 1 개 뿐입니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 오브젝트의 모니터를 소유하고 있지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>,
 
<A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="notifyAll()"><!-- --></A> <H3>
notifyAll</H3>
<PRE>
public final void <B>notifyAll</B>()</PRE>
<DL>
<DD>이 오브젝트의 모니터로 대기중의 모든 thread를 재개합니다. thread는
<code>wait</code> 메서드를 호출하면, 오브젝트의 모니터로 대기합니다.
 <p>
재개된 thread의 처리는
 현재의 thread가 이 오브젝트의 락을 해제할 때까지는 진행될 수가 없습니다. 재개된 thread는
 다른 thread와 같이, 이 오브젝트와 동기 하도록 적극적으로 겨룹니다. 예를 들어, 이 오브젝트를 잠그는 다음의 thread가 되려고 하는 경우에서도, 재개된 thread의 취급은 다른 thread보다 우세하지도 열세하지도 않습니다.
 <p>
이 메서드를 호출하는 것은, 이 오브젝트의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 오브젝트의 모니터의 오너가 되는 방법에 대해서는
<code>notify</code> 메서드를 참조하십시오.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 오브젝트의 모니터를 소유하고 있지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>,
 
<A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wait(long)"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>(long&nbsp;timeout)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출하는지, 지정된 시간이 경과할 때까지, 현재의 thread를 대기시킵니다.
 <p>
현재의 thread는
 이 오브젝트의 모니터의 오너가 아니면 안됩니다.
 <p>
이 메서드는
 현재의 thread (여기에서는 <var>T</var> 로 한다)를 이 오브젝트의 대기 세트에 넣고 나서, 이 오브젝트에 대한 동기 요구를 모두 폐기합니다. thread <var>T</var>는

 thread의 스케줄링에 대해서는 무효로 여겨져 이하의 4 개의 어떤 것인가가 발생할 때까지 대기합니다. <ul> <li>다른 thread가 이 오브젝트에 대해서 <tt>notify</tt> 메서드를 호출해, 재개되는 thread로서 thread <var>T</var> 가 선택되었다<li>다른 thread가 이 오브젝트에 대해서 <tt>notifyAll</tt> 메서드를 호출했다<li>다른 thread가 thread <var>T</var> 에<A HREF="../../java/lang/Thread.html#interrupt()"><CODE>끼어들었다</CODE></A> <li>지정된 실시간이 경과했다. <tt>timeout</tt> 가 제로의 경우, 실시간이 고려될 것은 없고, thread는 통지를 받을 때까지 계속 대기한다
</ul>
 그 후 thread <var>T</var>는
 이 오브젝트의 대기 세트로부터 삭제되어 thread의 스케줄링이 다시 가능하게 됩니다. 이후, 이 thread는 보통
대로 오브젝트와 동기화할 권리를 다른 thread와 경쟁합니다. 오브젝트의 제어를 획득하면, 오브젝트에 대한 이 thread의 동기 요구는
 이전 상태, 즉,<tt>wait</tt> 메서드가 불려 갔을 때 상태에 복원됩니다. 다음에 thread <var>T</var>는
 <tt>wait</tt> 메서드의 호출로부터 복귀합니다. 이렇게 해,<tt>wait</tt> 메서드로부터 복귀한 시점에서, 오브젝트 및 thread <tt>T</tt>
 동기 스테이터스는
<tt>wait</tt> 메서드가 불려 갔을 때와 완전히 같게 됩니다.
 <p>
thread는
 통지, 끼어들어, 타임 아웃없이 재개되는 일이 있습니다. 이것은, 「스프리아스웨이크압」이라고 불리고 있습니다. 스프리아스웨이크압은, 실제로는 보기 드물게 밖에 발생합니다만, 어플리케이션에서는
 thread가 재개되는 것으로 발생할 가능성이 있는 조건을 테스트해, 조건이 채워지지 않은 경우는 대기를 계속해, 스프리아스웨이크압으로부터 보호하지 않으면 안됩니다. 즉, 다음과 같이 루프로 항상 대기가 발생하도록 할 필요가 있습니다.
 
 <pre>

     synchronized (obj) {
         while (&lt;condition does not hold&gt;)
             obj.wait(timeout);
         ... // Perform action appropriate to condition
     }
 </pre>
(이 토픽의 자세한 것은, Doug Lea 저 「Concurrent Programming in Java (Second Edition)」(Addison-Wesley, 2000)의 섹션 3.2. 3 이나 Joshua Bloch 저 「Effective Java Programming Language Guide」(Addison-Wesley, 2001)의 아이템 50을
 참조하십시오).
 <p>
현재의 thread가 대기중에 다른 thread에
해<A HREF="../../java/lang/Thread.html#interrupt()"><CODE>끼어들어졌을</CODE></A> 경우는
<tt>InterruptedException</tt> 가 Throw 됩니다. 이 예외는
 이 오브젝트의 락 스테이터스가 전술과 같이 복원될 때까지는 Throw 되지 않습니다.
 <p>
현재의 thread를 이 오브젝트의 대기 세트에 넣을 때,<tt>wait</tt> 메서드는 이 오브젝트의 락만을 해제합니다. 현재의 thread가 동기화할 가능성이 있는 그 다른 오브젝트는
 이 thread가 대기하고 있는 동안도 락 된대로 입니다.
 <p>
이 메서드를 호출하는 것은, 이 오브젝트의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 오브젝트의 모니터의 오너가 되는 방법에 대해서는
<code>notify</code> 메서드를 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드 단위의 대기 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - timeout
 값이 부인 경우
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 오브젝트의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에
 다른 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>,
 
<A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="wait(long, int)"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>(long&nbsp;timeout,
                       int&nbsp;nanos)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출하는지, 다른 thread가 현재의 thread에 인터럽트를 걸거나 지정된 양의 실시간이 경과할 때까지, 현재의 thread를 대기시킵니다.
 <p>
이 메서드는
 인수가 1 개의 <code>wait</code> 메서드를 닮아 있습니다만, 타임 아웃까지의 대기 시간의 양을 보다 세세하게 제어할 수가 있습니다. 나노초단위의 실시간은, 다음의 식에서 지정합니다.  <blockquote>
 
 <pre>

 1000000*timeout+nanos</pre></blockquote>

 <p>
그 외의 면에서는
 이 메서드의 동작은 인수가 1 개의 <A HREF="../../java/lang/Object.html#wait(long)"><CODE>wait(long)</CODE></A>  메서드와 같습니다. 특히,<tt>wait(0, 0)</tt>는
 <tt>wait(0)</tt> 와 같은
미가 됩니다.
 <p>
현재의 thread는
 오브젝트의 모니터의 오너가 아니면 안됩니다. thread는 이 모니터의 소유권을 해방해, 다음의 어떤 것인가 상태가 발생할 때까지 대기합니다. <ul> <li>다른 thread가 <code>notify</code> 메서드 또는 <code>notifyAll</code> 메서드를 호출하는 것에
해, 이 오브젝트의 모니터로 대기중의 thread에 통지를 보내, 이 thread를 재개한다<li><code>timeout</code> 인수로 지정한 타임 아웃 기간 (밀리 세컨드 단위)과<code>nanos</code> 인수로 지정한 타임 아웃 기간 (나노초단위)을 더한 시간이 경과한다  
</ul>

 <p>
thread는 모니터의 소유권을 재차 획득할 때까지 대기해, 그 후 실행을 재개합니다.
 <p>
인수가 1 개의 버젼에서는
 인터럽트나 스프리아스웨이크압이 발생할 가능성이 있으므로 이 메서드는 항상 루프로 사용될 필요가 있습니다.
 
 <pre>

     synchronized (obj) {
         while (&lt;condition does not hold&gt;)
             obj.wait(timeout, nanos);
         ... // Perform action appropriate to condition
     }
 </pre>
이 메서드를 호출하는 것은, 이 오브젝트의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 오브젝트의 모니터의 오너가 되는 방법에 대해서는
<code>notify</code> 메서드를 참조하십시오.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>timeout</CODE> - 밀리 세컨드 단위의 대기 시간<DD><CODE>nanos</CODE> - 추가의 대기 시간 (나노초단위로 0 ~ 999999
 범위)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 대기 시간의 값이 부의 경우, 또는 nanos
 값이 0 ~ 999999
 범위외의 경우
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 이 오브젝트의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에
 다른 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="wait()"><!-- --></A> <H3>
wait</H3>
<PRE>
public final void <B>wait</B>()
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>다른 thread가 이 오브젝트의 <A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>  메서드 또는 <A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A>  메서드를 호출할 때까지, 현재의 thread를 대기시킵니다. 즉, 이 메서드의 동작은 <tt>wait(0)</tt>를
 호출했을 경우와 같습니다.
 <p>
현재의 thread는 이 오브젝트의 모니터의 오너가 아니면 안됩니다. thread는 이 모니터의 소유권을 해방해, 다른 thread가 <code>notify</code> 메서드 또는 <code>notifyAll</code> 메서드를 호출해 이 오브젝트의 모니터상에서 대기하는 thread에 통지를 보낼 때까지 대기합니다. 그 후, thread는 모니터의 소유권을 재차 취득할 때까지 대기하고 나서 실행을 재개합니다.
 <p>
인수가 1 개의 버젼에서는
 인터럽트나 스프리아스웨이크압이 발생할 가능성이 있으므로 이 메서드는 항상 루프로 사용될 필요가 있습니다.
 
 <pre>

     synchronized (obj) {
         while (&lt;condition does not hold&gt;)
             obj.wait();
         ... // Perform action appropriate to condition
     }
 </pre>
이 메서드를 호출하는 것은, 이 오브젝트의 모니터를 소유하는 thread 뿐만이 아니면 안됩니다. thread가 오브젝트의 모니터의 오너가 되는 방법에 대해서는
<code>notify</code> 메서드를 참조하십시오.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalMonitorStateException.html" title="java.lang 안의 클래스">IllegalMonitorStateException</A> </CODE> - 현재의 thread가 오브젝트의 모니터를 소유하고 있지 않는 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 현재의 thread가 통지를 대기하기 전 또는 대기중에
 다른 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>notify()</CODE></A>,
 
<A HREF="../../java/lang/Object.html#notifyAll()"><CODE>notifyAll()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="finalize()"><!-- --></A> <H3>
finalize</H3>
<PRE>
protected void <B>finalize</B>()
                 throws <A HREF="../../java/lang/Throwable.html" title="java.lang 내의 클래스">Throwable</A> </PRE>
<DL>
<DD>이 오브젝트에의 참조는 이제 없으면 가비지 컬렉션에
해 판단되었을 때에
 가비지 컬렉터에
해 불려 갑니다. 서브 클래스는 <code>finalize</code> 메서드를 오버라이드(override) 해, system resource를 파기하거나 그 외의 클린 업을 실시하거나 할 수가 있습니다.  
 <p>
<tt>finalize</tt>
 일반적인 규약에서는
 finalize
 호출은, 아직 생존하고 있는 임의의 thread가 이 오브젝트에 액세스 하는 방법은 없으면 Java<font size="-2"><sup>TM</sup></font> 가상 머신이 판단했을 경우에 행해집니다. 다만, 파이나라이즈의 준비가 끝난 것 외의 오브젝트 또는 클래스를 파이나라이즈하기 위한 처리의 결과 그렇게 되었을 경우를 제외합니다. <tt>finalize</tt> 메서드는
 이 오브젝트를 다른 thread로 다시 이용 가능하게 하는 일도 포함해, 임의의 액션을 실시할 수가 있습니다. 그러나,<tt>finalize</tt>
 보통
의 용도는
 오브젝트를 재생 불가능한 형태로 파기하기 전의 클린 업을 실행하는 것입니다. 예를 들어, 입출력의 접속을 나타내는 오브젝트의 finalize 메서드는
 오브젝트가 영구적으로 파기되기 전에
 접속을 절단하기 위한 명시적인 입출력 처리를 실시합니다.
 <p>
<tt>Object</tt> 클래스의 <tt>finalize</tt> 메서드는
 특별한 처리를 실시하지 않습니다. 일반적으로 아무것도 하지 않고 복귀합니다. <tt>Object</tt>
 서브 클래스는
 이 정의를 오버라이드(override) 할 수가 있습니다.
 <p>
Java 프로그램 언어는
 임의의 오브젝트에 대해 어느 thread가 <tt>finalize</tt> 메서드를 호출하는지를 보증하지 않습니다. 그러나, finalize를
 호출하는 thread가, 유저에게 가시인 동기 락을 finalize 호출의 시점에서는 보관 유지하고 있지 않는 것에 붙어 보증됩니다. 캐치 되지 않는 예외를 finalize 메서드가 Throw 했을 경우, 예외는 무시되어 오브젝트의 파이나라이즈는 종료합니다.
 <p>
어느 오브젝트에 대해 <tt>finalize</tt> 메서드가 불려 간 뒤에 다음의 처리가 발생하는 것은, 아직 생존하고 있는 임의의 thread가 이 오브젝트에 액세스 할 수 있는 방법은 없으면 Java 가상 머신이 다시 판단했을 때입니다. 이것에는
 파이나라이즈의 준비가 되어 있는 것 외의 오브젝트 또는 클래스에
해 발생한 처리도 포함되어 그 시점에서 이 오브젝트는 파기됩니다.
 <p>
임의의 오브젝트에 대해 Java 가상 머신이 <tt>finalize</tt> 메서드를 여러 차례 호출할 것은 없습니다.
 <p>
finalize 메서드에
해 예외가 Throw 되면,<code>finalize</code> 메서드의 처리는 정지됩니다. 그렇지 않은 경우는 무시됩니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> </CODE> - 이 메서드로 생긴 <code>Exception</code></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Object.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/lang/NumberFormatException.html" title="java.lang 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/lang/Object.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Object.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

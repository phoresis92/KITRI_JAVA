<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:56:58 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Thread (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.lang.Thread class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Thread (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형"><B>차의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang</FONT>
<BR>
클래스 Thread</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.Thread</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Thread</B><DT>extends <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </DL>
</PRE>

<P>
「thread」란
 프로그램내에서의 실행 thread입니다. Java 가상 머신에서는
 어플리케이션은 병렬에 실행되는 복수의 thread를 사용할 수가 있습니다.  
 <p>
각 thread에는 우선 순위를 붙일 수 있고 있습니다. 우선 순위의 높은 thread는
 우선 순위의 낮은 thread보다 우선해 실행됩니다. 게다가 각 thread가 demon로서 마크 되고 있는 경우도 있으면, 되어 있지 않은 경우도 있습니다. 어느 thread로 실행중의 코드가 새로운 <code>Thread</code> 오브젝트를 작성하면, 이 새로운 thread에는
 그 시점에서는
 작성측의 thread의 우선 순위에 동일한 우선 순위가 설정되어 작성측 thread가 demon인 경우에만, demon thread.  
 <p>
보통
, Java 가상 머신이 시작하는 (일반적으로는 있는 지정된 클래스의 <code>main</code> 라는 이름이 붙일 수 있었던 메서드를 호출한다)와 demon thread가 아닌 thread가 1 개 존재합니다. Java 가상 머신은, 이하의 어떤 것인가의 조건이 발생할 때까지 thread를 계속 실행합니다. <ul> <li><code>Runtime</code> 클래스의 <code>exit</code> 메서드가 불려 가 시큐러티 매니저가 exit 동작을 허가했다<li><code>run</code> 메서드의 호출로부터 복귀하는 것에
해, 또는 <code>run</code> 메서드 이외로부터 보내지는 예외를 Throw 하는 것에
해, demon thread는 아닌 모든 thread가 종료했다 
</ul>

 <p>
새로운 실행의 thread를 작성하려면 2 방법의 방법이 있습니다. 1 개의 방법은, 클래스를 <code>Thread</code>
 서브 클래스이다고 선언하는 것입니다. 이 서브 클래스는
 클래스 <code>Thread</code>
 <code>run</code> 메서드를 오버라이드(override) 하지 않으면 안됩니다. 그러면 서브 클래스의 인스턴스는 할당할 수 있어 시작될 수가 있습니다. 예를 들어, 초기치보다 큰 소수를 계산하는 thread는
 다음에 나타내도록(듯이) 해 작성할 수 있습니다.
 <p><hr><blockquote>
 <pre>

 class PrimeThread extends Thread { long minPrime; PrimeThread(long minPrime) { this.minPrime = minPrime; }  public void run() { // compute primes larger than minPrime &nbsp;. &nbsp;. &nbsp;.  } } </pre></blockquote><hr>
 <p>
다음에
 이하에 나타내는 코드로 thread를 작성해, thread의 실행을 개시합니다.
 <p><blockquote>
 <pre>

 PrimeThread p = new PrimeThread(143); p.start(); </pre></blockquote>
 <p>
thread를 작성하는 이제(벌써) 1 개의 방법은,<code>Runnable</code> 인터페이스를 구현하는 클래스를 선언하는 것입니다. 그렇다면, 그 클래스는
<code>run</code> 메서드를 구현합니다. 클래스의 인스턴스를 할당할 수 있어<code>Thread</code>
 작성시에 인수로서 건네받아 개시됩니다. 이 방법에서의 같은 예는
 이하에 나타내게 됩니다.
 <p><hr><blockquote>
 <pre>

 class PrimeRun implements Runnable { long minPrime; PrimeRun(long minPrime) { this.minPrime = minPrime; }  public void run() { // compute primes larger than minPrime &nbsp;. &nbsp;. &nbsp;.  } } </pre></blockquote><hr>
 <p>
다음에
 이하에 나타내는 코드로 thread를 작성해, thread의 실행을 개시합니다.
 <p><blockquote>
 <pre>

 PrimeRun p = new PrimeRun(143); new Thread(p). start(); </pre></blockquote>
 <p>
각 thread는 식별을 위한 이름을 가집니다. 복수의 thread가 같은 이름을 가지는 일이 있습니다. thread의 작성시에 이름이 지정되지 않으면 thread에는 새로운 이름이 생성됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 0</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스"><CODE>Runnable</CODE></A>,
 
<A HREF="../../java/lang/Runtime.html#exit(int)"><CODE>Runtime.exit(int)</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.State.html" title="java.lang 안의 열거형">Thread.State</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread 상태입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;interface</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에
해,<tt>Thread</tt> 가 돌연 종료했을 때에 불려 가는 것 핸들러의 인터페이스입니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MAX_PRIORITY">MAX_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread로 설정할 수 있는 최고 우선 순위입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#MIN_PRIORITY">MIN_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread로 설정할 수 있는 최저 우선 순위입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#NORM_PRIORITY">NORM_PRIORITY</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread에 할당할 수 있는 디폴트의 우선 순위입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread()">Thread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable)">Thread</A> </B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.Runnable, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;그 실행 오브젝트로서 <code>target</code>, 이름으로서 지정된 <code>name</code>를
 가지는
<code>group</code> 에
해 참조되는 thread 그룹에 속하는 것 같은, 새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
       long&nbsp;stackSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당해 실행 오브젝트로서 <code>target</code>를
 보관 유지해, 지정된 <code>name</code>를
 이름으로서 보관 유지하도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.String)">Thread</A> </B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
       <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;새로운 <code>Thread</code> 오브젝트를 할당합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#activeCount()">activeCount</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread의 thread 그룹내의 액티브한 thread수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#checkAccess()">checkAccess</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread가, 이 thread를 변경하기 위한 액세스권을 가지고 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#countStackFrames()">countStackFrames</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 호출의 정의는
 추천 되지 않는 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  에
존합니다. 또, 이 호출의 결과는 보증되지 않습니다. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#currentThread()">currentThread</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread 오브젝트의 참조를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#destroy()">destroy</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 원래 클린 업없이 파기되도록 설계되고 있었습니다. 보관 유지되는 모니터는 락 된 상태를 유지합니다. 다만, 이 메서드는 구현되지 않았습니다. 구현되고 있으면,<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 거의 똑같이 데드 록이 발생합니다. 타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다. 다른 thread가 이 자원을 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#dumpStack()">dumpStack</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread의 스택 트레이스를 출력합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#enumerate(java.lang.Thread[])">enumerate</A> </B>(<A HREF="../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> []&nbsp;tarray)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread의 thread 그룹 및 그 하위 그룹내의 모든 액티브한 thread를, 지정된 배열에 카피합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>,
<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getAllStackTraces()">getAllStackTraces</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;모든 라이브 thread의 스택 트레이스 맵을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getContextClassLoader()">getContextClassLoader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Thread
 컨텍스트
 ClassLoader를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getDefaultUncaughtExceptionHandler()">getDefaultUncaughtExceptionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에
해 thread가 돌연 종료했을 때에 불려 가는 디폴트의 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getId()">getId</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 식별자를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getName()">getName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getPriority()">getPriority</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 우선 순위를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getStackTrace()">getStackTrace</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 스택 덤프를 나타내는 스택 트레이스 요소의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형">Thread.State</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getState()">getState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread 상태를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 내의 클래스">ThreadGroup</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getThreadGroup()">getThreadGroup</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 소속하는 thread 그룹을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()">getUncaughtExceptionHandler</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에
해 thread가 돌연 종료했을 때에 불려 가는 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#holdsLock(java.lang.Object)">holdsLock</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현행 thread가 지정된 오브젝트에 대한 모니터 락을 보관 유지하는 경우에게만,<tt>true</tt>를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupt()">interrupt</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread에 끼어듭니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#interrupted()">interrupted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 thread가 끼어들어지고 있는지 어떤지를 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isAlive()">isAlive</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 생존하고 있을지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isDaemon()">isDaemon</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 demon thread일지 어떨지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#isInterrupted()">isInterrupted</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 끼어들어지고 있는 제발을 조사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join()">join</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 종료하는 것을 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long)">join</A> </B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 종료하는 것을, 최고로 <code>millis</code> 밀리 세컨드 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#join(long, int)">join</A> </B>(long&nbsp;millis,
     int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;최고로 <code>millis</code> 밀리 세컨드에 <code>nanos</code> 나노초를 가산한 사이, 이 thread가 종료하는 것을 대기합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#resume()">resume</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 함께 사용하기 위해인 만큼 제공되고 있습니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#run()">run</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread가 별개의 <code>Runnable</code> 실행 오브젝트를 사용해 작성되었을 경우, 그 <code>Runnable</code> 오브젝트의 <code>run</code> 메서드가 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)">setContextClassLoader</A> </B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 Thread
 컨텍스트
 ClassLoader를
 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDaemon(boolean)">setDaemon</A> </B>(boolean&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread를, demon thread 또는 유저 thread로서 마크 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setDefaultUncaughtExceptionHandler</A> </B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에
해, thread가 돌연 종료했을 때나, 이 thread에 대해서 그 밖에 핸들러가 정의되어 있지 않을 때에 불려 가는 디폴트의 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setName(java.lang.String)">setName</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 이름을 인수 <code>name</code> 에 동일해지도록 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setPriority(int)">setPriority</A> </B>(int&nbsp;newPriority)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 우선 순위를 변경합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)">setUncaughtExceptionHandler</A> </B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;캐치 되지 않는 예외에
해, 돌연 thread가 종료했을 때에 사용되는 핸들러를 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long)">sleep</A> </B>(long&nbsp;millis)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread를, 지정된 밀리 세컨드수의 사이, sleeve (일시적으로 실행을 정지) 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#sleep(long, int)">sleep</A> </B>(long&nbsp;millis,
      int&nbsp;nanos)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread를, 지정된 밀리 세컨드수로 지정된 나노초수를 가산한 사이, sleeve (실행 정지) 시킵니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#start()">start</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 thread의 실행을 개시합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop()">stop</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. Thread.stop를
 사용해 thread를 정지하면, 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에
해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에
해 직전까지 보호되고 있던 오브젝트가 정합성의 없는 상태에 있었을 경우, 망가진 오브젝트는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면,
<code>stop</code>는
 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는 이 변수를 정기적으로 체크해, 변수가 실행 정지를 지시하고 있는 경우는
 run 메서드로부터 적절히 복귀합니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면,
<code>interrupt</code> 메서드를 사용합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#stop(java.lang.Throwable)">stop</A> </B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> 를
 참조하십시오. 게다가 이 메서드는
 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메서드가 없으면 thread에
해 Throw 될리가 없는
 체크된 예외 등). 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#suspend()">suspend</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. 타겟 thread가, 중요한 system resource를 보호하고 있는 모니터의 락을 보관 유지하고 있는 상태로 중단되었을 경우, 타겟 thread가 재개될 때까지, 어느 thread도 이 자원에 액세스 할 수 없습니다. 타겟 thread를 재개하려고 하는 thread가,<code>resume</code>를
 호출하기 전에 이 모니터를 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#toString()">toString</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thread의 이름, 우선 순위, thread 그룹을 포함한 이 thread의 캐릭터 라인 표현을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/lang/Thread.html#yield()">yield</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재 실행중의 thread 오브젝트를 일시적으로 휴지시켜, 다른 thread를 실행할 수 있도록 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="MIN_PRIORITY"><!-- --></A> <H3>
MIN_PRIORITY</H3>
<PRE>
public static final int <B>MIN_PRIORITY</B></PRE>
<DL>
<DD>thread로 설정할 수 있는 최저 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MIN_PRIORITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="NORM_PRIORITY"><!-- --></A> <H3>
NORM_PRIORITY</H3>
<PRE>
public static final int <B>NORM_PRIORITY</B></PRE>
<DL>
<DD>thread에 할당할 수 있는 디폴트의 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.NORM_PRIORITY">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="MAX_PRIORITY"><!-- --></A> <H3>
MAX_PRIORITY</H3>
<PRE>
public static final int <B>MAX_PRIORITY</B></PRE>
<DL>
<DD>thread로 설정할 수 있는 최고 우선 순위입니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../constant-values.html#java.lang.Thread.MAX_PRIORITY">정수 필드치</A> </DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Thread()"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>()</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(null, null,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다. 이 경우,<b><i>gname</i></b>는

 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i>를
 정수로 하면 <code>"Thread-"+</code><i>n</i>
 형식을 취합니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(null, target,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다. 이 경우,<i>gname</i>는

 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i>를
 정수로 하면 <code>"Thread-"+</code><i>n</i>
 형식을 취합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>target</CODE> - 그 <code>run</code> 메서드가 불려 가는 오브젝트<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(group, target,</code> <i>gname</i><code>)</code> 와 같은 효과를 가집니다. 이 경우,<i>gname</i>는

 새롭게 작성되는 이름입니다. 자동적으로 작성되는 이름은,<i>n</i>를
 정수로 하면 <code>"Thread-"+</code><i>n</i>
 형식을 취합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메서드가 불려 가는 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내에 thread를 작성할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(null, null, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 새로운 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(group, null, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>name</CODE> - 새로운 thread의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내에 thread를 작성할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.Runnable, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당합니다. 이 생성자는
<code>Thread(null, target, name)</code> 와 같은 효과를 가집니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>target</CODE> - 그 <code>run</code> 메서드가 불려 가는 오브젝트<DD><CODE>name</CODE> - 새로운 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>그 실행 오브젝트로서 <code>target</code>, 이름으로서 지정된 <code>name</code>를
 가지는
<code>group</code> 에
해 참조되는 thread 그룹에 속하는 것 같은, 새로운 <code>Thread</code> 오브젝트를 할당합니다.
 <p>
<code>group</code> 가 <code>null</code> 로 시큐러티 매니저가 존재하는 경우, 그룹은 시큐러티 매니저의 <code>getThreadGroup</code> 메서드에
해 정해집니다. <code>group</code> 가 <code>null</code> 로 시큐러티 매니저가 존재하지 않는 경우, 또는 시큐러티 매니저의 <code>getThreadGroup</code> 메서드가 <code>null</code>를
 돌려주는 경우, 그룹은 새로운 thread를 작성중의 thread와 같은 ThreadGroup 로 설정됩니다.
<p>시큐러티 매니저가 존재하는 경우는
 ThreadGroup를
 인수로서 건네주어 <code>checkAccess</code> 메서드를 호출합니다.
<p>또,<code>getContextClassLoader</code> 메서드 또는 <code>setContextClassLoader</code> 메서드를 오버라이드(override) 하는 서브 클래스의 생성자에
해 직접적 또는 간접적으로 불려 갔을 때,<code>RuntimePermission("enableContextClassLoaderOverride")</code> 액세스권을 사용해 <code>checkPermission</code> 메서드를 호출합니다. 그 결과, SecurityException 가 발생하는 일이 있습니다.

 <p>
<code>target</code> 인수가 <code>null</code> 가 아닌 경우, 이 thread가 시작되면 <code>target</code>
 <code>run</code> 메서드가 불려 갑니다. target 인수가 <code>null</code> 인 경우는
 이 thread가 시작될 때 이 thread의 <code>run</code> 메서드가 불려 갑니다.
 <p>
새롭게 작성된 thread의 우선 순위는
 그 thread를 작성한 thread, 즉 현재 실행중의 thread의 우선 순위와 같게 설정됩니다. 이 우선 순위를 새로운 값으로 변경하는 경우는
 메서드 <code>setPriority</code>를
 사용할 수 있습니다.  
 <p>
새롭게 작성된 thread는
 그것을 작성하는 thread가 demon thread와 마크 되고 있는 경우에만, demon thread와 마크 됩니다. thread가 demon일지 어떨지를 변경하는 경우는
 메서드 <code>setDaemon</code>를
 사용할 수 있습니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메서드가 불려 가는 오브젝트<DD><CODE>name</CODE> - 새로운 thread의 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내에 thread를 작성할 수 없는
 또는 컨텍스트
 클래스 로더의 메서드를 오버라이드(override) 할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A>,
 
<A HREF="../../java/lang/ThreadGroup.html#checkAccess()"><CODE>ThreadGroup.checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(java.lang.Thread)</CODE></A> </DL>
</DL>
<HR>

<A NAME="Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String, long)"><!-- --></A> <H3>
Thread</H3>
<PRE>
public <B>Thread</B>(<A HREF="../../java/lang/ThreadGroup.html" title="java.lang 안의 클래스">ThreadGroup</A> &nbsp;group,
              <A HREF="../../java/lang/Runnable.html" title="java.lang 안의 인터페이스">Runnable</A> &nbsp;target,
              <A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name,
              long&nbsp;stackSize)</PRE>
<DL>
<DD>새로운 <code>Thread</code> 오브젝트를 할당해 실행 오브젝트로서 <code>target</code>를
 보관 유지해, 지정된 <code>name</code>를
 이름으로서 보관 유지하도록 합니다. 또,<code>group</code> 에
해 참조되는 thread 그룹에 소속해, 지정된 「스택 사이즈」를 보관 유지합니다.

<p>이 생성자는
 thread의 스택 사이즈 지정이 가능한 점을 제외해,<A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(ThreadGroup, Runnable, String)</CODE></A>  와 같습니다. 스택 사이즈는
 가상 머신을 이 thread의 스택에 할당하는 address 공간의 대략의 바이트수가 됩니다. <b><tt>stackSize</tt> 파라미터가 존재하는 경우, 그 효과는 플랫폼에
해 크게 다릅니다. </b>

<p>몇개의 플랫폼에서는
<tt>stackSize</tt> 파라미터에
해 큰 값을 지정하는 것으로 thread가 <A HREF="../../java/lang/StackOverflowError.html" title="java.lang 안의 클래스"><CODE>StackOverflowError</CODE></A> 를
 Throw 하기 전에
해 큰 회귀 심도를 달성하는 것이 가능하게 됩니다. 같이보다 작은 값을 지정하는 것으로 보다 많은 thread가 <A HREF="../../java/lang/OutOfMemoryError.html" title="java.lang 안의 클래스"><CODE>OutOfMemoryError</CODE></A>  (또는 다른 내부 에러)를 Throw 하지 않고,
 동시에 존재하는 것이 가능하게 됩니다. <tt>stackSize</tt> 파라미터의 값과 최대 회귀 심도나 병행 레벨과의 관계는 플랫폼에 따라서 다릅니다. <b>플랫폼에 따라서는
<tt>stackSize</tt> 파라미터의 값이 어떤 영향을 주지 않는 경우가 있습니다. </b>
<p>가상 머신은,<tt>stackSize</tt> 파라미터를 자유롭게 취급해, 지시할 수가 있습니다. 플랫폼에서는 지정된 값이 너무 작은 경우, 가상 머신은 대신에 플랫폼 고유의 최소치를 사용할 수 있습니다. 지정된 값이 너무 큰 경우에는
 가상 머신은 대신에 플랫폼 고유의 최대치를 사용할 수 있습니다. 같이 가상 머신은, 적절한 경우에는 지정된 값의 절상해 또는 인하를 자유롭게 실행 (또는 완전하게 무시)할 수 있습니다.

<p><tt>stackSize</tt> 파라미터에 값제로를 지정하면, 이 생성자는 <tt>Thread(ThreadGroup, Runnable, String)</tt> 생성자
과 정확하게 같은 동작을 실행합니다.

<p>이 생성자 동작은 플랫폼에 따라서 다르기 위해서, 신중하게 사용할 필요가 있습니다. 지정된 계산의 실행에 필요한 thread 스택 사이즈는
 JRE 구현에 따라서 다를 가능성이 있습니다. 이 때문에
 스택 사이즈 파라미터를 주의 깊게 튜닝 하거나 어플리케이션을 실행하는 JRE 구현 마다 튜닝을 반복하거나 하는 것이 필요한 경우가 있습니다.

<p>구현상의 주의점: Java 플랫폼 구현자는
<tt>stackSize parameter</tt>를
 기준으로 해 구현의 동작을 문서화해 두는 것을 추천합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>group</CODE> - thread 그룹<DD><CODE>target</CODE> - 그 <code>run</code> 메서드가 불려 가는 오브젝트<DD><CODE>name</CODE> - 새로운 thread의 이름<DD><CODE>stackSize</CODE> - 새로운 thread의 스택 사이즈 또는 제로 (이 파라미터를 무시하는 것을 나타낸다)
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가, 지정된 thread 그룹내에 thread를 작성할 수 없는 경우</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="currentThread()"><!-- --></A> <H3>
currentThread</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>  <B>currentThread</B>()</PRE>
<DL>
<DD>현재 실행중의 thread 오브젝트의 참조를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재 실행중의 thread</DL>
</DD>
</DL>
<HR>

<A NAME="yield()"><!-- --></A> <H3>
yield</H3>
<PRE>
public static void <B>yield</B>()</PRE>
<DL>
<DD>현재 실행중의 thread 오브젝트를 일시적으로 휴지시켜, 다른 thread를 실행할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long)"><!-- --></A> <H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재 실행중의 thread를, 지정된 밀리 세컨드수의 사이, sleeve (일시적으로 실행을 정지) 시킵니다. thread는 모니터의 소유권을 잃지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 sleeve 시간의 길이
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 별의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 인터럽트 스테이터스는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="sleep(long, int)"><!-- --></A> <H3>
sleep</H3>
<PRE>
public static void <B>sleep</B>(long&nbsp;millis,
                         int&nbsp;nanos)
                  throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>현재 실행중의 thread를, 지정된 밀리 세컨드수로 지정된 나노초수를 가산한 사이, sleeve (실행 정지) 시킵니다. thread는 모니터의 소유권을 잃지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 sleeve 시간의 길이<DD><CODE>nanos</CODE> - sleeve하기 위한 0 ~ 999999
 추가 나노초
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - millis
 값이 음수의 경우, 또는 nanos
 값이 0 ~ 999999
 범위외의 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 별의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 되는<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Object.html#notify()"><CODE>Object.notify()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="start()"><!-- --></A> <H3>
start</H3>
<PRE>
public void <B>start</B>()</PRE>
<DL>
<DD>이 thread의 실행을 개시합니다. Java 가상 머신은, 이 thread의 <code>run</code> 메서드를 호출합니다.  
 <p>
그 결과, (<code>start</code> 메서드에의 호출로부터 복귀한다) 현재의 thread와 (그 <code>run</code> 메서드를 실행한다) 다른 thread라고 하는 2 개의 thread가 병렬에 실행됩니다.
 <p>
thread를 여러 차례 시작하는 것은, 결코 올바르다고는 말할 수 없습니다. 특히, thread는 실행을 끝내고 나서 재시작할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - thread가 벌써 시작하고 있었을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="run()"><!-- --></A> <H3>
run</H3>
<PRE>
public void <B>run</B>()</PRE>
<DL>
<DD>이 thread가 별개의 <code>Runnable</code> 실행 오브젝트를 사용해 작성되었을 경우, 그 <code>Runnable</code> 오브젝트의 <code>run</code> 메서드가 불려 갑니다. 그렇지 않은 경우, 이 메서드는 아무것도 실시하지 않고 복귀합니다.
 <p>
<code>Thread</code>
 서브 클래스는
 이 메서드를 오버라이드(override) 하지 않으면 안됩니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/lang/Runnable.html" title="java.lang 내의 인터페이스">Runnable</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Runnable.html#run()">run</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)"><CODE>Thread(java.lang.ThreadGroup, java.lang.Runnable, java.lang.String)</CODE></A>,
 
<A HREF="../../java/lang/Runnable.html#run()"><CODE>Runnable.run()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="stop()"><!-- --></A> <H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>stop</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. Thread.stop를
 사용해 thread를 정지하면, 체크되어 있지 않은 <code>ThreadDeath</code> 예외가 스택아래에서 위에게 전할 수 있었던 결과, 그 thread에
해 락 되고 있던 모니터의 락이 모두 해제됩니다. 이러한 모니터에
해 직전까지 보호되고 있던 오브젝트가 정합성의 없는 상태에 있었을 경우, 망가진 오브젝트는 다른 thread에 대해서 가시가 되어, 동작이 보증되지 않는 것이 있습니다. 많은 경우, 타겟 thread의 실행 정지를 지시하려면,
<code>stop</code>는
 아니고, 단지 일부의 변수를 변경하는 코드를 사용할 필요가 있습니다. 타겟 thread는 이 변수를 정기적으로 체크해, 변수가 실행 정지를 지시하고 있는 경우는
 run 메서드로부터 적절히 복귀합니다. 조건 변수등으로 타겟 thread가 오랫동안 대기하고 있는 경우, 대기를 중단시키려면,
<code>interrupt</code> 메서드를 사용합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>
<P>
<DD>thread에 강제적으로 실행을 정지시킵니다.
 <p>
시큐러티 매니저가 인스톨 되고 있는 경우,<code>this</code>를
 인수로서 시큐러티 매니저의 <code>checkAccess</code> 메서드가 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
또, 이 thread가 현재의 thread와 다른 경우, 즉, 현재의 thread가 자신 이외의 thread를 정지하려고 하고 있는 경우는
<code>RuntimePermission("stopThread")</code>를
 인수로서 시큐러티 매니저의 <code>checkPermission</code> 메서드도 불려 갑니다. 이 경우에도, 현재의 thread로 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
이 thread에
해 나타내지는 thread는
 그것이 실행하고 있던 동작에 관계없이 강제적으로 이상 정지 당해 새롭게 생성한 <code>ThreadDeath</code> 오브젝트를 예외로서 Throw 합니다.  
 <p>
아직 시작되어 있지 않은 thread를 정지할 수가 있습니다. thread가 최종적으로 시작되자, 곧바로 종료합니다.
 <p>
어플리케이션은, 보통
과는 다른 클린 업 동작을 실행해야 하는 경우를 제외해,<code>ThreadDeath</code>를
 캐치 해야 하지는 않습니다. 다만,<code>ThreadDeath</code>를
 Throw 하면, thread가 정식으로 종료하기 전에 <code>try</code> 문의 <code>finally</code> 절이 실행되는 것에 주의해 주세요. <code>catch</code> 절이 <code>ThreadDeath</code> 오브젝트를 캐치 하는 경우는
 thread가 실제로 종료하도록 오브젝트를 Throw 다시 하는 것이 중요합니다.
 <p>
그렇지 않은 경우, 캐치되어 있지 않은 예외를 취급하는 최고 레벨의 에러 핸들러는
 캐치되어 있지 않은 예외가 <code>ThreadDeath</code>
 인스턴스이면, 메세지를 출력하거나 어플리케이션에 통지하거나 하는 것은 하지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>,
 
<A HREF="../../java/lang/ThreadDeath.html" title="java.lang 안의 클래스"><CODE>ThreadDeath</CODE></A>,
 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>java.lang.Throwable)(java.lang.Thread,</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="stop(java.lang.Throwable)"><!-- --></A> <H3>
stop</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>stop</B>(<A HREF="../../java/lang/Throwable.html" title="java.lang 안의 클래스">Throwable</A> &nbsp;obj)</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 본질적으로 안전하지는 않습니다. <A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A> 를
 참조하십시오. 게다가 이 메서드는
 타겟 thread로 처리의 준비가 되어 있지 않은 예외의 생성에 사용되는 일이 있는 점에서도 위험합니다 (이 메서드가 없으면 thread에
해 Throw 될리가 없는
 체크된 예외 등). 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>
<P>
<DD>thread에 강제적으로 실행을 정지시킵니다.
 <p>
시큐러티 매니저가 인스톨 되고 있는 경우, 시큐러티 매니저의 <code>checkAccess</code> 메서드가 불려 갑니다. 이 결과, 현재의 thread로 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
또, 이 thread가 현재의 thread와 다른 경우, 즉, 현재의 thread가 자신 이외의 thread를 정지하려고 하고 있는 경우, 또는 <code>obj</code> 가 <code>ThreadDeath</code>
 인스턴스가 아닌 경우는
<code>RuntimePermission("stopThread")</code>를
 인수로서 시큐러티 매니저의 <code>checkPermission</code> 메서드가 불려 갑니다. 이 경우에도, 현재의 thread로 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
인수 <code>obj</code> 가 null
 경우, 현재의 thread로 <code>NullPointerException</code> 가 Throw 됩니다.
 <p>
이 thread에
해 나타내지는 thread는
 그것이 실행하는 동작에는 관계없이 강제적으로 종료되어 예외로서 <code>Throwable</code> 오브젝트 <code>obj</code> 가 Throw 됩니다. 이것은 보통
에서는 행해지지 않는 동작이기 때문에
 일반적으로 인수를 설정하지 않는 <code>stop</code> 메서드를 사용해 주세요.
 <p>
아직 시작되어 있지 않은 thread를 정지할 수가 있습니다. thread가 최종적으로 시작되자, 곧바로 종료합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - Throw 대상의 Throwable 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupt()"><CODE>interrupt()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#run()"><CODE>run()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#start()"><CODE>start()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#stop()"><CODE>stop()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(Thread)</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="interrupt()"><!-- --></A> <H3>
interrupt</H3>
<PRE>
public void <B>interrupt</B>()</PRE>
<DL>
<DD>이 thread에 끼어듭니다.
<p> 현재의 thread가 자신에게 끼어들지 않은 한 (이 인터럽트는 허가된다), 이 thread의 <A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess</CODE></A>  메서드가 불려 갑니다. 이 메서드에
해,<A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 Throw 되는 경우가 있습니다.

<p> <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스"><CODE>Object</CODE></A>  클래스의 <A HREF="../../java/lang/Object.html#wait()"><CODE>wait()</CODE></A>,
<A HREF="../../java/lang/Object.html#wait(long)"><CODE>wait(long)</CODE></A>,
 또는 <A HREF="../../java/lang/Object.html#wait(long, int)"><CODE>wait(long, int)</CODE></A>  메서드의 호출해, 또는 이 클래스의 <A HREF="../../java/lang/Thread.html#join()"><CODE>join()</CODE></A>,
<A HREF="../../java/lang/Thread.html#join(long)"><CODE>join(long)</CODE></A>,
<A HREF="../../java/lang/Thread.html#join(long, int)"><CODE>join(long, int)</CODE></A>,
<A HREF="../../java/lang/Thread.html#sleep(long)"><CODE>sleep(long)</CODE></A>,
 또는 <A HREF="../../java/lang/Thread.html#sleep(long, int)"><CODE>sleep(long, int)</CODE></A>  메서드의 호출로 이 thread가 블록 되는 경우, 인터럽트 스테이터스는 클리어 되어<A HREF="../../java/lang/InterruptedException.html" title="java.lang 동안의 클래스"><CODE>InterruptedException</CODE></A> 를
 받습니다.

<p> <A HREF="../../java/nio/channels/InterruptibleChannel.html" title="java.nio.channels 안의 인터페이스"><CODE><code>interruptible channel</code></CODE></A>  에 대한 I/O 조작으로 이 thread가 블록 되는 경우, 채널은 닫혀져 thread의 인터럽트 스테이터스가 설정됩니다. 또, thread는 <A HREF="../../java/nio/channels/ClosedByInterruptException.html" title="java.nio.channels 안의 클래스"><CODE>ClosedByInterruptException</CODE></A> 를
 받습니다.

<p> <A HREF="../../java/nio/channels/Selector.html" title="java.nio.channels 안의 클래스"><CODE>Selector</CODE></A>  로 이 thread가 블록 되는 경우, thread의 인터럽트 스테이터스가 설정되어, 선택 조작으로부터 즉석에서 돌려주고집니다. 보통
, 돌려주고지는 값은, 셀렉터의 <A HREF="../../java/nio/channels/Selector.html#wakeup()"><CODE>wakeup</CODE></A>  메서드가 불려 갔을 경우와 같이, 제로 이외의 값이 됩니다.

<p> 전술의 조건의 어느 것에도 들어맞지 않는 경우, 이 thread의 인터럽트 스테이터스가 설정됩니다.  </p>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="interrupted()"><!-- --></A> <H3>
interrupted</H3>
<PRE>
public static boolean <B>interrupted</B>()</PRE>
<DL>
<DD>현재의 thread가 끼어들어지고 있는지 어떤지를 조사합니다. 이 메서드에
해 thread의 「인터럽트 스테이터스」가 클리어 됩니다. 즉, 이 메서드가 계속해 2 회 불려 갔을 경우, 2 번째의 호출은 false를
 돌려줍니다 (최초의 호출이 끼어들어 스테이터스를 클리어 한 후에
 2 번째의 호출이 그것을 확인하기 전에 현재의 thread가 한번 더 끼어들어졌을 경우를 제외하다).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 thread가 끼어들어지고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#isInterrupted()"><CODE>isInterrupted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isInterrupted()"><!-- --></A> <H3>
isInterrupted</H3>
<PRE>
public boolean <B>isInterrupted</B>()</PRE>
<DL>
<DD>이 thread가 끼어들어지고 있는 제발을 조사합니다. 이 메서드에
해 thread의 「인터럽트 스테이터스」가 영향을 받을 것은 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 끼어들어지고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#interrupted()"><CODE>interrupted()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="destroy()"><!-- --></A> <H3>
destroy</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public void <B>destroy</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 원래 클린 업없이 파기되도록 설계되고 있었습니다. 보관 유지되는 모니터는 락 된 상태를 유지합니다. 다만, 이 메서드는 구현되지 않았습니다. 구현되고 있으면,<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 거의 똑같이 데드 록이 발생합니다. 타겟 thread가 중요한 system resource를 보호하는 락을 보관 유지한 상태로 파기되었을 경우, 어느 thread도 다시 이 자원에 액세스 할 수 없습니다. 다른 thread가 이 자원을 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>
<P>
<DD><A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 안의 클래스"><CODE>NoSuchMethodError</CODE></A> 를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NoSuchMethodError.html" title="java.lang 안의 클래스">NoSuchMethodError</A> </CODE> - 상시</DL>
</DD>
</DL>
<HR>

<A NAME="isAlive()"><!-- --></A> <H3>
isAlive</H3>
<PRE>
public final boolean <B>isAlive</B>()</PRE>
<DL>
<DD>이 thread가 생존하고 있을지 어떨지를 판정합니다. thread가 시작되고 있어, 아직 종료되어 있지 않은 경우, thread는 생존하고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 생존하고 있는 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code></DL>
</DD>
</DL>
<HR>

<A NAME="suspend()"><!-- --></A> <H3>
suspend</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>suspend</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. 타겟 thread가, 중요한 system resource를 보호하고 있는 모니터의 락을 보관 유지하고 있는 상태로 중단되었을 경우, 타겟 thread가 재개될 때까지, 어느 thread도 이 자원에 액세스 할 수 없습니다. 타겟 thread를 재개하려고 하는 thread가,<code>resume</code>를
 호출하기 전에 이 모니터를 잠그려고 하면, 데드 록이 발생합니다. 보통
, 그러한 데드 록은, 자신을 「다운 당했다」프로세스로서 표명합니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>
<P>
<DD>이 thread를 중단합니다.
 <p>
우선, 이 thread의 <code>checkAccess</code> 메서드가, 인수없이 불려 갑니다. 이 결과, 현재의 thread내에서 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
thread는
 생존하고 있는 경우에 중단되어 재개되지 않는 처리를 먼저 진행할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resume()"><!-- --></A> <H3>
resume</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public final void <B>resume</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 데드 록을 발생하기 쉽기 때문에 추천 되지 않습니다. <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  와 함께 사용하기 위해인 만큼 제공되고 있습니다. 자세한 것은,<a href="../../../guide/misc/threadPrimitiveDeprecation.html">「Thread.stop, Thread.suspend 및 Thread.resume 가 추천 되지 않는 이유」</a>를 참조하십시오. </I>
<P>
<DD>중단된 thread를 재개합니다.
 <p>
우선, 이 thread의 <code>checkAccess</code> 메서드가, 인수없이 불려 갑니다. 이 결과, 현재의 thread내에서 <code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
thread는
 생존하고 있지만 중단되고 있는 경우, 실행이 재개되어 처리를 먼저 진행하는 것이 허가됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setPriority(int)"><!-- --></A> <H3>
setPriority</H3>
<PRE>
public final void <B>setPriority</B>(int&nbsp;newPriority)</PRE>
<DL>
<DD>이 thread의 우선 순위를 변경합니다.
 <p>
우선, 이 thread의 <code>checkAccess</code> 메서드가, 인수없이 불려 갑니다. 이 결과,<code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
그렇지 않은 경우, 이 thread의 우선 순위는
 지정된 <code>newPriority</code> 와 thread의 thread 그룹의 최고 허용 우선 순위 중의 어느 쪽인지 작은 편으로 설정됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>newPriority</CODE> - 이 thread를 설정하는 우선 순위
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 우선 순위가 <code>MIN_PRIORITY</code> ~ <code>MAX_PRIORITY</code>
 범위외인 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getPriority()"><CODE>getPriority()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#getPriority()"><CODE>getPriority()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#getThreadGroup()"><CODE>getThreadGroup()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#MAX_PRIORITY"><CODE>MAX_PRIORITY</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#MIN_PRIORITY"><CODE>MIN_PRIORITY</CODE></A>,
 
<A HREF="../../java/lang/ThreadGroup.html#getMaxPriority()"><CODE>ThreadGroup.getMaxPriority()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getPriority()"><!-- --></A> <H3>
getPriority</H3>
<PRE>
public final int <B>getPriority</B>()</PRE>
<DL>
<DD>이 thread의 우선 순위를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 우선 순위<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#setPriority(int)"><CODE>setPriority(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setName(java.lang.String)"><!-- --></A> <H3>
setName</H3>
<PRE>
public final void <B>setName</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;name)</PRE>
<DL>
<DD>이 thread의 이름을 인수 <code>name</code> 에 동일해지도록 변경합니다.  
 <p>
우선, 이 thread의 <code>checkAccess</code> 메서드가, 인수없이 불려 갑니다. 이 결과,<code>SecurityException</code> 가 Throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>name</CODE> - 이 thread의 새로운 이름
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getName()"><CODE>getName()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#getName()"><CODE>getName()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getName()"><!-- --></A> <H3>
getName</H3>
<PRE>
public final <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>getName</B>()</PRE>
<DL>
<DD>이 thread의 이름을 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 이름<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setName(java.lang.String)"><CODE>setName(java.lang.String)</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#setName(java.lang.String)"><CODE>setName(java.lang.String)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getThreadGroup()"><!-- --></A> <H3>
getThreadGroup</H3>
<PRE>
public final <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 내의 클래스">ThreadGroup</A>  <B>getThreadGroup</B>()</PRE>
<DL>
<DD>이 thread가 소속하는 thread 그룹을 돌려줍니다. 이 thread가 종료되고 있는 (정지되고 있다) 경우, 이 메서드는 null를
 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 thread 그룹</DL>
</DD>
</DL>
<HR>

<A NAME="activeCount()"><!-- --></A> <H3>
activeCount</H3>
<PRE>
public static int <B>activeCount</B>()</PRE>
<DL>
<DD>현행 thread의 thread 그룹내의 액티브한 thread수를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>현행 thread의 thread 그룹내의 액티브한 thread수</DL>
</DD>
</DL>
<HR>

<A NAME="enumerate(java.lang.Thread[])"><!-- --></A> <H3>
enumerate</H3>
<PRE>
public static int <B>enumerate</B>(<A HREF="../../java/lang/Thread.html" title="java.lang 안의 클래스">Thread</A> []&nbsp;tarray)</PRE>
<DL>
<DD>현행 thread의 thread 그룹 및 그 하위 그룹내의 모든 액티브한 thread를, 지정된 배열에 카피합니다. 이 메서드는
 현행 thread의 thread 그룹의 <code>enumerate</code> 메서드를, 배열 인수를 지정해 호출할 뿐입니다.  
 <p>
시큐러티 매니저가 존재하는 경우,<code>enumerate</code> 메서드는
 thread 그룹을 인수로서 시큐러티 매니저의 <code>checkAccess</code> 메서드를 호출합니다. 이 결과,<code>SecurityException</code> 가 Throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tarray</CODE> - Thread 오브젝트의 카피처 배열
<DT><B>반환값:</B><DD>배열에 포함되는 thread수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkAccess</code> 메서드가 이 조작을 허가하지 않는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/ThreadGroup.html#enumerate(java.lang.Thread[])"><CODE>ThreadGroup.enumerate(java.lang.Thread[])</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.ThreadGroup)"><CODE>SecurityManager.checkAccess(java.lang.ThreadGroup)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="countStackFrames()"><!-- --></A> <H3>
countStackFrames</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public int <B>countStackFrames</B>()</PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 호출의 정의는
 추천 되지 않는 <A HREF="../../java/lang/Thread.html#suspend()"><CODE>suspend()</CODE></A>  에
존합니다. 또, 이 호출의 결과는 보증되지 않습니다. </I>
<P>
<DD>이 thread내의 스택 프레임수를 카운트 합니다. thread는 중단될 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread내의 스택 프레임의 수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - 이 thread가 중단되지 않는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="join(long)"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>이 thread가 종료하는 것을, 최고로 <code>millis</code> 밀리 세컨드 대기합니다. <code>0</code>
 타임 아웃은 영원히 대기하는 것을
미합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 대기 시간
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 별의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="join(long, int)"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>(long&nbsp;millis,
                       int&nbsp;nanos)
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>최고로 <code>millis</code> 밀리 세컨드에 <code>nanos</code> 나노초를 가산한 사이, 이 thread가 종료하는 것을 대기합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>millis</CODE> - 밀리 세컨드 단위의 대기 시간<DD><CODE>nanos</CODE> - 대기하기 위한 0 ~ 999999
 추가 나노초
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - millis
 값이 음수의 경우, 또는 nanos
 값이 0 ~ 999999
 범위외의 경우
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 별의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A> <H3>
join</H3>
<PRE>
public final void <B>join</B>()
                throws <A HREF="../../java/lang/InterruptedException.html" title="java.lang 내의 클래스">InterruptedException</A> </PRE>
<DL>
<DD>이 thread가 종료하는 것을 대기합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/InterruptedException.html" title="java.lang 안의 클래스">InterruptedException</A> </CODE> - 별의 thread가 현재의 thread에 끼어들었을 경우. 이 예외가 Throw 되면, 현재의 thread의 「인터럽트 스테이터스」는 클리어 된다</DL>
</DD>
</DL>
<HR>

<A NAME="dumpStack()"><!-- --></A> <H3>
dumpStack</H3>
<PRE>
public static void <B>dumpStack</B>()</PRE>
<DL>
<DD>현재의 thread의 스택 트레이스를 출력합니다. 이 메서드는 디버그의 경우에만 사용합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Throwable.html#printStackTrace()"><CODE>Throwable.printStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setDaemon(boolean)"><!-- --></A> <H3>
setDaemon</H3>
<PRE>
public final void <B>setDaemon</B>(boolean&nbsp;on)</PRE>
<DL>
<DD>이 thread를, demon thread 또는 유저 thread로서 마크 합니다. Java 가상 머신은, 실행중의 thread가 demon thread만으로 되면 종료합니다.
 <p>
이 메서드는
 thread 시작전에 호출할 필요가 있습니다.
 <p>
이 메서드는
 인수없이 이 thread의 <code>checkAccess</code> 메서드를 호출합니다. 이 결과, 현재의 thread로 <code>SecurityException </code> 가 Throw 되는 일이 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>on</CODE> - <code>true</code>
 경우, 이 thread를 demon thread로서 마크 한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalThreadStateException.html" title="java.lang 안의 클래스">IllegalThreadStateException</A> </CODE> - 이 thread가 액티브한 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread를 변경할 수 없는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#isDaemon()"><CODE>isDaemon()</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#checkAccess()"><CODE>checkAccess()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isDaemon()"><!-- --></A> <H3>
isDaemon</H3>
<PRE>
public final boolean <B>isDaemon</B>()</PRE>
<DL>
<DD>이 thread가 demon thread일지 어떨지를 판정합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread가 demon thread인 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDaemon(boolean)"><CODE>setDaemon(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="checkAccess()"><!-- --></A> <H3>
checkAccess</H3>
<PRE>
public final void <B>checkAccess</B>()</PRE>
<DL>
<DD>현재 실행중의 thread가, 이 thread를 변경하기 위한 액세스권을 가지고 있을지 어떨지를 판정합니다.
 <p>
시큐러티 매니저가 존재하는 경우, 이 thread가 그 인수로 지정되어 <code>checkAccess</code> 메서드가 불려 갑니다. 이 결과,<code>SecurityException</code> 가 Throw 되는 일이 있습니다.
 <p>
주: 이 메서드가 JDK 1.1 에서는 final 가 아니었던 것은 잘못입니다. Java 2 플랫폼에서는 final 가 되어 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread에의 액세스가 용서되지 않은 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkAccess(java.lang.Thread)"><CODE>SecurityManager.checkAccess(java.lang.Thread)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A> <H3>
toString</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>toString</B>()</PRE>
<DL>
<DD>thread의 이름, 우선 순위, thread 그룹을 포함한 이 thread의 캐릭터 라인 표현을 돌려줍니다.
<P>
<DD><DL>
<DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE> 내의 <CODE><A HREF="../../java/lang/Object.html#toString()">toString</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 캐릭터 라인 표현</DL>
</DD>
</DL>
<HR>

<A NAME="getContextClassLoader()"><!-- --></A> <H3>
getContextClassLoader</H3>
<PRE>
public <A HREF="../../java/lang/ClassLoader.html" title="java.lang 내의 클래스">ClassLoader</A>  <B>getContextClassLoader</B>()</PRE>
<DL>
<DD>이 Thread
 컨텍스트
 ClassLoader를
 돌려줍니다. 컨텍스트
 ClassLoader는

 클래스 및 자원을 로드할 때, 이 thread로 실행중의 코드가 사용하기 위해서 thread의 작성 측에야는 제공됩니다. 컨텍스트
 ClassLoader 가 설정되어 있지 않은 경우, 디폴트에서는 친 Thread
 ClassLoader 컨텍스트
이 됩니다. 보통
, 친thread의 컨텍스트
 ClassLoader는

 어플리케이션의 로드에 사용되는 클래스 로더로 설정됩니다.

<p>시큐러티 매니저가 존재하는 경우, 호출측의 클래스 로더가 null는
 아니고, 컨텍스트
 클래스 로더가 요구되고 있는 thread의 컨텍스트
 클래스 로더와 같지 않고, 그 컨텍스트
 클래스 로더의 상위 오브젝트도 아닐 때는
 컨텍스트
 ClassLoader를
 취득해도 괜찮은지 어떤지를 확인하기 위해서,<code>RuntimePermission("getClassLoader")</code> 액세스권을 사용해, 시큐러티 매니저의 <code>checkPermission</code> 메서드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 Thread
 컨텍스트
 ClassLoader
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <code>checkPermission</code> 메서드가 컨텍스트
 ClassLoader
 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setContextClassLoader(java.lang.ClassLoader)"><CODE>setContextClassLoader(java.lang.ClassLoader)</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setContextClassLoader(java.lang.ClassLoader)"><!-- --></A> <H3>
setContextClassLoader</H3>
<PRE>
public void <B>setContextClassLoader</B>(<A HREF="../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;cl)</PRE>
<DL>
<DD>이 Thread
 컨텍스트
 ClassLoader를
 설정합니다. 컨텍스트
 ClassLoader는
 thread의 작성시로 설정되어 이것에
해 thread의 작성측은, 클래스 및 자원의 로드시에 thread로 실행중의 코드에 적절한 클래스 로더를 제공할 수 있게 됩니다.

<p>시큐러티 매니저가 존재하는 경우, 최초로 컨텍스트
 ClassLoader를
 설정해도 좋은지 어떤지를 조사하기 위해서 <code>RuntimePermission("setContextClassLoader")</code> 액세스권을 사용해 <code>checkPermission</code> 메서드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 이 Thread
 컨텍스트
 ClassLoader
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 컨텍스트
 ClassLoader를
 설정할 수 없는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getContextClassLoader()"><CODE>getContextClassLoader()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="holdsLock(java.lang.Object)"><!-- --></A> <H3>
holdsLock</H3>
<PRE>
public static boolean <B>holdsLock</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</PRE>
<DL>
<DD>현행 thread가 지정된 오브젝트에 대한 모니터 락을 보관 유지하는 경우에게만,<tt>true</tt>를
 돌려줍니다.

<p>이 메서드는
 아래와 같이, 프로그램이, 현행 thread가 지정된 락을 벌써 보관 유지하고 있는 것을 나타낼 때에 사용됩니다.
 
 <pre>

     assert Thread.holdsLock(obj);
 </pre>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 소유권의 락을 테스트하는 오브젝트
<DT><B>반환값:</B><DD>현행 thread가 지정된 오브젝트에 대한 모니터 락을 보관 유지하는 경우,<tt>true</tt> 가 돌려주고진다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - obj 가 <tt>null</tt>
 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getStackTrace()"><!-- --></A> <H3>
getStackTrace</H3>
<PRE>
public <A HREF="../../java/lang/StackTraceElement.html" title="java.lang 내의 클래스">StackTraceElement</A> [] <B>getStackTrace</B>()</PRE>
<DL>
<DD>이 thread의 스택 덤프를 나타내는 스택 트레이스 요소의 배열을 돌려줍니다. 이 thread가 시작하고 있지 않았던 경우나 종료하고 있었을 경우, 이 메서드는 제로의 길이의 배열을 돌려줍니다. 돌려주고진 배열이 제로 이외의 길이의 배열인 경우, 배열의 최초의 요소는 스택의 최상부를 나타냅니다. 이것은 순서로 불려 간 최근의 메서드입니다. 배열의 마지막 요소는
 스택의 저부를 나타냅니다. 이것은 순서로 불려 간 가장 낡은 메서드입니다.

<p>시큐러티 매니저가 존재해, 이 thread가 현재의 thread가 아닌 경우, 스택 트레이스를 취득해도 좋은지 어떤지를 조사하기 위해서,<tt>RuntimePermission("getStackTrace")</tt> 액세스권을 사용해 시큐러티 매니저의 <tt>checkPermission</tt> 메서드가 불려 갑니다.

<p>가상 머신안에는
 특정의 상황하로 스택 트레이스로부터 1 개 이상의 스택 프레임을 생략 하는 것이 있습니다. 극단적인 경우, 이 thread에 관한 스택 트레이스 정보를 가지지 않는 가상 머신이, 이 메서드로부터 길이 제로의 배열을 돌려주는 것이 허가됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>1 개의 스택 프레임을 나타내는 <tt>StackTraceElement</tt>
 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <tt>checkPermission</tt> 메서드가 thread의 스택 트레이스의 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A>,
 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAllStackTraces()"><!-- --></A> <H3>
getAllStackTraces</H3>
<PRE>
public static <A HREF="../../java/util/Map.html" title="java.util 내의 인터페이스">Map</A> &lt;<A HREF="../../java/lang/Thread.html" title="java.lang 내의 클래스">Thread</A>,
<A HREF="../../java/lang/StackTraceElement.html" title="java.lang 안의 클래스">StackTraceElement</A> []&gt; <B>getAllStackTraces</B>()</PRE>
<DL>
<DD>모든 라이브 thread의 스택 트레이스 맵을 돌려줍니다. 맵 키는 thread입니다. 또, 각 맵의 값은 대응하는 <tt>Thread</tt>
 스택 덤프를 나타내는 <tt>StackTraceElement</tt>
 배열입니다. 돌려주고진 스택 트레이스는
<A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace</CODE></A>  메서드에 대해서 지정된 포맷입니다.

<p>이 메서드가 불려 가고 있는 동안에
 thread가 실행되고 있을 가능성이 있습니다. 각 thread의 스택 트레이스는
 snapshot를 나타낼 뿐입니다. 각 스택 트레이스는 다른 시기에 취득할 수 있습니다. 가상 머신이 thread에 관한 스택 트레이스 정보를 가지지 않는 경우, 맵치에 길이 제로의 배열이 돌려주고집니다.

<p>시큐러티 매니저가 존재해, 이 thread가 현재의 thread가 아닌 경우, 모든 thread의 스택 트레이스를 취득해도 좋은지 어떤지를 조사하기 위해서,<tt>RuntimePermission("getStackTrace")</tt> 액세스권과 <tt>RuntimePermission("modifyThreadGroup")</tt> 액세스권을 사용해 시큐러티 매니저의 <tt>checkPermission</tt> 메서드가 불려 갑니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD><tt>Thread</tt> 로부터, 대응하는 thread의 스택 트레이스를 나타내는 <tt>StackTraceElement</tt>
 배열까지의 <tt>Map</tt>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 시큐러티 매니저의 <tt>checkPermission</tt> 메서드가 thread의 스택 트레이스의 취득을 허가하지 않는 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#getStackTrace()"><CODE>getStackTrace()</CODE></A>,
 
<A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A>,
 
<A HREF="../../java/lang/Throwable.html#getStackTrace()"><CODE>Throwable.getStackTrace()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getId()"><!-- --></A> <H3>
getId</H3>
<PRE>
public long <B>getId</B>()</PRE>
<DL>
<DD>이 thread의 식별자를 돌려줍니다. thread ID는

 thread가 작성되었을 때에 생성된 정의 <tt>long</tt> 형의 숫자입니다. thread ID는
 일의이며, 그 수명을 통해서 변경될 것은 없습니다. thread가 종료하면, thread ID는
 재이용 가능합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread의 ID<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getState()"><!-- --></A> <H3>
getState</H3>
<PRE>
public <A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형">Thread.State</A>  <B>getState</B>()</PRE>
<DL>
<DD>이 thread 상태를 돌려줍니다. 이 메서드는
 동기 제어용은 아니고, 시스템 상태의 감시에 사용되도록 설계되고 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>이 thread 상태<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A> <H3>
setDefaultUncaughtExceptionHandler</H3>
<PRE>
public static void <B>setDefaultUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</PRE>
<DL>
<DD>캐치 되지 않는 예외에
해, thread가 돌연 종료했을 때나, 이 thread에 대해서 그 밖에 핸들러가 정의되어 있지 않을 때에 불려 가는 디폴트의 핸들러를 설정합니다.

<p>캐치 되지 않는 예외의 취급은 thread에
해 우선 제어되어 다음에 thread <A HREF="../../java/lang/ThreadGroup.html" title="java.lang 중의 클래스"><CODE>ThreadGroup</CODE></A>  오브젝트에
해, 최종적으로는 디폴트의 캐치 되지 않는 예외 핸들러에
해 제어됩니다. thread가 명시적인 캐치 되지 않는 예외 핸들러 세트를 가지지 않는 경우, thread의 thread 그룹 (친thread 그룹을 포함한다)은,<tt>uncaughtException</tt> 메서드를 특수화 하지 않습니다. 다음에
 디폴트 핸들러의 <tt>uncaughtException</tt> 메서드가 불려 갑니다.
<p>디폴트의 캐치 되지 않는 예외 핸들러를 설정하는 것으로 어플리케이션에서는
 시스템으로 제공된 「디폴트」의 동작을 벌써 받아들이고 있는 thread의 캐치 되지 않는 예외를 취급하는 방법 (특정의 디바이스나 파일에의 로그인등)을 변경할 수 있습니다.　

<p>보통
, 디폴트의 캐치 되지 않는 예외 핸들러는
 thread의 <tt>ThreadGroup</tt> 오브젝트와 달라서는 안됩니다. 이것은, 무한의 재귀를 부를 가능성이 있기 때문입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>eh</CODE> - 디폴트의 캐치 되지 않는 예외 핸들러로서 사용하는 오브젝트. <tt>null</tt>
 경우, 디폴트의 핸들러는 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해,<tt><A HREF="../../java/lang/RuntimePermission.html" title="java.lang 안의 클래스"><CODE>RuntimePermission</CODE></A>  (&quot;setDefaultUncaughtExceptionHandler&quot;)</tt>를
 거부했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A>,
 
<A HREF="../../java/lang/Thread.html#getUncaughtExceptionHandler()"><CODE>getUncaughtExceptionHandler()</CODE></A>,
 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getDefaultUncaughtExceptionHandler()"><!-- --></A> <H3>
getDefaultUncaughtExceptionHandler</H3>
<PRE>
public static <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A>  <B>getDefaultUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>캐치 되지 않는 예외에
해 thread가 돌연 종료했을 때에 불려 가는 디폴트의 핸들러를 돌려줍니다. 반환값이 <tt>null</tt>
 경우, 디폴트의 핸들러는 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getUncaughtExceptionHandler()"><!-- --></A> <H3>
getUncaughtExceptionHandler</H3>
<PRE>
public <A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 내의 인터페이스">Thread.UncaughtExceptionHandler</A>  <B>getUncaughtExceptionHandler</B>()</PRE>
<DL>
<DD>캐치 되지 않는 예외에
해 thread가 돌연 종료했을 때에 불려 가는 핸들러를 돌려줍니다. 이 thread가 명시적으로 설정된 캐치 되지 않는 예외 핸들러를 가지지 않는 경우, thread가 종료하지 않는 한, thread의 <tt>ThreadGroup</tt> 오브젝트가 돌려주고집니다. 이 경우,<tt>null</tt> 가 돌려주고집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><!-- --></A> <H3>
setUncaughtExceptionHandler</H3>
<PRE>
public void <B>setUncaughtExceptionHandler</B>(<A HREF="../../java/lang/Thread.UncaughtExceptionHandler.html" title="java.lang 안의 인터페이스">Thread.UncaughtExceptionHandler</A> &nbsp;eh)</PRE>
<DL>
<DD>캐치 되지 않는 예외에
해, 돌연 thread가 종료했을 때에 사용되는 핸들러를 설정합니다.
<p>캐치 되지 않는 예외 핸들러를 명시적으로 설정하는 것으로 thread는 캐치 되지 않는 예외를 완전하게 제어할 수 있습니다. 이러한 핸들러가 설정되어 있지 않은 경우는
 thread의 <tt>ThreadGroup</tt> 오브젝트가 핸들러로서 기능합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>eh</CODE> - thread의 캐치 되지 않는 예외 핸들러로서 사용되는 오브젝트. <tt>null</tt>
 경우, thread는 명시적인 핸들러를 가지지 않는다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 현재의 thread가 이 thread의 변경이 용서되지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.5</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/Thread.html#setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)"><CODE>setDefaultUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler)</CODE></A>,
 
<A HREF="../../java/lang/ThreadGroup.html#uncaughtException(java.lang.Thread, java.lang.Throwable)"><CODE>ThreadGroup.uncaughtException(java.lang.Thread, java.lang.Throwable)</CODE></A> </DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Thread.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/lang/System.html" title="java.lang 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/lang/Thread.State.html" title="java.lang 내의 열거형"><B>차의 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/lang/Thread.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Thread.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">NESTED</A> &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

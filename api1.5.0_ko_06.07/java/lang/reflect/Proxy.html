<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:57:07 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Proxy (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.lang.reflect.Proxy class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Proxy (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Proxy.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/reflect/ReflectPermission.html" title="java.lang.reflect 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/lang/reflect/Proxy.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Proxy.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang.reflect</FONT>
<BR>
클래스 Proxy</H2>
<PRE>
<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../../resources/inherit.gif" ALT="상위를 확장 "><B>java.lang.reflect.Proxy</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>Proxy</B><DT>extends <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> <DT>implements <A HREF="../../../java/io/Serializable.html" title="java.io 내의 인터페이스">Serializable</A> </DL>
</PRE>

<P>
<code>Proxy</code>는

 동적 프록시의 클래스 및 인스턴스를 생성하는 static 메서드를 제공해, 또, 그러한 메서드에
해 생성된 동적 프록시 클래스 모든 슈퍼 클래스이기도 합니다.

<p>인터페이스 <code>Foo</code>
 프록시를 작성하려면,
 다음과 같이 설정합니다.

 
 <pre>

     InvocationHandler handler = new MyInvocationHandler(...);
     Class proxyClass = Proxy.getProxyClass(
         Foo.class.getClassLoader(), new Class[] { Foo.class });
     Foo f = (Foo) proxyClass.
         getConstructor(new Class[] { InvocationHandler.class }).
         newInstance(new Object[] { handler });
 </pre>
혹은 좀 더 단순하게, 다음과 같이 설정합니다.
 
 <pre>

     Foo f = (Foo) Proxy.newProxyInstance(Foo.class.getClassLoader(),
                                          new Class[] { Foo.class },
                                          handler);
 </pre>


<p>「동적 프록시 클래스」(이하에서는 단지 「프록시 클래스」라고 부른다)은, 클래스 작성의 실행시로 지정된 인터페이스의 리스트를 구현하는 클래스이며, 이하에 말하는 동작을 합니다.
「프록시 인터페이스」는
 프록시 클래스가 구현하는 인터페이스입니다.
「프록시 인스턴스」는
 프록시 클래스의 인스턴스입니다.
각 프록시 인스턴스에는 관련한 「호출 핸들러」오브젝트가 있어, 이것은 인터페이스 <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스"><CODE>InvocationHandler</CODE></A> 를
 구현하고 있습니다. 프록시 인터페이스의 1 개를 사용한 프록시 인스턴스에서의 메서드 호출은, 인스턴스의 호출 핸들러의 <A HREF="../../../java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])"><CODE>invoke</CODE></A>  메서드에 디스패치 되어 불려 간 메서드를 식별하는 <code>java.lang.reflect.Method</code> 오브젝트 및 인수를 포함하는 <code>Object</code> 형의 배열을 프록시 인스턴스에 인도합니다. 호출 핸들러는 encode 된 메서드 호출을 적절히 처리해, 호출 핸들러가 돌려주는 결과가, 프록시 인스턴스에서의 메서드 호출의 결과로서 돌려주고집니다.

<p>프록시 클래스에는 이하의 프로퍼티가 있습니다.

<ul> <li>프록시 클래스는 public 및 final 이며, abstract는
 아니다
<li>프록시 클래스의 비수식명은 지정되어 있지 않다. 다만 캐릭터 라인 「<code>$Proxy</code>」로 시작되는 클래스명의 영역을 프록시 클래스를 위해서 확보해 둘 필요가 있다
<li>프록시 클래스는 <code>java.lang.reflect.Proxy</code>를
 확장한다
<li>프록시 클래스는 그 작성시로 지정되었던 대로의 인터페이스를, 같은 순서로 구현한다
<li>프록시 클래스가 public 가 아닌 인터페이스를 구현하는 경우, 프록시 클래스는 그 인터페이스와 같은 패키지로 정의된다. 그렇지 않은 경우는 프록시 클래스의 패키지도 지정되지 않는다. 패키지의 실링은, 프록시 클래스가 실행시에 특정의 패키지로 정의되는 방해는 되지 않는다. 특정의 서명자를 가지는 같은 클래스 로더와 같은 패키지로 벌써 정의되고 있는 클래스에 대해서도 같이
<li>프록시 클래스는 그 생성시로 지정된 인터페이스를 모두 구현하고 있기 때문에
 그 <code>Class</code> 오브젝트로 <code>getInterfaces</code>를
 호출하면, 같은 인터페이스의 리스트를 생성시로 지정된 순서로 포함하는 배열이 돌려주고진다. <code>Class</code> 오브젝트로 <code>getMethods</code>를
 호출하면, 그러한 인터페이스의 메서드 모든 것을 포함한 <code>Method</code> 오브젝트의 배열이 돌려주고진다. <code>getMethod</code>를
 호출하면, 예상되는 메서드가 프록시 인터페이스로 발견된다
<li><A HREF="../../../java/lang/reflect/Proxy.html#isProxyClass(java.lang.Class)"><CODE>Proxy.isProxyClass</CODE></A>  메서드는
<code>Proxy.getProxyClass</code> 에
해 돌려주고진 프록시 클래스, 혹은 <code>Proxy.newProxyInstance</code> 에
해 돌려주고진 오브젝트의 클래스등의 프록시 클래스에 인도해졌을 경우에 true를
 돌려준다. 그 외의 경우는 false를
 돌려준다
<li>프록시 클래스의 <code>java.security.ProtectionDomain</code>는

<code>java.lang.Object</code> 등의 bootstrap 클래스 로더에
해 로드 된 시스템 클래스의 <code>java.security.ProtectionDomain</code> 와 같게 된다. 이것은, 프록시 클래스의 코드가 신뢰성이 있는 시스템 코드에
해 생성되기 때문에 있다. 이 보호 도메인에는 보통
,<code>java.security.AllPermission</code> 가 허가된다
<li>각 프록시 클래스에는
 프록시 인스턴스의 호출 핸들러를 설정하기 위해서, 1 개의 인수 즉 인터페이스　<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스"><CODE>InvocationHandler</CODE></A> 
 구현을 취하는 1 개의 public 생성자가 있다. 리플렉션 API를
 사용해 public 생성자에 액세스 하는 것 외에
<A HREF="../../../java/lang/reflect/Proxy.html#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)"><CODE>Proxy.newInstance</CODE></A>  메서드를 호출해 프록시 인스턴스를 생성할 수도 있다. 이 메서드는 <A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><CODE>Proxy.getProxyClass</CODE></A> 
 호출 동작을, 호출 핸들러를 가지는 생성자 호출과 결합한다 
</ul>


<p>프록시 인스턴스에는 이하의 프로퍼티가 있습니다.

<ul> <li>프록시 클래스 <code>Foo</code> 가 프록시 인스턴스 <code>proxy</code> 및 인터페이스의 1 개를 구현하고 있는 경우, 다음의 식이 true를
 돌려준다
 
 <pre>

     <code>proxy instanceof Foo</code>
 </pre>
또, 다음의 캐스트 조작이 성공한다 (<code>ClassCastException</code>는
 Throw 되지 않는다)
 
 <pre>

     <code>(Foo) proxy</code>
 </pre>

<li>각 프록시 인스턴스에는
 그 생성자에 인도해진, 관련된 호출 핸들러가 있다. static
 <A HREF="../../../java/lang/reflect/Proxy.html#getInvocationHandler(java.lang.Object)"><CODE>Proxy.getInvocationHandler</CODE></A>  메서드는
 그 인수로서 건네받은 프록시 인스턴스에 관련된 호출 핸들러를 돌려준다
<li>프록시 인스턴스에서의 인터페이스 메서드의 호출은, 그 메서드의 문서로 진술되고 있도록 encode 되어 호출 핸들러의 <A HREF="../../../java/lang/reflect/InvocationHandler.html#invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])"><CODE>invoke</CODE></A>  메서드에 디스패치 된다
<li><code>java.lang.Object</code> 로 선언되고 있는 <code>hashCode</code>,<code>equals</code>, 또는 <code>toString</code>
 각 메서드의 프록시 인스턴스에서의 호출은, 인터페이스 메서드 호출이 전술과 같이 encode 되어 디스패치 되는 것과 같은 방법으로 encode 되어 호출 핸들러의 <code>invoke</code> 메서드에 디스패치 된다. <code>invoke</code> 에 인도해진 <code>Method</code> 오브젝트의 선언 클래스는 <code>java.lang.Object</code> 가 된다. <code>java.lang.Object</code> 로부터 상속된 프록시 인스턴스외의 public 메서드는 프록시 메서드에
해 오버라이드(override) 되지 않기 때문에
 그러한 메서드의 호출은,<code>java.lang.Object</code>
 인스턴스를 호출하는 것과 같은 동작을 한다 
</ul>

<h3>복수의 프록시 인터페이스로 중복 하는 메서드</h3>


<p>프록시 클래스의 2 개 이상의 인터페이스가 같은 이름과 파라메이타시그니쳐를 가지는 메서드를 포함한 경우, 프록시 클래스의 인터페이스의 순서가 중요하게 됩니다. 프록시 인스턴스로 이러한 「중복 메서드」가 불려 갔을 경우, 호출 핸들러에 인도해진 <code>Method</code> 오브젝트는 반드시, 프록시의 메서드의 호출에 사용된 인터페이스의 참조형으로부터 선언 클래스를 할당하고 할 수 있는 오브젝트일 필요는 없습니다. 이 제한이 있는 것은, 생성된 프록시 클래스의 해당의 메서드 구현이, 호출에 사용된 인터페이스를 판정할 수 없기 때문입니다. 따라서, 중복 메서드가 프록시 인스턴스로 불려 갔을 경우, 메서드 호출이 발생한 참조형에 관계없이, 프록시 클래스의 인터페이스의 리스트의 메서드를 직접, 또는 슈퍼 인터페이스 경유로 상속해 포함한 주요한 인터페이스의 메서드의 <code>Method</code> 오브젝트가, 호출 핸들러의 <code>invoke</code> 메서드에 인도해집니다.

<p>프록시 인터페이스가 <code>java.lang.Object</code>
 <code>hashCode</code>,<code>equals</code>, 또는 <code>toString</code>
 각 메서드와 같은 이름과 파라메이타시그니쳐를 가지고 있는 메서드를 포함한 경우, 프록시 인스턴스로 이러한 메서드가 불려 가면, 호출 핸들러에 인도해진 <code>Method</code> 오브젝트는 그 선언 클래스로서 <code>java.lang.Object</code>를
 가집니다. 바꾸어 말하면,<code>java.lang.Object</code>
, public 이며 final 가 아닌 메서드는
 호출 핸들러에 어느 <code>Method</code> 오브젝트를 인도할까를 결정할 때에
 프록시 인터페이스의 모두에게 논리적으로 우선합니다.

<p>중복 메서드가 호출해 핸들러에 디스패치 되는 경우,<code>invoke</code> 메서드는
 호출에 사용할 수 있는 모든 프록시 인터페이스의 메서드의 <code>throws</code> 절의 예외 타입의 1 개에 할당하고 가능한 확인이 끝난 예외 타입만을 Throw 할 수 있습니다. <code>invoke</code> 메서드가, 호출에 사용할 수 있는 프록시 인터페이스의 1 개의 메서드로 선언된 예외 타입의 어느 것에도 할당하고 할 수 없는 확인이 끝난 예외를 Throw 했을 경우, 확인되어 있지 않은 <code>UndeclaredThrowableException</code> 가 프록시 인스턴스에서의 호출에
해 Throw 됩니다. 이 제한은,<code>invoke</code> 메서드에 인도해진 <code>Method</code> 오브젝트에서의 <code>getExceptionTypes</code>
 호출에
해 돌려주고진 예외 타입이 <code>invoke</code> 메서드에
해 Throw 되어도, 모두 반드시 성공한다고는 할 수 없는 것을
미합니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스"><CODE>InvocationHandler</CODE></A>,
 
<A HREF="../../../serialized-form.html#java.lang.reflect.Proxy">직렬화 된 형식</A> </DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#h">h</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 프록시 인스턴스의 호출 핸들러입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#Proxy(java.lang.reflect.InvocationHandler)">Proxy</A> </B>(<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 값으로 서브 클래스 (일반적으로 동적 프록시 클래스)로부터 그 호출 핸들러에 새로운 <code>Proxy</code> 인스턴스를 구축합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#getInvocationHandler(java.lang.Object)">getInvocationHandler</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;proxy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 프록시 인스턴스의 호출 핸들러를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#getProxyClass(java.lang.ClassLoader, java.lang.Class...)">getProxyClass</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
              <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;...&nbsp;interfaces)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;클래스 로더와 인터페이스의 배열의 지정된 프록시 클래스의 <code>java.lang.Class</code> 오브젝트를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#isProxyClass(java.lang.Class)">isProxyClass</A> </B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 클래스가 <code>getProxyClass</code> 메서드 또는 <code>newProxyInstance</code> 메서드를 사용해 동적으로 생성되어 프록시 클래스가 되는 경우에만, true를
 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/reflect/Proxy.html#newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)">newProxyInstance</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                 <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;[]&nbsp;interfaces,
                 <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 호출 핸들러에 대해서 메서드 호출을 디스패치 하는
 지정된 인터페이스의 프록시 클래스의 인스턴스를 돌려줍니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="h"><!-- --></A> <H3>
h</H3>
<PRE>
protected <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A>  <B>h</B></PRE>
<DL>
<DD>이 프록시 인스턴스의 호출 핸들러입니다.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="Proxy(java.lang.reflect.InvocationHandler)"><!-- --></A> <H3>
Proxy</H3>
<PRE>
protected <B>Proxy</B>(<A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)</PRE>
<DL>
<DD>지정된 값으로 서브 클래스 (일반적으로 동적 프록시 클래스)로부터 그 호출 핸들러에 새로운 <code>Proxy</code> 인스턴스를 구축합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>h</CODE> - 이 프록시 인스턴스의 호출 핸들러</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getProxyClass(java.lang.ClassLoader, java.lang.Class...)"><!-- --></A> <H3>
getProxyClass</H3>
<PRE>
public static <A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>getProxyClass</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                                     <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;...&nbsp;interfaces)
                              throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>클래스 로더와 인터페이스의 배열의 지정된 프록시 클래스의 <code>java.lang.Class</code> 오브젝트를 돌려줍니다. 프록시 클래스는 지정된 클래스 로더에
해 정의되어 지정된 인터페이스를 모두 구현합니다. 인터페이스의 같은 순열의 프록시 클래스가 벌써 클래스 로더에
해 정의되고 있는 경우, 기존의 프록시 클래스가 돌려주고집니다. 그렇지 않은 경우는
 이러한 인터페이스의 프록시 클래스가 동적으로 생성되어 클래스 로더에
해 정의됩니다.

<p><code>Proxy.getProxyClass</code> 에 인도해지는 파라미터에는
 몇개의 제약이 있습니다.
<ul> <li><code>interfaces</code> 배열의 <code>Class</code> 오브젝트는 모두, 클래스 또는 원시적형은 아니고 인터페이스를 나타낼 필요가 있다
<li><code>interfaces</code> 배열의 2 개의 요소가 동일한 <code>Class</code> 오브젝트를 참조할 수 없다
<li>어느 인터페이스형도, 지정된 클래스 로더를 통해 이름에
해 가시가 아니면 안된다. 즉, 클래스 로더 <code>cl</code> 및 전인터페이스 <code>i</code> 에 대해, 이하의 식이 true 가 아니면 안된다
 
 <pre>

     Class.forName(i.getName(), false, cl) == i
 </pre>

<li>public 가 아닌 인터페이스는 모두 같은 패키지에 없으면 안 된다. 그렇지 않은 경우, 프록시 클래스가 어느 패키지로 정의되고 있을까에 관계없이, 프록시 클래스가 인터페이스를 모두 구현하는 것은 불가능하다
<li>같은 서명을 가지는 지정된 인터페이스의 멤버 메서드세트의 경우,<ul> <li>메서드의 어떤 것인가의 반환값의 형태가 원시적형 또는 void
 경우, 모든 메서드는 같은 반환값의 형태를 가지지 않으면 안 된다<li>그렇지 않은 경우, 메서드의 1 개는
 그 이외의 메서드의 모든 반환값의 형태에 할당할 수가 있는 반환값의 형태를 가지지 않으면 안 된다 
</ul>

<li>결과의 프록시 클래스는
 가상 머신에
해 클래스로 설정된 제한을 넘을 수 없다. 예를 들어, 가상 머신은 클래스를 구현할 수 있는 인터페이스의 수를 65535 에 제한한다. 이 경우,<code>interfaces</code> 배열의 사이즈는 65535를
 넘어서는 안 된다 
</ul>


<p>이러한 제약에 1 개에서도 위반하는 경우는
<code>Proxy.getProxyClass</code> 에
해 <code>IllegalArgumentException</code> 가 Throw 됩니다. <code>interfaces</code> 배열의 인수 또는 그 요소의 어떤 것인가가 <code>null</code>
 경우는
<code>NullPointerException</code> 가 Throw 됩니다.

<p>지정된 프록시 인터페이스의 순서는 중요한
미를 가집니다. 프록시 클래스에 대한, 같은 인터페이스의 편성으로 순서가 다른 2 개의 요구의 결과는
 2 개의 개별의 프록시 클래스가 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 프록시 클래스를 정의하는 클래스 로더<DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 리스트
<DT><B>반환값:</B><DD>지정된 클래스 로더로 정의되어 지정된 인터페이스를 구현하는 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>getProxyClass</code> 에 인도해지는 파라미터에 관한 제약의 어떤 것인가가 지켜질 수  없었던 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>interfaces</code> 배열의 인수 또는 그 요소의 어떤 것인가가 <code>null</code>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler)"><!-- --></A> <H3>
newProxyInstance</H3>
<PRE>
public static <A HREF="../../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>newProxyInstance</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader,
                                      <A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;[]&nbsp;interfaces,
                                      <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 안의 인터페이스">InvocationHandler</A> &nbsp;h)
                               throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>지정된 호출 핸들러에 대해서 메서드 호출을 디스패치 하는
 지정된 인터페이스의 프록시 클래스의 인스턴스를 돌려줍니다. 이 메서드는 아래와 동등합니다.
 
 <pre>

     Proxy.getProxyClass(loader, interfaces).
         getConstructor(new Class[] { InvocationHandler.class }).
         newInstance(new Object[] { handler });
 </pre>


<p><code>Proxy.getProxyClass</code>
 경우와 같은 이유로써,<code>Proxy.newProxyInstance</code>는
 <code>IllegalArgumentException</code>를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 프록시 클래스를 정의하는 클래스 로더<DD><CODE>interfaces</CODE> - 프록시 클래스가 구현하는 인터페이스의 리스트<DD><CODE>h</CODE> - 메서드 호출의 디스패치처의 호출 핸들러
<DT><B>반환값:</B><DD>지정된 클래스 로더에
해 정의되어 지정된 인터페이스를 구현하는 프록시 클래스의, 지정된 호출 핸들러를 가지는 프록시 인터페이스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - <code>getProxyClass</code> 에 인도해지는 파라미터에 관한 제약의 어떤 것인가가 지켜질 수  없었던 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>interfaces</code> 배열의 인수 또는 그 요소의 어떤 것인가가 <code>null</code>
 경우, 또는 호출해 핸들러 <code>h</code> 가 <code>null</code>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isProxyClass(java.lang.Class)"><!-- --></A> <H3>
isProxyClass</H3>
<PRE>
public static boolean <B>isProxyClass</B>(<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</PRE>
<DL>
<DD>지정된 클래스가 <code>getProxyClass</code> 메서드 또는 <code>newProxyInstance</code> 메서드를 사용해 동적으로 생성되어 프록시 클래스가 되는 경우에만, true를
 돌려줍니다.

<p>이 메서드의 신뢰성은, 이 메서드에
해 시큐러티 보호를 할 수 있을지 어떨지를 결정할 때에 중요합니다. 이 때문에
 해당 클래스가 <code>Proxy</code>를
 확장할지 어떨지를 이 메서드의 구현으로 테스트하는 것 만으로는 충분하다고는 말할 수 없습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 테스트하는 클래스
<DT><B>반환값:</B><DD>클래스가 프록시 클래스의 경우는 <code>true</code>, 그렇지 않은 경우는 <code>false</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>cl</code> 가 <code>null</code>
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="getInvocationHandler(java.lang.Object)"><!-- --></A> <H3>
getInvocationHandler</H3>
<PRE>
public static <A HREF="../../../java/lang/reflect/InvocationHandler.html" title="java.lang.reflect 내의 인터페이스">InvocationHandler</A>  <B>getInvocationHandler</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;proxy)
                                              throws <A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 내의 클래스">IllegalArgumentException</A> </PRE>
<DL>
<DD>지정된 프록시 인스턴스의 호출 핸들러를 돌려줍니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>proxy</CODE> - 호출 핸들러를 돌려주는 프록시 인스턴스
<DT><B>반환값:</B><DD>프록시 인스턴스의 호출 핸들러
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 인수가 프록시 인스턴스가 아닌 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Proxy.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/lang/reflect/ParameterizedType.html" title="java.lang.reflect 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/reflect/ReflectPermission.html" title="java.lang.reflect 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/lang/reflect/Proxy.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Proxy.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</A> &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

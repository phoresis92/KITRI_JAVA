<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:57:01 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
Instrumentation (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.lang.instrument.Instrumentation interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="Instrumentation (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Instrumentation.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/lang/instrument/IllegalClassFormatException.html" title="java.lang.instrument 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/lang/instrument/Instrumentation.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Instrumentation.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.lang.instrument</FONT>
<BR>
인터페이스 Instrumentation</H2>
<HR>
<DL>
<DT><PRE>public interface <B>Instrumentation</B></DL>
</PRE>

<P>
이 클래스는
 Java 프로그램 언어 코드를 파악
하기 위한 서비스를 제공합니다. 인스트르멘테이션이란
 툴로 사용하는 데이터를 수집하는 것을 목적으로 해 메서드에 바이트 코드를 추가하는 것입니다. 변경은 단지 추가되기 때문에
 이러한 툴은 어플리케이션 상태나 동작을 변경하지 않습니다. 상태나 동작에 영향을 미치지 않는 이런 종류의 툴에는
 감시 에이전트, 프로 filer, 카버리지 analyzer 및 이벤트 로거등이 있습니다.

<P>
 <code>Instrumentation</code> 인터페이스의 인스턴스에 액세스 하는 유일한 방법은, 에이전트 클래스를 지정하는 방법으로 JVM를
 시작하는 것입니다 (<A HREF="../../../java/lang/instrument/package-summary.html">the package specification</A> 를
 참조). <code>Instrumentation</code> 인스턴스는
 그 에이전트 클래스의 <code>premain</code> 메서드에게 건네집니다. 에이전트가 <code>Instrumentation</code> 인스턴스를 취득하면, 인스턴스상의 메서드를 언제라도 호출할 수가 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 5</DD>
</DL>
<HR>

<P>

<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer)">addTransformer</A> </B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 안의 인터페이스">ClassFileTransformer</A> &nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제공된 트랜스 포머를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getAllLoadedClasses()">getAllLoadedClasses</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JVM 에
해 현재 로드 사라질 수 있어 모든 클래스의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> []</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getInitiatedClasses(java.lang.ClassLoader)">getInitiatedClasses</A> </B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>loader</code> 가 시작 로더인 모든 클래스의 배열을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#getObjectSize(java.lang.Object)">getObjectSize</A> </B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;objectToSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 오브젝트에
해 소비되는 기억 영역의 용량의 구현 고유의 근사치를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()">isRedefineClassesSupported</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 JVM 구성이 클래스의 재정의를 서포트하고 있을지 어떨지를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition[])">redefineClasses</A> </B>(<A HREF="../../../java/lang/instrument/ClassDefinition.html" title="java.lang.instrument 안의 클래스">ClassDefinition</A> []&nbsp;definitions)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제공된 클래스 파일을 사용해 제공된 클래스세트를 재정의합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../java/lang/instrument/Instrumentation.html#removeTransformer(java.lang.instrument.ClassFileTransformer)">removeTransformer</A> </B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 안의 인터페이스">ClassFileTransformer</A> &nbsp;transformer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;제공된 트랜스 포머의 등록을 해제합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="addTransformer(java.lang.instrument.ClassFileTransformer)"><!-- --></A> <H3>
addTransformer</H3>
<PRE>
void <B>addTransformer</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 안의 인터페이스">ClassFileTransformer</A> &nbsp;transformer)</PRE>
<DL>
<DD>제공된 트랜스 포머를 등록합니다. 이것에
해, 등록된 트랜스 포머가
존하는 클래스의 정의를 제외해, 장래의 모든 클래스 정의는 트랜스 포머에
해 확인됩니다. 복수의 트랜스 포머가 등록되었을 경우, 추가된 순서에 불려 갑니다. 트랜스 포머가 실행중에 예외를 Throw 하면, JVM는
 등록되어 있는 그 외의 트랜스 포머를 순서에 호출합니다. 같은 트랜스 포머를 여러 차례 추가할 수 있습니다. <code>addTransformer</code>를
 사용해 등록된 모든 트랜스 포머는
 외부의 JVMTI ClassFileLoadHook 이벤트 리스너가 확인하기 전에
 항상 모든 클래스 파일을 확인합니다.
<P>
 이 메서드는
<A HREF="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument 안의 인터페이스">class specification</A>  로 기술되고 있도록, 인스트르멘테이션으로 사용하는 것입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformer</CODE> - 등록하는 트랜스 포머
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>null</code> 트랜스 포머를 건네주었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="removeTransformer(java.lang.instrument.ClassFileTransformer)"><!-- --></A> <H3>
removeTransformer</H3>
<PRE>
boolean <B>removeTransformer</B>(<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 안의 인터페이스">ClassFileTransformer</A> &nbsp;transformer)</PRE>
<DL>
<DD>제공된 트랜스 포머의 등록을 해제합니다. 등록 해제된 트랜스 포머는
 장래 클래스 정의를 확인할 수 없게 됩니다. 직전에 추가된 일치하는 트랜스 포머의 인스턴스를 삭제합니다. 클래스 로딩의 multi-thread적 성질에
해, 삭제된 후에도 트랜스 포머를 호출할 수가 있습니다. 이러한 상황을 고려해, 신중하게 트랜스 포머를 기술할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>transformer</CODE> - 등록을 해제하는 트랜스 포머
<DT><B>반환값:</B><DD>트랜스 포머가 발견되어, 삭제되었을 경우는 true. 트랜스 포머가 발견되지 않았던 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>null</code> 트랜스 포머를 건네주었을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="isRedefineClassesSupported()"><!-- --></A> <H3>
isRedefineClassesSupported</H3>
<PRE>
boolean <B>isRedefineClassesSupported</B>()</PRE>
<DL>
<DD>현재의 JVM 구성이 클래스의 재정의를 서포트하고 있을지 어떨지를 돌려줍니다. 벌써 로드 되고 있는 클래스를 재정의하는 기능은, JVM
 옵션의 기능입니다. 단일의 JVM
 1 개의 인스턴스 생성동안에
 이 메서드에 복수의 호출을 실시하면, 항상 같은 대답이 돌려주고집니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 JVM 구성이 클래스의 재정의를 지원하는
 경우는 true, 서포트하지 않는 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#redefineClasses(java.lang.instrument.ClassDefinition[])"><CODE>redefineClasses(java.lang.instrument.ClassDefinition[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="redefineClasses(java.lang.instrument.ClassDefinition[])"><!-- --></A> <H3>
redefineClasses</H3>
<PRE>
void <B>redefineClasses</B>(<A HREF="../../../java/lang/instrument/ClassDefinition.html" title="java.lang.instrument 안의 클래스">ClassDefinition</A> []&nbsp;definitions)
                     throws <A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 내의 클래스">ClassNotFoundException</A>,

                            <A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 안의 클래스">UnmodifiableClassException</A> </PRE>
<DL>
<DD>제공된 클래스 파일을 사용해 제공된 클래스세트를 재정의합니다. 동시에 1 개 이상의 클래스에 대해서 인터락 된 변경 (클래스 A
 재정의는 클래스 B
 재정의를 필요로 하는 등)을 가능하게 하기 위해서 세트상에서 동작합니다.

<P>
 재정의된 메서드가 액티브한 스택 프레임을 가지는 경우, 액티브한 스택 프레임은 원의 메서드의 바이트 코드를 계속해 실행합니다. 재정의된 메서드는 새로운 호출로 사용됩니다.

<P>
 이 메서드는
 관행의 JVM 시멘틱스아래에서 발생하는 초기화를 제외해, 초기화를 발생시키지 않습니다. 즉, 클래스의 재정의에서는
 클래스의 초기화자는 실행되지 않습니다. static 변수의 값은 호출해 전의 값대로 유지됩니다.

<P>
 재정의된 클래스의 인스턴스는 영향을 받지 않습니다.

<P>
 등록된 트랜스 포머는
 재정의 조작이 적용되기 전에 불려 갑니다.

<P>
 재정의에서는
 메서드의 본문, 정수 풀 및 속성의 변경이 가능합니다. 다만, 재정의에서는
 필드 또는 메서드의 추가, 삭제, 혹은 이름의 변경, 메서드의 시그니쳐의 변경, 혹은 상속의 변경은 할 수 없습니다. 이러한 제약은, 장래 버젼으로 해소될 가능성이 있습니다.

<P>
 길이 제로의 <code>definitions</code> 배열은 사용할 수 있습니다만, 사용했을 경우, 이 메서드는 아무것도 실행하지 않습니다.

<P>
 이 메서드가 예외를 Throw 했을 경우, 클래스의 재정의는 행해지지 않습니다.
<P>
 이 메서드는
<A HREF="../../../java/lang/instrument/Instrumentation.html" title="java.lang.instrument 안의 인터페이스">class specification</A>  로 기술되고 있도록, 인스트르멘테이션으로 사용하는 것입니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>definitions</CODE> - 대응하는 정의를 사용해 재정의하는 클래스의 배열
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 지정된 클래스가 발견되지 않는 경우
<DD><CODE><A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 안의 클래스">UnmodifiableClassException</A> </CODE> - 지정된 클래스를 변경할 수 없는 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedOperationException.html" title="java.lang 안의 클래스">UnsupportedOperationException</A> </CODE> - JVM
 현재의 구성이 재정의 (<A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A>  가 false)를 허가하지 않는지, 재정의로 서포트되어 있지 않은 변경을 실시했을 경우
<DD><CODE><A HREF="../../../java/lang/ClassFormatError.html" title="java.lang 안의 클래스">ClassFormatError</A> </CODE> - 데이터가 유효한 클래스를 포함하지 않았던 경우
<DD><CODE><A HREF="../../../java/lang/NoClassDefFoundError.html" title="java.lang 안의 클래스">NoClassDefFoundError</A> </CODE> - 클래스 파일의 이름이 클래스의 이름과 동일하지 않은 경우
<DD><CODE><A HREF="../../../java/lang/UnsupportedClassVersionError.html" title="java.lang 안의 클래스">UnsupportedClassVersionError</A> </CODE> - 클래스 파일 버젼 번호가 서포트되어 있지 않은 경우
<DD><CODE><A HREF="../../../java/lang/ClassCircularityError.html" title="java.lang 안의 클래스">ClassCircularityError</A> </CODE> - 새로운 클래스가 순환을 포함한 경우
<DD><CODE><A HREF="../../../java/lang/LinkageError.html" title="java.lang 안의 클래스">LinkageError</A> </CODE> - 링키지 에러가 발생했을 경우
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 제공된 정의 배열 또는 그 컴퍼넌트가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../../java/lang/instrument/Instrumentation.html#isRedefineClassesSupported()"><CODE>isRedefineClassesSupported()</CODE></A>,
 
<A HREF="../../../java/lang/instrument/Instrumentation.html#addTransformer(java.lang.instrument.ClassFileTransformer)"><CODE>addTransformer(java.lang.instrument.ClassFileTransformer)</CODE></A>,
 
<A HREF="../../../java/lang/instrument/ClassFileTransformer.html" title="java.lang.instrument 안의 인터페이스"><CODE>ClassFileTransformer</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAllLoadedClasses()"><!-- --></A> <H3>
getAllLoadedClasses</H3>
<PRE>
<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> [] <B>getAllLoadedClasses</B>()</PRE>
<DL>
<DD>JVM 에
해 현재 로드 사라질 수 있어 모든 클래스의 배열을 돌려줍니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>JVM 에
해 로드 된 모든 클래스를 포함한 배열. 클래스가 없는 경우는 길이 제로의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getInitiatedClasses(java.lang.ClassLoader)"><!-- --></A> <H3>
getInitiatedClasses</H3>
<PRE>
<A HREF="../../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> [] <B>getInitiatedClasses</B>(<A HREF="../../../java/lang/ClassLoader.html" title="java.lang 안의 클래스">ClassLoader</A> &nbsp;loader)</PRE>
<DL>
<DD><code>loader</code> 가 시작 로더인 모든 클래스의 배열을 돌려줍니다. 제공된 로더가 <code>null</code>
 경우, bootstrap 클래스 로더에
해 시작된 클래스가 돌려주고집니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>loader</CODE> - 시작한 클래스 리스트가 돌려주고지는 로더
<DT><B>반환값:</B><DD>로더가 시작 로더인 모든 클래스를 포함한 배열. 클래스가 없는 경우는 길이 제로의 배열</DL>
</DD>
</DL>
<HR>

<A NAME="getObjectSize(java.lang.Object)"><!-- --></A> <H3>
getObjectSize</H3>
<PRE>
long <B>getObjectSize</B>(<A HREF="../../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;objectToSize)</PRE>
<DL>
<DD>지정된 오브젝트에
해 소비되는 기억 영역의 용량의 구현 고유의 근사치를 돌려줍니다. 결과에는
 오브젝트의 오버헤드의 일부 또는 모든 것이 포함될 가능성이 있습니다. 따라서, 구현내에서의 비교에는 도움이 됩니다만, 구현간에서의 비교에는 도움이 되지 않습니다.
JVM
 단일의 호출동안에 근사치가 바뀔 가능성이 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>objectToSize</CODE> - 사이즈를 평가하는 오브젝트
<DT><B>반환값:</B><DD>지정된 오브젝트에
해 소비되는 기억 영역의 용량의 구현 고유의 근사치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - 제공된 오브젝트가 <code>null</code>
 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Instrumentation.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../java/lang/instrument/IllegalClassFormatException.html" title="java.lang.instrument 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../java/lang/instrument/UnmodifiableClassException.html" title="java.lang.instrument 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?java/lang/instrument/Instrumentation.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="Instrumentation.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED&nbsp;|&nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드&nbsp;|&nbsp;생성자&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

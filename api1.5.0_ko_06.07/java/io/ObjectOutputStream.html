<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:56:32 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ObjectOutputStream (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.io.ObjectOutputStream class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ObjectOutputStream (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
클래스 ObjectOutputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">java.io.OutputStream</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.io.ObjectOutputStream</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A>,
 <A HREF="../../java/io/DataOutput.html" title="java.io 안의 인터페이스">DataOutput</A>,
 <A HREF="../../java/io/Flushable.html" title="java.io 안의 인터페이스">Flushable</A>,
 <A HREF="../../java/io/ObjectOutput.html" title="java.io 안의 인터페이스">ObjectOutput</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ObjectOutputStream</B><DT>extends <A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> <DT>implements <A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DL>
</PRE>

<P>
Java
 기본 데이터형과 오브젝트 그래프를 OutputStream 에 기입합니다. 이러한 오브젝트를 읽어들이려면 (재구축 하기) ObjectInputStream를
 사용합니다. 오브젝트의 지속적 기억은, 그 스트림을 위한 파일을 사용하면 가능합니다. 스트림이 네트워크 소켓 스트림의 경우는
 다른 호스트나 다른 프로세스상에서 오브젝트를 재구축 할 수도 있습니다.

<p>스트림에 기입할 수 있는 것은 java.io.Serializable 인터페이스를 지원하는 오브젝트만입니다. 각 직렬화 가능 오브젝트의 클래스는
 클래스의 이름과 시그니쳐, 오브젝트의 필드치와 배열 및 초기 오브젝트로부터 참조되는 것 외의 모든 오브젝트의 크로쟈를 포함해 encode 됩니다.

<p>오브젝트를 스트림에 기입하려면 writeObject 메서드를 사용합니다. String 나 배열을 포함한 임의의 오브젝트가 writeObject 에
해 기입해집니다. 복수의 오브젝트나 원시적도, 스트림에의 기입이 가능합니다. 오브젝트를 읽어들일 때는
 대응하는 ObjectInputstream 로부터 같은 형태로서 한편 기입해졌을 때와 같은 순서로 읽어들이지 않으면 안됩니다.

<p>기본 데이터형을 스트림에 기입하려면,
 DataOutput
 적절한 메서드를 사용합니다. String를
 기입하는 경우는 writeUTF 메서드를 사용합니다.

<p>오브젝트의 디폴트의 직렬화 도구
는
 클래스의 오브젝트, 클래스의 시그니쳐 및 모든 비 transient 와 비 static 필드가 가지는 값을 기입합니다. 다른 오브젝트에의 참조 (transient 와 static 필드는 제외하다)가 있으면, 이러한 오브젝트도 역시 기입해집니다. 단일 오브젝트에의 다중 참조는 참조 공유 도구
에
해 encode 되어 오브젝트 그래프를, 오리지날이 기입해졌을 때의 형상에 복원할 수가 있습니다.

<p>예를 들어, ObjectInputStream
 예로 읽어들일 수 있도록 오브젝트를 기입하려면,
 다음과 같이 합니다. <br>
 
 <pre>

        FileOutputStream fos = new FileOutputStream("t.tmp");
        ObjectOutputStream oos = new ObjectOutputStream(fos);

        oos.writeInt(12345);
        oos.writeObject("Today");
        oos.writeObject(new Date());

        oos.close();
 </pre>


<p>직렬화와 직렬화 복원 시에 특수한 취급이 필요한 클래스에서는
 정확하게 다음과 같은 시그니쳐를 가지는 특수한 메서드를 구현할 필요가 있습니다. <br>
 
 <pre>

 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException;
 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException
 </pre>
 
<p>writeObject 메서드는
 대응하는 readObject 가 오브젝트 상태를 복원할 수가 있도록, 오브젝트의 특정의 클래스에 도착해, 오브젝트 상태를 기입할 책임이 있습니다. 이 메서드는
 오브젝트의 슈퍼 클래스나 서브 클래스에 속하는 상태에 관여할 필요는 없습니다. 상태를 보존하려면,
 개개의 필드에 도착해 writeObject 메서드를 사용해 ObjectOutputStream 에 기입하는지, 또는 DataOutput 가 지원하는 기본 데이터형용의 메서드를 사용합니다.

<p>직렬화는
 java.io.Serializable 인터페이스를 구현하지 않는 오브젝트의 필드의 기입은 실시하지 않습니다. 직렬화 가능하지 않은 오브젝트의 서브 클래스를 직렬화 가능하게 하는 것은 가능합니다. 이 경우, 직렬화 가능하지 않은 클래스는
 그 필드를 초기화할 수 있도록 하기 위한, 인수 없음의 생성자를 가질 필요가 있습니다. 이 경우, 직렬화 가능하지 않은 클래스 상태를 보존 및 재구축 하는 것은, 서브 클래스의 책임이 됩니다. 그 클래스의 필드가 액세스 가능하다 (public, package, 또는 protected)인가, 또는 상태를 재구축 하기 위해서 사용할 수 있는 get 와 set 메서드가 존재하는 경우가 자주 있습니다.

<p>writeObject 와 readObject 메서드로 NotSerializableException를
 Throw 하도록 구현해 두면, 오브젝트의 직렬화를 방지할 수 있습니다. 예외는
 ObjectOutputStream 에 캐치 되어 직렬화 처리를 이상종료(ABEND) 시킵니다.

<p>Externalizable 인터페이스를 구현하면, 오브젝트의 직렬화 된 형식의 내용 및 형식을 오브젝트측이 완전하게 제어하는 것이 가능하게 됩니다. Externalizable 인터페이스의 메서드인 writeExternal 와 readExternal는

 오브젝트 상태를 보존 및 복원하기 위해서 불려 갑니다. 이러한 메서드는
 클래스에
해 구현되었을 경우에는
 ObjectOutput 와 ObjectInput
 모든 메서드를 사용해, 자신 상태의 기입 및 read를 실시할 수가 있습니다. 어떠한 버젼이어도 처리할 수 있도록 하는 것은, 오브젝트의 책임입니다.

<p>enum 정수는
 보통
의 직렬화 가능 오브젝트나 외부화 가능 오브젝트와는 다른 방법으로 직렬화 됩니다. enum 정수의 직렬화 형식은 이름만으로 구성됩니다. 정수의 필드치는 전송 되지 않습니다. enum 정수를 직렬화하기 위해서, ObjectOutputStream는
 정수의 이름 메서드로부터 돌려주고진 캐릭터 라인을 기입합니다. 다른 직렬화 가능 오브젝트 또는 외부화 가능 오브젝트와 같이, enum 정수도, 직렬화 스트림에 나중에 나타나는 역참조의 타겟으로서 기능할 수 있습니다. enum 정수가 직렬화 되는 순서는 커스터마이즈 할 수 없습니다. 즉, enum 형에
해 정의된, 클래스 특유의 writeObject 및 writeReplace 메서드는
 직렬화의 사이는 무시됩니다. 같이 serialPersistentFields 또는 serialVersionUID 필드 선언도 무시됩니다. 모든 enum 형은, serialVersionUID 가 0L 에 고정되고 있습니다.

<p>직렬화 가능 필드 및 외부화 가능 데이터를 제외한 원시적 데이터는
 블록 데이터 레코드로서 ObjectOutputStream 에 기입해집니다. 블록 데이터 레코드는
 헤더와 데이터로 구성됩니다. 블록 데이터의 헤더는
 마커 및 헤더에 계속되는 바이트수로 구성됩니다. 연속하는 원시적 데이터의 기입은, 1 개의 블록 데이터 레코드에 머지 됩니다. 블록 데이터 레코드에 사용되는 블록 계수는 1024 바이트입니다. 각 블록 데이터 레코드는
 1024 바이트까지 파묻히는지, 블록 데이터 모드의 종료까지 기입해집니다. ObjectOutputStream
 메서드 writeObject, defaultWriteObject 및 writeFields를
 호출하면, 최초로 기존의 블록 데이터 레코드가 종료됩니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스"><CODE>DataOutput</CODE></A>,
 
<A HREF="../../java/io/ObjectInputStream.html" title="java.io 안의 클래스"><CODE>ObjectInputStream</CODE></A>,
 
<A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스"><CODE>Serializable</CODE></A>,
 
<A HREF="../../java/io/Externalizable.html" title="java.io 안의 인터페이스"><CODE>Externalizable</CODE></A>,
 
<a href="../../../guide/serialization/spec/output.doc.html">Object Serialization Specification, Section 2, Object Output Classes</a> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 안의 클래스">ObjectOutputStream.PutField</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutput 에 기입해지는 지속 필드에의 프로그램에
한 액세스를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_ENUM">SC_ENUM</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENUM">TC_ENUM</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()">ObjectOutputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream를
 완전하게 다시 구현하는 서브 클래스가, ObjectOutputStream
 이 구현에
해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream(java.io.OutputStream)">ObjectOutputStream</A> </B>(<A HREF="../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;out)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 OutputStream 에 기입하는 ObjectOutputStream를
 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateClass(java.lang.Class)">annotateClass</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스는
 클래스의 데이터를 스트림에 보존할 수 있도록 이 메서드를 구현하는 경우가 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)">annotateProxyClass</A> </B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스는 이 메서드를 구현해, 다이나믹 프록시 클래스에 대한 기술자와 함께 커스텀 데이터를 스트림에 포함합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#defaultWriteObject()">defaultWriteObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클래스의 비 static 필드와 비 transient 필드를, 스트림에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#drain()">drain</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 에 있는 버퍼 데이터를 모두 비웁니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#enableReplaceObject(boolean)">enableReplaceObject</A> </B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림내에서 오브젝트를 치환할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#flush()">flush</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 플래시 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스">ObjectOutputStream.PutField</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#putFields()">putFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림에 기입해지는 지속 필드를 버퍼에 포함하기 위해서 사용되는 오브젝트를 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#replaceObject(java.lang.Object)">replaceObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;직렬화 시에
 ObjectOutputStream
 신뢰할 수 있는 서브 클래스가, 어느 오브젝트를 다른 오브젝트에 치환할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#reset()">reset</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림에 벌써 기입해지고 있는 오브젝트 상태를 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)">useProtocolVersion</A> </B>(int&nbsp;version)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림의 기입시에 사용하는 스트림 프로토콜의 버젼을 지정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[])">write</A> </B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트 배열을 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(byte[], int, int)">write</A> </B>(byte[]&nbsp;buf,
      int&nbsp;off,
      int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트 배열의 일부를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#write(int)">write</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터의 바이트를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBoolean(boolean)">writeBoolean</A> </B>(boolean&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeByte(int)">writeByte</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 비트의 바이트를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeBytes(java.lang.String)">writeBytes</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String를
 바이트의 열로서 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChar(int)">writeChar</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 char를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeChars(java.lang.String)">writeChars</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String를
 char
 열로서 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)">writeClassDescriptor</A> </B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 로 지정된 클래스 기술자를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeDouble(double)">writeDouble</A> </B>(double&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 double를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFields()">writeFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;버퍼에 포함된 필드를 스트림에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeFloat(float)">writeFloat</A> </B>(float&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 float를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeInt(int)">writeInt</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 int를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeLong(long)">writeLong</A> </B>(long&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 long를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)">writeObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 오브젝트를 ObjectOutputStream 에 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeObjectOverride(java.lang.Object)">writeObjectOverride</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스에
해 디폴트의 writeObject 메서드의 오버라이드(override)에 사용됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeShort(int)">writeShort</A> </B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 short를
 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeStreamHeader()">writeStreamHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스가 자신의 헤더를 스트림의 전 또는 뒤로 추가할 수 있도록 제공되고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUnshared(java.lang.Object)">writeUnshared</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectOutputStream 에 「공유되지 않는다」오브젝트를 기입합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectOutputStream.html#writeUTF(java.lang.String)">writeUTF</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 String
 원시적 데이터를<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식에서 기입합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ObjectOutputStream(java.io.OutputStream)"><!-- --></A> <H3>
ObjectOutputStream</H3>
<PRE>
public <B>ObjectOutputStream</B>(<A HREF="../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;out)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 OutputStream 에 기입하는 ObjectOutputStream를
 작성합니다. 이 생성자는
 직렬화 스트림 헤더를 기본으로 되는 스트림에 기입합니다. 이 스트림은 호출해 옆에서 즉시 플래시 해 주세요. ObjectInputStreams를
 받은 생성자는
 헤더를 읽어들일 때 블록 하기 때문에입니다.

<p>시큐러티 매니저가 인스톨 되고 있는 경우, ObjectOutputStream.putFields 메서드 또는 ObjectOutputStream.writeUnshared 메서드를 오버라이드(override) 하는 서브 클래스의 생성자에
해 SerializablePermission("enableSubclassImplementation")가 직접 또는 간접에 불려 갔을 때에
 이 생성자는 이 액세스권을 확인합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>out</CODE> - 기입처의 출력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 스트림 헤더의 기입중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 신뢰되어 있지 않은 서브 클래스가, 보안상 중요한 메서드를 부정하게 오버라이드(override) 했을 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>out</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A>,
 
<A HREF="../../java/io/ObjectOutputStream.html#putFields()"><CODE>putFields()</CODE></A>,
 
<A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)"><CODE>ObjectInputStream.ObjectInputStream(InputStream)</CODE></A> </DL>
</DL>
<HR>

<A NAME="ObjectOutputStream()"><!-- --></A> <H3>
ObjectOutputStream</H3>
<PRE>
protected <B>ObjectOutputStream</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                             <A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>ObjectOutputStream를
 완전하게 다시 구현하는 서브 클래스가, ObjectOutputStream
 이 구현에
해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다.

<p>시큐러티 매니저가 인스톨 되고 있는 경우, 이 메서드는 우선 시큐러티 매니저의 <code>checkPermission</code> 메서드를 액세스권 <code>SerializablePermission("enableSubclassImplementation")</code> 로 호출해, 서브 클래스화를 유효하게 할 수 있도록 합니다.
<P>
<DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 그 <code>checkPermission</code> 메서드가 서브 클래스화를 유효하게 하는 것을 거부했을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="useProtocolVersion(int)"><!-- --></A> <H3>
useProtocolVersion</H3>
<PRE>
public void <B>useProtocolVersion</B>(int&nbsp;version)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림의 기입시에 사용하는 스트림 프로토콜의 버젼을 지정합니다.

<p>이 루틴은, 현재의 버젼의 직렬화가, 전의 버젼의 스트림 형식과 하위 호환성이 있는 형식에서 기입할 수 있도록 하는 훅을 제공합니다.

<p>하위 호환성이 없는 형식이 한층 더 도입되는 것을 막기 위해서 모든 노력을 합니다만, 선택의 여지가 없는 경우도 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>version</CODE> - java.io.ObjectStreamConstants 로부터 ProtocolVersion를
 사용
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/IllegalStateException.html" title="java.lang 안의 클래스">IllegalStateException</A> </CODE> - 오브젝트가 직렬화 된 뒤에 불려 갔을 경우
<DD><CODE><A HREF="../../java/lang/IllegalArgumentException.html" title="java.lang 안의 클래스">IllegalArgumentException</A> </CODE> - 건네받은 버젼이 무효인 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A>,
 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_2</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeObject(java.lang.Object)"><!-- --></A> <H3>
writeObject</H3>
<PRE>
public final void <B>writeObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 오브젝트를 ObjectOutputStream 에 기입합니다. 오브젝트의 클래스, 클래스의 시그니쳐, 클래스의 비 transient 및 비 static 필드와 그 슈퍼 클래스의 모든 값이 기입해집니다. 어느 클래스에 도착해 디폴트의 직렬화는
 writeObject 와 readObject 메서드를 사용해 오버라이드(override) 할 수가 있습니다. 이 오브젝트에
해 참조되는 오브젝트는 중간적으로 기입해져 거기에 따라, 오브젝트의 완전하게 동등한 그래프가 ObjectInputStream 에
해를 재구축 됩니다.

<p>예외는
 OutputStream 에 관한 문제나, 직렬화해야 하는 것이 아닌 클래스에 도착해 Throw 됩니다. 모든 예외는
 OutputStream 에 있어 치명적이어, OutputStream를
 불확정인 상태로 합니다. 스트림 상태를 무시할까 회복 처리할까를 결정하는 것은 호출측입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#writeObject(java.lang.Object)">writeObject</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 기입해지는 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화로 사용되는 클래스에 하등의 불편이 있었을 경우
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 안의 클래스">NotSerializableException</A> </CODE> - 직렬화의 대상 오브젝트가 java.io.Serializable 인터페이스를 구현하고 있지 않는 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 Throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeObjectOverride(java.lang.Object)"><!-- --></A> <H3>
writeObjectOverride</H3>
<PRE>
protected void <B>writeObjectOverride</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                            throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스에
해 디폴트의 writeObject 메서드의 오버라이드(override)에 사용됩니다. 인수 없음의 protected 생성자를 사용해 ObjectInputStream를
 작성한 ObjectInputStream
 신뢰할 수 있는 서브 클래스에
해 불려 갑니다. 서브 클래스는
 수식자가 final
 오버라이드(override) 메서드를 제공한다고 보여집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 기본이 되는 스트림에 기입해지는 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream()"><CODE>ObjectOutputStream()</CODE></A>,
 
<A HREF="../../java/io/ObjectOutputStream.html#writeObject(java.lang.Object)"><CODE>writeObject(Object)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeUnshared(java.lang.Object)"><!-- --></A> <H3>
writeUnshared</H3>
<PRE>
public void <B>writeUnshared</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                   throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>ObjectOutputStream 에 「공유되지 않는다」오브젝트를 기입합니다. 이 메서드는
 writeObject 와 닮아 있습니다. 다만, 직렬화 된 인스턴스를 가리키는 역참조로서가 아니고, 스트림내에서 일의의 새로운 오브젝트로서 기입합니다. 예를 들어, 구체적으로 다음과 같이 됩니다. <ul> <li>writeUnshared를
 사용해 기입해진 오브젝트는
 그 오브젝트가 스트림에 기입해지고 있는지 어떤지에 관계없이, 새롭게 기입해진 오브젝트 (스트림에 기입해지지 않은 오브젝트)로서 직렬화 된다
<li>writeUnshared 로 벌써 기입해지고 있는 오브젝트를 writeObject를
 사용해 기입했을 경우, 전의 writeUnshared 조작에
해 기입해진 오브젝트와 관련성을 가지지 않는 오브젝트라고 보여진다. 즉, ObjectOutputStream는

 writeUnshared 호출에
해 기입해진 오브젝트 데이터에 대해서, 역참조를 생성할 것은 없다
</ul>
 writeUnshared를
 사용해 기입한 오브젝트를 직렬화 복원했을 때에
 그 오브젝트에의 참조가 일의이다고는 할 수 없습니다.  writeUnshared 에서는
 1 개의 오브젝트를 스트림내에 여러 차례 정의할 수 있기 때문에
 수신측으로부터 readUnshared를
 여러 차례 호출해도 중복은 발생하지 않습니다. 이 규칙은, writeUnshared를
 사용해 기입해진 베이스 레벨의 오브젝트에만 적용됩니다. 직렬화하는 오브젝트 그래프내에서 참조되는 서브 오브젝트에는 적용되지 않습니다.

<p>이 메서드를 오버라이드(override) 하는 ObjectOutputStream 서브 클래스는
 SerializablePermission("enableSubclassImplementation")를 가지는 시큐러티 컨텍스트
내에서만 구축할 수 있습니다. 이 액세스권을 가지지 않는 시큐러티 컨텍스트
으로 인스턴스화하려고 하면, SecurityException 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 스트림에 기입하는 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/NotSerializableException.html" title="java.io 안의 클래스">NotSerializableException</A> </CODE> - 직렬화하는 그래프내의 오브젝트가 Serializable 인터페이스를 구현하지 않는 경우
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화하는 오브젝트의 클래스에 문제가 있는 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 직렬화중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="defaultWriteObject()"><!-- --></A> <H3>
defaultWriteObject</H3>
<PRE>
public void <B>defaultWriteObject</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>현재의 클래스의 비 static 필드와 비 transient 필드를, 스트림에 기입합니다. 이 메서드를 호출할 수가 있는 것은, 직렬화를 하고 있는 클래스의 writeObject 메서드 뿐입니다. 다른 방법으로 불려 갔을 경우는 NotActiveException를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>OutputStream</code>
 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="putFields()"><!-- --></A> <H3>
putFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스">ObjectOutputStream.PutField</A>  <B>putFields</B>()
                                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림에 기입해지는 지속 필드를 버퍼에 포함하기 위해서 사용되는 오브젝트를 취득합니다. 필드는
 writeFields 메서드가 불려 갔을 때에 스트림에 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 가능 필드를 보관 유지하고 있는 클래스 Putfield
 인스턴스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeFields()"><!-- --></A> <H3>
writeFields</H3>
<PRE>
public void <B>writeFields</B>()
                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>버퍼에 포함된 필드를 스트림에 기입합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 오브젝트 상태를 기입하기 위해서 클래스의 writeObject 메서드가 불려 가지 않았을 때에 불려 갔을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="reset()"><!-- --></A> <H3>
reset</H3>
<PRE>
public void <B>reset</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림에 벌써 기입해지고 있는 오브젝트 상태를 무효로 합니다. 상태는
 새로운 ObjectOutputStream
 작성시와 같게 리셋트 됩니다. 스트림의 현재 위치에 마크가 설정되어 대응하는 ObjectInputStream 도 같은 위치에 리셋트 됩니다. 그 이전에 스트림에 기입해지고 있던 오브젝트는 스트림상에 있다고는 보여지지 않고, 재차 스트림에 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 오브젝트를 직렬화중에 reset()가 불려 갔을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="annotateClass(java.lang.Class)"><!-- --></A> <H3>
annotateClass</H3>
<PRE>
protected void <B>annotateClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스는
 클래스의 데이터를 스트림에 보존할 수 있도록 이 메서드를 구현하는 경우가 있습니다. 디폴트에서는 이 메서드는 아무것도 실시하지 않습니다. ObjectInputStream
 대응하는 메서드는 resolveClass 입니다. 이 메서드는
 스트림의 일의의 클래스 각각 붙어 1 회만 불려 갑니다. 그 시점에서 클래스명과 시그니쳐는 벌써 스트림에 기입해지고 있습니다. 이 메서드는
 ObjectOutputStream를
 자유롭게 사용해, 적당이라고 판단된다면 클래스의 임의의 표현 (예를 들어, 클래스 파일의 바이트)을 보존할 수 있습니다. ObjectInputStream
 대응하는 서브 클래스의 resolveClass 메서드는
 annotateClass 에
해 기입해진 데이터나 오브젝트를 읽어들여, 사용하지 않으면 안됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 커스텀 데이터에 주석을 붙이는 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 Throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="annotateProxyClass(java.lang.Class)"><!-- --></A> <H3>
annotateProxyClass</H3>
<PRE>
protected void <B>annotateProxyClass</B>(<A HREF="../../java/lang/Class.html" title="java.lang 안의 클래스">Class</A> &lt;? &gt;&nbsp;cl)
                           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스는 이 메서드를 구현해, 다이나믹 프록시 클래스에 대한 기술자와 함께 커스텀 데이터를 스트림에 포함합니다.

<p>이 메서드는 스트림의 일의의 프록시 클래스 기술자의 각각 붙어 1 회만 불려 갑니다. <code>ObjectOutputStream</code> 에 있는 이 메서드의 디폴트 구현은 아무것도 하지 않습니다.

<p><code>ObjectInputStream</code> 에서의 대응하는 메서드는 <code>resolveProxyClass</code> 입니다. 이 메서드를 오버라이드(override) 하는 지정된 서브 클래스 <code>ObjectOutputStream</code> 에 대해서,<code>ObjectInputStream</code>
 대응하는 서브 클래스에 있는 <code>resolveProxyClass</code> 메서드는 <code>annotateProxyClass</code> 가 기입하는 임의의 데이터 또는 오브젝트를 읽어들일 필요가 있습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cl</CODE> - 커스텀 데이터에 주석을 붙이는 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>OutputStream</code> 가 예외를 Throw 했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])"><CODE>ObjectInputStream.resolveProxyClass(String[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="replaceObject(java.lang.Object)"><!-- --></A> <H3>
replaceObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>replaceObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>직렬화 시에
 ObjectOutputStream
 신뢰할 수 있는 서브 클래스가, 어느 오브젝트를 다른 오브젝트에 치환할 수 있도록 합니다. 오브젝트의 치환은, enableReplaceObject 가 불려 갈 때까지는 실시할 수 없습니다. enableReplaceObject 메서드는
 치환을 요구하고 있는 스트림을 신뢰할 수 있을지 어떨지를 조사합니다. 직렬화 스트림에 기입해지는 각 오브젝트의 쳐 최초로 출현한 것은, replaceObject 에게 건네집니다. 오브젝트의 private 인 상태가
도하지 않고 누설 하는 것이 없게, replaceObject를
 사용하는 것은 신뢰할 수 있는 스트림로 한정됩니다.
<p>ObjectOutputStream.writeObject 메서드는 Object 형의 파라미터 (Serializable 형과는 다르다)를 취해, 직렬화 가능하지 않은 오브젝트가 직렬화 가능 오브젝트로 옮겨지도록 합니다.
<p>서브 클래스는
 오브젝트를 치환할 때, 직렬화 복원 실행시에 상보적으로 치환을 하는지, 또는 치환된 오브젝트와 참조가 포함되는 각 필드와의 호환성을 보증할 필요가 있습니다. 필드 또는 배열 요소의 형태의 서브 클래스가 아닌 형태의 오브젝트는
 예외를 발생시키는 것에
해 직렬화를 중단해, 그 결과 오브젝트는 포함되지 않습니다.

<p>이 메서드는
 각 오브젝트가 최초로 검출되었을 때에 1 회만 불려 갑니다. 이것 이후 검출되는 그 오브젝트에의 참조는
 새로운 오브젝트에 리디렉트 됩니다. 이 메서드는
 치환되는 메서드인가, 또는 오리지날의 어느 쪽인지를 돌려주지 않으면 안됩니다.

<p>치환되는 오브젝트로서 null를
 돌려줄 수도 있습니다만, 오리지날 오브젝트에의 참조를 포함한 클래스에서는
 null는
 아니고 오브젝트가 돌려주고지는 것을 가정하고 있는 것이 있어, 이 경우는 NullReferenceException 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 옮겨놓을 수 있는 오브젝트
<DT><B>반환값:</B><DD>지정된 오브젝트와 옮겨놓을 수 있었던 대체 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 OutputStream 가 예외를 Throw 했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="enableReplaceObject(boolean)"><!-- --></A> <H3>
enableReplaceObject</H3>
<PRE>
protected boolean <B>enableReplaceObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 내의 클래스">SecurityException</A> </PRE>
<DL>
<DD>스트림내에서 오브젝트를 치환할 수 있도록 합니다. 치환이 가능하게 되면, 직렬화 되는 각 오브젝트에 대해 replaceObject 메서드가 불려 갑니다.

<p><code>enable</code> 가 true 로 시큐러티 매니저가 인스톨 되고 있는 경우, 이 메서드는 우선 시큐러티 매니저의 <code>checkPermission</code> 메서드를 액세스권 <code>SerializablePermission("enableSubstitution")</code> 로 호출해, 스트림의 오브젝트를 스트림을 치환할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enable</CODE> - 오브젝트의 치환을 가능하게 하는 boolean 파라미터
<DT><B>반환값:</B><DD>이 메서드가 불려 가기 전의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 그 <code>checkPermission</code> 메서드가, 스트림내의 오브젝트의 스트림에
한 치환을 허가하지 않았던 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="writeStreamHeader()"><!-- --></A> <H3>
writeStreamHeader</H3>
<PRE>
protected void <B>writeStreamHeader</B>()
                          throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>서브 클래스가 자신의 헤더를 스트림의 전 또는 뒤로 추가할 수 있도록 제공되고 있습니다. 이 메서드는
 매직 번호와 버젼 정보를 스트림에 기입합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeClassDescriptor(java.io.ObjectStreamClass)"><!-- --></A> <H3>
writeClassDescriptor</H3>
<PRE>
protected void <B>writeClassDescriptor</B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>ObjectOutputStream 로 지정된 클래스 기술자를 기입합니다. 클래스 기술자는 스트림에 기입해진 오브젝트의 클래스를 식별할 때에 사용합니다. ObjectOutputStream
 서브 클래스는 이 메서드에 오버라이드(override) 해, 클래스 기술자가 직렬화 스트림에 기입하는 방법을 커스터마이즈 합니다. ObjectInputStream 내의 대응하는 메서드 <code>readClassDescriptor</code> 은, 오버라이드(override) 되고 클래스 기술자를 커스텀 스트림 표현으로부터 복원할 필요가 있습니다. 디폴트에서는
 이 메서드는
 오브젝트 직렬화 사양으로 정의된 형식에 따라 클래스 기술자를 기입합니다.  
<p>이 메서드는 ObjectOutputStream 가 낡은 직렬화 스트림 형식 (ObjectOutputStream
 <code>useProtocolVersion</code> 메서드를 호출해 설정)을 사용하고 있지 않는 경우에 한정해 불려 가는 점에 주의해 주세요. 이 직렬화 스트림이 낡은 형식 (<code>PROTOCOL_VERSION_1</code>)을 사용하고 있는 경우, 클래스 기술자는 오버라이드(override) 되지 않는 방법 또는 커스터마이즈 할 수 없는 방법으로 내부적으로 기입해집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>desc</CODE> - 스트림에 기입하는 클래스 기술자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()"><CODE>ObjectInputStream.readClassDescriptor()</CODE></A>,
 
<A HREF="../../java/io/ObjectOutputStream.html#useProtocolVersion(int)"><CODE>useProtocolVersion(int)</CODE></A>,
 
<A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1"><CODE>ObjectStreamConstants.PROTOCOL_VERSION_1</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="write(int)"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(int&nbsp;val)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>데이터의 바이트를 기입합니다. 이 메서드는
 데이터가 실제로 기입해질 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(int)">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(int)">write</A> </CODE><DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 스트림에 기입해지는 바이트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[])"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트 배열을 기입합니다. 이 메서드는
 데이터가 실제로 기입해질 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[])">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[])">write</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[])">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 기입해지는 데이터
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)"><CODE>OutputStream.write(byte[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="write(byte[], int, int)"><!-- --></A> <H3>
write</H3>
<PRE>
public void <B>write</B>(byte[]&nbsp;buf,
                  int&nbsp;off,
                  int&nbsp;len)
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트 배열의 일부를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#write(byte[], int, int)">write</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#write(byte[], int, int)">write</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#write(byte[], int, int)">write</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 기입해지는 데이터<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 기입해지는 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="flush()"><!-- --></A> <H3>
flush</H3>
<PRE>
public void <B>flush</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림을 플래시 합니다. 이 메서드는
 버퍼링 떠날 수 있어 모든 출력 바이트를 기입해, 기본이 되는 스트림을 통해 플래시 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Flushable.html" title="java.io 내의 인터페이스">Flushable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Flushable.html#flush()">flush</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#flush()">flush</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#flush()">flush</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="drain()"><!-- --></A> <H3>
drain</H3>
<PRE>
protected void <B>drain</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>ObjectOutputStream 에 있는 버퍼 데이터를 모두 비웁니다. flush 와 닮은 동작입니다만, 이 메서드에서는 기본이 되는 스트림의 flush는
 일어나지 않습니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>스트림을 닫습니다. 스트림에 관련된 모든 자원을 해방하기 위해서 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Closeable.html#close()">close</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스">ObjectOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectOutput.html#close()">close</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/OutputStream.html" title="java.io 내의 클래스">OutputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/OutputStream.html#close()">close</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeBoolean(boolean)"><!-- --></A> <H3>
writeBoolean</H3>
<PRE>
public void <B>writeBoolean</B>(boolean&nbsp;val)
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>boolean를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeBoolean(boolean)">writeBoolean</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeByte(int)"><!-- --></A> <H3>
writeByte</H3>
<PRE>
public void <B>writeByte</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>8 비트의 바이트를 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeByte(int)">writeByte</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeShort(int)"><!-- --></A> <H3>
writeShort</H3>
<PRE>
public void <B>writeShort</B>(int&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 short를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeShort(int)">writeShort</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeChar(int)"><!-- --></A> <H3>
writeChar</H3>
<PRE>
public void <B>writeChar</B>(int&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 char를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeChar(int)">writeChar</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 char 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeInt(int)"><!-- --></A> <H3>
writeInt</H3>
<PRE>
public void <B>writeInt</B>(int&nbsp;val)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 int를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeInt(int)">writeInt</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 int 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeLong(long)"><!-- --></A> <H3>
writeLong</H3>
<PRE>
public void <B>writeLong</B>(long&nbsp;val)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 long를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeLong(long)">writeLong</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 long 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeFloat(float)"><!-- --></A> <H3>
writeFloat</H3>
<PRE>
public void <B>writeFloat</B>(float&nbsp;val)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 float를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeFloat(float)">writeFloat</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 float 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeDouble(double)"><!-- --></A> <H3>
writeDouble</H3>
<PRE>
public void <B>writeDouble</B>(double&nbsp;val)
                 throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 double를
 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeDouble(double)">writeDouble</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>val</CODE> - 기입해지는 double 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeBytes(java.lang.String)"><!-- --></A> <H3>
writeBytes</H3>
<PRE>
public void <B>writeBytes</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>String를
 바이트의 열로서 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeBytes(java.lang.String)">writeBytes</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 바이트의 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeChars(java.lang.String)"><!-- --></A> <H3>
writeChars</H3>
<PRE>
public void <B>writeChars</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>String를
 char
 열로서 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeChars(java.lang.String)">writeChars</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 char
 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="writeUTF(java.lang.String)"><!-- --></A> <H3>
writeUTF</H3>
<PRE>
public void <B>writeUTF</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> &nbsp;str)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>이 String
 원시적 데이터를<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식에서 기입합니다. 스트림에 String를
 원시적 데이터로서 기입하는 것으로 Object 로서 기입하는 것에는 큰 차이가 있습니다. writeObject 에
해 기입해지는 String
 인스턴스는
 처음은 String 로서 스트림에 기입해집니다. 그 이후의 writeObject()의 호출은, 캐릭터 라인에의 참조를 스트림에 기입합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataOutput.html" title="java.io 내의 인터페이스">DataOutput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataOutput.html#writeUTF(java.lang.String)">writeUTF</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>str</CODE> - 기입해지는 캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 기입중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectOutputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/io/ObjectOutput.html" title="java.io 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectOutputStream.PutField.html" title="java.io 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/io/ObjectOutputStream.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ObjectOutputStream.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

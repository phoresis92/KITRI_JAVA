<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 11:56:30 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
ObjectInputStream (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="java.io.ObjectInputStream class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="ObjectInputStream (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/io/ObjectInputStream.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
java.io</FONT>
<BR>
클래스 ObjectInputStream</H2>
<PRE>
<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">java.lang.Object</A> 
  <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">java.io.InputStream</A> 
      <IMG SRC="../../resources/inherit.gif" ALT="상위를 확장 "><B>java.io.ObjectInputStream</B>
</PRE>
<DL>
<DT><B>모든 구현된 인터페이스:</B> <DD><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A>,
 <A HREF="../../java/io/DataInput.html" title="java.io 안의 인터페이스">DataInput</A>,
 <A HREF="../../java/io/ObjectInput.html" title="java.io 안의 인터페이스">ObjectInput</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>ObjectInputStream</B><DT>extends <A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> <DT>implements <A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A> </DL>
</PRE>

<P>
사전에 ObjectOutputStream를
 사용해 작성된 원시적 데이터와 원시적 오브젝트를 직렬화 복원합니다.
<p>ObjectOutputStream 와 ObjectInputStream는

 FileOutputStream 또는 FileInputStream 와 함께 사용하면, 어플리케이션에
 오브젝트의 그래프를 위한 지속적인 스토리지를 제공할 수가 있습니다. ObjectInputStream는

 사전에 직렬화 된 오브젝트를 바탕으로 되돌리기 위해서 사용합니다. 다른 사용 방법으로서는
 소켓 스트림의 사용에
한, 호스트 사이에서의 오브젝트의 수수나, 리모트 통신 시스템에 있어서의 속성이나 파라미터의 정렬이나 정렬 해제가 있습니다.

<p>ObjectInputStream는

 스트림로부터 작성된 오브젝트 그래프에 있어서의 모든 형태의 오브젝트가, Java 가상 머신에 존재하는 클래스에 확실히 성냥 하도록 합니다. 클래스는
 표준의 도구
를 사용해 필요에 따라서 로드 됩니다.

<p>스트림로부터 읽어들일 수가 있는 것은, java.io.Serializable 인터페이스나 java.io.Externalizable 인터페이스를 지원하는 오브젝트만입니다.

<p>오브젝트를 스트림로부터 읽어들이려면 <code>readObject</code> 메서드를 사용합니다. 희망의 형태를 취득하려면,
 Java
 안전한 캐스트를 사용할 필요가 있습니다. Java 에서는
 캐릭터 라인과 배열은 오브젝트로 직렬화의 사이는 오브젝트로서 다루어집니다. 그것들을 읽어들이려면,
 희망의 형태에 캐스트 되고 있을 필요가 있습니다.

<p>기본 데이터형을 스트림로부터 읽어들이려면,
 DataInput
 적절한 메서드를 사용합니다.
<p>오브젝트의 디폴트의 직렬화 복원 도구
는
 각 필드의 내용을, 기입해졌을 때 상태에 되돌립니다. transient 또는 static 라고 선언된 필드는
 직렬화 복원 처리에서는 무시됩니다. 다른 오브젝트를 참조하면, 그러한 오브젝트는
 필요에 따라서 스트림로부터 읽힙니다. 오브젝트의 그래프는
 참조 공유 도구
를 사용해 올바르게 복원됩니다. 직렬화 복원을 할 때는
 항상 새로운 오브젝트를 할당할 수 있어 거기에 따라 기존의 오브젝트에의 덧쓰기가 방지됩니다.

<p>오브젝트의 read는
 새로운 오브젝트의 생성자 실행을 닮아 있습니다. 메모리를 오브젝트에 할당할 수 있어 제로 (NULL)에 초기화됩니다. 직렬화 가능하지 않은 클래스에 대해서, 인수 없음의 생성자가 불려 간 뒤, 직렬화 가능 클래스의 필드가, java.lang.Object 에 가장 가까운 클래스로부터 시작되어, 가장 오브젝트에 고유의 클래스에서 끝나는 스트림로부터 복원됩니다.

<p>예를 들어, ObjectOutputStream
 예로 기입해진 스트림로부터의 read는
 다음과 같이 실시합니다. <br>
 
 <pre>

        FileInputStream fis = new FileInputStream("t.tmp");
        ObjectInputStream ois = new ObjectInputStream(fis);

        int i = ois.readInt();
        String today = (String) ois.readObject();
        Date date = (Date) ois.readObject();

        ois.close();
 </pre>


<p>클래스는
 인터페이스 java.io.Serializable 또는 java.io.Externalizable를
 구현하는 것에
해, 클래스가 어떻게 직렬화 되는지를 제어합니다.

<p>Serializable 인터페이스를 구현하는 것에
해, 오브젝트의 직렬화가, 오브젝트 상태 전체의 보존과 복원을 실시하는 것이 가능하게 되어, 또 클래스가, 스트림의 기입시와 스트림의 read시의 사이에 전개하는 것이 가능하게 됩니다. 오브젝트의 직렬화는
 오브젝트간의 참조를 자동적으로 이동해, 오브젝트 그래프의 전체를 보존 및 복원합니다.

<p>직렬화 처리와 직렬화 복원 처리 때에 특별한 조작을 필요로 하는 Serializable 클래스는
 다음의 메서드를 구현할 필요가 있습니다. <p> 
 
 <pre>

 private void writeObject(java.io.ObjectOutputStream stream)
     throws IOException;
 private void readObject(java.io.ObjectInputStream stream)
     throws IOException, ClassNotFoundException; 
 private void readObjectNoData() 
     throws ObjectStreamException;
 </pre>


<p>readObject 메서드는
 대응하는 writeObject 메서드에
해 스트림에 기입해진 데이터를 사용하는 특정의 클래스에 도착해, 오브젝트 상태를 보존 및 복원할 책임을 가집니다. 이 메서드는
 그 슈퍼 클래스나 서브 클래스에 속하는 상태에 관여할 필요는 없습니다. 상태를 복원하려면,
 개개의 필드에 도착해 ObjectInputStream 로부터 데이터를 읽어들여, 오브젝트의 적절한 필드에의 할당을 실시합니다. 기본 데이터형의 read는
 DataInput 에
해 지원됩니다.

<p>오브젝트 데이터를 읽어들이려고 할 경우에
 그 위치가 대응하는 writeObject 메서드에
해 기입해진 커스텀 데이터의 경계를 넘고 있는 경우는
 eof 필드의 값이 true 상태로 OptionalDataException 가 Throw 됩니다. 오브젝트를 직렬화해 읽어들이려고 할 경우에
 그 위치가 할당하고가 끝난 데이터의 마지막을 넘고 있는 경우는
 스트림의 경우와 같게, 데이터의 마지막을 나타내는 예외가 돌려주고집니다. 즉, 바이트 단위의 read에서는
 바이트가 읽혔을 때에 -1 가 돌려주고집니다. 원시적 read에서는
 EOFException 가 Throw 됩니다. 대응하는 writeObject 메서드가 없는 경우는
 디폴트의 직렬화 데이터의 마지막이 할당하고가 끝난 데이터가 끝나게 됩니다.

<p>원시적 read와 오브젝트 read가 readExternal 메서드로부터 불려 갔을 경우는
 양쪽 모두 똑같이 동작합니다. 스트림의 위치가 대응하는 writeExternal 메서드에
해 기입해진 데이터의 마지막에 있는 경우, 오브젝트 read에서는 eof 가 true 로 설정된 상태로 OptionalDataException 가 Throw 되어 바이트 단위의 read에서는 -1 이 돌려주고져 원시적 read에서는 EOFException 가 Throw 됩니다. 다만, 낡은 <code>ObjectStreamConstants.PROTOCOL_VERSION_1</code> 프로토콜을 사용해 기입해진 스트림에서는
 이 동작은 적용되지 않습니다. writeExternal 메서드와 달리, 데이터의 마지막이 기입해지지 않기 때문에
 데이터의 마지막을 검출할 수 없기 때문입니다.

<p>readObjectNoData 메서드는
 직렬화 복원되는 오브젝트의 슈퍼 클래스가 직렬화 스트림로 지정되어 있지 않을 때에
 특정의 클래스에 도착해 그 오브젝트 상태를 초기화합니다. 직렬화 복원되는 인스턴스의 클래스가 수신측과 송신측에서 다른 경우나, 수신측의 인스턴스로 확장되고 있는 클래스가 송신측에서 확장되어 있지 않은 경우에
 이러한 상황이 발생하는 일이 있습니다. 또, 직렬화 스트림이 개찬되고 있는 경우에도 발생합니다. 악의가 있는 또는 불완전한 소스 스트림로부터 직렬화 복원한 오브젝트를 적절히 초기화할 때는
 readObjectNoData를
 사용합니다.
<p>직렬화는
 java.io.Serializable 인터페이스를 구현하지 않는 오브젝트의 필드의 read나, 그러한 필드에의 값의 할당은 실시하지 않습니다. 직렬화 가능하지 않은 오브젝트의 서브 클래스를 직렬화 가능하게 하는 것은 가능합니다. 이 경우, 직렬화 가능하지 않은 클래스는
 그 필드를 초기화할 수 있도록 하기 위한, 인수 없음의 생성자를 가질 필요가 있습니다. 이 경우, 직렬화 가능하지 않은 클래스 상태를 보존 및 복원하는 것은, 서브 클래스의 책임이 됩니다. 그 클래스의 필드가 액세스 가능한 (public, package, 또는 protected) 경우, 혹은 상태의 복원에 이용할 수 있는 set 메서드나 get 메서드가 있는 경우가 자주 있습니다.

<p>오브젝트를 직렬화 복원하는 동안에 발생한 모든 예외는
 ObjectInputStream 에 캐치 되어 read 처리를 이상종료(ABEND) 시킵니다.

<p>Externalizable 인터페이스를 구현하면, 오브젝트의 직렬화 된 형식의 내용 및 형식을 오브젝트측이 완전하게 제어하는 것이 가능하게 됩니다. Externalizable 인터페이스의 메서드인 writeExternal 와 readExternal는

 오브젝트 상태를 보존 및 복원하기 위해서 불려 갑니다. 이러한 메서드는
 클래스에
해 구현되었을 경우에는
 ObjectOutput 와 ObjectInput
 모든 메서드를 사용해, 자신 상태의 기입 및 read를 실시할 수가 있습니다. 어떠한 버젼이어도 처리할 수 있도록 하는 것은, 오브젝트의 책임입니다.

<p>enum 정수는
 보통
의 직렬화 가능 오브젝트나 외부화 가능 오브젝트와는 다른 방법으로 직렬화 복원됩니다. enum 정수의 직렬화 형식은 이름만으로 구성됩니다. 정수의 필드치는 전송 되지 않습니다. enum 정수를 직렬화 복원하려면,
 ObjectInputStream 가 스트림로부터 정수의 이름을 읽어들입니다. 다음에
 enum 정수의 기저형이라고 받은 정수명을 인수로서 사용해, static 메서드 <code>Enum.valueOf(Class, String)</code>를
 호출하면 직렬화 복원된 정수를 취득할 수 있습니다. 다른 직렬화 가능 오브젝트 또는 외부화 가능 오브젝트와 같이, enum 정수도, 직렬화 스트림에 나중에 나타나는 역참조의 타겟으로서 기능할 수 있습니다. enum 정수가 직렬화 복원되는 순서는 커스터마이즈 할 수 없습니다. 즉, enum 형에
해 정의된, 클래스 특유의 readObject, readObjectNoData 및 readResolve 메서드는
 직렬화 복원동안은 무시됩니다. 같이 serialPersistentFields 또는 serialVersionUID 필드 선언도 무시됩니다. 모든 enum 형은, serialVersionUID 가 0L 에 고정되고 있습니다.
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>JDK1. 1</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스"><CODE>DataInput</CODE></A>,
 
<A HREF="../../java/io/ObjectOutputStream.html" title="java.io 안의 클래스"><CODE>ObjectOutputStream</CODE></A>,
 
<A HREF="../../java/io/Serializable.html" title="java.io 안의 인터페이스"><CODE>Serializable</CODE></A>,
 
<a href="../../../guide/serialization/spec/input.doc.html"> Object Serialization Specification, Section 3, Object Input Classes</a> </DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>중첩(Nested) 클래스 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 안의 클래스">ObjectInputStream.GetField</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력 스트림로부터 읽힌 지속 필드에의 액세스를 제공합니다. </TD>
</TR>
</TABLE>
&nbsp;<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_java.io.ObjectStreamConstants"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectStreamConstants.html" title="java.io 안의 인터페이스">ObjectStreamConstants</A>  로부터 상속된 필드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectStreamConstants.html#baseWireHandle">baseWireHandle</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_1">PROTOCOL_VERSION_1</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#PROTOCOL_VERSION_2">PROTOCOL_VERSION_2</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_BLOCK_DATA">SC_BLOCK_DATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_ENUM">SC_ENUM</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_EXTERNALIZABLE">SC_EXTERNALIZABLE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_SERIALIZABLE">SC_SERIALIZABLE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SC_WRITE_METHOD">SC_WRITE_METHOD</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_MAGIC">STREAM_MAGIC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#STREAM_VERSION">STREAM_VERSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SUBCLASS_IMPLEMENTATION_PERMISSION">SUBCLASS_IMPLEMENTATION_PERMISSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#SUBSTITUTION_PERMISSION">SUBSTITUTION_PERMISSION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ARRAY">TC_ARRAY</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BASE">TC_BASE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATA">TC_BLOCKDATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_BLOCKDATALONG">TC_BLOCKDATALONG</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASS">TC_CLASS</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_CLASSDESC">TC_CLASSDESC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENDBLOCKDATA">TC_ENDBLOCKDATA</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_ENUM">TC_ENUM</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_EXCEPTION">TC_EXCEPTION</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_LONGSTRING">TC_LONGSTRING</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_MAX">TC_MAX</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_NULL">TC_NULL</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_OBJECT">TC_OBJECT</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_PROXYCLASSDESC">TC_PROXYCLASSDESC</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_REFERENCE">TC_REFERENCE</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_RESET">TC_RESET</A>,
 <A HREF="../../java/io/ObjectStreamConstants.html#TC_STRING">TC_STRING</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>생성자 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()">ObjectInputStream</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream를
 완전하게 재구현하는 서브 클래스가, ObjectInputStream
 이 구현에
해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream(java.io.InputStream)">ObjectInputStream</A> </B>(<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;in)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 InputStream 로부터 읽어들이는 ObjectInputStream를
 작성합니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#available()">available</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;블록 하지 않고 읽어들일 수가 있는 바이트수를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#close()">close</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;입력 스트림을 닫습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#defaultReadObject()">defaultReadObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;현재의 클래스의 비 static 및 비 transient
 필드를, 이 스트림로부터 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#enableResolveObject(boolean)">enableResolveObject</A> </B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림로부터 읽힌 오브젝트가 치환됩니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read()">read</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;데이터의 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#read(byte[], int, int)">read</A> </B>(byte[]&nbsp;buf,
     int&nbsp;off,
     int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트의 배열에 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readBoolean()">readBoolean</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readByte()">readByte</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 비트의 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readChar()">readChar</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 char를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 내의 클래스">ObjectStreamClass</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readClassDescriptor()">readClassDescriptor</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;직렬화 스트림로부터 클래스 기술자를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readDouble()">readDouble</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 double를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스">ObjectInputStream.GetField</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFields()">readFields</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림로부터 지속 필드를 읽어들여, 그것들을 이름을 지정해 액세스 할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;float</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFloat()">readFloat</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 float를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[])">readFully</A> </B>(byte[]&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readFully(byte[], int, int)">readFully</A> </B>(byte[]&nbsp;buf,
          int&nbsp;off,
          int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readInt()">readInt</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32 비트의 int를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLine()">readLine</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 바이트를 정확하게 문자로 변환하지 않습니다. 상세 및 대체 메서드에 대해서는 DataInputStream를
 참조하십시오. </I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readLong()">readLong</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;64 비트의 long를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObject()">readObject</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream 로부터 오브젝트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readObjectOverride()">readObjectOverride</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;인수 없음의 protected 생성자를 사용해 ObjectOutputStream를
 작성한 ObjectOutputStream
 신뢰할 수 있는 서브 클래스에
해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readShort()">readShort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16 비트의 short를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readStreamHeader()">readStreamHeader</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;서브 클래스가 자신의 스트림 헤더의 read와 검증을 실시할 수 있도록 하기 위해서 제공되고 있습니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnshared()">readUnshared</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ObjectInputStream 로부터 「공유되지 않는다」오브젝트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedByte()">readUnsignedByte</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;부호 없음 8 비트 바이트를 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUnsignedShort()">readUnsignedShort</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;부호 없음 16 비트의 short를
 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#readUTF()">readUTF</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식의 캐릭터 라인을 읽어들입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#registerValidation(java.io.ObjectInputValidation, int)">registerValidation</A> </B>(<A HREF="../../java/io/ObjectInputValidation.html" title="java.io 안의 인터페이스">ObjectInputValidation</A> &nbsp;obj,
                   int&nbsp;prio)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;오브젝트 그래프가 돌려주고지기 전에 검증되어야 할 오브젝트를 등록합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveClass(java.io.ObjectStreamClass)">resolveClass</A> </B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 스트림 클래스의 기술에 대응하는 로컬 클래스를 로드합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveObject(java.lang.Object)">resolveObject</A> </B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;직렬화 복원 시에
 ObjectInputStream
 신뢰할 수 있는 서브 클래스가, 어느 오브젝트를 다른 오브젝트에 치환할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#resolveProxyClass(java.lang.String[])">resolveProxyClass</A> </B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프록시 클래스 기술자로 지정된 인터페이스를 구현하는 프록시 클래스를 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../java/io/ObjectInputStream.html#skipBytes(int)">skipBytes</A> </B>(int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;바이트를 스킵 합니다. </TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.InputStream"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.io. <A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/InputStream.html#mark(int)">mark</A>,
 <A HREF="../../java/io/InputStream.html#markSupported()">markSupported</A>,
 <A HREF="../../java/io/InputStream.html#read(byte[])">read</A>,
 <A HREF="../../java/io/InputStream.html#reset()">reset</A>,
 <A HREF="../../java/io/InputStream.html#skip(long)">skip</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>클래스 java.lang. <A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/lang/Object.html#clone()">clone</A>,
 <A HREF="../../java/lang/Object.html#equals(java.lang.Object)">equals</A>,
 <A HREF="../../java/lang/Object.html#finalize()">finalize</A>,
 <A HREF="../../java/lang/Object.html#getClass()">getClass</A>,
 <A HREF="../../java/lang/Object.html#hashCode()">hashCode</A>,
 <A HREF="../../java/lang/Object.html#notify()">notify</A>,
 <A HREF="../../java/lang/Object.html#notifyAll()">notifyAll</A>,
 <A HREF="../../java/lang/Object.html#toString()">toString</A>,
 <A HREF="../../java/lang/Object.html#wait()">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long)">wait</A>,
 <A HREF="../../java/lang/Object.html#wait(long, int)">wait</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.io.ObjectInput"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>인터페이스 java.io. <A HREF="../../java/io/ObjectInput.html" title="java.io 안의 인터페이스">ObjectInput</A>  로부터 상속된 메서드</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../java/io/ObjectInput.html#read(byte[])">read</A>,
 <A HREF="../../java/io/ObjectInput.html#skip(long)">skip</A> </CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>생성자 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="ObjectInputStream(java.io.InputStream)"><!-- --></A> <H3>
ObjectInputStream</H3>
<PRE>
public <B>ObjectInputStream</B>(<A HREF="../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;in)
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>지정된 InputStream 로부터 읽어들이는 ObjectInputStream를
 작성합니다. 직렬화 스트림 헤더는
 스트림로부터 읽힌 뒤, 검증됩니다. 이 생성자는
 대응하는 ObjectOutputStream 가 헤더를 기입해 플래시 할 때까지 블록 합니다.

<p>시큐러티 매니저가 인스톨 되고 있는 경우, ObjectInputStream.readFields 메서드 또는 ObjectInputStream.readUnshared 메서드를 오버라이드(override) 하는 서브 클래스의 생성자에
해 SerializablePermission("enableSubclassImplementation")가 직접 또는 간접에 불려 갔을 때에
 이 생성자는 이 액세스권을 확인합니다.
<P>
<DL>
<DT><B>파라미터:</B><DD><CODE>in</CODE> - read원의 입력 스트림
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림 헤더가 부정한 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 스트림 헤더의 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 신뢰되어 있지 않은 서브 클래스가, 보안상 중요한 메서드를 부정하게 오버라이드(override) 했을 경우
<DD><CODE><A HREF="../../java/lang/NullPointerException.html" title="java.lang 안의 클래스">NullPointerException</A> </CODE> - <code>in</code> 가 <code>null</code>
 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()"><CODE>ObjectInputStream()</CODE></A>,
 
<A HREF="../../java/io/ObjectInputStream.html#readFields()"><CODE>readFields()</CODE></A>,
 
<A HREF="../../java/io/ObjectOutputStream.html#ObjectOutputStream(java.io.OutputStream)"><CODE>ObjectOutputStream.ObjectOutputStream(OutputStream)</CODE></A> </DL>
</DL>
<HR>

<A NAME="ObjectInputStream()"><!-- --></A> <H3>
ObjectInputStream</H3>
<PRE>
protected <B>ObjectInputStream</B>()
                     throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                            <A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </PRE>
<DL>
<DD>ObjectInputStream를
 완전하게 재구현하는 서브 클래스가, ObjectInputStream
 이 구현에
해 사용된지 얼마 안된 private 데이터를 할당할 필요가 없게 하는 수단을 제공합니다.

<p>시큐러티 매니저가 인스톨 되고 있는 경우, 이 메서드는 우선 시큐러티 매니저의 <code>checkPermission</code> 메서드를 액세스권 <code>SerializablePermission("enableSubclassImplementation")</code> 로 호출해, 서브 클래스화를 유효하게 할 수 있도록 합니다.
<P>
<DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 그 <code>checkPermission</code> 메서드가 서브 클래스화를 유효하게 하는 것을 거부했을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE><DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="readObject()"><!-- --></A> <H3>
readObject</H3>
<PRE>
public final <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readObject</B>()
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                               <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>ObjectInputStream 로부터 오브젝트를 읽어들입니다. 오브젝트의 클래스, 클래스의 시그니쳐, 클래스의 비 transient 및 비 static 필드와 그 슈퍼타입의 모든 값이 읽힙니다. 어느 클래스에 대한 디폴트의 직렬화 복원은, writeObject 와 readObject 메서드를 사용해 오버라이드(override) 할 수가 있습니다. 이 오브젝트에
해 참조되는 오브젝트는 중간적으로 읽혀 거기에 따라, 완전하게 동등한 오브젝트 그래프가 readObject 에
해 재구축 됩니다.

<p>루트 오브젝트는
 참조하는 필드와 오브젝트의 모든 것이 복원되었을 때, 완전하게 복원됩니다. 이 시점에서, 그러한 등록된 우선 순위에 근거해, 오브젝트 검증 콜백이 실행됩니다. 이 콜백은, (특별한 readObject 메서드의) 오브젝트에
해, 그것들이 개별적으로 복원될 때 등록됩니다.

<p>예외는
 InputStream 에 관한 문제나, 직렬화 복원해야 하는 것이 아닌 클래스에 도착해 Throw 됩니다. 모든 예외는
 InputStream 에 있어 치명적이어, InputStream를
 불확정 상태로 합니다. 스트림 상태를 무시할까 회복 처리할까를 결정하는 것은 호출측입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#readObject()">readObject</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스트림로부터 읽힌 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 오브젝트의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/InvalidClassException.html" title="java.io 안의 클래스">InvalidClassException</A> </CODE> - 직렬화로 사용되는 클래스에 하등의 불편이 있었을 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 원시적 데이터가, 오브젝트는 아니고 스트림에 발견되었을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력에 관련한 예외의 어떤 것인가가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readObjectOverride()"><!-- --></A> <H3>
readObjectOverride</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readObjectOverride</B>()
                             throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                    <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>인수 없음의 protected 생성자를 사용해 ObjectOutputStream를
 작성한 ObjectOutputStream
 신뢰할 수 있는 서브 클래스에
해 불려 갑니다. 서브 클래스는
 수식자가 final
 오버라이드(override) 메서드를 제공한다고 보여집니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>스트림로부터 읽힌 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 오브젝트의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 원시적 데이터가, 오브젝트는 아니고 스트림에 발견되었을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 스트림의 read중에 입출력 에러가 발생했을 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectInputStream.html#ObjectInputStream()"><CODE>ObjectInputStream()</CODE></A>,
 
<A HREF="../../java/io/ObjectInputStream.html#readObject()"><CODE>readObject()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="readUnshared()"><!-- --></A> <H3>
readUnshared</H3>
<PRE>
public <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>readUnshared</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                           <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>ObjectInputStream 로부터 「공유되지 않는다」오브젝트를 읽어들입니다. 이 메서드는
 readObject 와 닮아 있습니다. 다만, readObject 및 readUnshared를
 호출해, 이 호출이 취득한 직렬화 복원된 인스턴스에 대한 참조를 돌려줄 수 없습니다. 예를 들어, 다음과 같은 참조는 할 수 없습니다. <ul> <li>readUnshared를
 호출해 역참조 (스트림에 기입해진 오브젝트의 스트림 표현)를 직렬화 복원하려고 하면, ObjectStreamException 가 Throw 된다
<li>readUnshared 가 정상적으로 복귀한 다음에
 readUnshared 가 직렬화 복원한 스트림 핸들에의 역참조를 직렬화 복원하려고 하면, ObjectStreamException 가 Throw 된다
</ul>
 readUnshared를
 호출해 오브젝트를 직렬화 복원하면, 돌려주고지는 오브젝트에 관련지을 수 있었던 스트림 핸들이 무효가 됩니다. 다만, readUnshared 로부터 돌려주고지는 참조가 일의이다고는 할 수 없습니다. 직렬화 복원된 오브젝트에 readResolve 메서드가 정의되고 있었을 경우, 공유되고 있는 오브젝트가 돌려주고지는 일이 있습니다. 또, 그 스트림외의 장소나 외부로부터 취득한 Class 오브젝트 또는 enum 정수를 돌려주는 일도 있습니다.

<p>다만, 복원된 오브젝트가 enum 정수 또는 java.lang.Class
 인스턴스는 아니고, readResolve 메서드를 정의하고 있지 않는 경우, readUnshared 로부터 돌려주고지는 오브젝트 참조는 항상 일의입니다. 바탕으로 되는 데이터 스트림이 조작되고 있는 경우에서도, 그것을 작성한 ObjectInputStream 로부터 오브젝트 참조를 재차 취득할 수 없습니다. 이 규칙은, readUnshared 로부터 돌려주고진 베이스 레벨의 오브젝트인 만큼 적용되어 돌려주고진 오브젝트 그래프내에서 참조되는 서브 오브젝트에는 적용되지 않습니다.

<p>이 메서드를 오버라이드(override) 하는 ObjectInputStream 서브 클래스는
 SerializablePermission("enableSubclassImplementation")를 가지는 시큐러티 컨텍스트
내에서만 구축할 수 있습니다. 이 액세스권을 가지지 않는 시큐러티 컨텍스트
으로 인스턴스화하려고 하면, SecurityException 가 Throw 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 복원 오브젝트에의 참조
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 복원하는 오브젝트의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우
<DD><CODE><A HREF="../../java/io/ObjectStreamException.html" title="java.io 안의 클래스">ObjectStreamException</A> </CODE> - 직렬화 복원하는 오브젝트가 벌써 스트림내에 있었을 경우
<DD><CODE><A HREF="../../java/io/OptionalDataException.html" title="java.io 안의 클래스">OptionalDataException</A> </CODE> - 스트림내의 다음의 데이터가 원시적의 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 직렬화 복원중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="defaultReadObject()"><!-- --></A> <H3>
defaultReadObject</H3>
<PRE>
public void <B>defaultReadObject</B>()
                       throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                              <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>현재의 클래스의 비 static 및 비 transient
 필드를, 이 스트림로부터 읽어들입니다. 이 메서드를 호출할 수가 있는 것은, 직렬화가 복원되고 있는 클래스의 readObject 메서드 뿐입니다. 다른 방법으로 불려 갔을 경우는 NotActiveException를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 오브젝트의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 오브젝트를 읽어들이지 않은 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFields()"><!-- --></A> <H3>
readFields</H3>
<PRE>
public <A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스">ObjectInputStream.GetField</A>  <B>readFields</B>()
                                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                             <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>스트림로부터 지속 필드를 읽어들여, 그것들을 이름을 지정해 액세스 할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>직렬화 복원되고 있는 오브젝트의 지속 필드를 나타내는 <code>GetField</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 오브젝트의 클래스가 발견되지 않았던 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 오브젝트를 읽어들이지 않은 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="registerValidation(java.io.ObjectInputValidation, int)"><!-- --></A> <H3>
registerValidation</H3>
<PRE>
public void <B>registerValidation</B>(<A HREF="../../java/io/ObjectInputValidation.html" title="java.io 안의 인터페이스">ObjectInputValidation</A> &nbsp;obj,
                               int&nbsp;prio)
                        throws <A HREF="../../java/io/NotActiveException.html" title="java.io 내의 클래스">NotActiveException</A>,

                               <A HREF="../../java/io/InvalidObjectException.html" title="java.io 안의 클래스">InvalidObjectException</A> </PRE>
<DL>
<DD>오브젝트 그래프가 돌려주고지기 전에 검증되어야 할 오브젝트를 등록합니다. 이 검증은, resolveObject를
 닮아 있습니다만, 오브젝트 그래프 전체가 재구축 된 뒤에 불려 가는 점이 다릅니다. 보통
, readObject 메서드는
 스트림과 함께 오브젝트를 등록해, 거기에 따라 오브젝트의 모든 것이 복원되었을 때에 최종적인 검증을 실행할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 검증의 콜백을 받는 오브젝트<DD><CODE>prio</CODE> - 콜백의 순서를 제어하는 값. 0 이 적절한 디폴트치이다. 빨리 콜백 하는 경우는 큰 번호를, 나중에 콜백 하는 경우는 작은 번호를 사용한다. 같은 우선 순위내에서는
 콜백의 처리에 특별한 순서는 없다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/NotActiveException.html" title="java.io 안의 클래스">NotActiveException</A> </CODE> - 스트림이 현재 오브젝트를 읽어들이지 않기 때문에
 콜백을 등록할 수 없는 경우
<DD><CODE><A HREF="../../java/io/InvalidObjectException.html" title="java.io 안의 클래스">InvalidObjectException</A> </CODE> - 검증 오브젝트가 null
 경우</DL>
</DD>
</DL>
<HR>

<A NAME="resolveClass(java.io.ObjectStreamClass)"><!-- --></A> <H3>
resolveClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>resolveClass</B>(<A HREF="../../java/io/ObjectStreamClass.html" title="java.io 안의 클래스">ObjectStreamClass</A> &nbsp;desc)
                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>지정된 스트림 클래스의 기술에 대응하는 로컬 클래스를 로드합니다. 서브 클래스는
 이 메서드를 구현해, 대체 소스로부터 클래스를 취득합니다.

<p><code>ObjectOutputStream</code>
 대응하는 메서드는 <code>annotateClass</code> 입니다. 이 메서드는
 스트림의 일의의 클래스 각각 붙어 1 회만 불려 갑니다. 이 메서드는
 대체의 로드 도구
를 사용하기 위해서 구현할 수가 있습니다만,<code>Class</code> 오브젝트를 돌려줄 필요가 있습니다. 클래스 오브젝트가 돌려주고지면, 그 클래스의 serialVersionUID 가, 직렬화 된 클래스의 serialVersionUID 라고 비교됩니다. 불일치가 있으면, 직렬화 복원에 불편이 발생해, 예외가 불려 갑니다.

<p>디폴트에서는
 클래스명은,<code>readObject</code>를
 호출한 클래스와 대응 붙여 해결됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>desc</CODE> - <code>ObjectStreamClass</code> 클래스의 인스턴스
<DT><B>반환값:</B><DD><code>desc</code> 에 대응하는 <code>Class</code> 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 보통
의 입출력 관련의 예외가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 직렬화 된 오브젝트가 발견되지 않았던 경우</DL>
</DD>
</DL>
<HR>

<A NAME="resolveProxyClass(java.lang.String[])"><!-- --></A> <H3>
resolveProxyClass</H3>
<PRE>
protected <A HREF="../../java/lang/Class.html" title="java.lang 내의 클래스">Class</A> &lt;? &gt; <B>resolveProxyClass</B>(<A HREF="../../java/lang/String.html" title="java.lang 안의 클래스">String</A> []&nbsp;interfaces)
                              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                     <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>프록시 클래스 기술자로 지정된 인터페이스를 구현하는 프록시 클래스를 돌려줍니다. 서브 클래스는 이 메서드를 구현해 다이나믹 프록시 클래스의 기술자와 함께 스트림로부터 커스텀 데이터를 읽어들여, 인터페이스나 프록시 클래스의 대체 로딩 도구
를 사용할 수 있도록 합니다.

<p>이 메서드는 스트림의 일의의 각 프록시 클래스 기술자에 대해 1 회만 불려 갑니다.

<p><code>ObjectOutputStream</code> 에서의 대응하는 메서드는 <code>annotateProxyClass</code> 입니다. 이 메서드를 오버라이드(override) 하는 지정된 서브 클래스 <code>ObjectInputStream</code> 에 대해서,<code>ObjectOutputStream</code>
 대응하는 서브 클래스에 있는 <code>annotateProxyClass</code> 메서드는 이 메서드가 읽어들이는 임의의 데이터 또는 오브젝트를 기입할 필요가 있습니다.

<p><code>ObjectInputStream</code> 에 있는 이 메서드의 디폴트 구현은,<code>interfaces</code> 파라미터로 지정된 인터페이스의 <code>Class</code> 오브젝트의 리스트와 함께 <code>Proxy.getProxyClass</code>
 호출 결과를 돌려줍니다. 각 인터페이스명 <code>i</code>
 <code>Class</code> 오브젝트가 돌려주고집니다.
 
 <pre>

     Class.forName(i, false, loader)
 </pre>
여기서 <code>loader</code>는

 실행 스택까지의 최초의 <code>null</code> 가 아닌 클래스, 또는 <code>null</code> 가 아닌 클래스 로더가 스택측 (<code>resolveClass</code> 메서드가 사용하는 같은 클래스 로더의 선택)에 없는 경우는 <code>null</code> 입니다. 해결된 인터페이스가 public 가 아닌 경우는
 같은 값의 <code>loader</code> 가 <code>Proxy.getProxyClass</code> 에게 건네집니다. public 가 아닌 인터페이스가 있는 경우는
 그 클래스 로더가 건네받습니다 (public 가 아닌 인터페이스의 클래스 로더가 복수 검출되었을 경우는
<code>IllegalAccessError</code> 가 Throw 된다). <code>Proxy.getProxyClass</code> 가 <code>IllegalArgumentException</code>를
 Throw 하면,<code>resolveProxyClass</code>는
 <code>IllegalArgumentException</code> 와 함께 <code>ClassNotFoundException</code>를
 Throw 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>interfaces</CODE> - 프록시 클래스 기술자에게 직렬화 복원된 인터페이스명의 리스트
<DT><B>반환값:</B><DD>지정된 인터페이스의 프록시 클래스
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code> 에 예외가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 프록시 클래스 또는 지정된 인터페이스가 어느 것도 발견되지 않았던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#annotateProxyClass(java.lang.Class)"><CODE>ObjectOutputStream.annotateProxyClass(Class)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="resolveObject(java.lang.Object)"><!-- --></A> <H3>
resolveObject</H3>
<PRE>
protected <A HREF="../../java/lang/Object.html" title="java.lang 내의 클래스">Object</A>  <B>resolveObject</B>(<A HREF="../../java/lang/Object.html" title="java.lang 안의 클래스">Object</A> &nbsp;obj)
                        throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>직렬화 복원 시에
 ObjectInputStream
 신뢰할 수 있는 서브 클래스가, 어느 오브젝트를 다른 오브젝트에 치환할 수 있도록 합니다. 오브젝트의 치환은, enableResolveObject 가 불려 갈 때까지는 실시할 수 없습니다. enableResolveObject 메서드는
 오브젝트의 해석 처리를 요구하고 있는 스트림을 신뢰할 수 있을지 어떨지를 조사합니다. 직렬화 가능 오브젝트에의 모든 참조는
 resolveObject 에게 건네집니다. 오브젝트의 private 인 상태가
도하지 않고 누설 하는 것이 없게, resolveObject를
 사용하는 것은 신뢰할 수 있는 스트림로 한정됩니다.

<p>이 메서드는
 오브젝트가 읽힌 뒤, readObject 로부터 복귀하기 전에 불려 갑니다. 디폴트의 resolveObject 메서드는
 같은 오브젝트만을 돌려줍니다.

<p>서브 클래스는
 오브젝트를 치환할 때, 치환된 오브젝트와 참조가 포함되는 각 필드와의 호환성을 보증할 필요가 있습니다. 필드 또는 배열 요소의 형태의 서브 클래스가 아닌 형태의 오브젝트는
 예외를 발생시키는 것에
해 직렬화를 중단해, 그 결과 오브젝트는 포함되지 않습니다.

<p>이 메서드는
 각 오브젝트가 최초로 검출되었을 때에 1 회만 불려 갑니다. 이것 이후 검출되는 그 오브젝트에의 참조는
 새로운 오브젝트에 리디렉트 됩니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>obj</CODE> - 치환되는 오브젝트
<DT><B>반환값:</B><DD>치환된 오브젝트
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 보통
의 입출력 관련의 예외가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="enableResolveObject(boolean)"><!-- --></A> <H3>
enableResolveObject</H3>
<PRE>
protected boolean <B>enableResolveObject</B>(boolean&nbsp;enable)
                               throws <A HREF="../../java/lang/SecurityException.html" title="java.lang 내의 클래스">SecurityException</A> </PRE>
<DL>
<DD>스트림로부터 읽힌 오브젝트가 치환됩니다. 유효하게 하면, 오브젝트가 직렬화 복원될 때, 항상 resolveObject 메서드가 불려 갑니다.

<p><i>enable</i> 가 true 로 시큐러티 매니저가 인스톨 되고 있는 경우, 이 메서드는 우선 시큐러티 매니저의 <code>checkPermission</code> 메서드를 액세스권 <code>SerializablePermission("enableSubstitution")</code> 로 호출해, 스트림로부터 읽힌 오브젝트의 치환을 스트림을 허가할 수 있도록 합니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>enable</CODE> - 직렬화 복원되는 각 오브젝트에 대해 <code>resolveObject</code>
 사용을 유효하게 하는 경우는 true
<DT><B>반환값:</B><DD>이 메서드가 불려 가기 전의 설정
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/lang/SecurityException.html" title="java.lang 안의 클래스">SecurityException</A> </CODE> - 시큐러티 매니저가 존재해, 그 <code>checkPermission</code> 메서드가, 스트림로부터 읽힌 오브젝트의 치환을 스트림을 허가할 수 있도록 하는 것을 거부하는 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/lang/SecurityManager.html#checkPermission(java.security.Permission)"><CODE>SecurityManager.checkPermission(java.security.Permission)</CODE></A>,
 
<A HREF="../../java/io/SerializablePermission.html" title="java.io 안의 클래스"><CODE>SerializablePermission</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="readStreamHeader()"><!-- --></A> <H3>
readStreamHeader</H3>
<PRE>
protected void <B>readStreamHeader</B>()
                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                <A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </PRE>
<DL>
<DD>서브 클래스가 자신의 스트림 헤더의 read와 검증을 실시할 수 있도록 하기 위해서 제공되고 있습니다. 이 메서드는
 매직 번호와 버젼 번호를 읽어들입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code>
 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/StreamCorruptedException.html" title="java.io 안의 클래스">StreamCorruptedException</A> </CODE> - 스트림의 제어 정보에 일관성이 없는 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readClassDescriptor()"><!-- --></A> <H3>
readClassDescriptor</H3>
<PRE>
protected <A HREF="../../java/io/ObjectStreamClass.html" title="java.io 내의 클래스">ObjectStreamClass</A>  <B>readClassDescriptor</B>()
                                         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A>,

                                                <A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </PRE>
<DL>
<DD>직렬화 스트림로부터 클래스 기술자를 읽어들입니다. 이 메서드는
 ObjectInputStream 가 직렬화 스트림의 다음의 아이템으로서 클래스 기술자를 요구하면 불려 갑니다. ObjectInputStream
 서브 클래스는
 이 메서드를 오버라이드(override) 해 표준이 아닌 형식에서 (<code>writeClassDescriptor</code> 메서드를 오버라이드(override) 한 ObjectOutputStream
 서브 클래스에
해) 기입해진 클래스 기술자에게 읽어들입니다. 디폴트에서는
 이 메서드는 클래스 기술자를 오브젝트 직렬화 사양에 정의된 형식에서 읽어들입니다.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽힌 클래스 기술자
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/lang/ClassNotFoundException.html" title="java.lang 안의 클래스">ClassNotFoundException</A> </CODE> - 클래스 기술자 표현에 사용한 직렬화 된 오브젝트의 클래스가 발견되지 않았던 경우<DT><B>도입된 버젼:</B></DT>
  <DD>1.3</DD>
<DT><B>관련 항목:</B><DD><A HREF="../../java/io/ObjectOutputStream.html#writeClassDescriptor(java.io.ObjectStreamClass)"><CODE>ObjectOutputStream.writeClassDescriptor(java.io.ObjectStreamClass)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="read()"><!-- --></A> <H3>
read</H3>
<PRE>
public int <B>read</B>()
         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>데이터의 바이트를 읽어들입니다. 이 메서드는
 유효한 입력이 아직 없는 경우는 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#read()">read</A> </CODE><DT><B>정의:</B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#read()">read</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽힌 바이트. 스트림의 마지막에 이르렀을 경우는 -1
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="read(byte[], int, int)"><!-- --></A> <H3>
read</H3>
<PRE>
public int <B>read</B>(byte[]&nbsp;buf,
                int&nbsp;off,
                int&nbsp;len)
         throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트의 배열에 읽어들입니다. 이 메서드는
 입력을 할 수 있게 될 때까지 블록 합니다. 바이트의 길이를 정확하게 읽어들이려면,
 java.io.DataInputStream.readFully를
 사용해 주세요.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#read(byte[], int, int)">read</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#read(byte[], int, int)">read</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 독해처의 버퍼<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 읽히는 최대 바이트수
<DT><B>반환값:</B><DD>읽히는 바이트의 실제의 수. 스트림의 마지막에 이르렀을 경우는 -1
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우<DT><B>관련 항목:</B><DD><A HREF="../../java/io/DataInputStream.html#readFully(byte[], int, int)"><CODE>DataInputStream.readFully(byte[], int, int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="available()"><!-- --></A> <H3>
available</H3>
<PRE>
public int <B>available</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>블록 하지 않고 읽어들일 수가 있는 바이트수를 돌려줍니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#available()">available</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#available()">available</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽어들여 가능한 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code>
 read중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="close()"><!-- --></A> <H3>
close</H3>
<PRE>
public void <B>close</B>()
           throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>입력 스트림을 닫습니다. 스트림에 관련된 모든 자원을 해방하기 위해서 호출할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/Closeable.html" title="java.io 내의 인터페이스">Closeable</A> </CODE> 내의 <CODE><A HREF="../../java/io/Closeable.html#close()">close</A> </CODE><DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스">ObjectInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/ObjectInput.html#close()">close</A> </CODE><DT><B>오버라이드(override): </B><DD>클래스 <CODE><A HREF="../../java/io/InputStream.html" title="java.io 내의 클래스">InputStream</A> </CODE> 내의 <CODE><A HREF="../../java/io/InputStream.html#close()">close</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readBoolean()"><!-- --></A> <H3>
readBoolean</H3>
<PRE>
public boolean <B>readBoolean</B>()
                    throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>boolean를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readBoolean()">readBoolean</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readByte()"><!-- --></A> <H3>
readByte</H3>
<PRE>
public byte <B>readByte</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>8 비트의 바이트를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readByte()">readByte</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 8 비트의 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedByte()"><!-- --></A> <H3>
readUnsignedByte</H3>
<PRE>
public int <B>readUnsignedByte</B>()
                     throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>부호 없음 8 비트 바이트를 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUnsignedByte()">readUnsignedByte</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 8 비트의 바이트치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readChar()"><!-- --></A> <H3>
readChar</H3>
<PRE>
public char <B>readChar</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 char를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readChar()">readChar</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 char 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readShort()"><!-- --></A> <H3>
readShort</H3>
<PRE>
public short <B>readShort</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>16 비트의 short를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readShort()">readShort</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUnsignedShort()"><!-- --></A> <H3>
readUnsignedShort</H3>
<PRE>
public int <B>readUnsignedShort</B>()
                      throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>부호 없음 16 비트의 short를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUnsignedShort()">readUnsignedShort</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 16 비트의 short 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readInt()"><!-- --></A> <H3>
readInt</H3>
<PRE>
public int <B>readInt</B>()
            throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 int를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readInt()">readInt</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 32 비트의 int 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readLong()"><!-- --></A> <H3>
readLong</H3>
<PRE>
public long <B>readLong</B>()
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 long를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readLong()">readLong</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 64 비트의 long 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFloat()"><!-- --></A> <H3>
readFloat</H3>
<PRE>
public float <B>readFloat</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>32 비트의 float를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFloat()">readFloat</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 32 비트의 float 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readDouble()"><!-- --></A> <H3>
readDouble</H3>
<PRE>
public double <B>readDouble</B>()
                  throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>64 비트의 double를
 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readDouble()">readDouble</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>읽히는 64 비트의 double 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[])"><!-- --></A> <H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;buf)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 읽어들입니다. 모든 바이트가 읽힐 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFully(byte[])">readFully</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 독해처의 버퍼
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readFully(byte[], int, int)"><!-- --></A> <H3>
readFully</H3>
<PRE>
public void <B>readFully</B>(byte[]&nbsp;buf,
                      int&nbsp;off,
                      int&nbsp;len)
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 읽어들입니다. 모든 바이트가 읽힐 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readFully(byte[], int, int)">readFully</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>buf</CODE> - 데이터의 독해처의 버퍼<DD><CODE>off</CODE> - 데이터의 개시 오프셋(offset)<DD><CODE>len</CODE> - 읽어들이는 최대 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="skipBytes(int)"><!-- --></A> <H3>
skipBytes</H3>
<PRE>
public int <B>skipBytes</B>(int&nbsp;len)
              throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD>바이트를 스킵 합니다. 모든 바이트가 스킵 될 때까지 블록 합니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#skipBytes(int)">skipBytes</A> </CODE></DL>
</DD>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>len</CODE> - 스킵 하는 바이트수
<DT><B>반환값:</B><DD>실제로 스킵 된 바이트수
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/EOFException.html" title="java.io 안의 클래스">EOFException</A> </CODE> - 파일의 마지막에 이르렀을 경우
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 다른 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readLine()"><!-- --></A> <H3>
readLine</H3>
<PRE>
<FONT SIZE="-1"><A HREF="../../java/lang/Deprecated.html" title="java.lang 안의 주석">@Deprecated</A> 
</FONT>public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>readLine</B>()
                throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><B>추천하지 않습니다
. </B>&nbsp;<I>이 메서드는 바이트를 정확하게 문자로 변환하지 않습니다. 상세 및 대체 메서드에 대해서는 DataInputStream를
 참조하십시오. </I>
<P>
<DD>\n, \r, \r\n, 또는 EOF 로 종료하는 행을 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readLine()">readLine</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>행의 캐릭터 라인의 카피
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code>
 read중에 입출력 에러가 발생했을 경우</DL>
</DD>
</DL>
<HR>

<A NAME="readUTF()"><!-- --></A> <H3>
readUTF</H3>
<PRE>
public <A HREF="../../java/lang/String.html" title="java.lang 내의 클래스">String</A>  <B>readUTF</B>()
               throws <A HREF="../../java/io/IOException.html" title="java.io 내의 클래스">IOException</A> </PRE>
<DL>
<DD><a href="DataInput.html#modified-utf-8">수정 UTF-8</a>  형식의 캐릭터 라인을 읽어들입니다.
<P>
<DD><DL>
<DT><B>정의:</B><DD>인터페이스 <CODE><A HREF="../../java/io/DataInput.html" title="java.io 내의 인터페이스">DataInput</A> </CODE> 내의 <CODE><A HREF="../../java/io/DataInput.html#readUTF()">readUTF</A> </CODE></DL>
</DD>
<DD><DL>

<DT><B>반환값:</B><DD>캐릭터 라인
<DT><B>예외:</B>
<DD><CODE><A HREF="../../java/io/IOException.html" title="java.io 안의 클래스">IOException</A> </CODE> - 기본이 되는 <code>InputStream</code>
 read중에 입출력 에러가 발생했을 경우
<DD><CODE><A HREF="../../java/io/UTFDataFormatException.html" title="java.io 안의 클래스">UTFDataFormatException</A> </CODE> - 캐릭터 라인중의 read 바이트가, 유효한 수정 UTF-8 형식에서 encode 된 캐릭터 라인 이외에서 만났을 경우</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/ObjectInputStream.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../java/io/ObjectInput.html" title="java.io 내의 인터페이스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../java/io/ObjectInputStream.GetField.html" title="java.io 내의 클래스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../index.html?java/io/ObjectInputStream.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="ObjectInputStream.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;<A HREF="#nested_class_summary">상자</a>&nbsp;|&nbsp;필드&nbsp;|&nbsp;<A HREF="#constructor_summary">constructor</A> &nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;필드 &nbsp;|&nbsp;<A HREF="#constructor_detail">생성자</A> &nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0) on Mon Nov 15 12:21:25 JST 2004 -->
<META http-equiv="Content-Type" content="text/html; charset=euc-kr">
<TITLE>
GSSContext (Java 2 Platform SE 5.0)</TITLE>

<META NAME="keywords" CONTENT="org.ietf.jgss.GSSContext interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GSSContext (Java 2 Platform SE 5.0)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A> 
<A HREF="#skip-navbar_top" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A> 
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.ietf.jgss</FONT>
<BR>
인터페이스 GSSContext</H2>
<HR>
<DL>
<DT><PRE>public interface <B>GSSContext</B></DL>
</PRE>

<P>
이 인터페이스는
 GSS-API
 시큐러티 컨텍스트
을 캡슐화해, 그 컨텍스트
으로 이용할 수 있는 시큐러티 서비스를 제공합니다. 시큐러티 컨텍스트
은, 로컬에 취득한 자격을 사용해 피어간에 확립됩니다. 1 조의 피어간에는
 같은 자격 또는 다른 자격을 사용하는 복수의 컨텍스트
이 동시에 존재하는 경우가 있습니다. GSS-API는

 피어간의 시큐러티 컨텍스트
에
해 생성되는 토큰을 전송 할 경우에
 부하의 전송 프로토콜에는
존하지 않고, 그 호출측 어플리케이션에
존합니다. <p>
호출측이 디폴트의 <code>GSSManager</code> 인스턴스를 사용해 컨텍스트
을 인스턴스화하는 경우는
 Kerberos v5 GSS-API 도구
를 사용해 컨텍스트
이 확립됩니다. 이 도구
는
 OID 「1.2. 840.113554. 1.2. 2」(으)로서 식별되어 RFC 1964 에 정의되고 있습니다. <p>
컨텍스트
의 확립 처리가 개시되기 전에
 확립되는 컨텍스트
의 특성을 시작측이 요구하는 경우가 있습니다. 호출측이 요구한 특성이, 부하의 도구
에
해 서포트되어 있지 않은 것이 있습니다. 컨텍스트
이 확립하면, 호출측은 다양한 쿠에리 메서드를 사용해, 그 컨텍스트
으로부터 제공된 실제의 특성이나 서비스를 확인할 수 있습니다. 디폴트의 <code>GSSManager</code> 인스턴스로부터 제공되는 Kerberos v5 GSS-API 도구
를 사용하고 있을 때는
 모든 옵션 서비스를 로컬에 이용할 수 있습니다. 예를 들어, 상호 인증, 자격의 위양, 기밀성과 정합성의 보호, 메세지마다의 리플레이 검출이나 순서부등을 이용할 수 있습니다. GSS-API 에서는
 메세지의 기밀성을 보호하려면,
 메세지의 정합성을 보호할 필요가 있습니다. <p>
컨텍스트
이 확립할 때까지, 시작 측에
한 <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>  호출과 받아 들이는 쪽에
한 <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A>  호출이 반복해집니다. 이 루프는
 컨텍스트
이 확립하면 종료합니다. 이 루프의 처리중에
<code>initSecContext</code> 및 <code>acceptSecContext</code> 메서드가 토큰을 생성해, 어플리케이션은 그 토큰을 피어에 송신합니다. 피어는
<code>acceptSecContext</code> 또는 <code>initSecContext</code> 에 대해서 적절한 토큰을 입력으로서 건네줍니다. <p>
컨텍스트
이 완전하게 확립하기 전에서도,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  메서드를 호출해,<A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  및 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>  에
한 메세지마다의 조작에 컨텍스트
을 사용할 수 있을지 어떨지를 확인할 수 있습니다. 이 방법을 사용하면, 완전하게 확립되기 전의 컨텍스트
에 대해서 메세지마다의 조작을 사용할 수 있습니다. <p>
컨텍스트
의 확립이 완료한 후, 즉 <code>isProtReady</code> 메서드로부터 <code>true</code> 가 돌려주고진 후에는
 확립된 컨텍스트
의 실제의 특성이나 서비스를 확인하기 위해서 쿠에리 루틴을 호출할 수 있습니다. 또,<A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  및 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A> 
 메세지마다의 메서드를 사용해, 어플리케이션이 제공하는 데이터에 대해서 암호화 조작을 실시할 수도 있습니다. <p>
컨텍스트
이 불필요하게 되면,<A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()"><CODE>dispose</CODE></A> 를
 호출해, 그 컨텍스트
이 사용하고 있는 시스템 자원을 모두 해방할 필요가 있습니다. <p>
시큐러티 컨텍스트
은 보통
, 처리하는 토큰에 관한 순서부와 리플레이 검출 정보를 보관 유지하고 있습니다. 이 때문에
 토큰이 이 컨텍스트
에게 건네져 처리되는 순서가 중요하게 됩니다. 또, 이 인터페이스내의 메서드는 동기화 되지 않습니다. 복수의 thread간에 <code>GSSContext</code>를
 공유할 때는
 하등의 어플리케이션 레벨의 동기화를 실시할 필요가 있습니다. <p>
GSS-API 컨텍스트
을 사용할 때의 시큐러티 제한은, GSS-API 도구
 프로바이더에 따라서 다릅니다. 이러한 제한에 대해서는
 각 도구
 프로바이더의 문서를 참조하십시오. 이러한 시큐러티 제한을 도구
층에서 검사하는 경우는
 어플리케이션에 적절한 권한이 부여되고 있을 필요가 있습니다. <p>
다음에 나타내는 코드예는
 시작측 피어의 <code>GSSContext</code> 인터페이스의 사용법을 나타내고 있습니다. <code>GSSContext</code> 오브젝트에 대해서, 오브젝트의 인스턴스화, 지정하고 싶은 플래그의 설정, 컨텍스트
의 확립, 실제의 컨텍스트
 플래그의 조회, 어플리케이션 데이터에 대한 메세지마다의 조작, 컨텍스트
의 최종 검출등을 실시하고 있습니다. <p>

 
 <pre>

    // Create a context using default credentials 
    // and the implementation specific default mechanism
    GSSManager manager ...
    GSSName targetName ...
    GSSContext context = manager.createContext(targetName, null, null,
                                           GSSContext.INDEFINITE_LIFETIME);
 
    // set desired context options prior to context establishment
    context.requestConf(true);
    context.requestMutualAuth(true);
    context.requestReplayDet(true);
    context.requestSequenceDet(true);
    
    // establish a context between peers

    byte []inToken = new byte[0];

    // Loop while there still is a token to be processed

    while (! context.isEstablished()) {

        byte[] outToken 
            = context.initSecContext(inToken, 0, inToken.length);
        
        // send the output token if generated
        if (outToken ! = null)
            sendToken(outToken);
  
        if (! context.isEstablished()) {
            inToken = readToken();
    }
    
     // display context information
     System.out.println("Remaining lifetime in seconds = " 
                                          + context.getLifetime());
     System.out.println("Context mechanism = " + context.getMech());
     System.out.println("Initiator = " + context.getSrcName());
     System.out.println("Acceptor = " + context.getTargName());
  
     if (context.getConfState())
             System.out.println("Confidentiality (i.e., privacy) is available");
  
     if (context.getIntegState())
             System.out.println("Integrity is available");
  
     // perform wrap on an application supplied message, appMsg,
     // using QOP = 0, and requesting privacy service
     byte [] appMsg ...
  
     MessageProp mProp = new MessageProp(0, true);
  
     byte []tok = context.wrap(appMsg, 0, appMsg.length, mProp);
  
     sendToken(tok);
  
     // release the local-end of the context
     context.dispose();

 </pre>
<P>

<P>
<DL>
<DT><B>도입된 버젼:</B></DT>
  <DD>1.4</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>필드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#DEFAULT_LIFETIME">DEFAULT_LIFETIME</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 디폴트의 수명을 나타내는 수명 정수입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#INDEFINITE_LIFETIME">INDEFINITE_LIFETIME</A> </B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 수명이 무기한인 것을 나타내는 수명 정수입니다. </TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>메서드 개요</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)">acceptSecContext</A> </B>(byte[]&nbsp;inToken,
                 int&nbsp;offset,
                 int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;피어로부터 토큰이 착신했을 때에
 컨텍스트
의 받아 들이는 쪽에
해 불려 갑니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(java.io.InputStream, java.io.OutputStream)">acceptSecContext</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                 <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 받아 들이는 쪽에
해 불려 가는 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#dispose()">dispose</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
 오브젝트에 포함되고 있는 시스템 자원과 암호화 정보를 모두 해방해, 그 컨텍스트
을 무효로 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#export()">export</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
을 export 해, 다른 프로세스를 임포트 할 수 있도록 합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()">getAnonymityState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 시작측이 컨텍스트
의 받아 들이는 쪽에 익명으로서 인증되고 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()">getConfState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
으로 데이터의 기밀성을 이용할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()">getCredDelegState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
으로 자격의 위양이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스">GSSCredential</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getDelegCred()">getDelegCred</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 시작측으로부터 컨텍스트
의 받아 들이는 쪽에 위양 된 자격을 취득합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()">getIntegState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
으로 데이터의 정합성을 이용할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()">getLifetime</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
의 나머지의 수명을 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/Oid.html" title="org.ietf.jgss 내의 클래스">Oid</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMech()">getMech</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
에 사용되고 있는 도구
를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)">getMIC</A> </B>(byte[]&nbsp;inMsg,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;지정된 메세지의 암호화 MIC (메세지 정합성 코드)를 포함한 토큰을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">getMIC</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 지정된 메세지의 암호화 MIC를
 포함한 토큰을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()">getMutualAuthState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
으로 상호 인증이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()">getReplayDetState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
의 메세지마다의 시큐러티 서비스로 리플레이 검출이 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()">getSequenceDetState</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
의 메세지마다의 시큐러티 서비스로 sequence check가 유효하게 되어 있는지 어떤지를 판정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스">GSSName</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getSrcName()">getSrcName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 시작측의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스">GSSName</A> </CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getTargName()">getTargName</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 받아 들이는 쪽의 이름을 돌려줍니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#getWrapSizeLimit(int, boolean, int)">getWrapSizeLimit</A> </B>(int&nbsp;qop,
                 boolean&nbsp;confReq,
                 int&nbsp;maxTokenSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 에 건네줄 수가 있는 메세지 사이즈의 제한을 결정할 때 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)">initSecContext</A> </B>(byte[]&nbsp;inputBuf,
               int&nbsp;offset,
               int&nbsp;len)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 시작 측에야는 불려 가는 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(java.io.InputStream, java.io.OutputStream)">initSecContext</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
               <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 시작 측에야는 불려 가는 메서드입니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()">isEstablished</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
을 확립하기 전에
 컨텍스트
 상태를 확인할 경우에 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isInitiator()">isInitiator</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 피어가 컨텍스트
의 시작측일지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()">isProtReady</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;이 컨텍스트
으로 메세지마다의 조작을 곧바로 개시할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()">isTransferable</A> </B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A>  메서드를 사용해 이 컨텍스트
을 다른 프로세스에 전송 할 수 있을지 어떨지를 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)">requestAnonymity</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;시작측의 자격을 받아 들이는 쪽에 공개하지 않게 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)">requestConf</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 메서드로 데이터의 기밀성을 유효하게 하도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)">requestCredDeleg</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 확립 시에 시작측의 자격을 받아 들이는 쪽에 위양 하도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)">requestInteg</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>wrap</code> 메서드와 <code>getMIC</code> 메서드로 데이터의 정합성을 유효하게 하도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)">requestLifetime</A> </B>(int&nbsp;lifetime)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 수명을 초단위로 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)">requestMutualAuth</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
이 확립해 있을 때, 상호 인증을 하도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)">requestReplayDet</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
이 확립한 후에
 메세지마다의 시큐러티 서비스의 리플레이 검출이 유효하게 되도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)">requestSequenceDet</A> </B>(boolean&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
이 확립한 후에
 메세지마다의 시큐러티 서비스의 sequence check가 유효하게 되도록 요구합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#setChannelBinding(org.ietf.jgss.ChannelBinding)">setChannelBinding</A> </B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 안의 클래스">ChannelBinding</A> &nbsp;cb)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
이 확립해 있을 때 채널 바인딩이 사용되도록 설정합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)">unwrap</A> </B>(byte[]&nbsp;inBuf,
       int&nbsp;offset,
       int&nbsp;len,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;컨텍스트
의 상대측의 피어로 <code>wrap</code> 메서드에
해 생성된 토큰을 처리하기 위해서 사용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">unwrap</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
       <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
       <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 컨텍스트
의 상대측의 피어로 <code>wrap</code> 메서드에
해 생성된 토큰을 처리합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)">verifyMIC</A> </B>(byte[]&nbsp;inToken,
          int&nbsp;tokOffset,
          int&nbsp;tokLen,
          byte[]&nbsp;inMsg,
          int&nbsp;msgOffset,
          int&nbsp;msgLen,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;토큰 파라미터에 포함되는 암호화 MIC를
, 지정된 메세지에 대해서 검사합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)">verifyMIC</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;tokStream,
          <A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;msgStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 토큰 파라미터에 포함되는 지정된 메세지의 암호화 MIC를
 검증합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)">wrap</A> </B>(byte[]&nbsp;inBuf,
     int&nbsp;offset,
     int&nbsp;len,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;확립된 시큐러티 컨텍스트
에 대해서 메세지마다의 시큐러티 서비스를 적용합니다. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)">wrap</A> </B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
     <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
     <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;스트림을 사용해, 확립된 시큐러티 컨텍스트
에 메세지마다의 시큐러티 서비스를 적용합니다. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>필드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="DEFAULT_LIFETIME"><!-- --></A> <H3>
DEFAULT_LIFETIME</H3>
<PRE>
static final int <B>DEFAULT_LIFETIME</B></PRE>
<DL>
<DD>컨텍스트
의 디폴트의 수명을 나타내는 수명 정수입니다. 이 값은 0 으로 설정됩니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.DEFAULT_LIFETIME">정수 필드치</A> </DL>
</DL>
<HR>

<A NAME="INDEFINITE_LIFETIME"><!-- --></A> <H3>
INDEFINITE_LIFETIME</H3>
<PRE>
static final int <B>INDEFINITE_LIFETIME</B></PRE>
<DL>
<DD>컨텍스트
의 수명이 무기한인 것을 나타내는 수명 정수입니다. 이 값은, Java
 최대 정수치 <A HREF="../../../java/lang/Integer.html#MAX_VALUE"><CODE>Integer.MAX_VALUE</CODE></A>  로 설정할 필요가 있습니다.
<P>
<DL>
<DT><B>관련 항목:</B><DD><A HREF="../../../constant-values.html#org.ietf.jgss.GSSContext.INDEFINITE_LIFETIME">정수 필드치</A> </DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A> 
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>메서드의 상세</B></FONT></TH>
</TR>
</TABLE>

<A NAME="initSecContext(byte[], int, int)"><!-- --></A> <H3>
initSecContext</H3>
<PRE>
byte[] <B>initSecContext</B>(byte[]&nbsp;inputBuf,
                      int&nbsp;offset,
                      int&nbsp;len)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 시작 측에야는 불려 가는 메서드입니다. 컨텍스트
의 작성 처리를 개시해, 피어의 <code>acceptSecContext</code> 메서드에
해 생성된 토큰을 처리합니다. 이 메서드로부터 돌려주고지는 출력 토큰은, 피어의 <code>acceptSecContext</code> 메서드로 처리받기 위해서 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 어플리케이션은 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> 를
 호출하는 것으로 컨텍스트
의 이 편에 컨텍스트
의 확립 처리가 완료했는지 어떠했는지를 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주고졌을 경우는
<code>initSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내고 있습니다. 컨텍스트
의 확립이 완료하면, 이용 가능한 컨텍스트
 옵션을 get 메서드를 사용해 조회할 수 있습니다. <p>
<code>initSecContext</code> 메서드로부터 피어의 토큰이 돌려주고져<code>isEstablished</code> 로부터도 <code>true</code> 가 돌려주고지는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 컨텍스트
의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>
일부의 도구
 프로바이더에서는
 시큐러티 컨텍스트
을 시작하는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메서드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 Throw 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inputBuf</CODE> - 피어에
해 생성된 토큰. 최초의 호출에서는
 피어로부터 토큰을 수신하지 않기 때문에
 이 파라미터는 무시되는<DD><CODE>offset</CODE> - inputBuf 내의 오프셋(offset). 이 정도치로부터 토큰이 개시하는<DD><CODE>len</CODE> - 토큰의 길이
<DT><B>반환값:</B><DD>피어에 송신하는 토큰을 포함한 byte[]. <code>null</code>
 경우는
 토큰이 생성되지 않는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="initSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A> <H3>
initSecContext</H3>
<PRE>
int <B>initSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                   <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 시작 측에야는 불려 가는 메서드입니다. 컨텍스트
의 작성 처리를 개시해, 피어의 <code>acceptSecContext</code> 메서드에
해 생성된 토큰을 스트림을 사용해 처리합니다. 이 메서드로부터 <code>OutpuStream</code> 에 써내진 출력 토큰은, 피어의 <code>acceptSecContext</code> 호출로 처리받기 위해서 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 일반적으로 이 처리를 확실히 실시하기 위해서,<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메서드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. 토큰이 OutputStream 에 써내졌는지 어떠했는지는
 이 메서드의 반환값으로부터 판단할 수 있습니다. 반환값 <code>0</code> 은, 토큰이 써내지지 않았던 것을 나타냅니다. 컨텍스트
의 이 편에 컨텍스트
의 확립 처리가 완료했는지 어떠했는지는
<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> 를
 호출해 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주고졌을 경우는
<code>initSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내 있습니다. 컨텍스트
의 확립이 완료하면, 이용 가능한 컨텍스트
 옵션을 get 메서드를 사용해 조회할 수 있습니다. <p>
<code>initSecContext</code> 메서드로부터 피어의 토큰이 돌려주고져<code>isEstablished</code> 로부터도 <code>true</code> 가 돌려주고지는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 컨텍스트
의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>
GSS-API
 인증 토큰에는
 개시 토큰과 종료 토큰이 정의되고 있습니다. 이 메서드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 토큰의 일부가 읽히지 않았던 경우, 그 스트림은 블록 됩니다. 다른 모든 점에서는
 이 메서드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#initSecContext(byte[], int, int)"><CODE>initSecContext</CODE></A>  와 같습니다. <p>
일부의 도구
 프로바이더에서는
 시큐러티 컨텍스트
을 시작하는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메서드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 Throw 됩니다. <p>
다음의 코드예는
 이 메서드의 사용 방법을 나타내고 있습니다. <p>
 
 <pre>

     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {

         context.initSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에
해 생성된 토큰을 포함한 InputStream. 최초의 호출에서는
 피어로부터 수신하는 토큰이 없기 때문에
 이 파라미터는 무시되는<DD><CODE>outStream</CODE> - 출력 토큰이 써내지는 OutputStream. 컨텍스트
 확립의 최종 단계에서는
 써내지는 바이트가 없는 것도 있다
<DT><B>반환값:</B><DD>피어에 송신하는 토큰의 일부로서 OutputStream 에 써내지는 바이트수. 값 0 은, 토큰을 송신할 필요가 없는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_NAMETYPE"><CODE>GSSException.BAD_NAMETYPE</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(byte[], int, int)"><!-- --></A> <H3>
acceptSecContext</H3>
<PRE>
byte[] <B>acceptSecContext</B>(byte[]&nbsp;inToken,
                        int&nbsp;offset,
                        int&nbsp;len)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>피어로부터 토큰이 착신했을 때에
 컨텍스트
의 받아 들이는 쪽에
해 불려 갑니다. 어플리케이션은, 이 메서드로부터 돌려주고진 출력 토큰을 처리하기 위해서, 피어의 <code>initSecContext</code> 메서드에 송신할 필요가 있습니다. <p>
어플리케이션은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> 를
 호출하는 것으로 이 피어로 컨텍스트
의 확립 처리가 완료했는지 어떠했는지를 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주고졌을 경우는
 이 메서드에 한층 더 토큰을 제공할 필요가 있는 것을 나타내고 있습니다. 컨텍스트
의 확립이 완료하면, 이용 가능한 컨텍스트
 옵션을 get 메서드를 사용해 조회할 수 있습니다. <p>
<code>acceptSecContext</code> 메서드로부터 피어의 토큰이 돌려주고져<code>isEstablished</code> 로부터도 <code>true</code> 가 돌려주고지는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 컨텍스트
의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>
일부의 도구
 프로바이더에서는
 시큐러티 컨텍스트
을 받아들이는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메서드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 Throw 됩니다. <p>
다음의 코드예는
 이 메서드의 사용 방법을 나타내고 있습니다. <p>
 
 <pre>

     byte[] inToken;
     byte[] outToken;
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {
         inToken = readToken();
         outToken = context.acceptSecContext(inToken, 0,
                                             inToken.length);
         // send output token if generated
         if (outToken ! = null)
             sendToken(outToken);
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inToken</CODE> - 피어에
해 생성된 토큰<DD><CODE>offset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 토큰이 개시하는<DD><CODE>len</CODE> - 토큰의 길이
<DT><B>반환값:</B><DD>피어에 송신하는 토큰을 포함한 byte[]. <code>null</code>
 경우는
 토큰이 생성되지 않는 것을 나타낸다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="acceptSecContext(java.io.InputStream, java.io.OutputStream)"><!-- --></A> <H3>
acceptSecContext</H3>
<PRE>
void <B>acceptSecContext</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
                      <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 받아 들이는 쪽에
해 불려 가는 메서드입니다. 스트림을 사용해 피어로부터 수신한 토큰을 처리합니다. 이 메서드로부터 <code>OutpuStream</code> 에 써내진 출력 토큰은, 피어의 <code>initSecContext</code> 메서드로 처리받기 위해서 어플리케이션으로부터 피어에 송신할 필요가 있습니다. 일반적으로 이 처리를 확실히 실시하기 위해서,<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메서드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. 컨텍스트
의 이 편에 컨텍스트
의 확립 처리가 완료했는지 어떠했는지는
<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A> 를
 호출해 확인할 수 있습니다. <code>isEstablished</code> 로부터 반환값 <code>false</code> 가 돌려주고졌을 경우는
<code>acceptSecContext</code> 에 한층 더 토큰을 제공할 필요가 있는 것을 나타내고 있습니다. 컨텍스트
의 확립이 완료하면, 이용 가능한 컨텍스트
 옵션을 get 메서드를 사용해 조회할 수 있습니다. <p>
<code>acceptSecContext</code> 메서드로부터 피어의 토큰이 돌려주고져<code>isEstablished</code> 로부터도 <code>true</code> 가 돌려주고지는 일이 있습니다. 이 경우, 토큰은 피어에 송신할 필요가 있습니다만, 컨텍스트
의 상대측은 그 시점에서 완전하게 확립되어 있습니다. <p>
GSS-API
 인증 토큰에는
 개시 토큰과 종료 토큰이 정의되고 있습니다. 이 메서드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 토큰의 일부가 읽히지 않았던 경우, 그 스트림은 블록 됩니다. 다른 모든 점에서는
 이 메서드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#acceptSecContext(byte[], int, int)"><CODE>acceptSecContext</CODE></A>  와 같습니다. <p>
일부의 도구
 프로바이더에서는
 시큐러티 컨텍스트
을 받아들이는 액세스권이 호출해 측에 부여되고 있을 필요가 있습니다. 액세스권의 확인에 실패했을 경우, 이 메서드로부터 <A HREF="../../../java/lang/SecurityException.html" title="java.lang 안의 클래스"><CODE>SecurityException</CODE></A>  가 Throw 됩니다. <p>
다음의 코드예는
 이 메서드의 사용 방법을 나타내고 있습니다. <p>
 
 <pre>

     InputStream is ...
     OutputStream os ...
     GSSContext context ...

     // Loop while there is still a token to be processed

     while (! context.isEstablished()) {

         context.acceptSecContext(is, os);

         // send output token if generated
         os.flush();
     }
 </pre>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에
해 생성된 토큰을 포함한 InputStream<DD><CODE>outStream</CODE> - 출력 토큰이 써내지는 OutputStream. 컨텍스트
 확립의 최종 단계에서는
 써내지는 바이트가 없는 것도 있다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#NO_CRED"><CODE>GSSException.NO_CRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CREDENTIALS_EXPIRED"><CODE>GSSException.CREDENTIALS_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_BINDINGS"><CODE>GSSException.BAD_BINDINGS</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#OLD_TOKEN"><CODE>GSSException.OLD_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#DUPLICATE_TOKEN"><CODE>GSSException.DUPLICATE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MECH"><CODE>GSSException.BAD_MECH</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="isEstablished()"><!-- --></A> <H3>
isEstablished</H3>
<PRE>
boolean <B>isEstablished</B>()</PRE>
<DL>
<DD>컨텍스트
을 확립하기 전에
 컨텍스트
 상태를 확인할 경우에 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 컨텍스트
이 호출해 옆에서 완전하게 확립되어 피어로부터 토큰을 수신할 필요가 없는 경우는
<code>true</code>. </DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A> <H3>
dispose</H3>
<PRE>
void <B>dispose</B>()
             throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
 오브젝트에 포함되고 있는 시스템 자원과 암호화 정보를 모두 해방해, 그 컨텍스트
을 무효로 합니다.
<P>
<DD><DL>

<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getWrapSizeLimit(int, boolean, int)"><!-- --></A> <H3>
getWrapSizeLimit</H3>
<PRE>
int <B>getWrapSizeLimit</B>(int&nbsp;qop,
                     boolean&nbsp;confReq,
                     int&nbsp;maxTokenSize)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 에 건네줄 수가 있는 메세지 사이즈의 제한을 결정할 때 사용합니다. 이 메서드는
 최대 메세지 사이즈를 돌려줍니다. <code>confReq</code> 및 <code>qop</code> 파라미터가 같은 <code>wrap</code> 메서드에 이 사이즈의 메세지를 건네주면,<code>maxTokenSize</code> 바이트 이하의 출력 토큰이 생성됩니다. <p>
어플리케이션으로 이 메서드를 사용하는 경우는
 최대 메세지 사이즈를 사용하는 프로토콜을 개입시켜 통신하는 것을 전제로 하고 있습니다. 이 메서드를 사용하면, 메세지를 단편화하고 나서 보호를 적용할 수 있습니다. <p>
GSS-API 구현에서는
<code>getWrapSizeLimit</code>를
 호출했을 때에
 QOP 치가 유효한가 어떤가를 검출하도록 추천 하고 있습니다. 다만, 필수가 아닙니다. 이 루틴에서는
 최대 메세지 사이즈만이 보증되어 메세지 보호로 지정한 QOP 치를 이용할 수 있을지 어떨지에 대해서는 보증되지 않습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>qop</CODE> - 랩에 요구하는 보호 레벨<DD><CODE>confReq</CODE> - 랩에 프라이버시를 요구하는 경우는
<code>true</code>. 요구하지 않는 경우는
<code>false</code><DD><CODE>maxTokenSize</CODE> - 랩에
해 생성되는 토큰의 최대 사이즈로서 지정하는 값
<DT><B>반환값:</B><DD>지정된 출력 토큰 사이즈에 대한, 입력 토큰의 최대 사이즈
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
wrap</H3>
<PRE>
byte[] <B>wrap</B>(byte[]&nbsp;inBuf,
            int&nbsp;offset,
            int&nbsp;len,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>확립된 시큐러티 컨텍스트
에 대해서 메세지마다의 시큐러티 서비스를 적용합니다. 이 메서드는
 어플리케이션이 제공하는 데이터와 그에 대한 암호화 MIC를
 포함한 토큰을 돌려줍니다. 이 데이터는
 기밀성 (프라이버시)이 요구되었을 경우, 암호화됩니다. <p>
MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트를 사용해, 암호화 알고리즘을 선택하기 위한 QOP 치나, 임의 지정으로 메세지를 암호화하기 위한 프라이버시 서비스를 지정합니다. 이 호출에 사용되는 부하의 도구
에서는
 이 프라이버시 서비스를 제공할 수 없는 경우가 있습니다. 그 경우는
 부하의 도구
가 제공하는 실제의 프라이버시 서비스가, 이 MessageProp 오브젝트로 설정됩니다. 호출측은, 복귀하자 마자 프라이버시 서비스를 조회할 필요가 있습니다. 부하의 도구
가 요구된 QOP를
 제공할 수 없는 경우는
 BAD_QOP 코드가 설정된 GSSException 가 Throw 됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 랩에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지의 랩을 서포트할 필요가 있습니다. <p>
어플리케이션은, 이 토큰을 피어에 송신합니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inBuf</CODE> - 보호되는 어플리케이션 데이터<DD><CODE>offset</CODE> - inBuf 내의 오프셋(offset). 이 정도치로부터 데이터가 개시하는<DD><CODE>len</CODE> - 데이터의 길이<DD><CODE>msgProp</CODE> - MessageProp
 인스턴스. 필요한 QOP 와 프라이버시 상태를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP를
 요구하는 경우는
 지정하는 QOP 로서 0을
 설정한다. 이 메서드로부터 복귀하면, 이 오브젝트에는 부하의 도구
에
해 메세지에 적용된 실제의 프라이버시 상태가 포함된다
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="wrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
wrap</H3>
<PRE>
void <B>wrap</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
          <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
          <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
          throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 확립된 시큐러티 컨텍스트
에 메세지마다의 시큐러티 서비스를 적용합니다. 이 메서드는
 어플리케이션이 제공하는 데이터와 그에 대한 암호화 MIC를
 포함한 토큰을 돌려줍니다. 이 데이터는
 기밀성 (프라이버시)이 요구되었을 경우에 암호화됩니다. 이 메서드는
 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#wrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>wrap</CODE></A>  메서드와 같습니다. <p>
어플리케이션은, 이 토큰을 피어에 송신할 필요가 있습니다. 일반적으로 이 처리를 확실히 실시하기 위해서,<code>OutputStream</code> 에 대해서 <A HREF="../../../java/io/OutputStream.html#flush()"><CODE>flush</CODE></A>  메서드를 호출해 2 개의 피어간의 접속을 캡슐화합니다. <p>
MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트를 사용해, 암호화 알고리즘을 선택하기 위한 QOP 치나, 임의 지정으로 메세지를 암호화하기 위한 프라이버시 서비스를 지정합니다. 이 호출에 사용되는 부하의 도구
에서는
 이 프라이버시 서비스를 제공할 수 없는 경우가 있습니다. 그 경우는
 부하의 도구
가 제공하는 실제의 프라이버시 서비스가, 이 MessageProp 오브젝트로 설정됩니다. 호출측은, 복귀하자 마자 프라이버시 서비스를 조회할 필요가 있습니다. 부하의 도구
가 요구된 QOP를
 제공할 수 없는 경우는
 BAD_QOP 코드가 설정된 GSSException 가 Throw 됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 랩에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지의 랩을 서포트할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 보호되는 어플리케이션 데이터를 포함한 InputStream. InStream 내의 이용할 수 있는 데이터가 모두 사용되는<DD><CODE>outStream</CODE> - 보호된 메세지를 써내는 OutputStream<DD><CODE>msgProp</CODE> - MessageProp
 인스턴스. 필요한 QOP 와 프라이버시 상태를 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP를
 요구하는 경우는
 지정하는 QOP 로서 0을
 설정한다. 이 메서드로부터 복귀하면, 이 오브젝트에는 부하의 도구
에
해 메세지에 적용된 실제의 프라이버시 상태가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
byte[] <B>unwrap</B>(byte[]&nbsp;inBuf,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 상대측의 피어로 <code>wrap</code> 메서드에
해 생성된 토큰을 처리하기 위해서 사용합니다. 이 메서드는
 피어 어플리케이션으로부터 그 랩 호출에게 건네진 메세지를 돌려주고, 동시에 그 메세지에 파묻힌 MIC를
 검사합니다. <p>
MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트는
 QOP, 메세지에 기밀성이 적용되고 있는지 어떤지 및 메세지 상태에 관한 그 외의 보충 정보를 호출해 측에 돌려주기 위해서, 부하의 도구
에
해 사용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 랩에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지의 랩 및 랩 해제를 서포트할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inBuf</CODE> - 피어로부터 수신한 랩 토큰을 포함한 byte 배열<DD><CODE>offset</CODE> - 토큰이 개시하는 오프셋(offset)<DD><CODE>len</CODE> - 토큰의 길이<DD><CODE>msgProp</CODE> - 이 메서드로부터 복귀하면, 이 오브젝트에는
 적용된 QOP, 메세지의 프라이버시 상태 및 토큰의 보충 정보 (중복 하고 있는
 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>반환값:</B><DD>입력 토큰으로부터 랩 해제된 메세지를 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="unwrap(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
unwrap</H3>
<PRE>
void <B>unwrap</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 컨텍스트
의 상대측의 피어로 <code>wrap</code> 메서드에
해 생성된 토큰을 처리합니다. 이 메서드는
 피어 어플리케이션으로부터 그 랩 호출에게 건네진 메세지를 돌려주고, 동시에 그 메세지에 파묻힌 MIC를
 검사합니다. <p>  MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트는
 QOP, 메세지에 기밀성이 적용되고 있는지 어떤지 및 메세지 상태에 관한 그 외의 보충 정보를 호출해 측에 돌려주기 위해서, 부하의 도구
에
해 사용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 랩에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지의 랩 및 랩 해제를 서포트할 필요가 있습니다. <p>
이 메서드가 읽어내는 입력 토큰의 형식은, 사용하는 부하의 도구
의 사양에 정의되고 있습니다. 이 메서드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 이 도구
의 토큰에 개시 토큰과 종료 토큰이 정의되고 있는 경우, 일부의 토큰이 읽히지 않았을 때는
<code>InputStream</code>는
 블록 됩니다. 개시 토큰과 종료 토큰이 정의되어 있지 않은 경우는
 사용할 수 있는 모든 바이트가 그 토큰의 일부라고 보여집니다. <p>
입력 스트림의 블록이 발생하는 일이 있는 점을 제외하면, 이 메서드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#unwrap(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>unwrap</CODE></A>  메서드와 같습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - 피어에
해 생성된 랩 토큰을 포함한 InputStream<DD><CODE>outStream</CODE> - 어플리케이션 메세지를 써내는 OutputStream<DD><CODE>msgProp</CODE> - 이 메서드로부터 복귀하면, 이 오브젝트에는
 적용된 QOP, 메세지의 프라이버시 상태 및 토큰의 보충 정보 (중복 하고 있는
 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
getMIC</H3>
<PRE>
byte[] <B>getMIC</B>(byte[]&nbsp;inMsg,
              int&nbsp;offset,
              int&nbsp;len,
              <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>지정된 메세지의 암호화 MIC (메세지 정합성 코드)를 포함한 토큰을 돌려줍니다. 이 토큰은, 피어 어플리케이션에 전송 됩니다. 랩을 사용했을 경우는
 유저 메세지를 캡슐화한 토큰이 돌려주고집니다만, 이 메서드에서는
 메세지의 MIC 만을 포함한 출력 토큰이 돌려주고집니다. <p> 
프라이버시는
 랩을 호출했을 때에만 적용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 getMIC 에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지로부터 파생한 MIC를
 서포트할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inMsg</CODE> - MIC
 생성의 대상이 되는 메세지<DD><CODE>offset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 메세지가 개시하는<DD><CODE>len</CODE> - 메세지의 길이<DD><CODE>msgProp</CODE> - <code>MessageProp</code>
 인스턴스. 필요한 QOP를
 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP를
 요구하는 경우는
<code>msgProp</code> 로 지정하는 QOP 로서 <code>0</code>을
 설정하는지,<code>msgProp</code> 에 <code>null</code>를
 건네준다
<DT><B>반환값:</B><DD>피어에 송신되는 토큰을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getMIC(java.io.InputStream, java.io.OutputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
getMIC</H3>
<PRE>
void <B>getMIC</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;inStream,
            <A HREF="../../../java/io/OutputStream.html" title="java.io 안의 클래스">OutputStream</A> &nbsp;outStream,
            <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 지정된 메세지의 암호화 MIC를
 포함한 토큰을 돌려줍니다. 이 토큰은, 피어 어플리케이션에 전송 됩니다. 랩을 사용했을 경우는 유저 메세지를 캡슐화한 토큰이 돌려주고집니다만, 이 메서드에서는 메세지의 MIC 만을 포함한 출력 토큰이 돌려주고집니다. 이 메서드는
 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMIC(byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>getMIC</CODE></A>  메서드와 같습니다.
프라이버시는
 랩을 호출했을 때에만 적용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 getMIC 에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지로부터 파생한 MIC를
 서포트할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inStream</CODE> - MIC
 생성의 대상이 되는 메세지를 포함한 InputStream. InStream 내에서 이용할 수 있는 데이터가 모두 사용되는<DD><CODE>outStream</CODE> - 출력 토큰을 써내는 OutputStream<DD><CODE>msgProp</CODE> - <code>MessageProp</code>
 인스턴스. 필요한 QOP를
 설정하기 위해서 어플리케이션이 사용한다. 디폴트의 QOP를
 요구하는 경우는
<code>msgProp</code> 로 지정하는 QOP 로서 <code>0</code>을
 설정하는지,<code>msgProp</code> 에 <code>null</code>를
 건네준다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_QOP"><CODE>GSSException.BAD_QOP</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(byte[]&nbsp;inToken,
               int&nbsp;tokOffset,
               int&nbsp;tokLen,
               byte[]&nbsp;inMsg,
               int&nbsp;msgOffset,
               int&nbsp;msgLen,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>토큰 파라미터에 포함되는 암호화 MIC를
, 지정된 메세지에 대해서 검사합니다. <p>
MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트는
 메세지에 적용된 보호의 강함을 나타내는 QOP 및 메세지 상태에 관한 그 외의 보충 정보를 호출해 측에 돌려주기 위해서, 부하의 도구
에
해 사용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 getMIC 에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지에 대한 MIC를
 계산 및 검사할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>inToken</CODE> - 피어의 getMIC 메서드에
해 생성된 토큰<DD><CODE>tokOffset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 토큰이 개시하는<DD><CODE>tokLen</CODE> - 토큰의 길이<DD><CODE>inMsg</CODE> - 암호화 MIC
 검사의 대상이 되는 어플리케이션 메세지<DD><CODE>msgOffset</CODE> - inMsg 내의 오프셋(offset). 이 정도치로부터 메세지가 개시하는<DD><CODE>msgLen</CODE> - 메세지의 길이<DD><CODE>msgProp</CODE> - 이 메서드로부터 복귀하면, 이 오브젝트에는
 적용된 QOP 및 토큰의 보충 정보 (중복 하고 있는
 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="verifyMIC(java.io.InputStream, java.io.InputStream, org.ietf.jgss.MessageProp)"><!-- --></A> <H3>
verifyMIC</H3>
<PRE>
void <B>verifyMIC</B>(<A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;tokStream,
               <A HREF="../../../java/io/InputStream.html" title="java.io 안의 클래스">InputStream</A> &nbsp;msgStream,
               <A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스">MessageProp</A> &nbsp;msgProp)
               throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>스트림을 사용해, 토큰 파라미터에 포함되는 지정된 메세지의 암호화 MIC를
 검증합니다. 이 메서드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A>  메서드와 같습니다.
MessageProp 오브젝트는
 어플리케이션에
해 인스턴스화 됩니다. 이 오브젝트는
 메세지에 적용된 보호의 강함을 나타내는 QOP 및 메세지 상태에 관한 그 외의 보충 정보를 호출해 측에 돌려주기 위해서, 부하의 도구
에
해 사용됩니다. <p>
어플리케이션 레벨의 프로토콜에는
 getMIC 에
해 생성된 토큰을 사용해 「세큐아후레이밍」을 제공하는 것이 있기 때문에
 구현에서는 길이 0
 메세지에 대한 MIC를
 계산 및 검사할 필요가 있습니다. <p>
이 메서드가 읽어내는 입력 토큰의 형식은, 사용하는 부하의 도구
의 사양에 정의되고 있습니다. 이 메서드가 불려 갈 때마다, 이러한 토큰이 1 개씩 읽힙니다. 이 도구
의 토큰에 개시 토큰과 종료 토큰이 정의되고 있는 경우, 일부의 토큰이 읽히지 않았을 때는
<code>InputStream</code>는
 블록 됩니다. 개시 토큰과 종료 토큰이 정의되어 있지 않은 경우는
 사용할 수 있는 모든 바이트가 그 토큰의 일부라고 보여집니다. <p>
입력 스트림의 블록이 발생하는 일이 있는 점을 제외하면, 이 메서드는 byte 배열을 베이스로 한 <A HREF="../../../org/ietf/jgss/GSSContext.html#verifyMIC(byte[], int, int, byte[], int, int, org.ietf.jgss.MessageProp)"><CODE>verifyMIC</CODE></A>  메서드와 같습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>tokStream</CODE> - 피어의 getMIC 메서드에
해 생성된 토큰을 포함한 InputStream<DD><CODE>msgStream</CODE> - 암호화 MIC
 검사의 대상이 되는 어플리케이션 메세지를 포함한 InputStream. msgStream 내에서 이용할 수 있는 데이터가 모두 사용되는<DD><CODE>msgProp</CODE> - 이 메서드로부터 복귀하면, 이 오브젝트에는
 적용된 QOP 및 토큰의 보충 정보 (중복 하고 있는
 낡은, 순서가 올바르지 않은, 갭의 후에 착신했는지 어떠했는지)가 포함된다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#DEFECTIVE_TOKEN"><CODE>GSSException.DEFECTIVE_TOKEN</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#BAD_MIC"><CODE>GSSException.BAD_MIC</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="export()"><!-- --></A> <H3>
export</H3>
<PRE>
byte[] <B>export</B>()
              throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 컨텍스트
을 export 해, 다른 프로세스를 임포트 할 수 있도록 합니다. 이 메서드를 사용하면, 복수의 프로세스간에 컨텍스트
을 공유할 수 있습니다. 이 루틴은 보통
, 컨텍스트
의 받아 들이는 쪽으로 사용됩니다. 단일 프로세스가 착신 접속 요구를 수신해, 그러한 요구에 대한 시큐러티 컨텍스트
을 받아들입니다. 다음에
 확립된 컨텍스트
을 다른 몇개의 프로세스에 건네주어, 메세지를 교환합니다. <p>
이 메서드는
 시큐러티 컨텍스트
을 종료해, 프로세스간 토큰을 작성합니다. 이 프로세스간토큰을 다른 프로세스의 <A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext</CODE></A>  에 건네주면, 그 프로세스로 그 컨텍스트
이 재차 시작됩니다. 특정의 컨텍스트
의 인스턴스는
 1 번에 1 개 밖에 시작할 수 없습니다. 이 때문에
 export 한 시큐러티 컨텍스트
을 컨텍스트
의 export측에서 액세스 하려고 하면, 실패합니다. <p>
이 구현에서는
 프로세스간 토큰을 임포트 하는 프로세스가, 로컬 시큐러티 폴리시 또는 구현의 설정에
해 제한되는 일이 있습니다. 예를 들어, 같은 어카운트로 동작하는 프로세스간에만 컨텍스트
이 건네받거나 같은 프로세스 그룹의 프로세스간에만 건네받거나 합니다. <p>
프로세스간 토큰에는
 기밀 정보 (암호화키등)가 포함되어 있는 일이 있습니다. 이러한 기밀 정보는
 가능한 한 프로세스간 토큰에 포함하지 않게 하는지, 토큰을 암호화하고 나서 어플리케이션에 돌려주세요. 다만, 표준적인 GSS-API
 구현에서는
 이러한 대응을 적용할 수 없는 것이 있습니다. 이 때문에
 어플리케이션으로 프로세스간 토큰을 사용하는 경우는
 시큐러티에 충분히 배려해, 신뢰할 수 있는 프로세스에 전송 해 주세요.  <p>

시큐러티 컨텍스트
의 프로세스간 전송은, 구현에 따라서는 서포트되어 있지 않은 것이 있습니다. <A HREF="../../../org/ietf/jgss/GSSContext.html#isTransferable()"><CODE>isTransferable</CODE></A>  메서드를 호출하면, 컨텍스트
 오브젝트를 전송 할 수 있을지 어떨지를 확인할 수 있습니다. <p>
export 할 수 없는 컨텍스트
에 대해서 이 메서드를 호출하면, 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A> 를
 포함한 예외가 Throw 됩니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>export 된 컨텍스트
을 포함한 byte[]
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#UNAVAILABLE"><CODE>GSSException.UNAVAILABLE</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#CONTEXT_EXPIRED"><CODE>GSSException.CONTEXT_EXPIRED</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#NO_CONTEXT"><CODE>GSSException.NO_CONTEXT</CODE></A>,
<A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 을
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSManager.html#createContext(byte[])"><CODE>GSSManager.createContext(byte[])</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestMutualAuth(boolean)"><!-- --></A> <H3>
requestMutualAuth</H3>
<PRE>
void <B>requestMutualAuth</B>(boolean&nbsp;state)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
이 확립해 있을 때, 상호 인증을 하도록 요구합니다. 이 요구는
 컨텍스트
의 시작측으로부터,<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다. <p>
인증 도구
에 따라서는 상호 인증이 서포트되어 있지 않은 것이 있습니다. 또, 어플리케이션은 상호 인증을 필요로 하지 않아도, 인증 도구
가 상호 인증을 필요로 하고 있는 경우도 있습니다. 그 때문에
 이 요구를 받아들일 수 있었는지 어떠했는지를 확인하기 위해, 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState</CODE></A>  메서드를 사용할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 상호 인증을 사용할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getMutualAuthState()"><CODE>getMutualAuthState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestReplayDet(boolean)"><!-- --></A> <H3>
requestReplayDet</H3>
<PRE>
void <B>requestReplayDet</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
이 확립한 후에
 메세지마다의 시큐러티 서비스의 리플레이 검출이 유효하게 되도록 요구합니다. 이 요구는
 컨텍스트
의 시작측으로부터,<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다. 컨텍스트
이 확립해 있는 동안은, 리플레이 검출은 옵션은 아니고, 부하의 도구
의 기능이 됩니다. <p>
인증 도구
에 따라서는 리플레이 검출이 서포트되어 있지 않은 것이 있습니다. 또, 어플리케이션은 리플레이 검출을 필요로 하지 않아도, 인증 도구
가 리플레이 검출을 필요로 하고 있는 경우도 있습니다. 그 때문에
 이 요구를 받아들일 수 있었는지 어떠했는지를 확인하기 위해, 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState</CODE></A>  메서드를 사용할 필요가 있습니다. 리플레이 검출이 유효하게 되어 있는 경우,<A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A>  메서드와 <A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A>  메서드는
<code>unwrap</code> 메서드 또는 <code>verifyMIC</code> 메서드에게 건네지는 <code>MessageProp</code> 오브젝트에 대해서 유효한 결과를 돌려줍니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 확립한 컨텍스트
에 대해서 리플레이 검출을 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getReplayDetState()"><CODE>getReplayDetState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestSequenceDet(boolean)"><!-- --></A> <H3>
requestSequenceDet</H3>
<PRE>
void <B>requestSequenceDet</B>(boolean&nbsp;state)
                        throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
이 확립한 후에
 메세지마다의 시큐러티 서비스의 sequence check가 유효하게 되도록 요구합니다. 이 요구는
 컨텍스트
의 시작측으로부터,<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다. 컨텍스트
이 확립해 있는 동안은, sequence check는 옵션은 아니고, 부하의 도구
의 기능이 됩니다. <p>
인증 도구
에 따라서는 sequence check가 서포트되어 있지 않은 것이 있습니다. 또, 어플리케이션은 sequence check를 필요로 하지 않아도, 인증 도구
가 sequence check를 필요로 하고 있는 경우도 있습니다. 그 때문에
 이 요구를 받아들일 수 있었는지 어떠했는지를 확인하기 위해, 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState</CODE></A>  메서드를 사용할 필요가 있습니다. sequence check가 유효하게 되어 있는 경우,<A HREF="../../../org/ietf/jgss/MessageProp.html#isDuplicateToken()"><CODE>MessageProp.isDuplicateToken</CODE></A>,
<A HREF="../../../org/ietf/jgss/MessageProp.html#isOldToken()"><CODE>MessageProp.isOldToken</CODE></A>,
<A HREF="../../../org/ietf/jgss/MessageProp.html#isUnseqToken()"><CODE>MessageProp.isUnseqToken</CODE></A>,
<A HREF="../../../org/ietf/jgss/MessageProp.html#isGapToken()"><CODE>MessageProp.isGapToken</CODE></A> 
 각 메서드는
<code>unwrap</code> 메서드 또는 <code>verifyMIC</code> 메서드에게 건네지는 <code>MessageProp</code> 오브젝트에 대해서 유효한 결과를 돌려줍니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 확립된 컨텍스트
에 대해서 sequence check를 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getSequenceDetState()"><CODE>getSequenceDetState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestCredDeleg(boolean)"><!-- --></A> <H3>
requestCredDeleg</H3>
<PRE>
void <B>requestCredDeleg</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 확립 시에 시작측의 자격을 받아 들이는 쪽에 위양 하도록 요구합니다. 이 요구는
 컨텍스트
의 시작 측에서의 보고 실시할 수가 있어<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다.
인증 도구
에 따라서는
 자격의 위양이 서포트되어 있지 않은 것이 있습니다. 그 때문에
 위양을 필요로 하는 어플리케이션은, 요구를 받아들일 수 있었는지 어떠했는지를 확인하기 위해서 <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A>  메서드를 사용할 필요가 있습니다. 위양을 사용해서는 안 되면 어플리케이션으로부터 나타났을 경우, 도구
는 그 요구를 받아 위양은 행해지지 않습니다. 이것은 일반 규칙에 대한 예외로 어느 서비스가 요구되지 않아도 도구
가 그 서비스를 유효하게 하는 일이 있다고 하는 것입니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 자격을 위양 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestAnonymity(boolean)"><!-- --></A> <H3>
requestAnonymity</H3>
<PRE>
void <B>requestAnonymity</B>(boolean&nbsp;state)
                      throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>시작측의 자격을 받아 들이는 쪽에 공개하지 않게 요구합니다. 이 요구는
 컨텍스트
의 시작 측에서의 보고 실시할 수가 있어<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다.
인증 도구
에 따라서는
 시작측의 익명이 서포트되어 있지 않은 것이 있습니다. 그 때문에
 요구를 받아들일 수 있었는지 어떠했는지를 확인하기 위해, 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState</CODE></A>  메서드를 사용할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 시작측이 받아 들이는 쪽에 익명 주체로서 인증될지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getAnonymityState()"><CODE>getAnonymityState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestConf(boolean)"><!-- --></A> <H3>
requestConf</H3>
<PRE>
void <B>requestConf</B>(boolean&nbsp;state)
                 throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 메서드로 데이터의 기밀성을 유효하게 하도록 요구합니다. 이 요구는
 컨텍스트
의 시작 측에서의 보고 실시할 수가 있어<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다.
인증 도구
에 따라서는
 기밀성을 서포트하고 있지 않는 것이나, 어플리케이션으로부터 요구되지 않는 경우에서도 기밀성을 유효하게 하는 것이 있습니다. 요구를 받아들일 수 있었는지 어떠했는지를 확인하려면,
 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A>  메서드를 사용합니다. 기밀성이 유효되고 있는 경우에 한정해,<code>wrap</code> 메서드에게 건네진 <A HREF="../../../org/ietf/jgss/MessageProp.html#MessageProp(int, boolean)"><CODE>MessageProp</CODE></A>  오브젝트에 포함되는 프라이버시 요구를 인증 도구
가 받아들입니다. <p>
기밀성을 유효하게 하면, 정합성도 자동적으로 유효하게 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 기밀성을 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState()</CODE></A>,
 
<A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A>,
 
<A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A>,
 
<A HREF="../../../org/ietf/jgss/MessageProp.html" title="org.ietf.jgss 안의 클래스"><CODE>MessageProp</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestInteg(boolean)"><!-- --></A> <H3>
requestInteg</H3>
<PRE>
void <B>requestInteg</B>(boolean&nbsp;state)
                  throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><code>wrap</code> 메서드와 <code>getMIC</code> 메서드로 데이터의 정합성을 유효하게 하도록 요구합니다. 이 요구는
 컨텍스트
의 시작 측에서의 보고 실시할 수가 있어<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다.
인증 도구
에 따라서는 정합성이 서포트되어 있지 않은 것이 있습니다. 또, 어플리케이션이 정합성을 요구하지 않아도, 인증 도구
가 정합성을 유효하게 하는 경우도 있습니다. 이 요구를 받아들일 수 있었는지 어떠했는지를 확인하려면,
 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A>  메서드를 사용합니다. <p>
정합성을 무효로 하면, 기밀성도 자동적으로 무효가 됩니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>state</CODE> - 정합성을 유효하게 할지 어떨지를 나타내는 boolean 치
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="requestLifetime(int)"><!-- --></A> <H3>
requestLifetime</H3>
<PRE>
void <B>requestLifetime</B>(int&nbsp;lifetime)
                     throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 수명을 초단위로 요구합니다. 이 메서드의 호출은, 컨텍스트
의 시작측으로부터,<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다. <p>
컨텍스트
의 실제의 수명은 부하의 도구
의 기능에 따라서 다르기 때문에
 어플리케이션으로 <A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime</CODE></A>  메서드를 호출해 확인할 필요가 있습니다. <p>
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>lifetime</CODE> - 컨텍스트
으로 지정하고 싶은 수명 (초단위). 무기한의 수명을 요구하는 경우는 <code>INDEFINITE_LIFETIME</code>를
 사용해, 디폴트의 수명을 요구하는 경우는 <code>DEFAULT_LIFETIME</code>를
 사용한다
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#getLifetime()"><CODE>getLifetime()</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="setChannelBinding(org.ietf.jgss.ChannelBinding)"><!-- --></A> <H3>
setChannelBinding</H3>
<PRE>
void <B>setChannelBinding</B>(<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 안의 클래스">ChannelBinding</A> &nbsp;cb)
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
이 확립해 있을 때 채널 바인딩이 사용되도록 설정합니다. 이 메서드는
 컨텍스트
의 시작측 및 받아 들이는 쪽으로부터 호출할 수가 있습니다. 다만, 컨텍스트
의 확립을 개시하기 전에 호출할 필요가 있습니다. 즉, 시작측에서 호출할 때는
<code>initSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다. 받아 들이는 쪽으로부터 호출할 때는
<code>acceptSecContext</code>를
 최초로 호출하기 전에 실시할 필요가 있습니다.
<P>
<DD><DL>
<DT><B>파라미터:</B><DD><CODE>cb</CODE> - 사용하는 채널 바인딩
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getCredDelegState()"><!-- --></A> <H3>
getCredDelegState</H3>
<PRE>
boolean <B>getCredDelegState</B>()</PRE>
<DL>
<DD>이 컨텍스트
으로 자격의 위양이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메서드는
 컨텍스트
의 시작측이라고 불러 방편측의 어느 쪽으로부터에서도 호출할 수가 있습니다. 올바른 판정 결과를 얻으려면,
 컨텍스트
의 확립이 완료하고 나서 호출해 주세요. 시작측이 자격의 위양을 무효로 하도록 요구했을 경우,<A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg</CODE></A>  메서드는 그 요구를 받아들여 그 시점으로부터 시작 측에 대해 <code>false</code>를
 돌려줍니다.  <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>위양이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestCredDeleg(boolean)"><CODE>requestCredDeleg(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getMutualAuthState()"><!-- --></A> <H3>
getMutualAuthState</H3>
<PRE>
boolean <B>getMutualAuthState</B>()</PRE>
<DL>
<DD>이 컨텍스트
으로 상호 인증이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메서드는
 컨텍스트
의 시작측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 컨텍스트
의 확립이 완료하고 나서 호출해 주세요. 상호 인증을 요구한 시작측은, 컨텍스트
의 확립이 완료한 후에 이 메서드를 호출해, 요구를 받아들일 수 없었던 경우는 그 컨텍스트
을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>상호 인증이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestMutualAuth(boolean)"><CODE>requestMutualAuth(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getReplayDetState()"><!-- --></A> <H3>
getReplayDetState</H3>
<PRE>
boolean <B>getReplayDetState</B>()</PRE>
<DL>
<DD>이 컨텍스트
의 메세지마다의 시큐러티 서비스로 리플레이 검출이 유효하게 되어 있는지 어떤지를 판정합니다. 이 메서드는
 컨텍스트
의 시작측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 컨텍스트
의 확립이 완료하고 나서 호출해 주세요. 리플레이 검출을 요구한 시작측은, 컨텍스트
의 확립이 완료한 후에 이 메서드를 호출해, 요구를 받아들일 수 없었던 경우는 그 컨텍스트
을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>리플레이 검출이 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestReplayDet(boolean)"><CODE>requestReplayDet(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSequenceDetState()"><!-- --></A> <H3>
getSequenceDetState</H3>
<PRE>
boolean <B>getSequenceDetState</B>()</PRE>
<DL>
<DD>이 컨텍스트
의 메세지마다의 시큐러티 서비스로 sequence check가 유효하게 되어 있는지 어떤지를 판정합니다. 이 메서드는
 컨텍스트
의 시작측 및 호출해 옆으로부터 호출할 수가 있습니다. 다만, 컨텍스트
의 확립이 완료하고 나서 호출해 주세요. sequence check를 요구한 시작측은, 컨텍스트
의 확립이 완료한 후에 이 메서드를 호출해, 요구를 받아들일 수 없었던 경우는 그 컨텍스트
을 파기할 수 있습니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>sequence check가 유효한 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestSequenceDet(boolean)"><CODE>requestSequenceDet(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getAnonymityState()"><!-- --></A> <H3>
getAnonymityState</H3>
<PRE>
boolean <B>getAnonymityState</B>()</PRE>
<DL>
<DD>컨텍스트
의 시작측이 컨텍스트
의 받아 들이는 쪽에 익명으로서 인증되고 있는지 어떤지를 판정합니다. 이 메서드는
 컨텍스트
의 시작측 및 호출해 옆으로부터, 임의의 타이밍에 호출할 수가 있습니다. 시작측으로부터 이 메서드를 호출했을 경우는
<code>initSecContext</code> 에
해 그 시점까지 생성된 컨텍스트
 확립 토큰의 어느 쪽인가에
 시작측의 ID 가 공개되고 있는지 어떤지가 검사됩니다. 익명으로서의 인증이 필요한 경우는
<code>initSecContext</code>를
 호출하고 나서 이 메서드를 호출해, 생성된 토큰을 피어에 송신하는지, 그 컨텍스트
을 중지할까를 결정할 필요가 있습니다. 받아 들이는 쪽으로부터 이 메서드를 호출했을 경우는
<code>acceptSecContext</code> 에
해 그 시점까지 처리된 토큰의 어느 쪽인가에
 시작측의 ID 가 공개되고 있는지 어떤지가 검사됩니다. <strong></strong><p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>컨텍스트
의 시작측이 익명으로서 인증되고 있는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestAnonymity(boolean)"><CODE>requestAnonymity(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="isTransferable()"><!-- --></A> <H3>
isTransferable</H3>
<PRE>
boolean <B>isTransferable</B>()
                       throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD><A HREF="../../../org/ietf/jgss/GSSContext.html#export()"><CODE>export</CODE></A>  메서드를 사용해 이 컨텍스트
을 다른 프로세스에 전송 할 수 있을지 어떨지를 검사합니다. 이 호출은, 완전하게 확립된 컨텍스트
 에 대해서만 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>이 컨텍스트
을 export 할 수 있는 경우는 true, 그렇지 않은 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="isProtReady()"><!-- --></A> <H3>
isProtReady</H3>
<PRE>
boolean <B>isProtReady</B>()</PRE>
<DL>
<DD>이 컨텍스트
으로 메세지마다의 조작을 곧바로 개시할 수 있을지 어떨지를 검사합니다. 일부의 도구
에서는
 컨텍스트
이 완전하게 확립되기 전에
 메세지마다의 조작을 사용할 수 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>현재의 컨텍스트
 확립 단계에서 <code>wrap</code>,<code>unwrap</code>,<code>getMIC</code>,<code>verifyMIC</code> 등의 메서드를 사용할 수 있는 경우는 true, 그렇지 않은 경우는 false</DL>
</DD>
</DL>
<HR>

<A NAME="getConfState()"><!-- --></A> <H3>
getConfState</H3>
<PRE>
boolean <B>getConfState</B>()</PRE>
<DL>
<DD>이 컨텍스트
으로 데이터의 기밀성을 이용할 수 있을지 어떨지를 검사합니다. 이 메서드는
 컨텍스트
의 시작측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다. 다만,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 돌려주고진 다음이 아니면 안됩니다. 이 메서드가 <code>true</code>를
 돌려주는 경우는
<A HREF="../../../org/ietf/jgss/GSSContext.html#getIntegState()"><CODE>getIntegState</CODE></A>  도 <code>true</code>를
 돌려줍니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>기밀성 서비스를 이용할 수 있는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestConf(boolean)"><CODE>requestConf(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getIntegState()"><!-- --></A> <H3>
getIntegState</H3>
<PRE>
boolean <B>getIntegState</B>()</PRE>
<DL>
<DD>이 컨텍스트
으로 데이터의 정합성을 이용할 수 있을지 어떨지를 검사합니다. 이 메서드는
 컨텍스트
의 시작측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다. 다만,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 돌려주고진 다음이 아니면 안됩니다. <A HREF="../../../org/ietf/jgss/GSSContext.html#getConfState()"><CODE>getConfState</CODE></A>  가 <code>true</code>를
 돌려주는 경우는
 이 메서드도 <code>true</code>를
 돌려줍니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>정합성 서비스를 이용할 수 있는 경우는 true, 그렇지 않은 경우는 false<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestInteg(boolean)"><CODE>requestInteg(boolean)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getLifetime()"><!-- --></A> <H3>
getLifetime</H3>
<PRE>
int <B>getLifetime</B>()</PRE>
<DL>
<DD>이 컨텍스트
의 나머지의 수명을 검사합니다. 이 메서드는
 컨텍스트
의 시작측과 받아 들이는 쪽의 어느 쪽으로부터에서도 호출할 수가 있습니다. 다만, 올바른 결과를 얻기 위해서는
<A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 true 가 돌려주고진 다음이 아니면 안됩니다. <p>
<P>
<DD><DL>

<DT><B>반환값:</B><DD>나머지의 수명 (초단위)<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSContext.html#requestLifetime(int)"><CODE>requestLifetime(int)</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getSrcName()"><!-- --></A> <H3>
getSrcName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 안의 인터페이스">GSSName</A>  <B>getSrcName</B>()
                   throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 시작측의 이름을 돌려줍니다. 이 호출은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 돌려주고진 다음에 마셔 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>GSSName. 컨텍스트
의 시작측의 이름을 포함한 MN
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한<DT><B>관련 항목:</B><DD><A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 내의 인터페이스"><CODE>GSSName</CODE></A> </DL>
</DD>
</DL>
<HR>

<A NAME="getTargName()"><!-- --></A> <H3>
getTargName</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSName.html" title="org.ietf.jgss 안의 인터페이스">GSSName</A>  <B>getTargName</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 받아 들이는 쪽의 이름을 돌려줍니다. 이 호출은,<A HREF="../../../org/ietf/jgss/GSSContext.html#isProtReady()"><CODE>isProtReady</CODE></A>  또는 <A HREF="../../../org/ietf/jgss/GSSContext.html#isEstablished()"><CODE>isEstablished</CODE></A>  로부터 <code>true</code> 가 돌려주고진 다음에 마셔 유효합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>GSSName. 컨텍스트
의 받아 들이는 쪽의 이름을 포함한 MN
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getMech()"><!-- --></A> <H3>
getMech</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/Oid.html" title="org.ietf.jgss 안의 클래스">Oid</A>  <B>getMech</B>()
            throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 컨텍스트
에 사용되고 있는 도구
를 검사합니다. 이 메서드는
 컨텍스트
이 완전하게 확립되기 전에 호출할 수가 있습니다. 다만, GSS-API 도구
의 네고시에이션이 완료한 후에 이 메서드를 호출하면, 돌려주고지는 도구
가 바뀌는 일이 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>사용되고 있는 도구
의 OID
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="getDelegCred()"><!-- --></A> <H3>
getDelegCred</H3>
<PRE>
<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 안의 인터페이스">GSSCredential</A>  <B>getDelegCred</B>()
                           throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>컨텍스트
의 시작측으로부터 컨텍스트
의 받아 들이는 쪽에 위양 된 자격을 취득합니다. 이 메서드는
 컨텍스트
의 받아 들이는 쪽으로부터 마셔, 컨텍스트
이 완전하게 확립된 후에 호출할 필요가 있습니다. 위양 된 자격이 있을지 어떨지를 호출측에서 확인하려면,
 메서드 <A HREF="../../../org/ietf/jgss/GSSContext.html#getCredDelegState()"><CODE>getCredDelegState</CODE></A> 를
 사용합니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>시작측으로부터 위양 된 자격이 포함되는 GSSCredential. 위양 된 자격이 없는 경우는 <code>null</code>
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<HR>

<A NAME="isInitiator()"><!-- --></A> <H3>
isInitiator</H3>
<PRE>
boolean <B>isInitiator</B>()
                    throws <A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 내의 클래스">GSSException</A> </PRE>
<DL>
<DD>이 피어가 컨텍스트
의 시작측일지 어떨지를 검사합니다. 이 메서드는
 컨텍스트
의 시작측 및 받아 들이는 쪽으로부터 호출할 수가 있습니다.
<P>
<DD><DL>

<DT><B>반환값:</B><DD>컨텍스트
의 시작측인 경우는 true, 컨텍스트
의 받아 들이는 쪽인 경우는 false
<DT><B>예외:</B>
<DD><CODE><A HREF="../../../org/ietf/jgss/GSSException.html" title="org.ietf.jgss 안의 클래스">GSSException</A> </CODE> - 메이저 에러 코드 <A HREF="../../../org/ietf/jgss/GSSException.html#FAILURE"><CODE>GSSException.FAILURE</CODE></A> 를
 포함한다</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A> 
<A HREF="#skip-navbar_bottom" title="네비게이션 링크를 스킵"></A> 
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A> 
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>개요</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>패키지</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>클래스</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GSSContext.html"><FONT CLASS="NavBarFont1"><B>사용</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>계층 트리</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>비추천 API</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>색인</B></FONT></A> &nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>헬프</B></FONT></A> &nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Java<sup><font size=-2>TM</font></sup>&nbsp;2&nbsp;Platform<br>Standard&nbsp;Ed.  5.0</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
&nbsp;<A HREF="../../../org/ietf/jgss/ChannelBinding.html" title="org.ietf.jgss 내의 클래스"><B>이전 클래스</B></A> &nbsp;
&nbsp;<A HREF="../../../org/ietf/jgss/GSSCredential.html" title="org.ietf.jgss 내의 인터페이스"><B>다음 클래스</B></A> </FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-1">
  <A HREF="../../../index.html?org/ietf/jgss/GSSContext.html" target="_top"><B>프레임으로</B></A>   &nbsp;
&nbsp;<A HREF="GSSContext.html" target="_top"><B>프레임 없이</B></A>   &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> ');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>모든 클래스</B></A> 
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  개요: &nbsp;NESTED &nbsp;|&nbsp;<A HREF="#field_summary">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_summary">메서드</A> </FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
상세: &nbsp;<A HREF="#field_detail">필드</a>&nbsp;|&nbsp;constructor　 　&nbsp;|&nbsp;<A HREF="#method_detail">메서드</A> </FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A> 
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<font size="-1"> <p>Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  Use is subject to <a href="../../../../relnotes/license.html">license terms</a> .  <a href="http://java.sun.com/docs/redist.html">Documentation Redistribution Policy</a>  도 참조하십시오. </font>
</BODY>
</HTML>
